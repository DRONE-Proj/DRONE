{"Number":"1","API Relative Path":"com.sun.glass.ui.Application.java-setName(String)","Corresponding Source":"/**\n     * Sets the name for the application.  The application name may\n     * be used to identify the application in the user interface or\n     * as part of the platform specific path used to store application\n     * data.\n     *\n     * The name could be set only once. All subsequent calls are ignored.\n     *\n     * This is a hint and may not be used on some platforms.\n     *\n     * @param name the new application name\n     */\n    public void setName(String name) {\n        checkEventThread();\n        if (name != null && DEFAULT_NAME.equals(this.name)) {\n            this.name = name;\n        }\n    }"}
{"Number":"2","API Relative Path":"com.sun.glass.ui.CommonDialogs.java-showFileChooser(Window-File-String-String-int-boolean-List-int)","Corresponding Source":"/**\n     * Creates a native file chooser that lets the user select files.\n     *\n     * @param owner             the owner window for this file chooser (may be null)\n     * @param folder            the initial folder, may be {@code null}\n     * @param filename          the initial file name for a SAVE dialog (may be null)\n     * @param title             the title of the file chooser\n     * @param type              the type of the file chooser, one of the constants from {@link Type}\n     * @param multipleMode      enables or disable multiple file selections\n     * @param extensionFilters  the filters of the file chooser\n     * @param defaultFilterIndex the zero-based index of the filter selected by default\n     * @throws IllegalArgumentException\n     *         if the initial folder is an invalid folder;\n     *         if the type doesn't equal one of the constants from {@link Type}\n     * @return the files that the user selects and the selected extension\n     *         filter. If the user cancels the file chooser, the method returns empty\n     *         results object.\n     */\n    public static FileChooserResult showFileChooser(Window owner, File folder, String filename, String title, int type,\n                                        boolean multipleMode, List<ExtensionFilter> extensionFilters, int defaultFilterIndex)\n    {\n        Application.checkEventThread();\n        String _folder = convertFolder(folder);\n        if (filename == null) {\n            filename = \"\";\n        }\n\n        if (type != Type.OPEN && type != Type.SAVE) {\n            throw new IllegalArgumentException(\"Type parameter must be equal to one of the constants from Type\");\n        }\n\n        ExtensionFilter[] _extensionFilters = null;\n        if (extensionFilters != null) {\n            _extensionFilters = extensionFilters.toArray(new ExtensionFilter[extensionFilters.size()]);\n        }\n\n        if (extensionFilters == null\n                || extensionFilters.isEmpty()\n                || defaultFilterIndex < 0\n                || defaultFilterIndex >= extensionFilters.size()) {\n            defaultFilterIndex = 0;\n        }\n\n        return Application.GetApplication().\n            staticCommonDialogs_showFileChooser(owner, _folder, filename, convertTitle(title), type, multipleMode, _extensionFilters, defaultFilterIndex);\n    }"}
{"Number":"3","API Relative Path":"com.sun.glass.ui.mac.MacFileNSURL.java-createFromBookmark(byte[])","Corresponding Source":"/**\n     * Returns an instance of the MacFileNSURL class created from bookmark\n     * data stored in the byte array passed as an argument.\n     *\n     * The glass.macosx.enableFileNSURL system property must be set to {@code\n     * true} before calling this method.\n     *\n     * @return a new instance of MacFileNSURL\n     */\n    public static MacFileNSURL createFromBookmark(byte[] data) {\n        Application.checkEventThread();\n        if (data == null) {\n            throw new NullPointerException(\"data must not be null\");\n        }\n        if (!MacCommonDialogs.isFileNSURLEnabled()) {\n            throw new RuntimeException(\"The system property glass.macosx.enableFileNSURL is not 'true'\");\n        }\n        return _createFromBookmark(data, 0L);\n    }"}
{"Number":"4","API Relative Path":"com.sun.glass.ui.mac.MacFileNSURL.java-createFromDocumentScopedBookmark(byte[]-MacFileNSURL)","Corresponding Source":"/**\n     * Returns an instance of the MacFileNSURL class created from a\n     * document-scoped bookmark data stored in the byte array passed as an\n     * argument, relative to the {@code baseDocument} URL.\n     *\n     * The glass.macosx.enableFileNSURL system property must be set to {@code\n     * true} before calling this method.\n     *\n     * @throws NullPointerException if baseDocument is {@code null}\n     * @return a new instance of MacFileNSURL\n     */\n    public static MacFileNSURL createFromDocumentScopedBookmark(byte[] data, MacFileNSURL baseDocument) {\n        Application.checkEventThread();\n        if (data == null) {\n            throw new NullPointerException(\"data must not be null\");\n        }\n        if (!MacCommonDialogs.isFileNSURLEnabled()) {\n            throw new RuntimeException(\"The system property glass.macosx.enableFileNSURL is not 'true'\");\n        }\n        return _createFromBookmark(data, baseDocument.ptr);\n    }"}
{"Number":"5","API Relative Path":"com.sun.glass.ui.monocle.LinuxAbsoluteInputCapabilities.java-getCapabilities(File-BitSet)","Corresponding Source":"/** Reads capabilities from a device node.\n     *\n     * @return A Map of capabilities for each supported axis, or null if no\n     * capabilities are available.\n     * @throws IOException if an error occured when reading capabilities\n     * */\n    static Map<Integer, LinuxAbsoluteInputCapabilities> getCapabilities(\n            File devNode, BitSet axes) throws IOException {\n        if (axes == null || axes.isEmpty()) {\n            return null;\n        }\n        LinuxSystem system = LinuxSystem.getLinuxSystem();\n        LinuxSystem.InputAbsInfo info = new LinuxSystem.InputAbsInfo();\n        long fd = system.open(devNode.getPath(), LinuxSystem.O_RDONLY);\n        if (fd == -1) {\n            throw new IOException(system.getErrorMessage());\n        }\n        Map<Integer, LinuxAbsoluteInputCapabilities> caps =\n                new HashMap<Integer, LinuxAbsoluteInputCapabilities>();\n        for (int i = 0; (i = axes.nextSetBit(i)) != -1; i++) {\n            caps.put(i, new LinuxAbsoluteInputCapabilities(system, info, fd, i));\n        }\n        system.close(fd);\n        return caps;\n    }"}
{"Number":"6","API Relative Path":"com.sun.glass.ui.monocle.SysFS.java-readInts(String-int)","Corresponding Source":"/** Read a comma-separated list of integer values from a file */\n    static int[] readInts(String location, int expectedLength) throws IOException {\n        BufferedReader r = new BufferedReader(new FileReader(location));\n        String s = r.readLine();\n        r.close();\n        if (s != null && s.length() > 0) {\n            String[] elements = s.split(\",\");\n            try {\n                if (expectedLength == 0 || elements.length == expectedLength) {\n                    int[] xs = new int[elements.length];\n                    for (int i = 0; i < xs.length; i++) {\n                        xs[i] = Integer.parseInt(elements[i]);\n                    }\n                    return xs;\n                }\n            } catch (NumberFormatException e) {\n                // fall through to throw an IOException\n            }\n        }\n        if (expectedLength != 0) {\n            throw new IOException(\"Expected to find \" + expectedLength\n                    + \" integers in \" + location + \" but found '\"\n                    + s + \"'\");\n        } else {\n            return new int[0];\n        }\n    }"}
{"Number":"7","API Relative Path":"com.sun.glass.ui.monocle.TouchState.java-setPoint(int-Point)","Corresponding Source":"/** Replaces the touch point data at the given index with the given touch\n     *    point data\n     *\n     * @param index the index at which to change the touch point data\n     * @param p the data to copy to the given index.\n     */\n    void setPoint(int index, Point p) {\n        if (index >= pointCount) {\n            throw new IndexOutOfBoundsException();\n        }\n        p.copyTo(points[index]);\n    }"}
{"Number":"8","API Relative Path":"com.sun.glass.ui.Timer.java-Timer(Runnable)","Corresponding Source":"/**\n     * Constructs a new timer.\n     *\n     * If the application overrides the Timer.run(), it should call super.run()\n     * in order to run the runnable passed to the constructor.\n     */\n    protected Timer(Runnable runnable) {\n        if (runnable == null) {\n            throw new IllegalArgumentException(\"runnable shouldn't be null\");\n        }\n        this.runnable = runnable;\n    }"}
{"Number":"9","API Relative Path":"com.sun.glass.ui.Window.java-requestFocus(int)","Corresponding Source":"/**\n     * Requests or resigns focus on this window.\n     *\n     * If this is a top-level window (owned or not), then the only possible\n     * value for the {@code event} argument is WindowEvent.FOCUS_GAINED.\n     * Otherwise, if the window is a child window, the argument may be\n     * WindowEvent.FOCUS_LOST, FOCUS_GAINED, FOCUS_GAINED_FORWARD, or\n     * FOCUS_GAINED_BACKWARD.\n     *\n     * @param event one of WindowEvent.FOCUS_LOST, FOCUS_GAINED, FOCUS_GAINED_FORWARD, FOCUS_GAINED_BACKWARD\n     *\n     * @throws IllegalArgumentException if the argument value is invalid for this window\n     *\n     * @return {@code true} if the operation succeeded\n     */\n    public boolean requestFocus(int event) {\n        Application.checkEventThread();\n        checkNotClosed();\n\n        if (!isChild() && event != WindowEvent.FOCUS_GAINED) {\n            throw new IllegalArgumentException(\"Invalid focus event ID for top-level window\");\n        }\n\n        if (isChild() && (event < WindowEvent._FOCUS_MIN || event > WindowEvent._FOCUS_MAX)) {\n            throw new IllegalArgumentException(\"Invalid focus event ID for child window\");\n        }\n\n        if (event == WindowEvent.FOCUS_LOST && !isFocused()) {\n            // Already unfocused, nothing to do\n            return true;\n        }\n\n        // At this point either A) the user requests focus for a focused or unfocused window,\n        // or B) the window is focused and the user requests FOCUS_LOST\n        if (!this.isFocusable) {\n            // It's obviously A). Fail.\n            return false;\n        }\n\n        return _requestFocus(this.ptr, event);\n    }"}
{"Number":"10","API Relative Path":"com.sun.glass.ui.Window.java-requestFocus(int)","Corresponding Source":"/**\n     * Requests or resigns focus on this window.\n     *\n     * If this is a top-level window (owned or not), then the only possible\n     * value for the {@code event} argument is WindowEvent.FOCUS_GAINED.\n     * Otherwise, if the window is a child window, the argument may be\n     * WindowEvent.FOCUS_LOST, FOCUS_GAINED, FOCUS_GAINED_FORWARD, or\n     * FOCUS_GAINED_BACKWARD.\n     *\n     * @param event one of WindowEvent.FOCUS_LOST, FOCUS_GAINED, FOCUS_GAINED_FORWARD, FOCUS_GAINED_BACKWARD\n     *\n     * @throws IllegalArgumentException if the argument value is invalid for this window\n     *\n     * @return {@code true} if the operation succeeded\n     */\n    public boolean requestFocus(int event) {\n        Application.checkEventThread();\n        checkNotClosed();\n\n        if (!isChild() && event != WindowEvent.FOCUS_GAINED) {\n            throw new IllegalArgumentException(\"Invalid focus event ID for top-level window\");\n        }\n\n        if (isChild() && (event < WindowEvent._FOCUS_MIN || event > WindowEvent._FOCUS_MAX)) {\n            throw new IllegalArgumentException(\"Invalid focus event ID for child window\");\n        }\n\n        if (event == WindowEvent.FOCUS_LOST && !isFocused()) {\n            // Already unfocused, nothing to do\n            return true;\n        }\n\n        // At this point either A) the user requests focus for a focused or unfocused window,\n        // or B) the window is focused and the user requests FOCUS_LOST\n        if (!this.isFocusable) {\n            // It's obviously A). Fail.\n            return false;\n        }\n\n        return _requestFocus(this.ptr, event);\n    }"}
{"Number":"11","API Relative Path":"com.sun.glass.ui.Window.java-setAlpha(float)","Corresponding Source":"/**\n     * Sets the uniform translucency level for this window.\n     *\n     * In the full screen mode the native window is always fully opaque.\n     * The requested opacity level is applied upon exiting the full screen\n     * mode only.\n     *\n     * @param alpha a value in the range [0..1f] (transparent..fully-opaque)\n     */\n    public void setAlpha(final float alpha) {\n        Application.checkEventThread();\n        checkNotClosed();\n        if (alpha < 0f || alpha > 1f) {\n            throw new IllegalArgumentException(\"Alpha should be in the range [0f..1f]\");\n        }\n\n        this.alpha = alpha;\n\n        if (alpha < 1f && isInFullscreen()) {\n            return;\n        }\n\n        _setAlpha(this.ptr, this.alpha);\n    }"}
{"Number":"12","API Relative Path":"com.sun.glass.ui.Window.java-setLevel(int)","Corresponding Source":"/**\n     * Set the level of this window in the z-order.\n     *\n     * @param level one of the constants from {@link Window.Level}\n     * @see Window.Level\n     */\n    public void setLevel(final int level) {\n        Application.checkEventThread();\n        checkNotClosed();\n        if (level < Level._MIN || level > Level._MAX) {\n            throw new IllegalArgumentException(\"Level should be in the range [\" + Level._MIN + \"..\" + Level._MAX + \"]\");\n        }\n        if (this.level != level) {\n            _setLevel(this.ptr, level);\n            this.level = level;\n        }\n    }"}
{"Number":"13","API Relative Path":"com.sun.javafx.application.ParametersImpl.java-ParametersImpl(List)","Corresponding Source":"/**\n     * Constructs an Parameters object from the specified list of arguments.\n     * The list may be null.\n     *\n     * @param args list of command line arguments\n     */\n    public ParametersImpl(List<String> args) {\n        if (args != null) {\n            init(args);\n        }\n    }"}
{"Number":"14","API Relative Path":"com.sun.javafx.application.ParametersImpl.java-ParametersImpl(String[])","Corresponding Source":"/**\n     * Constructs an Parameters object from the specified array of unnamed\n     * parameters. The array may be null.\n     *\n     * @param args array of command line arguments\n     */\n    public ParametersImpl(String[] args) {\n        if (args != null) {\n            init(Arrays.asList(args));\n        }\n    }"}
{"Number":"15","API Relative Path":"com.sun.javafx.css.BitSet.java-add(T)","Corresponding Source":"/** {@inheritDoc} */\n    @Override\n    public boolean add(T t) {\n\n        if (t == null) {\n            // this not modified!\n            return false;\n        }\n\n        final int element = getIndex(t) / Long.SIZE;\n        final long bit = 1l << (getIndex(t) % Long.SIZE);\n\n        // need to grow?\n        if (element >= bits.length) {\n            final long[] temp = new long[element + 1];\n            System.arraycopy(bits, 0, temp, 0, bits.length);\n            bits = temp;\n        }\n\n        final long temp = bits[element];\n        bits[element] = temp | bit;\n\n        // if index[element] == temp, then the bit was already set\n        final boolean modified = (bits[element] != temp);\n        if (modified && SetListenerHelper.hasListeners(listenerHelper)){\n            notifyObservers(t, Change.ELEMENT_ADDED);\n        }\n        return modified;\n    }"}
{"Number":"16","API Relative Path":"com.sun.javafx.css.parser.CSSParser.java-parseExpr(String-String)","Corresponding Source":"/** convenience method for unit tests */\n    public ParsedValueImpl parseExpr(String property, String expr) {\n        if (property == null || expr == null) return null;\n\n        ParsedValueImpl value = null;\n        setInputSource(null, property + \": \" + expr);\n        char buf[] = new char[expr.length() + 1];\n        System.arraycopy(expr.toCharArray(), 0, buf, 0, expr.length());\n        buf[buf.length-1] = ';';\n\n        try (Reader reader = new CharArrayReader(buf)) {\n            CSSLexer lex = CSSLexer.getInstance();\n            lex.setReader(reader);\n\n            currentToken = nextToken(lex);\n            CSSParser.Term term = this.expr(lex);\n            value = valueFor(property, term, lex);\n        } catch (IOException ioe) {\n        } catch (ParseException e) {\n            if (LOGGER.isLoggable(Level.WARNING)) {\n                LOGGER.warning(\"\\\"\" +property + \": \" + expr  + \"\\\" \" + e.toString());\n            }\n        } catch (Exception ex) {\n            // Sometimes bad syntax causes an exception. The code should be\n            // fixed to handle the bad syntax, but the fallback is\n            // to handle the exception here. Uncaught, the exception can cause\n            // problems like RT-20311\n            reportException(ex);\n        }\n        return value;\n    }"}
{"Number":"17","API Relative Path":"com.sun.javafx.css.PseudoClassState.java-getPseudoClass(String)","Corresponding Source":"/**\n     * @see javafx.css.PseudoClass#getPseudoClass(String)\n     */\n    public static PseudoClass getPseudoClass(String pseudoClass) {\n\n        if (pseudoClass == null || pseudoClass.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"pseudoClass cannot be null or empty String\");\n        }\n\n        PseudoClass instance = null;\n\n        final Integer value = pseudoClassMap.get(pseudoClass);\n        final int index = value != null ? value.intValue() : -1;\n\n        final int size = pseudoClasses.size();\n        assert index < size;\n\n        if (index != -1 && index < size) {\n            instance = pseudoClasses.get(index);\n        }\n\n        if (instance == null) {\n            instance = new PseudoClassImpl(pseudoClass, size);\n            pseudoClasses.add(instance);\n            pseudoClassMap.put(pseudoClass, Integer.valueOf(size));\n        }\n\n        return instance;\n    }"}
{"Number":"18","API Relative Path":"com.sun.javafx.css.StyleClassSet.java-getStyleClass(String)","Corresponding Source":"/**\n     */\n    static StyleClass getStyleClass(String styleClass) {\n\n        if (styleClass == null || styleClass.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"styleClass cannot be null or empty String\");\n        }\n\n        StyleClass instance = null;\n\n        final Integer value = styleClassMap.get(styleClass);\n        final int index = value != null ? value.intValue() : -1;\n\n        final int size = styleClasses.size();\n        assert index < size;\n\n        if (index != -1 && index < size) {\n            instance = styleClasses.get(index);\n        }\n\n        if (instance == null) {\n            instance = new StyleClass(styleClass, size);\n            styleClasses.add(instance);\n            styleClassMap.put(styleClass, Integer.valueOf(size));\n        }\n\n        return instance;\n    }"}
{"Number":"19","API Relative Path":"com.sun.javafx.css.StyleManager.java-addUserAgentStylesheet(Scene-Stylesheet)","Corresponding Source":"/**\n     * Add a user agent stylesheet, possibly overriding styles in the default\n     * user agent stylesheet.\n     * @param scene Only used in CssError for tracking back to the scene that loaded the stylesheet\n     * @param ua_stylesheet  The stylesheet to add as a user-agent stylesheet\n     */\n    public void addUserAgentStylesheet(Scene scene, Stylesheet ua_stylesheet) {\n\n        if (ua_stylesheet == null ) {\n            throw new IllegalArgumentException(\"null arg ua_stylesheet\");\n        }\n\n        // null url is ok, just means that it is a stylesheet not loaded from a file\n        String url = ua_stylesheet.getUrl();\n        final String fname = url != null ? url.trim() : \"\";\n\n        synchronized (styleLock) {\n            // if we already have this stylesheet, bail\n            for (int n=0, nMax= platformUserAgentStylesheetContainers.size(); n < nMax; n++) {\n                StylesheetContainer container = platformUserAgentStylesheetContainers.get(n);\n                if (fname.equals(container.fname)) {\n                    return;\n                }\n            }\n\n            // RT-20643\n            CssError.setCurrentScene(scene);\n\n            platformUserAgentStylesheetContainers.add(new StylesheetContainer(fname, ua_stylesheet));\n\n            if (ua_stylesheet != null) {\n                ua_stylesheet.setOrigin(StyleOrigin.USER_AGENT);\n            }\n            userAgentStylesheetsChanged();\n\n            // RT-20643\n            CssError.setCurrentScene(null);\n        }\n    }"}
{"Number":"20","API Relative Path":"com.sun.javafx.css.StyleManager.java-forget(Parent)","Corresponding Source":"/**\n     * Called from Parent's scenesChanged method when the Parent's scene is set to null.\n     * @param parent The Parent being removed from the scene-graph\n     */\n    public void forget(Parent parent) {\n\n        if (parent == null) return;\n\n        synchronized (styleLock) {\n            // RT-34863 - clean up CSS cache when Parent is removed from scene-graph\n            CacheContainer removedContainer = cacheContainerMap.remove(parent);\n            if (removedContainer != null) {\n                removedContainer.clearCache();\n            }\n\n            final List<String> stylesheets = parent.getStylesheets();\n            if (stylesheets != null && !stylesheets.isEmpty()) {\n                for (String fname : stylesheets) {\n                    stylesheetRemoved(parent, fname);\n                }\n            }\n\n            Iterator<Entry<String,StylesheetContainer>> containerIterator = stylesheetContainerMap.entrySet().iterator();\n            while (containerIterator.hasNext()) {\n                Entry<String,StylesheetContainer> entry = containerIterator.next();\n                StylesheetContainer container = entry.getValue();\n                container.parentUsers.remove(parent);\n                if (container.parentUsers.list.isEmpty()) {\n\n                    containerIterator.remove();\n\n                    if (container.selectorPartitioning != null) {\n                        container.selectorPartitioning.reset();\n                    }\n\n\n                    // clean up image cache by removing images from the cache that\n                    // might have come from this stylesheet\n                    final String fname = container.fname;\n                    cleanUpImageCache(fname);\n                }\n            }\n\n            // Do not iterate over children since this method will be called on each from Parent#scenesChanged\n        }\n    }"}
{"Number":"21","API Relative Path":"com.sun.javafx.css.StyleManager.java-forget(Scene)","Corresponding Source":"/**\n     * called from Window when the scene is closed.\n     */\n    public void forget(final Scene scene) {\n\n        if (scene == null) return;\n\n        forget(scene.getRoot());\n\n        synchronized (styleLock) {\n            //\n            // if this scene has user-agent stylesheets, clean up the userAgentStylesheetContainers list\n            //\n            String sceneUserAgentStylesheet = null;\n            if ((scene.getUserAgentStylesheet() != null) &&\n                    (!(sceneUserAgentStylesheet = scene.getUserAgentStylesheet().trim()).isEmpty())) {\n\n                for(int n=userAgentStylesheetContainers.size()-1; 0<=n; --n) {\n                    StylesheetContainer container = userAgentStylesheetContainers.get(n);\n                    if (sceneUserAgentStylesheet.equals(container.fname)) {\n                        container.parentUsers.remove(scene.getRoot());\n                        if (container.parentUsers.list.size() == 0) {\n                            userAgentStylesheetContainers.remove(n);\n                        }\n                    }\n                }\n            }\n\n            //\n            // remove any parents belonging to this scene from the stylesheetContainerMap\n            //\n            Set<Entry<String,StylesheetContainer>> stylesheetContainers = stylesheetContainerMap.entrySet();\n            Iterator<Entry<String,StylesheetContainer>> iter = stylesheetContainers.iterator();\n\n            while(iter.hasNext()) {\n\n                Entry<String,StylesheetContainer> entry = iter.next();\n                StylesheetContainer container = entry.getValue();\n\n                Iterator<Reference<Parent>> parentIter = container.parentUsers.list.iterator();\n                while (parentIter.hasNext()) {\n\n                    Reference<Parent> ref = parentIter.next();\n                    Parent _parent = ref.get();\n\n                    if (_parent == null || _parent.getScene() == scene || _parent.getScene() == null) {\n                        ref.clear();\n                        parentIter.remove();\n                    }\n                }\n\n                if (container.parentUsers.list.isEmpty()) {\n                    iter.remove();\n                }\n            }\n        }\n    }"}
{"Number":"22","API Relative Path":"com.sun.javafx.css.StyleManager.java-forget(SubScene)","Corresponding Source":"/**\n     * called from Window when the scene is closed.\n     */\n    public void forget(final SubScene subScene) {\n\n        if (subScene == null) return;\n        final Parent subSceneRoot = subScene.getRoot();\n\n        if (subSceneRoot == null) return;\n        forget(subSceneRoot);\n\n        synchronized (styleLock) {\n            //\n            // if this scene has user-agent stylesheets, clean up the userAgentStylesheetContainers list\n            //\n            String sceneUserAgentStylesheet = null;\n            if ((subScene.getUserAgentStylesheet() != null) &&\n                    (!(sceneUserAgentStylesheet = subScene.getUserAgentStylesheet().trim()).isEmpty())) {\n\n                Iterator<StylesheetContainer> iterator = userAgentStylesheetContainers.iterator();\n                while(iterator.hasNext()) {\n                    StylesheetContainer container = iterator.next();\n                    if (sceneUserAgentStylesheet.equals(container.fname)) {\n                        container.parentUsers.remove(subScene.getRoot());\n                        if (container.parentUsers.list.size() == 0) {\n                            iterator.remove();\n                        }\n                    }\n                }\n            }\n\n            //\n            // remove any parents belonging to this SubScene from the stylesheetContainerMap\n            //\n            // copy the list to avoid concurrent mod.\n            List<StylesheetContainer> stylesheetContainers = new ArrayList<>(stylesheetContainerMap.values());\n\n            Iterator<StylesheetContainer> iter = stylesheetContainers.iterator();\n\n            while(iter.hasNext()) {\n\n                StylesheetContainer container = iter.next();\n\n                Iterator<Reference<Parent>> parentIter = container.parentUsers.list.iterator();\n                while (parentIter.hasNext()) {\n\n                    final Reference<Parent> ref = parentIter.next();\n                    final Parent _parent = ref.get();\n\n                    if (_parent != null) {\n                        // if this stylesheet refererent is a child of this subscene, nuke it.\n                        Parent p = _parent;\n                        while (p != null) {\n                            if (subSceneRoot == p.getParent()) {\n                                ref.clear();\n                                parentIter.remove();\n                                forget(_parent); // _parent, not p!\n                                break;\n                            }\n                            p = p.getParent();\n                        }\n                    }\n                }\n\n                // forget(_parent) will remove the container if the parentUser's list is empty\n                // if (container.parentUsers.list.isEmpty()) {\n                //    iter.remove();\n                // }\n            }\n        }\n\n    }"}
{"Number":"23","API Relative Path":"com.sun.javafx.css.StyleManager.java-setDefaultUserAgentStylesheet(Stylesheet)","Corresponding Source":"/**\n     * Set the user agent stylesheet. This is the base default stylesheet for\n     * the platform\n     */\n    public void setDefaultUserAgentStylesheet(Stylesheet ua_stylesheet) {\n        if (ua_stylesheet == null ) {\n            return;\n        }\n\n        // null url is ok, just means that it is a stylesheet not loaded from a file\n        String url = ua_stylesheet.getUrl();\n        final String fname = url != null ? url.trim() : \"\";\n\n        synchronized (styleLock) {\n            // if we already have this stylesheet, make sure it is the first element\n            for (int n=0, nMax= platformUserAgentStylesheetContainers.size(); n < nMax; n++) {\n                StylesheetContainer container = platformUserAgentStylesheetContainers.get(n);\n                if (fname.equals(container.fname)) {\n                    if (n > 0) {\n                        platformUserAgentStylesheetContainers.remove(n);\n                        if (hasDefaultUserAgentStylesheet) {\n                            platformUserAgentStylesheetContainers.set(0, container);\n                        } else {\n                            platformUserAgentStylesheetContainers.add(0, container);\n                        }\n                    }\n                    return;\n                }\n            }\n\n            StylesheetContainer sc = new StylesheetContainer(fname, ua_stylesheet);\n            if (platformUserAgentStylesheetContainers.size() == 0) {\n                platformUserAgentStylesheetContainers.add(sc);\n            } else if (hasDefaultUserAgentStylesheet) {\n                platformUserAgentStylesheetContainers.set(0,sc);\n            } else {\n                platformUserAgentStylesheetContainers.add(0,sc);\n            }\n            hasDefaultUserAgentStylesheet = true;\n\n            ua_stylesheet.setOrigin(StyleOrigin.USER_AGENT);\n            userAgentStylesheetsChanged();\n        }\n    }"}
{"Number":"24","API Relative Path":"com.sun.javafx.css.StyleManager.java-setUserAgentStylesheets(List)","Corresponding Source":"////////////////////////////////////////////////////////////////////////////\n    //\n    // User Agent stylesheet handling\n    //\n    ////////////////////////////////////////////////////////////////////////////\n\n\n    /**\n     * Set a bunch of user agent stylesheets all at once. The order of the stylesheets in the list\n     * is the order of their styles in the cascade. Passing null, an empty list, or a list full of empty\n     * strings does nothing.\n     *\n     * @param urls The list of stylesheet URLs as Strings.\n     */\n    public void setUserAgentStylesheets(List<String> urls) {\n\n        if (urls == null || urls.size() == 0) return;\n\n        synchronized (styleLock) {\n            // Avoid resetting user agent stylesheets if they haven't changed.\n            if (urls.size() == platformUserAgentStylesheetContainers.size()) {\n                boolean isSame = true;\n                for (int n=0, nMax=urls.size(); n < nMax && isSame; n++) {\n\n                    final String url = urls.get(n);\n                    final String fname = (url != null) ? url.trim() : null;\n\n                    if (fname == null || fname.isEmpty()) break;\n\n                    StylesheetContainer container = platformUserAgentStylesheetContainers.get(n);\n                    // assignment in this conditional is intentional!\n                    if(isSame = fname.equals(container.fname)) {\n                        // don't use fname in calculateCheckSum since it is just the key to\n                        // find the StylesheetContainer. Rather, use the URL of the\n                        // stylesheet that was already loaded. For example, we could have\n                        // fname = \"com/sun/javafx/scene/control/skin/modena/modena.css, but\n                        // the stylesheet URL could be jar:file://some/path/!com/sun/javafx/scene/control/skin/modena/modena.bss\n                        String stylesheetUrl = container.stylesheet.getUrl();\n                        byte[] checksum = calculateCheckSum(stylesheetUrl);\n                        isSame = Arrays.equals(checksum, container.checksum);\n                    }\n                }\n                if (isSame) return;\n            }\n\n            boolean modified = false;\n\n            for (int n=0, nMax=urls.size(); n < nMax; n++) {\n\n                final String url = urls.get(n);\n                final String fname = (url != null) ? url.trim() : null;\n\n                if (fname == null || fname.isEmpty()) continue;\n\n                if (!modified) {\n                    // we have at least one non null or non-empty url\n                    platformUserAgentStylesheetContainers.clear();\n                    modified = true;\n                }\n\n                if (n==0) {\n                    _setDefaultUserAgentStylesheet(fname);\n                } else {\n                    _addUserAgentStylesheet(fname);\n                }\n            }\n\n            if (modified) {\n                userAgentStylesheetsChanged();\n            }\n        }\n    }"}
{"Number":"25","API Relative Path":"com.sun.javafx.css.Stylesheet.java-convertToBinary(File-File)","Corresponding Source":"/**\n     * Convert the .css file referenced by urlIn to binary format and write to urlOut.\n     * @param source is the JavaFX .css file to convert\n     * @param destination is the file to which the binary conversion is written\n     * @throws IOException\n     * @throws IllegalArgumentException if either parameter is null, if source and destination are the same,\n     * if source cannot be read, or if destination cannot be written.\n     */\n    public static void convertToBinary(File source, File destination) throws IOException {\n\n        if (source == null || destination == null) {\n            throw new IllegalArgumentException(\"parameters may not be null\");\n        }\n\n        if (source.getAbsolutePath().equals(destination.getAbsolutePath())) {\n            throw new IllegalArgumentException(\"source and destination may not be the same\");\n        }\n\n        if (source.canRead() == false) {\n            throw new IllegalArgumentException(\"cannot read source file\");\n        }\n\n        if (destination.exists() ? (destination.canWrite() == false) : (destination.createNewFile() == false)) {\n            throw new IllegalArgumentException(\"cannot write destination file\");\n        }\n\n        URI sourceURI = source.toURI();\n        Stylesheet stylesheet = new CSSParser().parse(sourceURI.toURL());\n\n        // first write all the css binary data into the buffer and collect strings on way\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        DataOutputStream dos = new DataOutputStream(baos);\n        StringStore stringStore = new StringStore();\n        stylesheet.writeBinary(dos, stringStore);\n        dos.flush();\n        dos.close();\n\n        FileOutputStream fos = new FileOutputStream(destination);\n        DataOutputStream os = new DataOutputStream(fos);\n\n        // write file version\n        os.writeShort(BINARY_CSS_VERSION);\n\n        // write strings\n        stringStore.writeBinary(os);\n\n        // write binary css\n        os.write(baos.toByteArray());\n        os.flush();\n        os.close();\n    }"}
{"Number":"26","API Relative Path":"com.sun.javafx.css.Stylesheet.java-loadBinary(URL)","Corresponding Source":"/** Load a binary stylesheet file from a input stream */\n    public static Stylesheet loadBinary(URL url) throws IOException {\n\n        if (url == null) return null;\n\n        Stylesheet stylesheet = null;\n\n        try (DataInputStream dataInputStream =\n                     new DataInputStream(new BufferedInputStream(url.openStream(), 40 * 1024))) {\n\n            // read file version\n            final int bssVersion = dataInputStream.readShort();\n            if (bssVersion > Stylesheet.BINARY_CSS_VERSION) {\n                throw new IOException(url.toString() + \" wrong binary CSS version: \"\n                        + bssVersion + \". Expected version less than or equal to\" +\n                        Stylesheet.BINARY_CSS_VERSION);\n            }\n            // read strings\n            final String[] strings = StringStore.readBinary(dataInputStream);\n            // read binary data\n            stylesheet = new Stylesheet(url.toExternalForm());\n\n            try {\n\n                dataInputStream.mark(Integer.MAX_VALUE);\n                stylesheet.readBinary(bssVersion, dataInputStream, strings);\n\n            } catch (Exception e) {\n\n                stylesheet = new Stylesheet(url.toExternalForm());\n\n                dataInputStream.reset();\n\n                if (bssVersion == 2) {\n                    // RT-31022\n                    stylesheet.readBinary(3, dataInputStream, strings);\n                } else {\n                    stylesheet.readBinary(Stylesheet.BINARY_CSS_VERSION, dataInputStream, strings);\n                }\n            }\n\n        } catch (FileNotFoundException fnfe) {\n            // This comes from url.openStream() and is expected.\n            // It just means that the .bss file doesn't exist.\n        }\n\n        // return stylesheet\n        return stylesheet;\n    }"}
{"Number":"27","API Relative Path":"com.sun.javafx.event.EventHandlerManager.java-addEventFilter(EventType-EventHandler)","Corresponding Source":"/**\n     * Registers an event filter in {@code EventHandlerManager}.\n     *\n     * @param <T> the specific event class of the filter\n     * @param eventType the type of the events to receive by the filter\n     * @param eventFilter the filter to register\n     * @throws NullPointerException if the event type or filter is null\n     */\n    public final <T extends Event> void addEventFilter(\n            final EventType<T> eventType,\n            final EventHandler<? super T> eventFilter) {\n        validateEventType(eventType);\n        validateEventFilter(eventFilter);\n\n        final CompositeEventHandler<T> compositeEventHandler =\n                createGetCompositeEventHandler(eventType);\n\n        compositeEventHandler.addEventFilter(eventFilter);\n    }"}
{"Number":"28","API Relative Path":"com.sun.javafx.event.EventHandlerManager.java-addEventFilter(EventType-EventHandler)","Corresponding Source":"/**\n     * Registers an event filter in {@code EventHandlerManager}.\n     *\n     * @param <T> the specific event class of the filter\n     * @param eventType the type of the events to receive by the filter\n     * @param eventFilter the filter to register\n     * @throws NullPointerException if the event type or filter is null\n     */\n    public final <T extends Event> void addEventFilter(\n            final EventType<T> eventType,\n            final EventHandler<? super T> eventFilter) {\n        validateEventType(eventType);\n        validateEventFilter(eventFilter);\n\n        final CompositeEventHandler<T> compositeEventHandler =\n                createGetCompositeEventHandler(eventType);\n\n        compositeEventHandler.addEventFilter(eventFilter);\n    }"}
{"Number":"29","API Relative Path":"com.sun.javafx.event.EventHandlerManager.java-addEventFilter(EventType-EventHandler)","Corresponding Source":"/**\n     * Registers an event filter in {@code EventHandlerManager}.\n     *\n     * @param <T> the specific event class of the filter\n     * @param eventType the type of the events to receive by the filter\n     * @param eventFilter the filter to register\n     * @throws NullPointerException if the event type or filter is null\n     */\n    public final <T extends Event> void addEventFilter(\n            final EventType<T> eventType,\n            final EventHandler<? super T> eventFilter) {\n        validateEventType(eventType);\n        validateEventFilter(eventFilter);\n\n        final CompositeEventHandler<T> compositeEventHandler =\n                createGetCompositeEventHandler(eventType);\n\n        compositeEventHandler.addEventFilter(eventFilter);\n    }"}
{"Number":"30","API Relative Path":"com.sun.javafx.event.EventHandlerManager.java-addEventHandler(EventType-EventHandler)","Corresponding Source":"/**\n     * Registers an event handler in {@code EventHandlerManager}.\n     *\n     * @param <T> the specific event class of the handler\n     * @param eventType the type of the events to receive by the handler\n     * @param eventHandler the handler to register\n     * @throws NullPointerException if the event type or handler is null\n     */\n    public final <T extends Event> void addEventHandler(\n            final EventType<T> eventType,\n            final EventHandler<? super T> eventHandler) {\n        validateEventType(eventType);\n        validateEventHandler(eventHandler);\n\n        final CompositeEventHandler<T> compositeEventHandler =\n                createGetCompositeEventHandler(eventType);\n\n        compositeEventHandler.addEventHandler(eventHandler);\n    }"}
{"Number":"31","API Relative Path":"com.sun.javafx.event.EventHandlerManager.java-addEventHandler(EventType-EventHandler)","Corresponding Source":"/**\n     * Registers an event handler in {@code EventHandlerManager}.\n     *\n     * @param <T> the specific event class of the handler\n     * @param eventType the type of the events to receive by the handler\n     * @param eventHandler the handler to register\n     * @throws NullPointerException if the event type or handler is null\n     */\n    public final <T extends Event> void addEventHandler(\n            final EventType<T> eventType,\n            final EventHandler<? super T> eventHandler) {\n        validateEventType(eventType);\n        validateEventHandler(eventHandler);\n\n        final CompositeEventHandler<T> compositeEventHandler =\n                createGetCompositeEventHandler(eventType);\n\n        compositeEventHandler.addEventHandler(eventHandler);\n    }"}
{"Number":"32","API Relative Path":"com.sun.javafx.event.EventHandlerManager.java-addEventHandler(EventType-EventHandler)","Corresponding Source":"/**\n     * Registers an event handler in {@code EventHandlerManager}.\n     *\n     * @param <T> the specific event class of the handler\n     * @param eventType the type of the events to receive by the handler\n     * @param eventHandler the handler to register\n     * @throws NullPointerException if the event type or handler is null\n     */\n    public final <T extends Event> void addEventHandler(\n            final EventType<T> eventType,\n            final EventHandler<? super T> eventHandler) {\n        validateEventType(eventType);\n        validateEventHandler(eventHandler);\n\n        final CompositeEventHandler<T> compositeEventHandler =\n                createGetCompositeEventHandler(eventType);\n\n        compositeEventHandler.addEventHandler(eventHandler);\n    }"}
{"Number":"33","API Relative Path":"com.sun.javafx.event.EventHandlerManager.java-removeEventFilter(EventType-EventHandler)","Corresponding Source":"/**\n     * Unregisters a previously registered event filter.\n     *\n     * @param <T> the specific event class of the filter\n     * @param eventType the event type from which to unregister\n     * @param eventFilter the filter to unregister\n     * @throws NullPointerException if the event type or filter is null\n     */\n    public final <T extends Event> void removeEventFilter(\n            final EventType<T> eventType,\n            final EventHandler<? super T> eventFilter) {\n        validateEventType(eventType);\n        validateEventFilter(eventFilter);\n\n        final CompositeEventHandler<T> compositeEventHandler =\n                (CompositeEventHandler<T>) eventHandlerMap.get(eventType);\n\n        if (compositeEventHandler != null) {\n            compositeEventHandler.removeEventFilter(eventFilter);\n        }\n    }"}
{"Number":"34","API Relative Path":"com.sun.javafx.event.EventHandlerManager.java-removeEventFilter(EventType-EventHandler)","Corresponding Source":"/**\n     * Unregisters a previously registered event filter.\n     *\n     * @param <T> the specific event class of the filter\n     * @param eventType the event type from which to unregister\n     * @param eventFilter the filter to unregister\n     * @throws NullPointerException if the event type or filter is null\n     */\n    public final <T extends Event> void removeEventFilter(\n            final EventType<T> eventType,\n            final EventHandler<? super T> eventFilter) {\n        validateEventType(eventType);\n        validateEventFilter(eventFilter);\n\n        final CompositeEventHandler<T> compositeEventHandler =\n                (CompositeEventHandler<T>) eventHandlerMap.get(eventType);\n\n        if (compositeEventHandler != null) {\n            compositeEventHandler.removeEventFilter(eventFilter);\n        }\n    }"}
{"Number":"35","API Relative Path":"com.sun.javafx.event.EventHandlerManager.java-removeEventFilter(EventType-EventHandler)","Corresponding Source":"/**\n     * Unregisters a previously registered event filter.\n     *\n     * @param <T> the specific event class of the filter\n     * @param eventType the event type from which to unregister\n     * @param eventFilter the filter to unregister\n     * @throws NullPointerException if the event type or filter is null\n     */\n    public final <T extends Event> void removeEventFilter(\n            final EventType<T> eventType,\n            final EventHandler<? super T> eventFilter) {\n        validateEventType(eventType);\n        validateEventFilter(eventFilter);\n\n        final CompositeEventHandler<T> compositeEventHandler =\n                (CompositeEventHandler<T>) eventHandlerMap.get(eventType);\n\n        if (compositeEventHandler != null) {\n            compositeEventHandler.removeEventFilter(eventFilter);\n        }\n    }"}
{"Number":"36","API Relative Path":"com.sun.javafx.event.EventHandlerManager.java-removeEventHandler(EventType-EventHandler)","Corresponding Source":"/**\n     * Unregisters a previously registered event handler.\n     *\n     * @param <T> the specific event class of the handler\n     * @param eventType the event type from which to unregister\n     * @param eventHandler the handler to unregister\n     * @throws NullPointerException if the event type or handler is null\n     */\n    public final <T extends Event> void removeEventHandler(\n            final EventType<T> eventType,\n            final EventHandler<? super T> eventHandler) {\n        validateEventType(eventType);\n        validateEventHandler(eventHandler);\n\n        final CompositeEventHandler<T> compositeEventHandler =\n                (CompositeEventHandler<T>) eventHandlerMap.get(eventType);\n\n        if (compositeEventHandler != null) {\n            compositeEventHandler.removeEventHandler(eventHandler);\n        }\n    }"}
{"Number":"37","API Relative Path":"com.sun.javafx.event.EventHandlerManager.java-removeEventHandler(EventType-EventHandler)","Corresponding Source":"/**\n     * Unregisters a previously registered event handler.\n     *\n     * @param <T> the specific event class of the handler\n     * @param eventType the event type from which to unregister\n     * @param eventHandler the handler to unregister\n     * @throws NullPointerException if the event type or handler is null\n     */\n    public final <T extends Event> void removeEventHandler(\n            final EventType<T> eventType,\n            final EventHandler<? super T> eventHandler) {\n        validateEventType(eventType);\n        validateEventHandler(eventHandler);\n\n        final CompositeEventHandler<T> compositeEventHandler =\n                (CompositeEventHandler<T>) eventHandlerMap.get(eventType);\n\n        if (compositeEventHandler != null) {\n            compositeEventHandler.removeEventHandler(eventHandler);\n        }\n    }"}
{"Number":"38","API Relative Path":"com.sun.javafx.event.EventHandlerManager.java-removeEventHandler(EventType-EventHandler)","Corresponding Source":"/**\n     * Unregisters a previously registered event handler.\n     *\n     * @param <T> the specific event class of the handler\n     * @param eventType the event type from which to unregister\n     * @param eventHandler the handler to unregister\n     * @throws NullPointerException if the event type or handler is null\n     */\n    public final <T extends Event> void removeEventHandler(\n            final EventType<T> eventType,\n            final EventHandler<? super T> eventHandler) {\n        validateEventType(eventType);\n        validateEventHandler(eventHandler);\n\n        final CompositeEventHandler<T> compositeEventHandler =\n                (CompositeEventHandler<T>) eventHandlerMap.get(eventType);\n\n        if (compositeEventHandler != null) {\n            compositeEventHandler.removeEventHandler(eventHandler);\n        }\n    }"}
{"Number":"39","API Relative Path":"com.sun.javafx.event.EventHandlerManager.java-setEventHandler(EventType-EventHandler)","Corresponding Source":"/**\n     * Sets the specified singleton handler. There can only be one such handler\n     * specified at a time.\n     *\n     * @param <T> the specific event class of the handler\n     * @param eventType the event type to associate with the given eventHandler\n     * @param eventHandler the handler to register, or null to unregister\n     * @throws NullPointerException if the event type is null\n     */\n    public final <T extends Event> void setEventHandler(\n            final EventType<T> eventType,\n            final EventHandler<? super T> eventHandler) {\n        validateEventType(eventType);\n\n        CompositeEventHandler<T> compositeEventHandler =\n                (CompositeEventHandler<T>) eventHandlerMap.get(eventType);\n\n        if (compositeEventHandler == null) {\n            if (eventHandler == null) {\n                return;\n            }\n            compositeEventHandler = new CompositeEventHandler<T>();\n            eventHandlerMap.put(eventType, compositeEventHandler);\n        }\n\n        compositeEventHandler.setEventHandler(eventHandler);\n    }"}
{"Number":"40","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-coerce(Object-Class)","Corresponding Source":"/**\n     * Coerces a value to a given type.\n     *\n     * @param value\n     * @param type\n     *\n     * @return\n     * The coerced value.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> T coerce(Object value, Class<? extends T> type) {\n        if (type == null) {\n            throw new NullPointerException();\n        }\n\n        Object coercedValue = null;\n\n        if (value == null) {\n            // Null values can only be coerced to null\n            coercedValue = null;\n        } else if (type.isAssignableFrom(value.getClass())) {\n            // Value doesn't require coercion\n            coercedValue = value;\n        } else if (type == Boolean.class\n            || type == Boolean.TYPE) {\n            coercedValue = Boolean.valueOf(value.toString());\n        } else if (type == Character.class\n            || type == Character.TYPE) {\n            coercedValue = value.toString().charAt(0);\n        } else if (type == Byte.class\n            || type == Byte.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).byteValue();\n            } else {\n                coercedValue = Byte.valueOf(value.toString());\n            }\n        } else if (type == Short.class\n            || type == Short.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).shortValue();\n            } else {\n                coercedValue = Short.valueOf(value.toString());\n            }\n        } else if (type == Integer.class\n            || type == Integer.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).intValue();\n            } else {\n                coercedValue = Integer.valueOf(value.toString());\n            }\n        } else if (type == Long.class\n            || type == Long.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).longValue();\n            } else {\n                coercedValue = Long.valueOf(value.toString());\n            }\n        } else if (type == BigInteger.class) {\n            if (value instanceof Number) {\n                coercedValue = BigInteger.valueOf(((Number)value).longValue());\n            } else {\n                coercedValue = new BigInteger(value.toString());\n            }\n        } else if (type == Float.class\n            || type == Float.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).floatValue();\n            } else {\n                coercedValue = Float.valueOf(value.toString());\n            }\n        } else if (type == Double.class\n            || type == Double.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).doubleValue();\n            } else {\n                coercedValue = Double.valueOf(value.toString());\n            }\n        } else if (type == Number.class) {\n            String number = value.toString();\n            if (number.contains(\".\")) {\n                coercedValue = Double.valueOf(number);\n            } else {\n                coercedValue = Long.valueOf(number);\n            }\n        } else if (type == BigDecimal.class) {\n            if (value instanceof Number) {\n                coercedValue = BigDecimal.valueOf(((Number)value).doubleValue());\n            } else {\n                coercedValue = new BigDecimal(value.toString());\n            }\n        } else if (type == Class.class) {\n            try {\n                final String className = value.toString();\n                ReflectUtil.checkPackageAccess(className);\n                final ClassLoader cl = Thread.currentThread().getContextClassLoader();\n                coercedValue = Class.forName(\n                        className,\n                        false,\n                        cl);\n            } catch (ClassNotFoundException exception) {\n                throw new IllegalArgumentException(exception);\n            }\n        } else {\n            Class<?> valueType = value.getClass();\n            Method valueOfMethod = null;\n\n            while (valueOfMethod == null\n                && valueType != null) {\n                try {\n                    ReflectUtil.checkPackageAccess(type);\n                    valueOfMethod = type.getDeclaredMethod(VALUE_OF_METHOD_NAME, valueType);\n                } catch (NoSuchMethodException exception) {\n                    // No-op\n                }\n\n                if (valueOfMethod == null) {\n                    valueType = valueType.getSuperclass();\n                }\n            }\n\n            if (valueOfMethod == null) {\n                throw new IllegalArgumentException(\"Unable to coerce \" + value + \" to \" + type + \".\");\n            }\n\n            if (type.isEnum()\n                && value instanceof String\n                && Character.isLowerCase(((String)value).charAt(0))) {\n                value = toAllCaps((String)value);\n            }\n\n            try {\n                coercedValue = MethodUtil.invoke(valueOfMethod, null, new Object[] { value });\n            } catch (IllegalAccessException exception) {\n                throw new RuntimeException(exception);\n            } catch (InvocationTargetException exception) {\n                throw new RuntimeException(exception);\n            } catch (SecurityException exception) {\n                throw new RuntimeException(exception);\n            }\n        }\n\n        return (T)coercedValue;\n    }"}
{"Number":"41","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-coerce(Object-Class)","Corresponding Source":"/**\n     * Coerces a value to a given type.\n     *\n     * @param value\n     * @param type\n     *\n     * @return\n     * The coerced value.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> T coerce(Object value, Class<? extends T> type) {\n        if (type == null) {\n            throw new NullPointerException();\n        }\n\n        Object coercedValue = null;\n\n        if (value == null) {\n            // Null values can only be coerced to null\n            coercedValue = null;\n        } else if (type.isAssignableFrom(value.getClass())) {\n            // Value doesn't require coercion\n            coercedValue = value;\n        } else if (type == Boolean.class\n            || type == Boolean.TYPE) {\n            coercedValue = Boolean.valueOf(value.toString());\n        } else if (type == Character.class\n            || type == Character.TYPE) {\n            coercedValue = value.toString().charAt(0);\n        } else if (type == Byte.class\n            || type == Byte.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).byteValue();\n            } else {\n                coercedValue = Byte.valueOf(value.toString());\n            }\n        } else if (type == Short.class\n            || type == Short.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).shortValue();\n            } else {\n                coercedValue = Short.valueOf(value.toString());\n            }\n        } else if (type == Integer.class\n            || type == Integer.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).intValue();\n            } else {\n                coercedValue = Integer.valueOf(value.toString());\n            }\n        } else if (type == Long.class\n            || type == Long.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).longValue();\n            } else {\n                coercedValue = Long.valueOf(value.toString());\n            }\n        } else if (type == BigInteger.class) {\n            if (value instanceof Number) {\n                coercedValue = BigInteger.valueOf(((Number)value).longValue());\n            } else {\n                coercedValue = new BigInteger(value.toString());\n            }\n        } else if (type == Float.class\n            || type == Float.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).floatValue();\n            } else {\n                coercedValue = Float.valueOf(value.toString());\n            }\n        } else if (type == Double.class\n            || type == Double.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).doubleValue();\n            } else {\n                coercedValue = Double.valueOf(value.toString());\n            }\n        } else if (type == Number.class) {\n            String number = value.toString();\n            if (number.contains(\".\")) {\n                coercedValue = Double.valueOf(number);\n            } else {\n                coercedValue = Long.valueOf(number);\n            }\n        } else if (type == BigDecimal.class) {\n            if (value instanceof Number) {\n                coercedValue = BigDecimal.valueOf(((Number)value).doubleValue());\n            } else {\n                coercedValue = new BigDecimal(value.toString());\n            }\n        } else if (type == Class.class) {\n            try {\n                final String className = value.toString();\n                ReflectUtil.checkPackageAccess(className);\n                final ClassLoader cl = Thread.currentThread().getContextClassLoader();\n                coercedValue = Class.forName(\n                        className,\n                        false,\n                        cl);\n            } catch (ClassNotFoundException exception) {\n                throw new IllegalArgumentException(exception);\n            }\n        } else {\n            Class<?> valueType = value.getClass();\n            Method valueOfMethod = null;\n\n            while (valueOfMethod == null\n                && valueType != null) {\n                try {\n                    ReflectUtil.checkPackageAccess(type);\n                    valueOfMethod = type.getDeclaredMethod(VALUE_OF_METHOD_NAME, valueType);\n                } catch (NoSuchMethodException exception) {\n                    // No-op\n                }\n\n                if (valueOfMethod == null) {\n                    valueType = valueType.getSuperclass();\n                }\n            }\n\n            if (valueOfMethod == null) {\n                throw new IllegalArgumentException(\"Unable to coerce \" + value + \" to \" + type + \".\");\n            }\n\n            if (type.isEnum()\n                && value instanceof String\n                && Character.isLowerCase(((String)value).charAt(0))) {\n                value = toAllCaps((String)value);\n            }\n\n            try {\n                coercedValue = MethodUtil.invoke(valueOfMethod, null, new Object[] { value });\n            } catch (IllegalAccessException exception) {\n                throw new RuntimeException(exception);\n            } catch (InvocationTargetException exception) {\n                throw new RuntimeException(exception);\n            } catch (SecurityException exception) {\n                throw new RuntimeException(exception);\n            }\n        }\n\n        return (T)coercedValue;\n    }"}
{"Number":"42","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-coerce(Object-Class)","Corresponding Source":"/**\n     * Coerces a value to a given type.\n     *\n     * @param value\n     * @param type\n     *\n     * @return\n     * The coerced value.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> T coerce(Object value, Class<? extends T> type) {\n        if (type == null) {\n            throw new NullPointerException();\n        }\n\n        Object coercedValue = null;\n\n        if (value == null) {\n            // Null values can only be coerced to null\n            coercedValue = null;\n        } else if (type.isAssignableFrom(value.getClass())) {\n            // Value doesn't require coercion\n            coercedValue = value;\n        } else if (type == Boolean.class\n            || type == Boolean.TYPE) {\n            coercedValue = Boolean.valueOf(value.toString());\n        } else if (type == Character.class\n            || type == Character.TYPE) {\n            coercedValue = value.toString().charAt(0);\n        } else if (type == Byte.class\n            || type == Byte.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).byteValue();\n            } else {\n                coercedValue = Byte.valueOf(value.toString());\n            }\n        } else if (type == Short.class\n            || type == Short.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).shortValue();\n            } else {\n                coercedValue = Short.valueOf(value.toString());\n            }\n        } else if (type == Integer.class\n            || type == Integer.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).intValue();\n            } else {\n                coercedValue = Integer.valueOf(value.toString());\n            }\n        } else if (type == Long.class\n            || type == Long.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).longValue();\n            } else {\n                coercedValue = Long.valueOf(value.toString());\n            }\n        } else if (type == BigInteger.class) {\n            if (value instanceof Number) {\n                coercedValue = BigInteger.valueOf(((Number)value).longValue());\n            } else {\n                coercedValue = new BigInteger(value.toString());\n            }\n        } else if (type == Float.class\n            || type == Float.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).floatValue();\n            } else {\n                coercedValue = Float.valueOf(value.toString());\n            }\n        } else if (type == Double.class\n            || type == Double.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).doubleValue();\n            } else {\n                coercedValue = Double.valueOf(value.toString());\n            }\n        } else if (type == Number.class) {\n            String number = value.toString();\n            if (number.contains(\".\")) {\n                coercedValue = Double.valueOf(number);\n            } else {\n                coercedValue = Long.valueOf(number);\n            }\n        } else if (type == BigDecimal.class) {\n            if (value instanceof Number) {\n                coercedValue = BigDecimal.valueOf(((Number)value).doubleValue());\n            } else {\n                coercedValue = new BigDecimal(value.toString());\n            }\n        } else if (type == Class.class) {\n            try {\n                final String className = value.toString();\n                ReflectUtil.checkPackageAccess(className);\n                final ClassLoader cl = Thread.currentThread().getContextClassLoader();\n                coercedValue = Class.forName(\n                        className,\n                        false,\n                        cl);\n            } catch (ClassNotFoundException exception) {\n                throw new IllegalArgumentException(exception);\n            }\n        } else {\n            Class<?> valueType = value.getClass();\n            Method valueOfMethod = null;\n\n            while (valueOfMethod == null\n                && valueType != null) {\n                try {\n                    ReflectUtil.checkPackageAccess(type);\n                    valueOfMethod = type.getDeclaredMethod(VALUE_OF_METHOD_NAME, valueType);\n                } catch (NoSuchMethodException exception) {\n                    // No-op\n                }\n\n                if (valueOfMethod == null) {\n                    valueType = valueType.getSuperclass();\n                }\n            }\n\n            if (valueOfMethod == null) {\n                throw new IllegalArgumentException(\"Unable to coerce \" + value + \" to \" + type + \".\");\n            }\n\n            if (type.isEnum()\n                && value instanceof String\n                && Character.isLowerCase(((String)value).charAt(0))) {\n                value = toAllCaps((String)value);\n            }\n\n            try {\n                coercedValue = MethodUtil.invoke(valueOfMethod, null, new Object[] { value });\n            } catch (IllegalAccessException exception) {\n                throw new RuntimeException(exception);\n            } catch (InvocationTargetException exception) {\n                throw new RuntimeException(exception);\n            } catch (SecurityException exception) {\n                throw new RuntimeException(exception);\n            }\n        }\n\n        return (T)coercedValue;\n    }"}
{"Number":"43","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-coerce(Object-Class)","Corresponding Source":"/**\n     * Coerces a value to a given type.\n     *\n     * @param value\n     * @param type\n     *\n     * @return\n     * The coerced value.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> T coerce(Object value, Class<? extends T> type) {\n        if (type == null) {\n            throw new NullPointerException();\n        }\n\n        Object coercedValue = null;\n\n        if (value == null) {\n            // Null values can only be coerced to null\n            coercedValue = null;\n        } else if (type.isAssignableFrom(value.getClass())) {\n            // Value doesn't require coercion\n            coercedValue = value;\n        } else if (type == Boolean.class\n            || type == Boolean.TYPE) {\n            coercedValue = Boolean.valueOf(value.toString());\n        } else if (type == Character.class\n            || type == Character.TYPE) {\n            coercedValue = value.toString().charAt(0);\n        } else if (type == Byte.class\n            || type == Byte.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).byteValue();\n            } else {\n                coercedValue = Byte.valueOf(value.toString());\n            }\n        } else if (type == Short.class\n            || type == Short.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).shortValue();\n            } else {\n                coercedValue = Short.valueOf(value.toString());\n            }\n        } else if (type == Integer.class\n            || type == Integer.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).intValue();\n            } else {\n                coercedValue = Integer.valueOf(value.toString());\n            }\n        } else if (type == Long.class\n            || type == Long.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).longValue();\n            } else {\n                coercedValue = Long.valueOf(value.toString());\n            }\n        } else if (type == BigInteger.class) {\n            if (value instanceof Number) {\n                coercedValue = BigInteger.valueOf(((Number)value).longValue());\n            } else {\n                coercedValue = new BigInteger(value.toString());\n            }\n        } else if (type == Float.class\n            || type == Float.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).floatValue();\n            } else {\n                coercedValue = Float.valueOf(value.toString());\n            }\n        } else if (type == Double.class\n            || type == Double.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).doubleValue();\n            } else {\n                coercedValue = Double.valueOf(value.toString());\n            }\n        } else if (type == Number.class) {\n            String number = value.toString();\n            if (number.contains(\".\")) {\n                coercedValue = Double.valueOf(number);\n            } else {\n                coercedValue = Long.valueOf(number);\n            }\n        } else if (type == BigDecimal.class) {\n            if (value instanceof Number) {\n                coercedValue = BigDecimal.valueOf(((Number)value).doubleValue());\n            } else {\n                coercedValue = new BigDecimal(value.toString());\n            }\n        } else if (type == Class.class) {\n            try {\n                final String className = value.toString();\n                ReflectUtil.checkPackageAccess(className);\n                final ClassLoader cl = Thread.currentThread().getContextClassLoader();\n                coercedValue = Class.forName(\n                        className,\n                        false,\n                        cl);\n            } catch (ClassNotFoundException exception) {\n                throw new IllegalArgumentException(exception);\n            }\n        } else {\n            Class<?> valueType = value.getClass();\n            Method valueOfMethod = null;\n\n            while (valueOfMethod == null\n                && valueType != null) {\n                try {\n                    ReflectUtil.checkPackageAccess(type);\n                    valueOfMethod = type.getDeclaredMethod(VALUE_OF_METHOD_NAME, valueType);\n                } catch (NoSuchMethodException exception) {\n                    // No-op\n                }\n\n                if (valueOfMethod == null) {\n                    valueType = valueType.getSuperclass();\n                }\n            }\n\n            if (valueOfMethod == null) {\n                throw new IllegalArgumentException(\"Unable to coerce \" + value + \" to \" + type + \".\");\n            }\n\n            if (type.isEnum()\n                && value instanceof String\n                && Character.isLowerCase(((String)value).charAt(0))) {\n                value = toAllCaps((String)value);\n            }\n\n            try {\n                coercedValue = MethodUtil.invoke(valueOfMethod, null, new Object[] { value });\n            } catch (IllegalAccessException exception) {\n                throw new RuntimeException(exception);\n            } catch (InvocationTargetException exception) {\n                throw new RuntimeException(exception);\n            } catch (SecurityException exception) {\n                throw new RuntimeException(exception);\n            }\n        }\n\n        return (T)coercedValue;\n    }"}
{"Number":"44","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-coerce(Object-Class)","Corresponding Source":"/**\n     * Coerces a value to a given type.\n     *\n     * @param value\n     * @param type\n     *\n     * @return\n     * The coerced value.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> T coerce(Object value, Class<? extends T> type) {\n        if (type == null) {\n            throw new NullPointerException();\n        }\n\n        Object coercedValue = null;\n\n        if (value == null) {\n            // Null values can only be coerced to null\n            coercedValue = null;\n        } else if (type.isAssignableFrom(value.getClass())) {\n            // Value doesn't require coercion\n            coercedValue = value;\n        } else if (type == Boolean.class\n            || type == Boolean.TYPE) {\n            coercedValue = Boolean.valueOf(value.toString());\n        } else if (type == Character.class\n            || type == Character.TYPE) {\n            coercedValue = value.toString().charAt(0);\n        } else if (type == Byte.class\n            || type == Byte.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).byteValue();\n            } else {\n                coercedValue = Byte.valueOf(value.toString());\n            }\n        } else if (type == Short.class\n            || type == Short.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).shortValue();\n            } else {\n                coercedValue = Short.valueOf(value.toString());\n            }\n        } else if (type == Integer.class\n            || type == Integer.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).intValue();\n            } else {\n                coercedValue = Integer.valueOf(value.toString());\n            }\n        } else if (type == Long.class\n            || type == Long.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).longValue();\n            } else {\n                coercedValue = Long.valueOf(value.toString());\n            }\n        } else if (type == BigInteger.class) {\n            if (value instanceof Number) {\n                coercedValue = BigInteger.valueOf(((Number)value).longValue());\n            } else {\n                coercedValue = new BigInteger(value.toString());\n            }\n        } else if (type == Float.class\n            || type == Float.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).floatValue();\n            } else {\n                coercedValue = Float.valueOf(value.toString());\n            }\n        } else if (type == Double.class\n            || type == Double.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).doubleValue();\n            } else {\n                coercedValue = Double.valueOf(value.toString());\n            }\n        } else if (type == Number.class) {\n            String number = value.toString();\n            if (number.contains(\".\")) {\n                coercedValue = Double.valueOf(number);\n            } else {\n                coercedValue = Long.valueOf(number);\n            }\n        } else if (type == BigDecimal.class) {\n            if (value instanceof Number) {\n                coercedValue = BigDecimal.valueOf(((Number)value).doubleValue());\n            } else {\n                coercedValue = new BigDecimal(value.toString());\n            }\n        } else if (type == Class.class) {\n            try {\n                final String className = value.toString();\n                ReflectUtil.checkPackageAccess(className);\n                final ClassLoader cl = Thread.currentThread().getContextClassLoader();\n                coercedValue = Class.forName(\n                        className,\n                        false,\n                        cl);\n            } catch (ClassNotFoundException exception) {\n                throw new IllegalArgumentException(exception);\n            }\n        } else {\n            Class<?> valueType = value.getClass();\n            Method valueOfMethod = null;\n\n            while (valueOfMethod == null\n                && valueType != null) {\n                try {\n                    ReflectUtil.checkPackageAccess(type);\n                    valueOfMethod = type.getDeclaredMethod(VALUE_OF_METHOD_NAME, valueType);\n                } catch (NoSuchMethodException exception) {\n                    // No-op\n                }\n\n                if (valueOfMethod == null) {\n                    valueType = valueType.getSuperclass();\n                }\n            }\n\n            if (valueOfMethod == null) {\n                throw new IllegalArgumentException(\"Unable to coerce \" + value + \" to \" + type + \".\");\n            }\n\n            if (type.isEnum()\n                && value instanceof String\n                && Character.isLowerCase(((String)value).charAt(0))) {\n                value = toAllCaps((String)value);\n            }\n\n            try {\n                coercedValue = MethodUtil.invoke(valueOfMethod, null, new Object[] { value });\n            } catch (IllegalAccessException exception) {\n                throw new RuntimeException(exception);\n            } catch (InvocationTargetException exception) {\n                throw new RuntimeException(exception);\n            } catch (SecurityException exception) {\n                throw new RuntimeException(exception);\n            }\n        }\n\n        return (T)coercedValue;\n    }"}
{"Number":"45","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-coerce(Object-Class)","Corresponding Source":"/**\n     * Coerces a value to a given type.\n     *\n     * @param value\n     * @param type\n     *\n     * @return\n     * The coerced value.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> T coerce(Object value, Class<? extends T> type) {\n        if (type == null) {\n            throw new NullPointerException();\n        }\n\n        Object coercedValue = null;\n\n        if (value == null) {\n            // Null values can only be coerced to null\n            coercedValue = null;\n        } else if (type.isAssignableFrom(value.getClass())) {\n            // Value doesn't require coercion\n            coercedValue = value;\n        } else if (type == Boolean.class\n            || type == Boolean.TYPE) {\n            coercedValue = Boolean.valueOf(value.toString());\n        } else if (type == Character.class\n            || type == Character.TYPE) {\n            coercedValue = value.toString().charAt(0);\n        } else if (type == Byte.class\n            || type == Byte.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).byteValue();\n            } else {\n                coercedValue = Byte.valueOf(value.toString());\n            }\n        } else if (type == Short.class\n            || type == Short.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).shortValue();\n            } else {\n                coercedValue = Short.valueOf(value.toString());\n            }\n        } else if (type == Integer.class\n            || type == Integer.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).intValue();\n            } else {\n                coercedValue = Integer.valueOf(value.toString());\n            }\n        } else if (type == Long.class\n            || type == Long.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).longValue();\n            } else {\n                coercedValue = Long.valueOf(value.toString());\n            }\n        } else if (type == BigInteger.class) {\n            if (value instanceof Number) {\n                coercedValue = BigInteger.valueOf(((Number)value).longValue());\n            } else {\n                coercedValue = new BigInteger(value.toString());\n            }\n        } else if (type == Float.class\n            || type == Float.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).floatValue();\n            } else {\n                coercedValue = Float.valueOf(value.toString());\n            }\n        } else if (type == Double.class\n            || type == Double.TYPE) {\n            if (value instanceof Number) {\n                coercedValue = ((Number)value).doubleValue();\n            } else {\n                coercedValue = Double.valueOf(value.toString());\n            }\n        } else if (type == Number.class) {\n            String number = value.toString();\n            if (number.contains(\".\")) {\n                coercedValue = Double.valueOf(number);\n            } else {\n                coercedValue = Long.valueOf(number);\n            }\n        } else if (type == BigDecimal.class) {\n            if (value instanceof Number) {\n                coercedValue = BigDecimal.valueOf(((Number)value).doubleValue());\n            } else {\n                coercedValue = new BigDecimal(value.toString());\n            }\n        } else if (type == Class.class) {\n            try {\n                final String className = value.toString();\n                ReflectUtil.checkPackageAccess(className);\n                final ClassLoader cl = Thread.currentThread().getContextClassLoader();\n                coercedValue = Class.forName(\n                        className,\n                        false,\n                        cl);\n            } catch (ClassNotFoundException exception) {\n                throw new IllegalArgumentException(exception);\n            }\n        } else {\n            Class<?> valueType = value.getClass();\n            Method valueOfMethod = null;\n\n            while (valueOfMethod == null\n                && valueType != null) {\n                try {\n                    ReflectUtil.checkPackageAccess(type);\n                    valueOfMethod = type.getDeclaredMethod(VALUE_OF_METHOD_NAME, valueType);\n                } catch (NoSuchMethodException exception) {\n                    // No-op\n                }\n\n                if (valueOfMethod == null) {\n                    valueType = valueType.getSuperclass();\n                }\n            }\n\n            if (valueOfMethod == null) {\n                throw new IllegalArgumentException(\"Unable to coerce \" + value + \" to \" + type + \".\");\n            }\n\n            if (type.isEnum()\n                && value instanceof String\n                && Character.isLowerCase(((String)value).charAt(0))) {\n                value = toAllCaps((String)value);\n            }\n\n            try {\n                coercedValue = MethodUtil.invoke(valueOfMethod, null, new Object[] { value });\n            } catch (IllegalAccessException exception) {\n                throw new RuntimeException(exception);\n            } catch (InvocationTargetException exception) {\n                throw new RuntimeException(exception);\n            } catch (SecurityException exception) {\n                throw new RuntimeException(exception);\n            }\n        }\n\n        return (T)coercedValue;\n    }"}
{"Number":"46","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-containsKey(Object)","Corresponding Source":"/**\n     * Verifies the existence of a property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @return\n     * <tt>true<\/tt> if the property exists; <tt>false<\/tt>, otherwise.\n     */\n    @Override\n    public boolean containsKey(Object key) {\n        if (key == null) {\n            throw new NullPointerException();\n        }\n\n        return getType(key.toString()) != null;\n    }"}
{"Number":"47","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-get(Object)","Corresponding Source":"/**\n     * Invokes the getter method for the given property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @return\n     * The value returned by the method, or <tt>null<\/tt> if no such method\n     * exists.\n     */\n    @Override\n    public Object get(Object key) {\n        if (key == null) {\n            throw new NullPointerException();\n        }\n\n        return get(key.toString());\n    }"}
{"Number":"48","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-get(Object-Class-String)","Corresponding Source":"/**\n     * Invokes the static getter method for the given property.\n     *\n     * @param target\n     * The object to which the property is attached.\n     *\n     * @param sourceType\n     * The class that defines the property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @return\n     * The value returned by the method, or <tt>null<\/tt> if no such method\n     * exists.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> T get(Object target, Class<?> sourceType, String key) {\n        T value = null;\n\n        Class<?> targetType = target.getClass();\n        Method getterMethod = getStaticGetterMethod(sourceType, key, targetType);\n\n        if (getterMethod != null) {\n            try {\n                value = (T) MethodUtil.invoke(getterMethod, null, new Object[] { target } );\n            } catch (InvocationTargetException exception) {\n                throw new RuntimeException(exception);\n            } catch (IllegalAccessException exception) {\n                throw new RuntimeException(exception);\n            }\n        }\n\n        return value;\n    }"}
{"Number":"49","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-get(Object-Class-String)","Corresponding Source":"/**\n     * Invokes the static getter method for the given property.\n     *\n     * @param target\n     * The object to which the property is attached.\n     *\n     * @param sourceType\n     * The class that defines the property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @return\n     * The value returned by the method, or <tt>null<\/tt> if no such method\n     * exists.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> T get(Object target, Class<?> sourceType, String key) {\n        T value = null;\n\n        Class<?> targetType = target.getClass();\n        Method getterMethod = getStaticGetterMethod(sourceType, key, targetType);\n\n        if (getterMethod != null) {\n            try {\n                value = (T) MethodUtil.invoke(getterMethod, null, new Object[] { target } );\n            } catch (InvocationTargetException exception) {\n                throw new RuntimeException(exception);\n            } catch (IllegalAccessException exception) {\n                throw new RuntimeException(exception);\n            }\n        }\n\n        return value;\n    }"}
{"Number":"50","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-getConstantValue(Class-String)","Corresponding Source":"/**\n     * Returns the value of a named constant.\n     *\n     * @param type\n     * The type that defines the constant.\n     *\n     * @param name\n     * The name of the constant.\n     */\n    public static Object getConstantValue(Class<?> type, String name) {\n        if (type == null) {\n            throw new IllegalArgumentException();\n        }\n\n        if (name == null) {\n            throw new IllegalArgumentException();\n        }\n\n        Field field;\n        try {\n            field = FieldUtil.getField(type, name);\n        } catch (NoSuchFieldException exception) {\n            throw new IllegalArgumentException(exception);\n        }\n\n        int fieldModifiers = field.getModifiers();\n        if ((fieldModifiers & Modifier.STATIC) == 0\n            || (fieldModifiers & Modifier.FINAL) == 0) {\n            throw new IllegalArgumentException(\"Field is not a constant.\");\n        }\n\n        Object value;\n        try {\n            value = field.get(null);\n        } catch (IllegalAccessException exception) {\n            throw new IllegalArgumentException(exception);\n        }\n\n        return value;\n    }"}
{"Number":"51","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-getConstantValue(Class-String)","Corresponding Source":"/**\n     * Returns the value of a named constant.\n     *\n     * @param type\n     * The type that defines the constant.\n     *\n     * @param name\n     * The name of the constant.\n     */\n    public static Object getConstantValue(Class<?> type, String name) {\n        if (type == null) {\n            throw new IllegalArgumentException();\n        }\n\n        if (name == null) {\n            throw new IllegalArgumentException();\n        }\n\n        Field field;\n        try {\n            field = FieldUtil.getField(type, name);\n        } catch (NoSuchFieldException exception) {\n            throw new IllegalArgumentException(exception);\n        }\n\n        int fieldModifiers = field.getModifiers();\n        if ((fieldModifiers & Modifier.STATIC) == 0\n            || (fieldModifiers & Modifier.FINAL) == 0) {\n            throw new IllegalArgumentException(\"Field is not a constant.\");\n        }\n\n        Object value;\n        try {\n            value = field.get(null);\n        } catch (IllegalAccessException exception) {\n            throw new IllegalArgumentException(exception);\n        }\n\n        return value;\n    }"}
{"Number":"52","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-getGenericType(Class-String-Class)","Corresponding Source":"/**\n     * Returns the generic type of a static property.\n     *\n     * @param sourceType\n     * The class that defines the property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @param targetType\n     * The type of the object to which the property applies.\n     */\n    public static Type getGenericType(Class<?> sourceType, String key, Class<?> targetType) {\n        Method getterMethod = getStaticGetterMethod(sourceType, key, targetType);\n        return (getterMethod == null) ? null : getterMethod.getGenericReturnType();\n    }"}
{"Number":"53","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-getGenericType(Class-String-Class)","Corresponding Source":"/**\n     * Returns the generic type of a static property.\n     *\n     * @param sourceType\n     * The class that defines the property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @param targetType\n     * The type of the object to which the property applies.\n     */\n    public static Type getGenericType(Class<?> sourceType, String key, Class<?> targetType) {\n        Method getterMethod = getStaticGetterMethod(sourceType, key, targetType);\n        return (getterMethod == null) ? null : getterMethod.getGenericReturnType();\n    }"}
{"Number":"54","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-getGenericType(String)","Corresponding Source":"/**\n     * Returns the generic type of a property.\n     *\n     * @param key\n     * The property name.\n     */\n    public Type getGenericType(String key) {\n        if (key == null) {\n            throw new NullPointerException();\n        }\n\n        Method getterMethod = getGetterMethod(key);\n\n        return (getterMethod == null) ? null : getterMethod.getGenericReturnType();\n    }"}
{"Number":"55","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-getPropertyModel(String)","Corresponding Source":"/**\n     * Returns the property model for the given property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @return\n     * The named property model, or <tt>null<\/tt> if no such property exists.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> ObservableValue<T> getPropertyModel(String key) {\n        if (key == null) {\n            throw new NullPointerException();\n        }\n\n        return (ObservableValue<T>)get(key + BeanAdapter.PROPERTY_SUFFIX);\n    }"}
{"Number":"56","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-getType(Class-String-Class)","Corresponding Source":"/**\n     * Returns the type of a static property.\n     *\n     * @param sourceType\n     * The class that defines the property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @param targetType\n     * The type of the object to which the property applies.\n     */\n    public static Class<?> getType(Class<?> sourceType, String key, Class<?> targetType) {\n        Method getterMethod = getStaticGetterMethod(sourceType, key, targetType);\n        return (getterMethod == null) ? null : getterMethod.getReturnType();\n    }"}
{"Number":"57","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-getType(Class-String-Class)","Corresponding Source":"/**\n     * Returns the type of a static property.\n     *\n     * @param sourceType\n     * The class that defines the property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @param targetType\n     * The type of the object to which the property applies.\n     */\n    public static Class<?> getType(Class<?> sourceType, String key, Class<?> targetType) {\n        Method getterMethod = getStaticGetterMethod(sourceType, key, targetType);\n        return (getterMethod == null) ? null : getterMethod.getReturnType();\n    }"}
{"Number":"58","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-getType(String)","Corresponding Source":"/**\n     * Returns the type of a property.\n     *\n     * @param key\n     * The property name.\n     */\n    public Class<?> getType(String key) {\n        if (key == null) {\n            throw new NullPointerException();\n        }\n\n        Method getterMethod = getGetterMethod(key);\n\n        return (getterMethod == null) ? null : getterMethod.getReturnType();\n    }"}
{"Number":"59","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-isDefined(Class-String-Class)","Corresponding Source":"/**\n     * Tests the existence of a static property.\n     *\n     * @param sourceType\n     * The class that defines the property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @param targetType\n     * The type of the object to which the property applies.\n     *\n     * @return\n     * <tt>true<\/tt> if the property exists; <tt>false<\/tt>, otherwise.\n     */\n    public static boolean isDefined(Class<?> sourceType, String key, Class<?> targetType) {\n        return (getStaticGetterMethod(sourceType, key, targetType) != null);\n    }"}
{"Number":"60","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-isDefined(Class-String-Class)","Corresponding Source":"/**\n     * Tests the existence of a static property.\n     *\n     * @param sourceType\n     * The class that defines the property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @param targetType\n     * The type of the object to which the property applies.\n     *\n     * @return\n     * <tt>true<\/tt> if the property exists; <tt>false<\/tt>, otherwise.\n     */\n    public static boolean isDefined(Class<?> sourceType, String key, Class<?> targetType) {\n        return (getStaticGetterMethod(sourceType, key, targetType) != null);\n    }"}
{"Number":"61","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-isReadOnly(String)","Corresponding Source":"/**\n     * Tests the mutability of a property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @return\n     * <tt>true<\/tt> if the property is read-only; <tt>false<\/tt>, otherwise.\n     */\n    public boolean isReadOnly(String key) {\n        if (key == null) {\n            throw new NullPointerException();\n        }\n\n        return getSetterMethod(key) == null;\n    }"}
{"Number":"62","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-isReadOnly(String)","Corresponding Source":"/**\n     * Tests the mutability of a property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @return\n     * <tt>true<\/tt> if the property is read-only; <tt>false<\/tt>, otherwise.\n     */\n    public boolean isReadOnly(String key) {\n        if (key == null) {\n            throw new NullPointerException();\n        }\n\n        return getSetterMethod(key) == null;\n    }"}
{"Number":"63","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-put(Object-Class-String-Object)","Corresponding Source":"/**\n     * Invokes a static setter method for the given property. If the value is\n     * <tt>null<\/tt> or there is no explicit setter for a given type, the\n     * {@link #coerce(Object, Class)} method is used to attempt to convert the\n     * value to the actual property type (defined by the return value of the\n     * getter method).\n     *\n     * @param target\n     * The object to which the property is or will be attached.\n     *\n     * @param sourceType\n     * The class that defines the property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @param value\n     * The new property value.\n     *\n     * @throws PropertyNotFoundException\n     * If the given static property does not exist or is read-only.\n     */\n    public static void put(Object target, Class<?> sourceType, String key, Object value) {\n        Class<?> targetType = target.getClass();\n\n        Method setterMethod = null;\n        if (value != null) {\n            setterMethod = getStaticSetterMethod(sourceType, key, value.getClass(), targetType);\n        }\n\n        if (setterMethod == null) {\n            // Get the property type and attempt to coerce the value to it\n            Class<?> propertyType = getType(sourceType, key, targetType);\n\n            if (propertyType != null) {\n                setterMethod = getStaticSetterMethod(sourceType, key, propertyType, targetType);\n                value = coerce(value, propertyType);\n            }\n        }\n\n        if (setterMethod == null) {\n            throw new PropertyNotFoundException(\"Static property \\\"\" + key + \"\\\" does not exist\"\n                + \" or is read-only.\");\n        }\n\n        // Invoke the setter\n        try {\n            MethodUtil.invoke(setterMethod, null, new Object[] { target, value });\n        } catch (InvocationTargetException exception) {\n            throw new RuntimeException(exception);\n        } catch (IllegalAccessException exception) {\n            throw new RuntimeException(exception);\n        }\n    }"}
{"Number":"64","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-put(Object-Class-String-Object)","Corresponding Source":"/**\n     * Invokes a static setter method for the given property. If the value is\n     * <tt>null<\/tt> or there is no explicit setter for a given type, the\n     * {@link #coerce(Object, Class)} method is used to attempt to convert the\n     * value to the actual property type (defined by the return value of the\n     * getter method).\n     *\n     * @param target\n     * The object to which the property is or will be attached.\n     *\n     * @param sourceType\n     * The class that defines the property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @param value\n     * The new property value.\n     *\n     * @throws PropertyNotFoundException\n     * If the given static property does not exist or is read-only.\n     */\n    public static void put(Object target, Class<?> sourceType, String key, Object value) {\n        Class<?> targetType = target.getClass();\n\n        Method setterMethod = null;\n        if (value != null) {\n            setterMethod = getStaticSetterMethod(sourceType, key, value.getClass(), targetType);\n        }\n\n        if (setterMethod == null) {\n            // Get the property type and attempt to coerce the value to it\n            Class<?> propertyType = getType(sourceType, key, targetType);\n\n            if (propertyType != null) {\n                setterMethod = getStaticSetterMethod(sourceType, key, propertyType, targetType);\n                value = coerce(value, propertyType);\n            }\n        }\n\n        if (setterMethod == null) {\n            throw new PropertyNotFoundException(\"Static property \\\"\" + key + \"\\\" does not exist\"\n                + \" or is read-only.\");\n        }\n\n        // Invoke the setter\n        try {\n            MethodUtil.invoke(setterMethod, null, new Object[] { target, value });\n        } catch (InvocationTargetException exception) {\n            throw new RuntimeException(exception);\n        } catch (IllegalAccessException exception) {\n            throw new RuntimeException(exception);\n        }\n    }"}
{"Number":"65","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-put(Object-Class-String-Object)","Corresponding Source":"/**\n     * Invokes a static setter method for the given property. If the value is\n     * <tt>null<\/tt> or there is no explicit setter for a given type, the\n     * {@link #coerce(Object, Class)} method is used to attempt to convert the\n     * value to the actual property type (defined by the return value of the\n     * getter method).\n     *\n     * @param target\n     * The object to which the property is or will be attached.\n     *\n     * @param sourceType\n     * The class that defines the property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @param value\n     * The new property value.\n     *\n     * @throws PropertyNotFoundException\n     * If the given static property does not exist or is read-only.\n     */\n    public static void put(Object target, Class<?> sourceType, String key, Object value) {\n        Class<?> targetType = target.getClass();\n\n        Method setterMethod = null;\n        if (value != null) {\n            setterMethod = getStaticSetterMethod(sourceType, key, value.getClass(), targetType);\n        }\n\n        if (setterMethod == null) {\n            // Get the property type and attempt to coerce the value to it\n            Class<?> propertyType = getType(sourceType, key, targetType);\n\n            if (propertyType != null) {\n                setterMethod = getStaticSetterMethod(sourceType, key, propertyType, targetType);\n                value = coerce(value, propertyType);\n            }\n        }\n\n        if (setterMethod == null) {\n            throw new PropertyNotFoundException(\"Static property \\\"\" + key + \"\\\" does not exist\"\n                + \" or is read-only.\");\n        }\n\n        // Invoke the setter\n        try {\n            MethodUtil.invoke(setterMethod, null, new Object[] { target, value });\n        } catch (InvocationTargetException exception) {\n            throw new RuntimeException(exception);\n        } catch (IllegalAccessException exception) {\n            throw new RuntimeException(exception);\n        }\n    }"}
{"Number":"66","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-put(Object-Class-String-Object)","Corresponding Source":"/**\n     * Invokes a static setter method for the given property. If the value is\n     * <tt>null<\/tt> or there is no explicit setter for a given type, the\n     * {@link #coerce(Object, Class)} method is used to attempt to convert the\n     * value to the actual property type (defined by the return value of the\n     * getter method).\n     *\n     * @param target\n     * The object to which the property is or will be attached.\n     *\n     * @param sourceType\n     * The class that defines the property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @param value\n     * The new property value.\n     *\n     * @throws PropertyNotFoundException\n     * If the given static property does not exist or is read-only.\n     */\n    public static void put(Object target, Class<?> sourceType, String key, Object value) {\n        Class<?> targetType = target.getClass();\n\n        Method setterMethod = null;\n        if (value != null) {\n            setterMethod = getStaticSetterMethod(sourceType, key, value.getClass(), targetType);\n        }\n\n        if (setterMethod == null) {\n            // Get the property type and attempt to coerce the value to it\n            Class<?> propertyType = getType(sourceType, key, targetType);\n\n            if (propertyType != null) {\n                setterMethod = getStaticSetterMethod(sourceType, key, propertyType, targetType);\n                value = coerce(value, propertyType);\n            }\n        }\n\n        if (setterMethod == null) {\n            throw new PropertyNotFoundException(\"Static property \\\"\" + key + \"\\\" does not exist\"\n                + \" or is read-only.\");\n        }\n\n        // Invoke the setter\n        try {\n            MethodUtil.invoke(setterMethod, null, new Object[] { target, value });\n        } catch (InvocationTargetException exception) {\n            throw new RuntimeException(exception);\n        } catch (IllegalAccessException exception) {\n            throw new RuntimeException(exception);\n        }\n    }"}
{"Number":"67","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-put(Object-Class-String-Object)","Corresponding Source":"/**\n     * Invokes a static setter method for the given property. If the value is\n     * <tt>null<\/tt> or there is no explicit setter for a given type, the\n     * {@link #coerce(Object, Class)} method is used to attempt to convert the\n     * value to the actual property type (defined by the return value of the\n     * getter method).\n     *\n     * @param target\n     * The object to which the property is or will be attached.\n     *\n     * @param sourceType\n     * The class that defines the property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @param value\n     * The new property value.\n     *\n     * @throws PropertyNotFoundException\n     * If the given static property does not exist or is read-only.\n     */\n    public static void put(Object target, Class<?> sourceType, String key, Object value) {\n        Class<?> targetType = target.getClass();\n\n        Method setterMethod = null;\n        if (value != null) {\n            setterMethod = getStaticSetterMethod(sourceType, key, value.getClass(), targetType);\n        }\n\n        if (setterMethod == null) {\n            // Get the property type and attempt to coerce the value to it\n            Class<?> propertyType = getType(sourceType, key, targetType);\n\n            if (propertyType != null) {\n                setterMethod = getStaticSetterMethod(sourceType, key, propertyType, targetType);\n                value = coerce(value, propertyType);\n            }\n        }\n\n        if (setterMethod == null) {\n            throw new PropertyNotFoundException(\"Static property \\\"\" + key + \"\\\" does not exist\"\n                + \" or is read-only.\");\n        }\n\n        // Invoke the setter\n        try {\n            MethodUtil.invoke(setterMethod, null, new Object[] { target, value });\n        } catch (InvocationTargetException exception) {\n            throw new RuntimeException(exception);\n        } catch (IllegalAccessException exception) {\n            throw new RuntimeException(exception);\n        }\n    }"}
{"Number":"68","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-put(Object-Class-String-Object)","Corresponding Source":"/**\n     * Invokes a static setter method for the given property. If the value is\n     * <tt>null<\/tt> or there is no explicit setter for a given type, the\n     * {@link #coerce(Object, Class)} method is used to attempt to convert the\n     * value to the actual property type (defined by the return value of the\n     * getter method).\n     *\n     * @param target\n     * The object to which the property is or will be attached.\n     *\n     * @param sourceType\n     * The class that defines the property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @param value\n     * The new property value.\n     *\n     * @throws PropertyNotFoundException\n     * If the given static property does not exist or is read-only.\n     */\n    public static void put(Object target, Class<?> sourceType, String key, Object value) {\n        Class<?> targetType = target.getClass();\n\n        Method setterMethod = null;\n        if (value != null) {\n            setterMethod = getStaticSetterMethod(sourceType, key, value.getClass(), targetType);\n        }\n\n        if (setterMethod == null) {\n            // Get the property type and attempt to coerce the value to it\n            Class<?> propertyType = getType(sourceType, key, targetType);\n\n            if (propertyType != null) {\n                setterMethod = getStaticSetterMethod(sourceType, key, propertyType, targetType);\n                value = coerce(value, propertyType);\n            }\n        }\n\n        if (setterMethod == null) {\n            throw new PropertyNotFoundException(\"Static property \\\"\" + key + \"\\\" does not exist\"\n                + \" or is read-only.\");\n        }\n\n        // Invoke the setter\n        try {\n            MethodUtil.invoke(setterMethod, null, new Object[] { target, value });\n        } catch (InvocationTargetException exception) {\n            throw new RuntimeException(exception);\n        } catch (IllegalAccessException exception) {\n            throw new RuntimeException(exception);\n        }\n    }"}
{"Number":"69","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-put(Object-Class-String-Object)","Corresponding Source":"/**\n     * Invokes a static setter method for the given property. If the value is\n     * <tt>null<\/tt> or there is no explicit setter for a given type, the\n     * {@link #coerce(Object, Class)} method is used to attempt to convert the\n     * value to the actual property type (defined by the return value of the\n     * getter method).\n     *\n     * @param target\n     * The object to which the property is or will be attached.\n     *\n     * @param sourceType\n     * The class that defines the property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @param value\n     * The new property value.\n     *\n     * @throws PropertyNotFoundException\n     * If the given static property does not exist or is read-only.\n     */\n    public static void put(Object target, Class<?> sourceType, String key, Object value) {\n        Class<?> targetType = target.getClass();\n\n        Method setterMethod = null;\n        if (value != null) {\n            setterMethod = getStaticSetterMethod(sourceType, key, value.getClass(), targetType);\n        }\n\n        if (setterMethod == null) {\n            // Get the property type and attempt to coerce the value to it\n            Class<?> propertyType = getType(sourceType, key, targetType);\n\n            if (propertyType != null) {\n                setterMethod = getStaticSetterMethod(sourceType, key, propertyType, targetType);\n                value = coerce(value, propertyType);\n            }\n        }\n\n        if (setterMethod == null) {\n            throw new PropertyNotFoundException(\"Static property \\\"\" + key + \"\\\" does not exist\"\n                + \" or is read-only.\");\n        }\n\n        // Invoke the setter\n        try {\n            MethodUtil.invoke(setterMethod, null, new Object[] { target, value });\n        } catch (InvocationTargetException exception) {\n            throw new RuntimeException(exception);\n        } catch (IllegalAccessException exception) {\n            throw new RuntimeException(exception);\n        }\n    }"}
{"Number":"70","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-put(Object-Class-String-Object)","Corresponding Source":"/**\n     * Invokes a static setter method for the given property. If the value is\n     * <tt>null<\/tt> or there is no explicit setter for a given type, the\n     * {@link #coerce(Object, Class)} method is used to attempt to convert the\n     * value to the actual property type (defined by the return value of the\n     * getter method).\n     *\n     * @param target\n     * The object to which the property is or will be attached.\n     *\n     * @param sourceType\n     * The class that defines the property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @param value\n     * The new property value.\n     *\n     * @throws PropertyNotFoundException\n     * If the given static property does not exist or is read-only.\n     */\n    public static void put(Object target, Class<?> sourceType, String key, Object value) {\n        Class<?> targetType = target.getClass();\n\n        Method setterMethod = null;\n        if (value != null) {\n            setterMethod = getStaticSetterMethod(sourceType, key, value.getClass(), targetType);\n        }\n\n        if (setterMethod == null) {\n            // Get the property type and attempt to coerce the value to it\n            Class<?> propertyType = getType(sourceType, key, targetType);\n\n            if (propertyType != null) {\n                setterMethod = getStaticSetterMethod(sourceType, key, propertyType, targetType);\n                value = coerce(value, propertyType);\n            }\n        }\n\n        if (setterMethod == null) {\n            throw new PropertyNotFoundException(\"Static property \\\"\" + key + \"\\\" does not exist\"\n                + \" or is read-only.\");\n        }\n\n        // Invoke the setter\n        try {\n            MethodUtil.invoke(setterMethod, null, new Object[] { target, value });\n        } catch (InvocationTargetException exception) {\n            throw new RuntimeException(exception);\n        } catch (IllegalAccessException exception) {\n            throw new RuntimeException(exception);\n        }\n    }"}
{"Number":"71","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-put(Object-Class-String-Object)","Corresponding Source":"/**\n     * Invokes a static setter method for the given property. If the value is\n     * <tt>null<\/tt> or there is no explicit setter for a given type, the\n     * {@link #coerce(Object, Class)} method is used to attempt to convert the\n     * value to the actual property type (defined by the return value of the\n     * getter method).\n     *\n     * @param target\n     * The object to which the property is or will be attached.\n     *\n     * @param sourceType\n     * The class that defines the property.\n     *\n     * @param key\n     * The property name.\n     *\n     * @param value\n     * The new property value.\n     *\n     * @throws PropertyNotFoundException\n     * If the given static property does not exist or is read-only.\n     */\n    public static void put(Object target, Class<?> sourceType, String key, Object value) {\n        Class<?> targetType = target.getClass();\n\n        Method setterMethod = null;\n        if (value != null) {\n            setterMethod = getStaticSetterMethod(sourceType, key, value.getClass(), targetType);\n        }\n\n        if (setterMethod == null) {\n            // Get the property type and attempt to coerce the value to it\n            Class<?> propertyType = getType(sourceType, key, targetType);\n\n            if (propertyType != null) {\n                setterMethod = getStaticSetterMethod(sourceType, key, propertyType, targetType);\n                value = coerce(value, propertyType);\n            }\n        }\n\n        if (setterMethod == null) {\n            throw new PropertyNotFoundException(\"Static property \\\"\" + key + \"\\\" does not exist\"\n                + \" or is read-only.\");\n        }\n\n        // Invoke the setter\n        try {\n            MethodUtil.invoke(setterMethod, null, new Object[] { target, value });\n        } catch (InvocationTargetException exception) {\n            throw new RuntimeException(exception);\n        } catch (IllegalAccessException exception) {\n            throw new RuntimeException(exception);\n        }\n    }"}
{"Number":"72","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-put(String-Object)","Corresponding Source":"/**\n     * Invokes a setter method for the given property. The\n     * {@link #coerce(Object, Class)} method is used as needed to attempt to\n     * convert a given value to the property type, as defined by the return\n     * value of the getter method.\n     *\n     * @param key\n     * The property name.\n     *\n     * @param value\n     * The new property value.\n     *\n     * @return\n     * Returns <tt>null<\/tt>, since returning the previous value would require\n     * an unnecessary call to the getter method.\n     *\n     * @throws PropertyNotFoundException\n     * If the given property does not exist or is read-only.\n     */\n    @Override\n    public Object put(String key, Object value) {\n        if (key == null) {\n            throw new NullPointerException();\n        }\n\n        Method setterMethod = getSetterMethod(key);\n\n        if (setterMethod == null) {\n            throw new PropertyNotFoundException(\"Property \\\"\" + key + \"\\\" does not exist\"\n                + \" or is read-only.\");\n        }\n\n        try {\n            MethodUtil.invoke(setterMethod, bean, new Object[] { coerce(value, getType(key)) });\n        } catch (IllegalAccessException exception) {\n            throw new RuntimeException(exception);\n        } catch (InvocationTargetException exception) {\n            throw new RuntimeException(exception);\n        }\n\n        return null;\n    }"}
{"Number":"73","API Relative Path":"com.sun.javafx.fxml.BeanAdapter.java-put(String-Object)","Corresponding Source":"/**\n     * Invokes a setter method for the given property. The\n     * {@link #coerce(Object, Class)} method is used as needed to attempt to\n     * convert a given value to the property type, as defined by the return\n     * value of the getter method.\n     *\n     * @param key\n     * The property name.\n     *\n     * @param value\n     * The new property value.\n     *\n     * @return\n     * Returns <tt>null<\/tt>, since returning the previous value would require\n     * an unnecessary call to the getter method.\n     *\n     * @throws PropertyNotFoundException\n     * If the given property does not exist or is read-only.\n     */\n    @Override\n    public Object put(String key, Object value) {\n        if (key == null) {\n            throw new NullPointerException();\n        }\n\n        Method setterMethod = getSetterMethod(key);\n\n        if (setterMethod == null) {\n            throw new PropertyNotFoundException(\"Property \\\"\" + key + \"\\\" does not exist\"\n                + \" or is read-only.\");\n        }\n\n        try {\n            MethodUtil.invoke(setterMethod, bean, new Object[] { coerce(value, getType(key)) });\n        } catch (IllegalAccessException exception) {\n            throw new RuntimeException(exception);\n        } catch (InvocationTargetException exception) {\n            throw new RuntimeException(exception);\n        }\n\n        return null;\n    }"}
{"Number":"74","API Relative Path":"com.sun.javafx.fxml.expression.Expression.java-add(Expression-Expression)","Corresponding Source":"/**\n     * Creates an addition or concatenation expression.\n     *\n     * @param left\n     * @param right\n     */\n    public static BinaryExpression add(Expression left, Expression right) {\n        return new BinaryExpression(left, right, (leftValue, rightValue) -> {\n            Object value;\n            if (leftValue instanceof String || rightValue instanceof String) {\n                value = leftValue.toString().concat(rightValue.toString());\n            } else {\n                Number leftNumber = (Number)leftValue;\n                Number rightNumber = (Number)rightValue;\n\n                if (leftNumber instanceof Double || rightNumber instanceof Double) {\n                    value = leftNumber.doubleValue() + rightNumber.doubleValue();\n                } else if (leftNumber instanceof Float || rightNumber instanceof Float) {\n                    value = leftNumber.floatValue() + rightNumber.floatValue();\n                } else if (leftNumber instanceof Long || rightNumber instanceof Long) {\n                    value = leftNumber.longValue() + rightNumber.longValue();\n                } else if (leftNumber instanceof Integer || rightNumber instanceof Integer) {\n                    value = leftNumber.intValue() + rightNumber.intValue();\n                } else if (leftNumber instanceof Short || rightNumber instanceof Short) {\n                    value = leftNumber.shortValue() + rightNumber.shortValue();\n                } else if (leftNumber instanceof Byte || rightNumber instanceof Byte) {\n                    value = leftNumber.byteValue() + rightNumber.byteValue();\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            return value;\n        });\n    }"}
{"Number":"75","API Relative Path":"com.sun.javafx.fxml.expression.Expression.java-add(Expression-Expression)","Corresponding Source":"/**\n     * Creates an addition or concatenation expression.\n     *\n     * @param left\n     * @param right\n     */\n    public static BinaryExpression add(Expression left, Expression right) {\n        return new BinaryExpression(left, right, (leftValue, rightValue) -> {\n            Object value;\n            if (leftValue instanceof String || rightValue instanceof String) {\n                value = leftValue.toString().concat(rightValue.toString());\n            } else {\n                Number leftNumber = (Number)leftValue;\n                Number rightNumber = (Number)rightValue;\n\n                if (leftNumber instanceof Double || rightNumber instanceof Double) {\n                    value = leftNumber.doubleValue() + rightNumber.doubleValue();\n                } else if (leftNumber instanceof Float || rightNumber instanceof Float) {\n                    value = leftNumber.floatValue() + rightNumber.floatValue();\n                } else if (leftNumber instanceof Long || rightNumber instanceof Long) {\n                    value = leftNumber.longValue() + rightNumber.longValue();\n                } else if (leftNumber instanceof Integer || rightNumber instanceof Integer) {\n                    value = leftNumber.intValue() + rightNumber.intValue();\n                } else if (leftNumber instanceof Short || rightNumber instanceof Short) {\n                    value = leftNumber.shortValue() + rightNumber.shortValue();\n                } else if (leftNumber instanceof Byte || rightNumber instanceof Byte) {\n                    value = leftNumber.byteValue() + rightNumber.byteValue();\n                } else {\n                    throw new UnsupportedOperationException();\n                }\n            }\n\n            return value;\n        });\n    }"}
{"Number":"76","API Relative Path":"com.sun.javafx.fxml.expression.Expression.java-get(Object-KeyPath)","Corresponding Source":"/**\n     * Returns the value at a given path within a namespace.\n     *\n     * @param namespace\n     * @param keyPath\n     *\n     * @return\n     * The value at the given path, or <tt>null<\/tt> if no such value exists.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> T get(Object namespace, KeyPath keyPath) {\n        if (keyPath == null) {\n            throw new NullPointerException();\n        }\n\n        return (T)get(namespace, keyPath.iterator());\n    }"}
{"Number":"77","API Relative Path":"com.sun.javafx.fxml.expression.Expression.java-get(Object-String)","Corresponding Source":"/**\n     * Returns the value at a given key within a namespace.\n     *\n     * @param namespace\n     * @param key\n     *\n     * @return\n     * The value at the given key, or <tt>null<\/tt> if no such value exists.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> T get(Object namespace, String key) {\n        if (key == null) {\n            throw new NullPointerException();\n        }\n\n        Object value;\n        if (namespace instanceof List<?>) {\n            List<Object> list = (List<Object>)namespace;\n            value = list.get(Integer.parseInt(key));\n        } else if (namespace != null) {\n            Map<String, Object> map;\n            if (namespace instanceof Map<?, ?>) {\n                map = (Map<String, Object>)namespace;\n            } else {\n                map = new BeanAdapter(namespace);\n            }\n\n            value = map.get(key);\n        } else {\n            value = null;\n        }\n\n        return (T)value;\n    }"}
{"Number":"78","API Relative Path":"com.sun.javafx.fxml.expression.Expression.java-isDefined(Object-KeyPath)","Corresponding Source":"/**\n     * Tests the existence of a path within a namespace.\n     *\n     * @param namespace\n     * @param keyPath\n     *\n     * @return\n     * <tt>true<\/tt> if the path exists; <tt>false<\/tt>, otherwise.\n     */\n    public static boolean isDefined(Object namespace, KeyPath keyPath) {\n        if (keyPath == null) {\n            throw new NullPointerException();\n        }\n\n        return isDefined(namespace, keyPath.iterator());\n    }"}
{"Number":"79","API Relative Path":"com.sun.javafx.fxml.expression.Expression.java-isDefined(Object-String)","Corresponding Source":"/**\n     * Tests the existence of a key within a namespace.\n     *\n     * @param namespace\n     * @param key\n     *\n     * @return\n     * <tt>true<\/tt> if the key exists; <tt>false<\/tt>, otherwise.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static boolean isDefined(Object namespace, String key) {\n        if (key == null) {\n            throw new NullPointerException();\n        }\n\n        boolean defined;\n        if (namespace instanceof List<?>) {\n            List<Object> list = (List<Object>)namespace;\n            defined = Integer.parseInt(key) < list.size();\n        } else if (namespace != null) {\n            Map<String, Object> map;\n            if (namespace instanceof Map<?, ?>) {\n                map = (Map<String, Object>)namespace;\n            } else {\n                map = new BeanAdapter(namespace);\n            }\n\n            defined = map.containsKey(key);\n        } else {\n            defined = false;\n        }\n\n        return defined;\n    }"}
{"Number":"80","API Relative Path":"com.sun.javafx.fxml.expression.Expression.java-set(Object-KeyPath-Object)","Corresponding Source":"/**\n     * Sets the value at a given path within a namespace.\n     *\n     * @param namespace\n     * @param keyPath\n     * @param value\n     */\n    public static void set(Object namespace, KeyPath keyPath, Object value) {\n        if (keyPath == null) {\n            throw new NullPointerException();\n        }\n\n        set(namespace, keyPath.iterator(), value);\n    }"}
{"Number":"81","API Relative Path":"com.sun.javafx.fxml.expression.Expression.java-set(Object-String-Object)","Corresponding Source":"/**\n     * Sets the value at a given path within a namespace.\n     *\n     * @param namespace\n     * @param key\n     * @param value\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static void set(Object namespace, String key, Object value) {\n        if (key == null) {\n            throw new NullPointerException();\n        }\n\n        if (namespace instanceof List<?>) {\n            List<Object> list = (List<Object>)namespace;\n            list.set(Integer.parseInt(key), value);\n        } else if (namespace != null) {\n            Map<String, Object> map;\n            if (namespace instanceof Map<?, ?>) {\n                map = (Map<String, Object>)namespace;\n            } else {\n                map = new BeanAdapter(namespace);\n            }\n\n            map.put(key, value);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }"}
{"Number":"82","API Relative Path":"com.sun.javafx.fxml.expression.Expression.java-set(Object-String-Object)","Corresponding Source":"/**\n     * Sets the value at a given path within a namespace.\n     *\n     * @param namespace\n     * @param key\n     * @param value\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static void set(Object namespace, String key, Object value) {\n        if (key == null) {\n            throw new NullPointerException();\n        }\n\n        if (namespace instanceof List<?>) {\n            List<Object> list = (List<Object>)namespace;\n            list.set(Integer.parseInt(key), value);\n        } else if (namespace != null) {\n            Map<String, Object> map;\n            if (namespace instanceof Map<?, ?>) {\n                map = (Map<String, Object>)namespace;\n            } else {\n                map = new BeanAdapter(namespace);\n            }\n\n            map.put(key, value);\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }"}
{"Number":"83","API Relative Path":"com.sun.javafx.fxml.expression.Expression.java-valueOf(String)","Corresponding Source":"/**\n     * Parses a string representation of an expression into an expression\n     * tree.\n     *\n     * @param value\n     * The string representation of the expression.\n     */\n    public static Expression valueOf(String value) {\n        if (value == null) {\n            throw new NullPointerException();\n        }\n\n        Parser parser = new Parser();\n        Expression expression;\n        try {\n            expression = parser.parse(new StringReader(value));\n        } catch (IOException exception) {\n            throw new RuntimeException(exception);\n        }\n\n        return expression;\n    }"}
{"Number":"84","API Relative Path":"com.sun.javafx.geom.Arc2D.java-Arc2D(int)","Corresponding Source":"/**\n     * Constructs a new arc, initialized to location (0, 0),\n     * size (0, 0), angular extents (start = 0, extent = 0), and\n     * the specified closure type.\n     *\n     * @param type The closure type for the arc:\n     * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.\n     */\n    public Arc2D(int type) {\n        setArcType(type);\n    }"}
{"Number":"85","API Relative Path":"com.sun.javafx.geom.Arc2D.java-setArc(float-float-float-float-float-float-int)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    public void setArc(float x, float y, float w, float h,\n               float angSt, float angExt, int closure) {\n        this.setArcType(closure);\n        this.x = x;\n        this.y = y;\n        this.width = w;\n        this.height = h;\n        this.start = angSt;\n        this.extent = angExt;\n    }"}
{"Number":"86","API Relative Path":"com.sun.javafx.geom.Arc2D.java-setArcByCenter(float-float-float-float-float-int)","Corresponding Source":"/**\n     * Sets the position, bounds, angular extents, and closure type of\n     * this arc to the specified values. The arc is defined by a center\n     * point and a radius rather than a framing rectangle for the full ellipse.\n     *\n     * @param x The X coordinate of the center of the arc.\n     * @param y The Y coordinate of the center of the arc.\n     * @param radius The radius of the arc.\n     * @param angSt The starting angle of the arc in degrees.\n     * @param angExt The angular extent of the arc in degrees.\n     * @param closure The closure type for the arc:\n     * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.\n     */\n    public void setArcByCenter(float x, float y, float radius,\n                   float angSt, float angExt, int closure) {\n        setArc(x - radius, y - radius, radius * 2f, radius * 2f,\n               angSt, angExt, closure);\n    }"}
{"Number":"87","API Relative Path":"com.sun.javafx.geom.Arc2D.java-setArcType(int)","Corresponding Source":"/**\n     * Sets the closure type of this arc to the specified value:\n     * <CODE>OPEN<\/CODE>, <CODE>CHORD<\/CODE>, or <CODE>PIE<\/CODE>.\n     *\n     * @param type The integer constant that represents the closure\n     * type of this arc: {@link #OPEN}, {@link #CHORD}, or\n     * {@link #PIE}.\n     *\n     * @throws IllegalArgumentException if <code>type<\/code> is not\n     * 0, 1, or 2.+\n     * @see #getArcType\n     */\n    public void setArcType(int type) {\n        if (type < OPEN || type > PIE) {\n            throw new IllegalArgumentException(\"invalid type for Arc: \"+type);\n        }\n        this.type = type;\n    }"}
{"Number":"88","API Relative Path":"com.sun.javafx.geom.Area.java-createTransformedArea(BaseTransform)","Corresponding Source":"/**\n     * Creates a new <code>Area<\/code> object that contains the same\n     * geometry as this <code>Area<\/code> transformed by the specified\n     * <code>BaseTransform<\/code>.  This <code>Area<\/code> object\n     * is unchanged.\n     * @param tx the specified <code>BaseTransform<\/code> used to transform\n     *           the new <code>Area<\/code>\n     * @throws NullPointerException if <code>t<\/code> is null\n     * @return   a new <code>Area<\/code> object representing the transformed\n     *           geometry.\n     */\n    public Area createTransformedArea(BaseTransform tx) {\n        Area a = new Area(this);\n        a.transform(tx);\n        return a;\n    }"}
{"Number":"89","API Relative Path":"com.sun.javafx.geom.Area.java-transform(BaseTransform)","Corresponding Source":"/**\n     * Transforms the geometry of this <code>Area<\/code> using the specified\n     * {@link BaseTransform}.  The geometry is transformed in place, which\n     * permanently changes the enclosed area defined by this object.\n     * @param tx the transformation used to transform the area\n     * @throws NullPointerException if <code>t<\/code> is null\n     */\n    public void transform(BaseTransform tx) {\n        if (tx == null) {\n            throw new NullPointerException(\"transform must not be null\");\n        }\n        // REMIND: A simpler operation can be performed for some types\n        // of transform.\n        curves = pathToCurves(getPathIterator(tx));\n        invalidateBounds();\n    }"}
{"Number":"90","API Relative Path":"com.sun.javafx.geom.CubicCurve2D.java-subdivide(float-CubicCurve2D-CubicCurve2D)","Corresponding Source":"/**\n     * Subdivides this cubic curve at the given parameter value\n     * (expected to be between 0 and 1) and stores the resulting two\n     * subdivided curves into the left and right curve parameters.\n     * Either or both of the left and right objects may be the same as\n     * this object or null.\n     * @param t the parameter value at which to subdivide the curve\n     * @param left the cubic curve object for storing for the left or\n     * first portion of the subdivided curve\n     * @param right the cubic curve object for storing for the right or\n     * second portion of the subdivided curve\n     */\n    public void subdivide(float t, CubicCurve2D left, CubicCurve2D right) {\n        if ((left == null) && (right == null)) return;\n\n        float npx = calcX(t);\n        float npy = calcY(t);\n\n        float x1 = this.x1;\n        float y1 = this.y1;\n        float c1x = this.ctrlx1;\n        float c1y = this.ctrly1;\n        float c2x = this.ctrlx2;\n        float c2y = this.ctrly2;\n        float x2 = this.x2;\n        float y2 = this.y2;\n        float u = 1-t;\n        float hx = u*c1x+t*c2x;\n        float hy = u*c1y+t*c2y;\n\n        if (left != null) {\n            float lx1 = x1;\n            float ly1 = y1;\n            float lc1x = u*x1+t*c1x;\n            float lc1y = u*y1+t*c1y;\n            float lc2x = u*lc1x+t*hx;\n            float lc2y = u*lc1y+t*hy;\n            float lx2 = npx;\n            float ly2 = npy;\n            left.setCurve(lx1, ly1,\n                          lc1x, lc1y,\n                          lc2x, lc2y,\n                          lx2, ly2);\n        }\n\n        if (right != null) {\n            float rx1 = npx;\n            float ry1 = npy;\n            float rc2x = u*c2x+t*x2;\n            float rc2y = u*c2y+t*y2;\n            float rc1x = u*hx+t*rc2x;\n            float rc1y = u*hy+t*rc2y;\n            float rx2 = x2;\n            float ry2 = y2;\n            right.setCurve(rx1, ry1,\n                           rc1x, rc1y,\n                           rc2x, rc2y,\n                           rx2, ry2);\n        }\n    }"}
{"Number":"91","API Relative Path":"com.sun.javafx.geom.FlatteningPathIterator.java-FlatteningPathIterator(PathIterator-float-int)","Corresponding Source":"/**\n     * Constructs a new <code>FlatteningPathIterator<\/code> object\n     * that flattens a path as it iterates over it.\n     * The <code>limit<\/code> parameter allows you to control the\n     * maximum number of recursive subdivisions that the iterator\n     * can make before it assumes that the curve is flat enough\n     * without measuring against the <code>flatness<\/code> parameter.\n     * The flattened iteration therefore never generates more than\n     * a maximum of <code>(2^limit)<\/code> line segments per curve.\n     * @param src the original unflattened path being iterated over\n     * @param flatness the maximum allowable distance between the\n     * control points and the flattened curve\n     * @param limit the maximum number of recursive subdivisions\n     * allowed for any curved segment\n     * @exception <code>IllegalArgumentException<\/code> if\n     *      <code>flatness<\/code> or <code>limit<\/code>\n     *      is less than zero\n     */\n    public FlatteningPathIterator(PathIterator src, float flatness,\n                  int limit) {\n        if (flatness < 0f) {\n            throw new IllegalArgumentException(\"flatness must be >= 0\");\n        }\n        if (limit < 0) {\n            throw new IllegalArgumentException(\"limit must be >= 0\");\n        }\n        this.src = src;\n        this.squareflat = flatness * flatness;\n        this.limit = limit;\n        this.levels = new int[limit + 1];\n        // prime the first path segment\n        next(false);\n    }"}
{"Number":"92","API Relative Path":"com.sun.javafx.geom.FlatteningPathIterator.java-FlatteningPathIterator(PathIterator-float-int)","Corresponding Source":"/**\n     * Constructs a new <code>FlatteningPathIterator<\/code> object\n     * that flattens a path as it iterates over it.\n     * The <code>limit<\/code> parameter allows you to control the\n     * maximum number of recursive subdivisions that the iterator\n     * can make before it assumes that the curve is flat enough\n     * without measuring against the <code>flatness<\/code> parameter.\n     * The flattened iteration therefore never generates more than\n     * a maximum of <code>(2^limit)<\/code> line segments per curve.\n     * @param src the original unflattened path being iterated over\n     * @param flatness the maximum allowable distance between the\n     * control points and the flattened curve\n     * @param limit the maximum number of recursive subdivisions\n     * allowed for any curved segment\n     * @exception <code>IllegalArgumentException<\/code> if\n     *      <code>flatness<\/code> or <code>limit<\/code>\n     *      is less than zero\n     */\n    public FlatteningPathIterator(PathIterator src, float flatness,\n                  int limit) {\n        if (flatness < 0f) {\n            throw new IllegalArgumentException(\"flatness must be >= 0\");\n        }\n        if (limit < 0) {\n            throw new IllegalArgumentException(\"limit must be >= 0\");\n        }\n        this.src = src;\n        this.squareflat = flatness * flatness;\n        this.limit = limit;\n        this.levels = new int[limit + 1];\n        // prime the first path segment\n        next(false);\n    }"}
{"Number":"93","API Relative Path":"com.sun.javafx.geom.Matrix3f.java-getRow(int-float[])","Corresponding Source":"/**\n     * Copies the matrix values in the specified row into the array parameter.\n     * @param row  the matrix row\n     * @param v    the array into which the matrix row values will be copied\n     */\n    public final void getRow(int row, float[] v) {\n        if (row == 0) {\n            v[0] = m00;\n            v[1] = m01;\n            v[2] = m02;\n        } else if (row == 1) {\n            v[0] = m10;\n            v[1] = m11;\n            v[2] = m12;\n        } else if (row == 2) {\n            v[0] = m20;\n            v[1] = m21;\n            v[2] = m22;\n        } else {\n            throw new ArrayIndexOutOfBoundsException(\"Matrix3f\");\n        }\n    }"}
{"Number":"94","API Relative Path":"com.sun.javafx.geom.Matrix3f.java-getRow(int-Vec3f)","Corresponding Source":"/**\n     * Copies the matrix values in the specified row into the vector parameter.\n     * @param row  the matrix row\n     * @param v    the vector into which the matrix row values will be copied\n     */\n    public final void getRow(int row, Vec3f v) {\n        if (row == 0) {\n            v.x = m00;\n            v.y = m01;\n            v.z = m02;\n        } else if (row == 1) {\n            v.x = m10;\n            v.y = m11;\n            v.z = m12;\n        } else if (row == 2) {\n            v.x = m20;\n            v.y = m21;\n            v.z = m22;\n        } else {\n            throw new ArrayIndexOutOfBoundsException(\"Matrix3f\");\n        }\n    }"}
{"Number":"95","API Relative Path":"com.sun.javafx.geom.Path2D.java-Path2D(int-int)","Corresponding Source":"/**\n     * Constructs a new empty single precision {@code Path2D} object\n     * with the specified winding rule and the specified initial\n     * capacity to store path segments.\n     * This number is an initial guess as to how many path segments\n     * will be added to the path, but the storage is expanded as\n     * needed to store whatever path segments are added.\n     *\n     * @param rule the winding rule\n     * @param initialCapacity the estimate for the number of path segments\n     *                        in the path\n     * @see #WIND_EVEN_ODD\n     * @see #WIND_NON_ZERO\n     */\n    public Path2D(int rule, int initialCapacity) {\n        setWindingRule(rule);\n        this.pointTypes = new byte[initialCapacity];\n        floatCoords = new float[initialCapacity * 2];\n    }"}
{"Number":"96","API Relative Path":"com.sun.javafx.geom.Path2D.java-setWindingRule(int)","Corresponding Source":"/**\n     * Sets the winding rule for this path to the specified value.\n     *\n     * @param rule an integer representing the specified\n     *             winding rule\n     * @exception IllegalArgumentException if\n     *      {@code rule} is not either\n     *      {@link #WIND_EVEN_ODD} or\n     *      {@link #WIND_NON_ZERO}\n     * @see #getWindingRule\n     */\n    public final void setWindingRule(int rule) {\n        if (rule != WIND_EVEN_ODD && rule != WIND_NON_ZERO) {\n            throw new IllegalArgumentException(\"winding rule must be \"+\n                               \"WIND_EVEN_ODD or \"+\n                               \"WIND_NON_ZERO\");\n        }\n        windingRule = rule;\n    }"}
{"Number":"97","API Relative Path":"com.sun.javafx.geom.transform.AffineBase.java-createTransformedShape(Shape)","Corresponding Source":"/**\n     * Returns a new {@link Shape} object defined by the geometry of the\n     * specified <code>Shape<\/code> after it has been transformed by\n     * this transform.\n     * @param pSrc the specified <code>Shape<\/code> object to be\n     * transformed by this transform.\n     * @return a new <code>Shape<\/code> object that defines the geometry\n     * of the transformed <code>Shape<\/code>, or null if {@code pSrc} is null.\n     */\n    public Shape createTransformedShape(Shape s) {\n        if (s == null) {\n            return null;\n        }\n        return new Path2D(s, this);\n    }"}
{"Number":"98","API Relative Path":"com.sun.javafx.iio.common.ImageTools.java-readFully(InputStream-byte[]-int-int)","Corresponding Source":"/**\n     * See the general contract of the <code>readFully<\/code>\n     * method of <code>DataInput<\/code>.\n     * <p>\n     * Bytes\n     * for this operation are read from the specified\n     * input stream.\n     *\n     * @param      stream the stream from which to read the data.\n     * @param      b     the buffer into which the data is read.\n     * @param      off   the start offset of the data.\n     * @param      len   the number of bytes to read.\n     * @exception  EOFException  if this input stream reaches the end before\n     *               reading all the bytes.\n     * @exception  IOException   if another I/O error occurs.\n     */\n    public static int readFully(InputStream stream,\n            byte[] b, int off, int len) throws IOException {\n        if (len < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n        int requestedLength = len;\n        // Fix 4430357 - if off + len < 0, overflow occurred\n        if (off < 0 || len < 0 || off + len > b.length || off + len < 0) {\n            throw new IndexOutOfBoundsException(\"off < 0 || len < 0 || off + len > b.length!\");\n        }\n\n        while (len > 0) {\n            int nbytes = stream.read(b, off, len);\n            if (nbytes == -1) {\n                throw new EOFException();\n            }\n            off += nbytes;\n            len -= nbytes;\n        }\n\n        return requestedLength;\n    }"}
{"Number":"99","API Relative Path":"com.sun.javafx.iio.common.ImageTools.java-readFully(InputStream-byte[]-int-int)","Corresponding Source":"/**\n     * See the general contract of the <code>readFully<\/code>\n     * method of <code>DataInput<\/code>.\n     * <p>\n     * Bytes\n     * for this operation are read from the specified\n     * input stream.\n     *\n     * @param      stream the stream from which to read the data.\n     * @param      b     the buffer into which the data is read.\n     * @param      off   the start offset of the data.\n     * @param      len   the number of bytes to read.\n     * @exception  EOFException  if this input stream reaches the end before\n     *               reading all the bytes.\n     * @exception  IOException   if another I/O error occurs.\n     */\n    public static int readFully(InputStream stream,\n            byte[] b, int off, int len) throws IOException {\n        if (len < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n        int requestedLength = len;\n        // Fix 4430357 - if off + len < 0, overflow occurred\n        if (off < 0 || len < 0 || off + len > b.length || off + len < 0) {\n            throw new IndexOutOfBoundsException(\"off < 0 || len < 0 || off + len > b.length!\");\n        }\n\n        while (len > 0) {\n            int nbytes = stream.read(b, off, len);\n            if (nbytes == -1) {\n                throw new EOFException();\n            }\n            off += nbytes;\n            len -= nbytes;\n        }\n\n        return requestedLength;\n    }"}
{"Number":"100","API Relative Path":"com.sun.javafx.iio.common.RoughScaler.java-putSourceScanline(byte[]-int)","Corresponding Source":"/**\n     * Push one scanline of source pixels into the scaling engine. A nearest\n     * neighbor interpolation algorithm is used.\n     *\n     * @param scanline One scanline of source data.\n     * @param off The offset into the buffer.\n     * @throws IllegalArgumentException if <code>off&nbsp;&lt;&nbsp;0<\/code>.\n     * @return Whether the destination image is complete.\n     */\n    public boolean putSourceScanline(byte[] scanline, int off) {\n        if (off < 0) {\n            throw new IllegalArgumentException(\"off < 0!\");\n        }\n\n        if (destLine < destHeight) {\n            if (sourceLine == nextSourceLine) {\n                assert destBuf.hasArray() : \"destBuf.hasArray() == false => destBuf is direct\";\n                byte[] dest = destBuf.array();\n\n                int destOffset = destLine * destWidth * numBands;\n\n                int doff = destOffset;\n                for (int i = 0; i < destWidth; i++) {\n                    int sourceOffset = off + this.colPositions[i];\n                    for (int j = 0; j < numBands; j++) {\n                        dest[doff++] = scanline[sourceOffset + j];\n                    }\n                }\n\n                while ((int) ((++destLine + 0.5) * scaleY) == sourceLine)\n                {\n                    System.arraycopy(dest, destOffset, dest, doff, destWidth * numBands);\n                    doff += destWidth * numBands;\n                }\n                nextSourceLine = (int) ((destLine + 0.5) * scaleY);\n            }\n\n            ++sourceLine;\n        }\n\n        return destLine == destHeight;\n    }"}
{"Number":"101","API Relative Path":"com.sun.javafx.iio.common.RoughScaler.java-RoughScaler(int-int-int-int-int)","Corresponding Source":"/**\n     * Instantiates a new <code>RoughScaler<\/code> object.\n     *\n     * @param sourceWidth The source image width\n     * @param sourceHeight The source image height\n     * @param numBands The number of components per pixel in the images\n     * @param destWidth The destination image width\n     * @param destHeight The destination image height\n     * @throws IllegalArgumentException if any of the parameters is non-positive.\n     */\n    public RoughScaler(int sourceWidth, int sourceHeight, int numBands,\n            int destWidth, int destHeight) {\n        if (sourceWidth <= 0 || sourceHeight <= 0 || numBands <= 0 ||\n                destWidth <= 0 || destHeight <= 0) {\n            throw new IllegalArgumentException();\n        }\n\n        // save parameters to instance variables\n        this.numBands = numBands;\n        this.destWidth = destWidth;\n        this.destHeight = destHeight;\n\n        // allocate the destination\n        this.destBuf = ByteBuffer.wrap(new byte[destHeight * destWidth * numBands]);\n\n        // calculate the destination-to-source scale factors\n        double scaleX = (double) sourceWidth / (double) destWidth;\n        this.scaleY = (double) sourceHeight / (double) destHeight;\n\n        this.colPositions = new int[destWidth];\n        for (int i = 0; i < destWidth; i++) {\n            int pos = (int) ((i + 0.5) * scaleX);\n            colPositions[i] = pos * numBands;\n        }\n\n        // initialize line numbers to track source and destination lines\n        this.sourceLine = 0;\n        this.destLine = 0;\n        // find nearest source line\n        this.nextSourceLine = (int) (0.5 * scaleY);\n    }"}
{"Number":"102","API Relative Path":"com.sun.javafx.iio.common.ScalerFactory.java-createScaler(int-int-int-int-int-boolean)","Corresponding Source":"/**\n     * Instantiates a new <code>PushbroomScaler<\/code> object.\n     *\n     * @param sourceWidth The source image width\n     * @param sourceHeight The source image height\n     * @param numBands The number of components per pixel in the images\n     * @param destWidth The destination image width\n     * @param destHeight The destination image height\n     * @throws IllegalArgumentException if any of the integral parameters is non-positive.\n     */\n    public static PushbroomScaler createScaler(int sourceWidth, int sourceHeight, int numBands,\n            int destWidth, int destHeight, boolean isSmooth) {\n        if (sourceWidth <= 0 || sourceHeight <= 0 || numBands <= 0 ||\n                destWidth <= 0 || destHeight <= 0) {\n            throw new IllegalArgumentException();\n        }\n\n        PushbroomScaler scaler = null;\n\n        boolean isMagnifying = destWidth > sourceWidth || destHeight > sourceHeight;\n\n        if (isMagnifying) {\n            if (isSmooth) {\n                // RT-27408\n                // TODO: bpb 2009-10-05 Need SmoothMagnifier class; use RoughScaler for now.\n                scaler = new RoughScaler(sourceWidth, sourceHeight, numBands,\n                        destWidth, destHeight);\n            } else {\n                scaler = new RoughScaler(sourceWidth, sourceHeight, numBands,\n                        destWidth, destHeight);\n            }\n        } else { // minifying\n            if (isSmooth) {\n                scaler = new SmoothMinifier(sourceWidth, sourceHeight, numBands,\n                        destWidth, destHeight);\n            } else {\n                scaler = new RoughScaler(sourceWidth, sourceHeight, numBands,\n                        destWidth, destHeight);\n            }\n        }\n\n        return scaler;\n    }"}
{"Number":"103","API Relative Path":"com.sun.javafx.iio.common.ScalerFactory.java-createScaler(int-int-int-int-int-boolean)","Corresponding Source":"/**\n     * Instantiates a new <code>PushbroomScaler<\/code> object.\n     *\n     * @param sourceWidth The source image width\n     * @param sourceHeight The source image height\n     * @param numBands The number of components per pixel in the images\n     * @param destWidth The destination image width\n     * @param destHeight The destination image height\n     * @throws IllegalArgumentException if any of the integral parameters is non-positive.\n     */\n    public static PushbroomScaler createScaler(int sourceWidth, int sourceHeight, int numBands,\n            int destWidth, int destHeight, boolean isSmooth) {\n        if (sourceWidth <= 0 || sourceHeight <= 0 || numBands <= 0 ||\n                destWidth <= 0 || destHeight <= 0) {\n            throw new IllegalArgumentException();\n        }\n\n        PushbroomScaler scaler = null;\n\n        boolean isMagnifying = destWidth > sourceWidth || destHeight > sourceHeight;\n\n        if (isMagnifying) {\n            if (isSmooth) {\n                // RT-27408\n                // TODO: bpb 2009-10-05 Need SmoothMagnifier class; use RoughScaler for now.\n                scaler = new RoughScaler(sourceWidth, sourceHeight, numBands,\n                        destWidth, destHeight);\n            } else {\n                scaler = new RoughScaler(sourceWidth, sourceHeight, numBands,\n                        destWidth, destHeight);\n            }\n        } else { // minifying\n            if (isSmooth) {\n                scaler = new SmoothMinifier(sourceWidth, sourceHeight, numBands,\n                        destWidth, destHeight);\n            } else {\n                scaler = new RoughScaler(sourceWidth, sourceHeight, numBands,\n                        destWidth, destHeight);\n            }\n        }\n\n        return scaler;\n    }"}
{"Number":"104","API Relative Path":"com.sun.javafx.iio.common.ScalerFactory.java-createScaler(int-int-int-int-int-boolean)","Corresponding Source":"/**\n     * Instantiates a new <code>PushbroomScaler<\/code> object.\n     *\n     * @param sourceWidth The source image width\n     * @param sourceHeight The source image height\n     * @param numBands The number of components per pixel in the images\n     * @param destWidth The destination image width\n     * @param destHeight The destination image height\n     * @throws IllegalArgumentException if any of the integral parameters is non-positive.\n     */\n    public static PushbroomScaler createScaler(int sourceWidth, int sourceHeight, int numBands,\n            int destWidth, int destHeight, boolean isSmooth) {\n        if (sourceWidth <= 0 || sourceHeight <= 0 || numBands <= 0 ||\n                destWidth <= 0 || destHeight <= 0) {\n            throw new IllegalArgumentException();\n        }\n\n        PushbroomScaler scaler = null;\n\n        boolean isMagnifying = destWidth > sourceWidth || destHeight > sourceHeight;\n\n        if (isMagnifying) {\n            if (isSmooth) {\n                // RT-27408\n                // TODO: bpb 2009-10-05 Need SmoothMagnifier class; use RoughScaler for now.\n                scaler = new RoughScaler(sourceWidth, sourceHeight, numBands,\n                        destWidth, destHeight);\n            } else {\n                scaler = new RoughScaler(sourceWidth, sourceHeight, numBands,\n                        destWidth, destHeight);\n            }\n        } else { // minifying\n            if (isSmooth) {\n                scaler = new SmoothMinifier(sourceWidth, sourceHeight, numBands,\n                        destWidth, destHeight);\n            } else {\n                scaler = new RoughScaler(sourceWidth, sourceHeight, numBands,\n                        destWidth, destHeight);\n            }\n        }\n\n        return scaler;\n    }"}
{"Number":"105","API Relative Path":"com.sun.javafx.iio.common.SmoothMinifier.java-putSourceScanline(byte[]-int)","Corresponding Source":"/**\n     * Push one scanline of source pixels into the downscaling engine. A smooth\n     * downscaling algorithm is used.\n     *\n     * @param scanline One scanline of source data.\n     * @param off The offline into the buffer.\n     * @throws IllegalArgumentException if <code>off&nbsp;&lt;&nbsp;0<\/code>.\n     * @return Whether the destination image is complete.\n     */\n    public boolean putSourceScanline(byte[] scanline, int off) {\n        if (off < 0) {\n            throw new IllegalArgumentException(\"off < 0!\");\n        }\n\n        // XXX Optimize this later:\n        // XXX Precalculate transition values from left end to center to right end\n        // and use three loops:\n        // left = min {i | leftPoints[i] >= 0 ^ rightPoints[i] < W - 1}\n        // right = max {i | leftPoints[i] >= 0 ^ rightPoints[i] < W - 1}\n\n        // Horizontally average the data into the intermediate buffer.\n        if (numBands == 1) {\n            int leftSample = scanline[off] & 0xff;\n            int rightSample = scanline[off + sourceWidth - 1] & 0xff;\n            for (int i = 0; i < destWidth; i++) {\n                int val = 0;\n                int rightBound = rightPoints[i];\n                for (int j = leftPoints[i]; j <= rightBound; j++) {\n                    if (j < 0) {\n                        val += leftSample;\n                    } else if (j >= sourceWidth) {\n                        val += rightSample;\n                    } else {\n                        val += scanline[off + j] & 0xff;\n                    }\n                }\n                val /= (rightBound - leftPoints[i] + 1);\n                sourceData[sourceDataLine][i] = (byte) val;\n            }\n        } else { // numBands != 1\n            int rightOff = off + (sourceWidth - 1) * numBands;\n            for (int i = 0; i < destWidth; i++) {\n                int leftBound = leftPoints[i];\n                int rightBound = rightPoints[i];\n                int numPoints = rightBound - leftBound + 1;\n                int iBands = i * numBands;\n                for (int k = 0; k < numBands; k++) {\n                    // XXX For multi-band could loop over bands with \"val\" becoming an\n                    // array \"int val[numBands]\". left/rightPoints could continue to\n                    // point to the first band only and incrementing would be used in\n                    // between or left/rightPoints could be used for all bands.\n                    int leftSample = scanline[off + k] & 0xff;\n                    int rightSample = scanline[rightOff + k] & 0xff;\n\n                    int val = 0;\n                    for (int j = leftBound; j <= rightBound; j++) {\n                        if (j < 0) {\n                            val += leftSample;\n                        } else if (j >= sourceWidth) {\n                            val += rightSample;\n                        } else {\n                            val += scanline[off + j * numBands + k] & 0xff;\n                        }\n//                        } else if (j * numBands + k >= sourceWidth * numBands) {\n//                            val += scanline[off + (sourceWidth - 1) * numBands + k] & 0xff;\n//                        } else {\n//                            val += scanline[off + j * numBands + k] & 0xff;\n//                        }\n                    }\n                    val /= numPoints;\n                    sourceData[sourceDataLine][iBands + k] = (byte) val;\n                }\n            }\n        }\n\n        // Compute a destination line if the source has no more data or the\n        // last line of the destination has been reached. Note that the last\n        // destination line can be reached before the source has been\n        // exhausted so the second part of the logical expression waits for\n        // the last line of the source to be available.\n        if (sourceLine == bottomPoints[destLine] ||\n                (destLine == destHeight - 1 && sourceLine == sourceHeight - 1)) {\n            // Vertically average the data from the intermediate buffer into\n            // the destination\n            assert destBuf.hasArray() : \"destBuf.hasArray() == false => destBuf is direct\";\n            byte[] dest = destBuf.array();\n\n            int destOffset = destLine * destWidth * numBands;\n            Arrays.fill(tmpBuf, 0);\n            for (int y = topPoints[destLine]; y <= bottomPoints[destLine]; y++) {\n                int index = 0;\n                if (y < 0) {\n                    index = 0 - sourceLine + sourceDataLine;\n                } else if (y >= sourceHeight) {\n                    index = (sourceHeight - 1 - sourceLine + sourceDataLine) % boxHeight;\n                } else {\n                    index = (y - sourceLine + sourceDataLine) % boxHeight;\n                }\n                if (index < 0) {\n                    index += boxHeight;\n                }\n                byte[] b = sourceData[index];\n                int destLen = b.length;\n                for (int x = 0; x < destLen; x++) {\n                    tmpBuf[x] += b[x] & 0xff;\n                }\n            }\n            int sourceLen = tmpBuf.length;\n            for (int x = 0; x < sourceLen; x++) {\n                dest[destOffset + x] = (byte) (tmpBuf[x] / boxHeight);\n            }\n\n            if (destLine < destHeight - 1) {\n                destLine++;\n            }\n        }\n\n        // Increment\n        if (++sourceLine != sourceHeight) {\n            sourceDataLine = (sourceDataLine + 1) % boxHeight;\n        }\n\n        return destLine == destHeight;\n    }"}
{"Number":"106","API Relative Path":"com.sun.javafx.iio.common.SmoothMinifier.java-SmoothMinifier(int-int-int-int-int)","Corresponding Source":"/**\n     * Instantiates a new <code>SmoothMinifier<\/code> object.\n     *\n     * @param sourceWidth The source image width\n     * @param sourceHeight The source image height\n     * @param numBands The number of components per pixel in the images\n     * @param destWidth The destination image width\n     * @param destHeight The destination image height\n     * @throws IllegalArgumentException if any of the parameters is non-positive\n     * or either destination dimension is greater than the corresponding source\n     * dimension.\n     */\n    SmoothMinifier(int sourceWidth, int sourceHeight, int numBands,\n            int destWidth, int destHeight) {\n        if (sourceWidth <= 0 || sourceHeight <= 0 || numBands <= 0 ||\n                destWidth <= 0 || destHeight <= 0 ||\n                destWidth > sourceWidth || destHeight > sourceHeight) {\n            throw new IllegalArgumentException();\n        }\n\n        // save parameters to instance variables\n        this.sourceWidth = sourceWidth;\n        this.sourceHeight = sourceHeight;\n        this.numBands = numBands;\n        this.destWidth = destWidth;\n        this.destHeight = destHeight;\n\n        // allocate the destination\n        this.destBuf = ByteBuffer.wrap(new byte[destHeight * destWidth * numBands]);\n\n        // calculate the destination-to-source scale factors\n        double scaleX = (double) sourceWidth / (double) destWidth;\n        this.scaleY = (double) sourceHeight / (double) destHeight;\n\n        // calculate the dimensions of the averaging box\n        int boxWidth = (sourceWidth + destWidth - 1) / destWidth;\n        this.boxHeight = (sourceHeight + destHeight - 1) / destHeight;\n\n\n        // calculate the number of pixels in the surround, excluding the center\n        int boxLeft = boxWidth / 2;\n        int boxRight = boxWidth - boxLeft - 1;\n        int boxTop = boxHeight / 2;\n        int boxBottom = boxHeight - boxTop - 1;\n\n        // allocate memory for source data\n        this.sourceData = new byte[boxHeight][destWidth * numBands];\n\n        // calculate the source positions of the points which form the left and\n        // right closed bounds of the region contributing to all columns in the\n        // destination.\n        this.leftPoints = new int[destWidth];\n        this.rightPoints = new int[destWidth];\n        for (int dx = 0; dx < destWidth; dx++) {\n            int sx = (int) (dx * scaleX); // floor\n            leftPoints[dx] = sx - boxLeft;\n            rightPoints[dx] = sx + boxRight;\n        }\n\n        // calculate the source positions of the points which form the top and\n        // bottom closed bounds of the region contributing to all rows in the\n        // destination.\n        this.topPoints = new int[destHeight];\n        this.bottomPoints = new int[destHeight];\n        for (int dy = 0; dy < destHeight; dy++) {\n            int sy = (int) (dy * scaleY); // floor\n            topPoints[dy] = sy - boxTop;\n            bottomPoints[dy] = sy + boxBottom;\n        }\n\n        // initialize line numbers to track source and destination lines\n        this.sourceLine = 0;\n        this.sourceDataLine = 0;\n        this.destLine = 0;\n\n        this.tmpBuf = new int[destWidth * numBands];\n    }"}
{"Number":"107","API Relative Path":"com.sun.javafx.iio.ImageStorage.java-loadAll(String-ImageLoadListener-int-int-boolean-float-boolean)","Corresponding Source":"/**\n     * Load all images present in the specified input. For more details refer to\n     * {@link #loadAll(java.io.InputStream, com.sun.javafx.iio.ImageLoadListener, int, int, boolean, boolean)}.\n     */\n    public static ImageFrame[] loadAll(String input, ImageLoadListener listener,\n            int width, int height, boolean preserveAspectRatio,\n            float devPixelScale, boolean smooth) throws ImageStorageException {\n\n        if (input == null || input.isEmpty()) {\n            throw new ImageStorageException(\"URL can't be null or empty\");\n        }\n\n        ImageFrame[] images = null;\n        InputStream theStream = null;\n        ImageLoader loader = null;\n\n        try {\n            float imgPixelScale = 1.0f;\n            try {\n                if (devPixelScale >= 1.5f) {\n                    // Use Mac Retina conventions for >= 1.5f\n                    try {\n                        String name2x = ImageTools.getScaledImageName(input);\n                        theStream = ImageTools.createInputStream(name2x);\n                        imgPixelScale = 2.0f;\n                    } catch (IOException e) {\n                    }\n                }\n                if (theStream == null) {\n                    theStream = ImageTools.createInputStream(input);\n                }\n\n                if (isIOS) {\n                    loader = IosImageLoaderFactory.getInstance().createImageLoader(theStream);\n                } else {\n                    loader = getLoaderBySignature(theStream, listener);\n                }\n            } catch (IOException e) {\n                throw new ImageStorageException(e.getMessage(), e);\n            }\n\n            if (loader != null) {\n                images = loadAll(loader, width, height, preserveAspectRatio, imgPixelScale, smooth);\n            } else {\n                throw new ImageStorageException(\"No loader for image data\");\n            }\n        } finally {\n            try {\n                if (theStream != null) {\n                    theStream.close();\n                }\n            } catch (IOException e) {\n            }\n        }\n\n        return images;\n    }"}
{"Number":"108","API Relative Path":"com.sun.javafx.iio.ios.IosImageLoaderFactory.java-createImageLoader(InputStream)","Corresponding Source":"/**\n     * @inheritDoc\n     */\n    public ImageLoader createImageLoader(final InputStream input) throws IOException {\n        return new IosImageLoader(input, IosDescriptor.getInstance());\n    }"}
{"Number":"109","API Relative Path":"com.sun.javafx.iio.png.PNGIDATChunkInputStream.java-PNGIDATChunkInputStream(DataInputStream-int)","Corresponding Source":"/**\n     * Create the stream.\n     *\n     * @param input stream positioned at the beginning of the data field of the\n     * first IDAT chunk in the PNG stream.\n     * @param firstIDATChunkLength the length of the data field of the first\n     * IDAT chunk.\n     */\n    PNGIDATChunkInputStream(DataInputStream input, int firstIDATChunkLength) throws IOException {\n        if (firstIDATChunkLength < 0) {\n            throw new IOException(\"Invalid chunk length\");\n        }\n        this.source = input;\n        this.numBytesAvailable = firstIDATChunkLength;\n    }"}
{"Number":"110","API Relative Path":"com.sun.javafx.media.PrismMediaFrameHandler.java-getTexture(Graphics-VideoDataBuffer)","Corresponding Source":"/* NOTE: The following methods will only ever happen on one thread, so thread\n     * safety should not be a concern here.\n     */\n\n    /**\n     * This should only ever be called during a render cycle. Any other time it\n     * will return null. Note that a returned texture should be unlocked when\n     * the caller no longer needs it.\n     *\n     * @param g the Graphics context about to be rendered into\n     * @return the current media texture valid for rendering into <code>g<\/code>\n     * or null if called outside a render cycle\n     */\n    public Texture getTexture(Graphics g, VideoDataBuffer currentFrame) {\n        Screen screen = g.getAssociatedScreen();\n        TextureMapEntry tme = textures.get(screen);\n\n        if (null == currentFrame) {\n            // null frame, remove the existing texture\n            if (textures.containsKey(screen)) {\n                textures.remove(screen);\n            }\n            return null;\n        }\n\n        if (null == tme) {\n            // we need to create a new texture for this graphics context\n            tme = new TextureMapEntry();\n            textures.put(screen, tme);\n        }\n\n        if (tme.texture != null) {\n            tme.texture.lock();\n            if (tme.texture.isSurfaceLost()) {\n                tme.texture = null;\n            }\n        }\n\n        // check if it needs to be updated\n        if (null == tme.texture || tme.lastFrameTime != currentFrame.getTimestamp()) {\n            updateTexture(g, currentFrame, tme);\n        }\n\n        return tme.texture;\n    }"}
{"Number":"111","API Relative Path":"com.sun.javafx.property.PropertyReference.java-PropertyReference(Class-String)","Corresponding Source":"// uses reflection to implement the get / set methods\n    /**\n     * Creates a new {@code PropertyReference} for a property of a bean.\n     *\n     * @param clazz\n     *            The class of the {@link Bean} that contains the property\n     * @param name\n     *            The name of the property\n     * @throws NullPointerException\n     *             if {@code clazz} or {@code name} are null\n     * @throws IllegalArgumentException\n     *             if {@code name} is an empty {@code String}\n     */\n    public PropertyReference(Class<?> clazz, String name) {\n        if (name == null)\n            throw new NullPointerException(\"Name must be specified\");\n        if (name.trim().length() == 0)\n            throw new IllegalArgumentException(\"Name must be specified\");\n        if (clazz == null)\n            throw new NullPointerException(\"Class must be specified\");\n        ReflectUtil.checkPackageAccess(clazz);\n        this.name = name;\n        this.clazz = clazz;\n    }"}
{"Number":"112","API Relative Path":"com.sun.javafx.robot.FXRobotImage.java-getArgb(int-int)","Corresponding Source":"/**\n     * Returns pixel in IntArgb format (non-premultiplied).\n     *\n     * @param x coordinate\n     * @param y coordinate\n     * @return pixel in IntArgb format\n     */\n    public int getArgb(int x, int y) {\n        if (x < 0 || x >= width || y < 0 || y >= height) {\n            throw new IllegalArgumentException(\"x,y must be >0, <width, height\");\n        }\n        int argb = pixelBuffer.get(x + y*scanlineStride/4);\n        if ((argb >> 24) == -1) {\n            return argb;\n        }\n        int a = argb >>> 24;\n        int r = (argb >> 16) & 0xff;\n        int g = (argb >>  8) & 0xff;\n        int b = (argb      ) & 0xff;\n        int a2 = a + (a >> 7);\n        r = (r * a2) >> 8;\n        g = (g * a2) >> 8;\n        b = (b * a2) >> 8;\n        return ((a << 24) | (r << 16) | (g << 8) | (b));\n    }"}
{"Number":"113","API Relative Path":"com.sun.javafx.robot.FXRobotImage.java-getArgbPre(int-int)","Corresponding Source":"/**\n     * Returns pixel (in IntArgbPre) format (Argb premultiplied).\n     *\n     * @param x coordinate\n     * @param y coordinate\n     * @return pixel in IntArgbPre format\n     */\n    public int getArgbPre(int x, int y) {\n        if (x < 0 || x >= width || y < 0 || y >= height) {\n            throw new IllegalArgumentException(\"x,y must be >0, <width, height\");\n        }\n        return pixelBuffer.get(x + y*scanlineStride/4);\n    }"}
{"Number":"114","API Relative Path":"com.sun.javafx.runtime.SystemProperties.java-addProperties(String[]-boolean)","Corresponding Source":"/**\n     * Registers a statically allocated System Properties table\n     * Once registered properties listed in the table are availabe for inquiry through FX.getProperty().\n     * Table is defined as a String array with JavaFX property name followed by property value or property mapping identifier\n     * depending on whether the table contains JavaFX specific properties or not.\n     * Note that JavaFX property names have \"javafx\" stripped out to optimize table lookup.\n     * The following identifiers are available:\n     * <\/p>\n     * 1. Underlying runtime platform property name. When listed, FX.getProperty() will invoke System.getProperty()\n     *    method to retrieve property value.\n     *    example:\n     *    {\"version\", \"java.version\"}\n     * <\/p>\n     * 2. \"javafx_specific\". When listed indicates there is no association between the property and underlying runtime\n     *    platform. Rather the property is JavaFX specific. In that case another table needs to be provided with values\n     *    for all JavaFX specific properties. JavaFX specific properties table is a string array containing property name\n     *    and corresponding property value.\n     *    example:\n     *    {\"hw.radio\", \"none\"}\n     * <\/p>\n     * 3. Empty string. When listed, the meaning there is no association between the property and underlying runtime\n     *    platform nor the property is JavaFX specific. FX.getProperty() invoked on that property returns null.\n     *    example:\n     *    {\"supports.mixing\", \"none\"}\n     * @param table System Properties table\n     * @param jfx_specific Indicates the table contains JavaFX specific properties\n     */\n    public static void addProperties (String[] table, boolean jfx_specific) {\n        if (table == null)\n            return;\n\n        Hashtable props;\n\n        if (jfx_specific) {\n            props = jfxprop_list;\n        } else {\n            props = sysprop_list;\n        }\n\n        for (int i=0; i<table.length; i+=2) {\n            props.put(table[i], table[i+1]);\n        }\n    }"}
{"Number":"115","API Relative Path":"com.sun.javafx.scene.control.behavior.TextBinding.java-TextBinding(String)","Corresponding Source":"/**\n     * Creates a new TextBinding instance from the given string.\n     *\n     * @param s the action text string\n     */\n    public TextBinding(String s) {\n        parseAndSplit(s);\n    }"}
{"Number":"116","API Relative Path":"com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList.java-subList(int-int)","Corresponding Source":"/**\n     * NOTE: This method does not fulfill the subList contract from Collections,\n     * it simply returns a list containing the values in the given range.\n     */\n    @Override public List<E> subList(final int fromIndex, final int toIndex) {\n        if (fromIndex < 0 || toIndex > size() || fromIndex > toIndex) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        final List<E> outer = this;\n        return new ReadOnlyUnbackedObservableList<E>() {\n            @Override public E get(int i) {\n                return outer.get(i + fromIndex);\n            }\n\n            @Override public int size() {\n                return toIndex - fromIndex;\n            }\n        };\n    }"}
{"Number":"117","API Relative Path":"com.sun.javafx.scene.control.skin.BehaviorSkinBase.java-BehaviorSkinBase(C-BB)","Corresponding Source":"/***************************************************************************\n     *                                                                         *\n     * Constructor                                                             *\n     *                                                                         *\n     **************************************************************************/\n\n    /**\n     * Constructor for all BehaviorSkinBase instances.\n     *\n     * @param control The control for which this Skin should attach to.\n     * @param behavior The behavior for which this Skin should defer to.\n     */\n    protected BehaviorSkinBase(final C control, final BB behavior) {\n        super(control);\n\n        if (behavior == null) {\n            throw new IllegalArgumentException(\"Cannot pass null for behavior\");\n        }\n\n        // Update the control and behavior\n        this.behavior = behavior;\n\n        // We will auto-add listeners for wiring up Region mouse events to\n        // be sent to the behavior\n        control.addEventHandler(MouseEvent.MOUSE_ENTERED, mouseHandler);\n        control.addEventHandler(MouseEvent.MOUSE_EXITED, mouseHandler);\n        control.addEventHandler(MouseEvent.MOUSE_PRESSED, mouseHandler);\n        control.addEventHandler(MouseEvent.MOUSE_RELEASED, mouseHandler);\n        control.addEventHandler(MouseEvent.MOUSE_DRAGGED, mouseHandler);\n\n        control.addEventHandler(ContextMenuEvent.CONTEXT_MENU_REQUESTED, contextMenuHandler);\n    }"}
{"Number":"118","API Relative Path":"com.sun.javafx.scene.control.skin.VirtualFlow.java-show(T)","Corresponding Source":"/**\n     * Adjusts the cells such that the selected cell will be fully visible in\n     * the viewport (but only just).\n     */\n    public void show(T cell) {\n        if (cell != null) {\n            final double start = getCellPosition(cell);\n            final double length = getCellLength(cell);\n            final double end = start + length;\n            final double viewportLength = getViewportLength();\n\n            if (start < 0) {\n                adjustPixels(start);\n            } else if (end > viewportLength) {\n                adjustPixels(end - viewportLength);\n            }\n        }\n    }"}
{"Number":"119","API Relative Path":"com.sun.javafx.scene.control.skin.VirtualFlow.java-showAsFirst(T)","Corresponding Source":"/**\n     * Adjust the position of cells so that the specified cell\n     * will be positioned at the start of the viewport. The given cell must\n     * already be \"live\". This is bad public API!\n     */\n    public void showAsFirst(T firstCell) {\n        if (firstCell != null) {\n            adjustPixels(getCellPosition(firstCell));\n        }\n    }"}
{"Number":"120","API Relative Path":"com.sun.javafx.scene.control.skin.VirtualFlow.java-showAsLast(T)","Corresponding Source":"/**\n     * Adjust the position of cells so that the specified cell\n     * will be positioned at the end of the viewport. The given cell must\n     * already be \"live\". This is bad public API!\n     */\n    public void showAsLast(T lastCell) {\n        if (lastCell != null) {\n            adjustPixels(getCellPosition(lastCell) + getCellLength(lastCell) - getViewportLength());\n        }\n    }"}
{"Number":"121","API Relative Path":"com.sun.javafx.sg.prism.GrowableDataBuffer.java-peekByte(int)","Corresponding Source":"/**\n     * Read a single byte from the byte-encoded stream, ignoring any read\n     * position, but honoring the current write position as a limit.\n     * The read and saved positions are not used or modified in any way\n     * by this method\n     *\n     * @param i the absolute byte location to return from the byte-encoding array\n     * @return the byte stored at the indicated location in the byte array\n     */\n    public byte peekByte(int i) {\n        if (i >= writevalpos) {\n            throw new BufferOverflowException();\n        }\n        return vals[i];\n    }"}
{"Number":"122","API Relative Path":"com.sun.javafx.sg.prism.GrowableDataBuffer.java-peekObject(int)","Corresponding Source":"/**\n     * Read a single {@code Object} from the object buffer, ignoring any read\n     * position, but honoring the current write position as a limit.\n     * The read and saved positions are not used or modified in any way\n     * by this method\n     *\n     * @param i the absolute index to return from the {@code Object} array\n     * @return the {@code Object} stored at the indicated index\n     */\n    public Object peekObject(int i) {\n        if (i >= writeobjpos) {\n            throw new BufferOverflowException();\n        }\n        return objs[i];\n    }"}
{"Number":"123","API Relative Path":"com.sun.javafx.sg.prism.NGGroup.java-add(int-NGNode)","Corresponding Source":"/**\n     * Adds a node to the given index. An index of -1 means \"append\", for legacy\n     * reasons (it was easier than asking for the number of children, iirc).\n     * @param index -1, or <= node.size()\n     * @param node\n     */\n    public void add(int index, NGNode node) {\n        // Validate the arguments\n        if ((index < -1) || (index > children.size())) {\n            throw new IndexOutOfBoundsException(\"invalid index\");\n        }\n\n        // NOTE: We used to do checks here to make sure that a node\n        // being added didn't already have another parent listed as\n        // its parent. Now we just silently accept them. The FX side\n        // is already doing this check, and implementing this check\n        // properly would require that the \"clear\" implementation visit\n        // all nodes and clear this flag, which is really just wasted work.\n        NGNode child = node;\n\n        // When a new node is added, we need to make sure the new node has this\n        // group registered as its parent. We also need to make sure I invalidate\n        // this group's cache and mark it dirty. Note that we don't have to worry\n        // about notifying the other parent that it has lost a node: the FX\n        // scene graph will be sure to send a \"remove\" notification to the other\n        // parent, so we don't have to be concerned with the other parent\n        // having to be marked dirty or whatnot.\n        child.setParent(this);\n        childDirty = true;\n        if (index == -1) {\n            children.add(node);\n        } else {\n            children.add(index, node);\n        }\n        child.markDirty();\n        markTreeDirtyNoIncrement();\n        geometryChanged();\n    }"}
{"Number":"124","API Relative Path":"com.sun.javafx.sg.prism.NGNode.java-accumulateDirtyRegions(RectBounds-RectBounds-DirtyRegionPool-DirtyRegionContainer-BaseTransform-GeneralTransform3D)","Corresponding Source":"/***************************************************************************\n     *                                                                         *\n     * Dirty Regions                                                           *\n     *                                                                         *\n     * Need to add documentation about dirty regions and how they work. One    *\n     * thing to be aware of is that during the dirty region accumulation phase *\n     * we use precise floating point values, but during                        *\n     *                                                                         *\n     **************************************************************************/\n\n    /**\n     * Accumulates and returns the dirty regions in transformed coordinates for\n     * this node. This method is designed such that a single downward traversal\n     * of the tree is sufficient to update the dirty regions.\n     * <p>\n     * This method only accumulates dirty regions for parts of the tree which lie\n     * inside the clip since there is no point in accumulating dirty regions which\n     * lie outside the clip. The returned dirty regions bounds  the same object\n     * as that passed into the function. The returned dirty regions bounds will\n     * always be adjusted such that they do not extend beyond the clip.\n     * <p>\n     * The given transform is the accumulated transform up to but not including the\n     * transform of this node.\n     *\n     * @param clip must not be null, the clip in scene coordinates, supplied by the\n     *        rendering system. At most, this is usually the bounds of the window's\n     *        content area, however it might be smaller.\n     * @param dirtyRegionTemp must not be null, the dirty region in scene coordinates.\n     *        When this method is initially invoked by the rendering system, the\n     *        dirtyRegion should be marked as invalid.\n     * @param dirtyRegionContainer must not be null, the container of dirty regions in scene\n     *        coordinates.\n     * @param tx must not be null, the accumulated transform up to but not\n     *        including this node's transform. When this method concludes, it must\n     *        restore this transform if it was changed within the function.\n     * @param pvTx must not be null, it's the perspective transform of the current\n     *        perspective camera or identity transform if parallel camera is used.\n     * @return The dirty region container. If the returned value is null, then that means\n     *         the clip should be used as the dirty region. This is a special\n     *         case indicating that there is no more need to walk the tree but\n     *         we can take a shortcut. Note that returning null is *always*\n     *         safe. Returning something other than null is simply an\n     *         optimization for cases where the dirty region is substantially\n     *         smaller than the clip.\n     * TODO: Only made non-final for the sake of testing (see javafx-sg-prism tests) (RT-23957)\n     */\n    public /*final*/ int accumulateDirtyRegions(final RectBounds clip,\n                                                final RectBounds dirtyRegionTemp,\n                                                DirtyRegionPool regionPool,\n                                                final DirtyRegionContainer dirtyRegionContainer,\n                                                final BaseTransform tx,\n                                                final GeneralTransform3D pvTx)\n    {\n        // This is the main entry point, make sure to check these inputs for validity\n        if (clip == null || dirtyRegionTemp == null || regionPool == null || dirtyRegionContainer == null ||\n                tx == null || pvTx == null) throw new NullPointerException();\n\n        // Even though a node with 0 visibility or 0 opacity doesn't get\n        // rendered, it may contribute to the dirty bounds, for example, if it\n        // WAS visible or if it HAD an opacity > 0 last time we rendered then\n        // we must honor its dirty region. We have front-loaded this work so\n        // that we don't mark nodes as having dirty flags or dirtyBounds if\n        // they shouldn't contribute to the dirty region. So we can simply\n        // treat all nodes, regardless of their opacity or visibility, as\n        // though their dirty regions matter. They do.\n\n        // If this node is clean then we can simply return the dirty region as\n        // there is no need to walk any further down this branch of the tree.\n        // The node is \"clean\" if neither it, nor its children, are dirty.\n         if (dirty == DirtyFlag.CLEAN && !childDirty) {\n             return DirtyRegionContainer.DTR_OK;\n         }\n\n        // We simply collect this nodes dirty region if it has its dirty flag\n        // set, regardless of whether it is a group or not. However, if this\n        // node is not dirty, then we can ask the accumulateGroupDirtyRegion\n        // method to collect the dirty regions of the children.\n        if (dirty != DirtyFlag.CLEAN) {\n            return accumulateNodeDirtyRegion(clip, dirtyRegionTemp, dirtyRegionContainer, tx, pvTx);\n        } else {\n            assert childDirty; // this must be true by this point\n            return accumulateGroupDirtyRegion(clip, dirtyRegionTemp, regionPool,\n                                              dirtyRegionContainer, tx, pvTx);\n        }\n    }"}
{"Number":"125","API Relative Path":"com.sun.javafx.sg.prism.NGNode.java-accumulateDirtyRegions(RectBounds-RectBounds-DirtyRegionPool-DirtyRegionContainer-BaseTransform-GeneralTransform3D)","Corresponding Source":"/***************************************************************************\n     *                                                                         *\n     * Dirty Regions                                                           *\n     *                                                                         *\n     * Need to add documentation about dirty regions and how they work. One    *\n     * thing to be aware of is that during the dirty region accumulation phase *\n     * we use precise floating point values, but during                        *\n     *                                                                         *\n     **************************************************************************/\n\n    /**\n     * Accumulates and returns the dirty regions in transformed coordinates for\n     * this node. This method is designed such that a single downward traversal\n     * of the tree is sufficient to update the dirty regions.\n     * <p>\n     * This method only accumulates dirty regions for parts of the tree which lie\n     * inside the clip since there is no point in accumulating dirty regions which\n     * lie outside the clip. The returned dirty regions bounds  the same object\n     * as that passed into the function. The returned dirty regions bounds will\n     * always be adjusted such that they do not extend beyond the clip.\n     * <p>\n     * The given transform is the accumulated transform up to but not including the\n     * transform of this node.\n     *\n     * @param clip must not be null, the clip in scene coordinates, supplied by the\n     *        rendering system. At most, this is usually the bounds of the window's\n     *        content area, however it might be smaller.\n     * @param dirtyRegionTemp must not be null, the dirty region in scene coordinates.\n     *        When this method is initially invoked by the rendering system, the\n     *        dirtyRegion should be marked as invalid.\n     * @param dirtyRegionContainer must not be null, the container of dirty regions in scene\n     *        coordinates.\n     * @param tx must not be null, the accumulated transform up to but not\n     *        including this node's transform. When this method concludes, it must\n     *        restore this transform if it was changed within the function.\n     * @param pvTx must not be null, it's the perspective transform of the current\n     *        perspective camera or identity transform if parallel camera is used.\n     * @return The dirty region container. If the returned value is null, then that means\n     *         the clip should be used as the dirty region. This is a special\n     *         case indicating that there is no more need to walk the tree but\n     *         we can take a shortcut. Note that returning null is *always*\n     *         safe. Returning something other than null is simply an\n     *         optimization for cases where the dirty region is substantially\n     *         smaller than the clip.\n     * TODO: Only made non-final for the sake of testing (see javafx-sg-prism tests) (RT-23957)\n     */\n    public /*final*/ int accumulateDirtyRegions(final RectBounds clip,\n                                                final RectBounds dirtyRegionTemp,\n                                                DirtyRegionPool regionPool,\n                                                final DirtyRegionContainer dirtyRegionContainer,\n                                                final BaseTransform tx,\n                                                final GeneralTransform3D pvTx)\n    {\n        // This is the main entry point, make sure to check these inputs for validity\n        if (clip == null || dirtyRegionTemp == null || regionPool == null || dirtyRegionContainer == null ||\n                tx == null || pvTx == null) throw new NullPointerException();\n\n        // Even though a node with 0 visibility or 0 opacity doesn't get\n        // rendered, it may contribute to the dirty bounds, for example, if it\n        // WAS visible or if it HAD an opacity > 0 last time we rendered then\n        // we must honor its dirty region. We have front-loaded this work so\n        // that we don't mark nodes as having dirty flags or dirtyBounds if\n        // they shouldn't contribute to the dirty region. So we can simply\n        // treat all nodes, regardless of their opacity or visibility, as\n        // though their dirty regions matter. They do.\n\n        // If this node is clean then we can simply return the dirty region as\n        // there is no need to walk any further down this branch of the tree.\n        // The node is \"clean\" if neither it, nor its children, are dirty.\n         if (dirty == DirtyFlag.CLEAN && !childDirty) {\n             return DirtyRegionContainer.DTR_OK;\n         }\n\n        // We simply collect this nodes dirty region if it has its dirty flag\n        // set, regardless of whether it is a group or not. However, if this\n        // node is not dirty, then we can ask the accumulateGroupDirtyRegion\n        // method to collect the dirty regions of the children.\n        if (dirty != DirtyFlag.CLEAN) {\n            return accumulateNodeDirtyRegion(clip, dirtyRegionTemp, dirtyRegionContainer, tx, pvTx);\n        } else {\n            assert childDirty; // this must be true by this point\n            return accumulateGroupDirtyRegion(clip, dirtyRegionTemp, regionPool,\n                                              dirtyRegionContainer, tx, pvTx);\n        }\n    }"}
{"Number":"126","API Relative Path":"com.sun.javafx.sg.prism.NGNode.java-accumulateGroupDirtyRegion(RectBounds-RectBounds-DirtyRegionPool-DirtyRegionContainer-BaseTransform-GeneralTransform3D)","Corresponding Source":"/**\n     * Accumulates the dirty region of an NGGroup. This is implemented here as opposed to\n     * using polymorphism because we wanted to centralize all of the dirty region\n     * management code in one place, rather than having it spread between Prism,\n     * Scenario, and any other future toolkits.\n     * TODO: Only made non-final for the sake of testing (see javafx-sg-prism tests) (RT-23957)\n     */\n    int accumulateGroupDirtyRegion(final RectBounds clip,\n                                   final RectBounds dirtyRegionTemp,\n                                   final DirtyRegionPool regionPool,\n                                   DirtyRegionContainer dirtyRegionContainer,\n                                   final BaseTransform tx,\n                                   final GeneralTransform3D pvTx) {\n        // We should have only made it to this point if this node has a dirty\n        // child. If this node itself is dirty, this method never would get called.\n        // If this node was not dirty and had no dirty children, then this\n        // method never should have been called. So at this point, the following\n        // assertions should be correct.\n        assert childDirty;\n        assert dirty == DirtyFlag.CLEAN;\n\n        int status = DirtyRegionContainer.DTR_OK;\n\n        if (dirtyChildrenAccumulated > DIRTY_CHILDREN_ACCUMULATED_THRESHOLD) {\n            status = accumulateNodeDirtyRegion(clip, dirtyRegionTemp, dirtyRegionContainer, tx, pvTx);\n            return status;\n        }\n\n        // If we got here, then we are following a \"bread crumb\" trail down to\n        // some child (perhaps distant) which is dirty. So we need to iterate\n        // over all the children and accumulate their dirty regions. Before doing\n        // so we, will save off the transform state and restore it after having\n        // called all the children.\n        double mxx = tx.getMxx();\n        double mxy = tx.getMxy();\n        double mxz = tx.getMxz();\n        double mxt = tx.getMxt();\n\n        double myx = tx.getMyx();\n        double myy = tx.getMyy();\n        double myz = tx.getMyz();\n        double myt = tx.getMyt();\n\n        double mzx = tx.getMzx();\n        double mzy = tx.getMzy();\n        double mzz = tx.getMzz();\n        double mzt = tx.getMzt();\n        BaseTransform renderTx = tx;\n        if (this.transform != null) renderTx = renderTx.deriveWithConcatenation(this.transform);\n\n        // If this group node has a clip, then we will perform some special\n        // logic which will cause the dirty region accumulation loops to run\n        // faster. We already have a system whereby if a node determines that\n        // its dirty region exceeds that of the clip, it simply returns null,\n        // short circuiting the accumulation process. We extend that logic\n        // here by also taking into account the clipNode on the group. If\n        // there is a clip node, then we will union the bounds of the clip\n        // node (in boundsInScene space) with the current clip and pass this\n        // new clip down to the children. If they determine that their dirty\n        // regions exceed the bounds of this new clip, then they will return\n        // null. We'll catch that here, and use that information to know that\n        // we ought to simply accumulate the bounds of this group as if it\n        // were dirty. This process will do all the other optimizations we\n        // already have in place for getting the normal dirty region.\n        RectBounds myClip = clip;\n        //Save current dirty region so we can fast-reset to (something like) the last state\n        //and possibly save a few intersects() calls\n\n        DirtyRegionContainer originalDirtyRegion = null;\n        BaseTransform originalRenderTx = null;\n        if (effectFilter != null) {\n            try {\n                myClip = new RectBounds();\n                BaseBounds myClipBaseBounds = renderTx.inverseTransform(clip, TEMP_BOUNDS);\n                myClipBaseBounds.flattenInto(myClip);\n            } catch (NoninvertibleTransformException ex) {\n                return DirtyRegionContainer.DTR_OK;\n            }\n\n            originalRenderTx = renderTx;\n            renderTx = BaseTransform.IDENTITY_TRANSFORM;\n            originalDirtyRegion = dirtyRegionContainer;\n            dirtyRegionContainer = regionPool.checkOut();\n        } else if (clipNode != null) {\n            originalDirtyRegion = dirtyRegionContainer;\n            myClip = new RectBounds();\n            BaseBounds clipBounds = clipNode.getCompleteBounds(myClip, renderTx);\n            pvTx.transform(clipBounds, clipBounds);\n            clipBounds.flattenInto(myClip);\n            myClip.intersectWith(clip);\n            dirtyRegionContainer = regionPool.checkOut();\n        }\n\n\n        //Accumulate also removed children to dirty region.\n        List<NGNode> removed = ((NGGroup) this).getRemovedChildren();\n        if (removed != null) {\n            NGNode removedChild;\n            for (int i = removed.size() - 1; i >= 0; --i) {\n                removedChild = removed.get(i);\n                removedChild.dirty = DirtyFlag.DIRTY;\n                    status = removedChild.accumulateDirtyRegions(myClip,\n                            dirtyRegionTemp,regionPool, dirtyRegionContainer, renderTx, pvTx);\n                    if (status == DirtyRegionContainer.DTR_CONTAINS_CLIP) {\n                        break;\n                    }\n            }\n        }\n\n        List<NGNode> children = ((NGGroup) this).getChildren();\n        int num = children.size();\n        for (int i=0; i<num && status == DirtyRegionContainer.DTR_OK; i++) {\n            NGNode child = children.get(i);\n            // The child will check the dirty bits itself. If we tested it here\n            // (as we used to), we are just doing the check twice. True, it might\n            // mean fewer method calls, but hotspot will probably inline this all\n            // anyway, and doing the check in one place is less error prone.\n            status = child.accumulateDirtyRegions(myClip, dirtyRegionTemp, regionPool,\n                                                  dirtyRegionContainer, renderTx, pvTx);\n            if (status == DirtyRegionContainer.DTR_CONTAINS_CLIP) {\n                break;\n            }\n        }\n\n        if (effectFilter != null && status == DirtyRegionContainer.DTR_OK) {\n            //apply effect on effect dirty regions\n            applyEffect(effectFilter, dirtyRegionContainer, regionPool);\n\n            if (clipNode != null) {\n                myClip = new RectBounds();\n                BaseBounds clipBounds = clipNode.getCompleteBounds(myClip, renderTx);\n                applyClip(clipBounds, dirtyRegionContainer);\n            }\n\n            //apply transform on effect dirty regions\n            applyTransform(originalRenderTx, dirtyRegionContainer);\n            renderTx = originalRenderTx;\n\n            originalDirtyRegion.merge(dirtyRegionContainer);\n            regionPool.checkIn(dirtyRegionContainer);\n        }\n\n        // If the process of applying the transform caused renderTx to not equal\n        // tx, then there is no point restoring it since it will be a different\n        // reference and will therefore be gc'd.\n        if (renderTx == tx) {\n            tx.restoreTransform(mxx, mxy, mxz, mxt, myx, myy, myz, myt, mzx, mzy, mzz, mzt);\n        }\n\n        // If the dirty region is null and there is a clip node specified, then what\n        // happened is that the dirty region of content within this group exceeded\n        // the clip of this group, and thus, we should accumulate the bounds of\n        // this group into the dirty region. If the bounds of the group exceeds\n        // the bounds of the dirty region, then we end up returning null in the\n        // end. But the implementation of accumulateNodeDirtyRegion handles this.\n        if (clipNode != null && effectFilter == null) {\n            if (status == DirtyRegionContainer.DTR_CONTAINS_CLIP) {\n                status = accumulateNodeDirtyRegion(clip, dirtyRegionTemp, originalDirtyRegion, tx, pvTx);\n            } else {\n                originalDirtyRegion.merge(dirtyRegionContainer);\n            }\n            regionPool.checkIn(dirtyRegionContainer);\n        }\n        return status;\n    }"}
{"Number":"127","API Relative Path":"com.sun.javafx.sg.prism.NGNode.java-accumulateGroupDirtyRegion(RectBounds-RectBounds-DirtyRegionPool-DirtyRegionContainer-BaseTransform-GeneralTransform3D)","Corresponding Source":"/**\n     * Accumulates the dirty region of an NGGroup. This is implemented here as opposed to\n     * using polymorphism because we wanted to centralize all of the dirty region\n     * management code in one place, rather than having it spread between Prism,\n     * Scenario, and any other future toolkits.\n     * TODO: Only made non-final for the sake of testing (see javafx-sg-prism tests) (RT-23957)\n     */\n    int accumulateGroupDirtyRegion(final RectBounds clip,\n                                   final RectBounds dirtyRegionTemp,\n                                   final DirtyRegionPool regionPool,\n                                   DirtyRegionContainer dirtyRegionContainer,\n                                   final BaseTransform tx,\n                                   final GeneralTransform3D pvTx) {\n        // We should have only made it to this point if this node has a dirty\n        // child. If this node itself is dirty, this method never would get called.\n        // If this node was not dirty and had no dirty children, then this\n        // method never should have been called. So at this point, the following\n        // assertions should be correct.\n        assert childDirty;\n        assert dirty == DirtyFlag.CLEAN;\n\n        int status = DirtyRegionContainer.DTR_OK;\n\n        if (dirtyChildrenAccumulated > DIRTY_CHILDREN_ACCUMULATED_THRESHOLD) {\n            status = accumulateNodeDirtyRegion(clip, dirtyRegionTemp, dirtyRegionContainer, tx, pvTx);\n            return status;\n        }\n\n        // If we got here, then we are following a \"bread crumb\" trail down to\n        // some child (perhaps distant) which is dirty. So we need to iterate\n        // over all the children and accumulate their dirty regions. Before doing\n        // so we, will save off the transform state and restore it after having\n        // called all the children.\n        double mxx = tx.getMxx();\n        double mxy = tx.getMxy();\n        double mxz = tx.getMxz();\n        double mxt = tx.getMxt();\n\n        double myx = tx.getMyx();\n        double myy = tx.getMyy();\n        double myz = tx.getMyz();\n        double myt = tx.getMyt();\n\n        double mzx = tx.getMzx();\n        double mzy = tx.getMzy();\n        double mzz = tx.getMzz();\n        double mzt = tx.getMzt();\n        BaseTransform renderTx = tx;\n        if (this.transform != null) renderTx = renderTx.deriveWithConcatenation(this.transform);\n\n        // If this group node has a clip, then we will perform some special\n        // logic which will cause the dirty region accumulation loops to run\n        // faster. We already have a system whereby if a node determines that\n        // its dirty region exceeds that of the clip, it simply returns null,\n        // short circuiting the accumulation process. We extend that logic\n        // here by also taking into account the clipNode on the group. If\n        // there is a clip node, then we will union the bounds of the clip\n        // node (in boundsInScene space) with the current clip and pass this\n        // new clip down to the children. If they determine that their dirty\n        // regions exceed the bounds of this new clip, then they will return\n        // null. We'll catch that here, and use that information to know that\n        // we ought to simply accumulate the bounds of this group as if it\n        // were dirty. This process will do all the other optimizations we\n        // already have in place for getting the normal dirty region.\n        RectBounds myClip = clip;\n        //Save current dirty region so we can fast-reset to (something like) the last state\n        //and possibly save a few intersects() calls\n\n        DirtyRegionContainer originalDirtyRegion = null;\n        BaseTransform originalRenderTx = null;\n        if (effectFilter != null) {\n            try {\n                myClip = new RectBounds();\n                BaseBounds myClipBaseBounds = renderTx.inverseTransform(clip, TEMP_BOUNDS);\n                myClipBaseBounds.flattenInto(myClip);\n            } catch (NoninvertibleTransformException ex) {\n                return DirtyRegionContainer.DTR_OK;\n            }\n\n            originalRenderTx = renderTx;\n            renderTx = BaseTransform.IDENTITY_TRANSFORM;\n            originalDirtyRegion = dirtyRegionContainer;\n            dirtyRegionContainer = regionPool.checkOut();\n        } else if (clipNode != null) {\n            originalDirtyRegion = dirtyRegionContainer;\n            myClip = new RectBounds();\n            BaseBounds clipBounds = clipNode.getCompleteBounds(myClip, renderTx);\n            pvTx.transform(clipBounds, clipBounds);\n            clipBounds.flattenInto(myClip);\n            myClip.intersectWith(clip);\n            dirtyRegionContainer = regionPool.checkOut();\n        }\n\n\n        //Accumulate also removed children to dirty region.\n        List<NGNode> removed = ((NGGroup) this).getRemovedChildren();\n        if (removed != null) {\n            NGNode removedChild;\n            for (int i = removed.size() - 1; i >= 0; --i) {\n                removedChild = removed.get(i);\n                removedChild.dirty = DirtyFlag.DIRTY;\n                    status = removedChild.accumulateDirtyRegions(myClip,\n                            dirtyRegionTemp,regionPool, dirtyRegionContainer, renderTx, pvTx);\n                    if (status == DirtyRegionContainer.DTR_CONTAINS_CLIP) {\n                        break;\n                    }\n            }\n        }\n\n        List<NGNode> children = ((NGGroup) this).getChildren();\n        int num = children.size();\n        for (int i=0; i<num && status == DirtyRegionContainer.DTR_OK; i++) {\n            NGNode child = children.get(i);\n            // The child will check the dirty bits itself. If we tested it here\n            // (as we used to), we are just doing the check twice. True, it might\n            // mean fewer method calls, but hotspot will probably inline this all\n            // anyway, and doing the check in one place is less error prone.\n            status = child.accumulateDirtyRegions(myClip, dirtyRegionTemp, regionPool,\n                                                  dirtyRegionContainer, renderTx, pvTx);\n            if (status == DirtyRegionContainer.DTR_CONTAINS_CLIP) {\n                break;\n            }\n        }\n\n        if (effectFilter != null && status == DirtyRegionContainer.DTR_OK) {\n            //apply effect on effect dirty regions\n            applyEffect(effectFilter, dirtyRegionContainer, regionPool);\n\n            if (clipNode != null) {\n                myClip = new RectBounds();\n                BaseBounds clipBounds = clipNode.getCompleteBounds(myClip, renderTx);\n                applyClip(clipBounds, dirtyRegionContainer);\n            }\n\n            //apply transform on effect dirty regions\n            applyTransform(originalRenderTx, dirtyRegionContainer);\n            renderTx = originalRenderTx;\n\n            originalDirtyRegion.merge(dirtyRegionContainer);\n            regionPool.checkIn(dirtyRegionContainer);\n        }\n\n        // If the process of applying the transform caused renderTx to not equal\n        // tx, then there is no point restoring it since it will be a different\n        // reference and will therefore be gc'd.\n        if (renderTx == tx) {\n            tx.restoreTransform(mxx, mxy, mxz, mxt, myx, myy, myz, myt, mzx, mzy, mzz, mzt);\n        }\n\n        // If the dirty region is null and there is a clip node specified, then what\n        // happened is that the dirty region of content within this group exceeded\n        // the clip of this group, and thus, we should accumulate the bounds of\n        // this group into the dirty region. If the bounds of the group exceeds\n        // the bounds of the dirty region, then we end up returning null in the\n        // end. But the implementation of accumulateNodeDirtyRegion handles this.\n        if (clipNode != null && effectFilter == null) {\n            if (status == DirtyRegionContainer.DTR_CONTAINS_CLIP) {\n                status = accumulateNodeDirtyRegion(clip, dirtyRegionTemp, originalDirtyRegion, tx, pvTx);\n            } else {\n                originalDirtyRegion.merge(dirtyRegionContainer);\n            }\n            regionPool.checkIn(dirtyRegionContainer);\n        }\n        return status;\n    }"}
{"Number":"128","API Relative Path":"com.sun.javafx.sg.prism.NGNode.java-doPreCulling(DirtyRegionContainer-BaseTransform-GeneralTransform3D)","Corresponding Source":"/***************************************************************************\n     *                                                                         *\n     * Culling                                                                 *\n     *                                                                         *\n     **************************************************************************/\n\n    /**\n     * Culling support for multiple dirty regions.\n     * Set culling bits for the whole graph.\n     * @param drc Array of dirty regions. Cannot be null.\n     * @param tx The transform for this render operation. Cannot be null.\n     * @param pvTx Perspective camera transformation. Cannot be null.\n     */\n    public final void doPreCulling(DirtyRegionContainer drc, BaseTransform tx, GeneralTransform3D pvTx) {\n        if (drc == null || tx == null || pvTx == null) throw new NullPointerException();\n        markCullRegions(drc, -1, tx, pvTx);\n    }"}
{"Number":"129","API Relative Path":"com.sun.javafx.sg.prism.NGNode.java-getRenderRoot(NodePath-RectBounds-int-BaseTransform-GeneralTransform3D)","Corresponding Source":"/**\n     * Called <strong>after<\/strong> preCullingBits in order to get the node\n     * from which we should begin drawing. This is our support for occlusion culling.\n     * This should only be called on the root node.\n     *\n     * If no render root was found, we need to render everything from this root, so the path will contain this node.\n     * If no rendering is needed (everything dirty is occluded), the path will remain empty\n     *\n     * @param path node path to store the node path\n     */\n    public final void getRenderRoot(NodePath path, RectBounds dirtyRegion, int cullingIndex,\n                                    BaseTransform tx, GeneralTransform3D pvTx) {\n\n        // This is the main entry point, make sure to check these inputs for validity\n        if (path == null || dirtyRegion == null || tx == null || pvTx == null) {\n            throw new NullPointerException();\n        }\n        if (cullingIndex < -1 || cullingIndex > 15) {\n            throw new IllegalArgumentException(\"cullingIndex cannot be < -1 or > 15\");\n        }\n\n        // This method must NEVER BE CALLED if the depth buffer is turned on. I don't have a good way to test\n        // for that because NGNode doesn't have a reference to the scene it is a part of...\n\n        RenderRootResult result = computeRenderRoot(path, dirtyRegion, cullingIndex, tx, pvTx);\n        if (result == RenderRootResult.NO_RENDER_ROOT) {\n            // We didn't find any render root, which means that no one node was large enough\n            // to obscure the entire dirty region (or, possibly, some combination of nodes in an\n            // NGGroup were not, together, large enough to do the job). So we need to render\n            // from the root node, which is this node.\n            path.add(this);\n        } else if (result == RenderRootResult.HAS_RENDER_ROOT_AND_IS_CLEAN) {\n            // We've found a render root, and it is clean and everything above it in painter order\n            // is clean, so actually we have nothing to paint this time around (some stuff must\n            // have been dirty which is completely occluded by the render root). So we can clear\n            // the path, which indicates to the caller that nothing needs to be painted.\n            path.clear();\n        }\n    }"}
{"Number":"130","API Relative Path":"com.sun.javafx.sg.prism.NGNode.java-getRenderRoot(NodePath-RectBounds-int-BaseTransform-GeneralTransform3D)","Corresponding Source":"/**\n     * Called <strong>after<\/strong> preCullingBits in order to get the node\n     * from which we should begin drawing. This is our support for occlusion culling.\n     * This should only be called on the root node.\n     *\n     * If no render root was found, we need to render everything from this root, so the path will contain this node.\n     * If no rendering is needed (everything dirty is occluded), the path will remain empty\n     *\n     * @param path node path to store the node path\n     */\n    public final void getRenderRoot(NodePath path, RectBounds dirtyRegion, int cullingIndex,\n                                    BaseTransform tx, GeneralTransform3D pvTx) {\n\n        // This is the main entry point, make sure to check these inputs for validity\n        if (path == null || dirtyRegion == null || tx == null || pvTx == null) {\n            throw new NullPointerException();\n        }\n        if (cullingIndex < -1 || cullingIndex > 15) {\n            throw new IllegalArgumentException(\"cullingIndex cannot be < -1 or > 15\");\n        }\n\n        // This method must NEVER BE CALLED if the depth buffer is turned on. I don't have a good way to test\n        // for that because NGNode doesn't have a reference to the scene it is a part of...\n\n        RenderRootResult result = computeRenderRoot(path, dirtyRegion, cullingIndex, tx, pvTx);\n        if (result == RenderRootResult.NO_RENDER_ROOT) {\n            // We didn't find any render root, which means that no one node was large enough\n            // to obscure the entire dirty region (or, possibly, some combination of nodes in an\n            // NGGroup were not, together, large enough to do the job). So we need to render\n            // from the root node, which is this node.\n            path.add(this);\n        } else if (result == RenderRootResult.HAS_RENDER_ROOT_AND_IS_CLEAN) {\n            // We've found a render root, and it is clean and everything above it in painter order\n            // is clean, so actually we have nothing to paint this time around (some stuff must\n            // have been dirty which is completely occluded by the render root). So we can clear\n            // the path, which indicates to the caller that nothing needs to be painted.\n            path.clear();\n        }\n    }"}
{"Number":"131","API Relative Path":"com.sun.javafx.sg.prism.NGNode.java-setCachedAsBitmap(boolean-CacheHint)","Corresponding Source":"/**\n     * Called by the FX scene graph whenever \"cached\" or \"cacheHint\" changes.\n     * These hints provide a way for the developer to indicate whether they\n     * want this node to be cached as a raster, which can be quite a performance\n     * optimization in some cases (and lethal in others).\n     * @param cached specifies whether or not this node should be cached\n     * @param cacheHint never null, indicates some hint as to how to cache\n     */\n    public void setCachedAsBitmap(boolean cached, CacheHint cacheHint) {\n        // Validate the arguments\n        if (cacheHint == null) {\n            throw new IllegalArgumentException(\"Internal Error: cacheHint must not be null\");\n        }\n\n        if (cached) {\n            if (cacheFilter == null) {\n                cacheFilter = new CacheFilter(this, cacheHint);\n                // We do not technically need to do a render pass here, but if\n                // we wait for the next render pass to cache it, then we will\n                // cache not the current visuals, but the visuals as defined\n                // by any transform changes that happen between now and then.\n                // Repainting now encourages the cached version to be as close\n                // as possible to the state of the node when the cache hint\n                // was set...\n                markDirty();\n            } else {\n                if (!cacheFilter.matchesHint(cacheHint)) {\n                    cacheFilter.setHint(cacheHint);\n                    // Different hints may have different requirements of\n                    // whether the cache is stale.  We do not have enough info\n                    // right here to evaluate that, but it will be determined\n                    // naturally during a repaint cycle.\n                    // If the new hint is more relaxed (QUALITY => SPEED for\n                    // instance) then rendering should be quick.\n                    // If the new hint is more restricted (SPEED => QUALITY)\n                    // then we need to render to improve the results anyway.\n                    markDirty();\n                }\n            }\n        } else {\n            if (cacheFilter != null) {\n                cacheFilter.dispose();\n                cacheFilter = null;\n                // A cache will often look worse than uncached rendering.  It\n                // may look the same in some circumstances, and this may then\n                // be an unnecessary rendering pass, but we do not have enough\n                // information here to be able to optimize that when possible.\n                markDirty();\n            }\n        }\n    }"}
{"Number":"132","API Relative Path":"com.sun.javafx.sg.prism.NGNode.java-setOpacity(float)","Corresponding Source":"/**\n     * Called by the FX scene graph whenever the opacity for the node changes.\n     * We create a special filter when the opacity is < 1.\n     * @param opacity A value between 0 and 1.\n     */\n    public void setOpacity(float opacity) {\n        // Check the argument to make sure it is valid.\n        if (opacity < 0 || opacity > 1) {\n            throw new IllegalArgumentException(\"Internal Error: The opacity must be between 0 and 1\");\n        }\n        // If the opacity has changed, react. If this node is being cached,\n        // then we do not want to invalidate the cache due to an opacity\n        // change. However, as usual, all parent caches must be invalidated.\n        if (opacity != this.opacity) {\n            final float old = this.opacity;\n            this.opacity = opacity;\n            markDirty();\n            // Even though the opacity has changed, for example from .5 to .6,\n            // we don't need to invalidate the opaque region unless it has toggled\n            // from 1 to !1, or from !1 to 1.\n            if (old < 1 && (opacity == 1 || opacity == 0) || opacity < 1 && (old == 1 || old == 0)) {\n                invalidateOpaqueRegion();\n            }\n        }\n    }"}
{"Number":"133","API Relative Path":"com.sun.javafx.text.CharArrayIterator.java-setIndex(int)","Corresponding Source":"/**\n     * Sets the position to the specified position in the text and returns that\n     * character.\n     * @param position the position within the text.  Valid values range from\n     * getBeginIndex() to getEndIndex().  An IllegalArgumentException is thrown\n     * if an invalid value is supplied.\n     * @return the character at the specified position or DONE if the specified position is equal to getEndIndex()\n     */\n    public char setIndex(int position) {\n\n        position -= begin;\n        if (position < 0 || position > chars.length) {\n            throw new IllegalArgumentException(\"Invalid index\");\n        }\n        pos = position;\n        return current();\n    }"}
{"Number":"134","API Relative Path":"com.sun.javafx.tk.quantum.PaintCollector.java-done(RenderJob)","Corresponding Source":"/**\n     * This object is a CompletionListener is registered with every GlassScene,\n     * such that when the repaint has completed, this method is called.\n     * This method will decrement the count on the allWorkCompletedLatch.\n     */\n    @Override public void done(RenderJob job) {\n        // It would be better to have an assertive check that\n        // this call is being made on the render thread, rather\n        // than on the FXT, but this is easier for now.\n        assert Thread.currentThread() != QuantumToolkit.getFxUserThread();\n\n        if (!(job instanceof PaintRenderJob)) {\n            throw new IllegalArgumentException(\"PaintCollector: invalid RenderJob\");\n        }\n\n        final PaintRenderJob paintjob = (PaintRenderJob)job;\n        final GlassScene scene = paintjob.getScene();\n\n        if (scene == null) {\n            throw new IllegalArgumentException(\"PaintCollector: null scene\");\n        }\n\n        // This callback on Scene only exists to allow the performance\n        // counter to be notified when a scene has been rendered. We\n        // could reduce the class count and indirection if we had a more\n        // direct method for notifying some performance tracker rather\n        // than going through this round-about way.\n        scene.frameRendered();\n\n        // Work to be done after all rendering is completed. Note that\n        // I check against \"1\" to indicate all rendering is done, and\n        // only decrement the allWorkCompletedLatch after wards. This is\n        // because as soon as I decrement the allWorkCompletedLatch to 0,\n        // then whatever code remains in this method will run concurrently\n        // with the FX app thread, and I'd prefer to minimize the number\n        // of things here that could be happening in parallel.\n        if (allWorkCompletedLatch.getCount() == 1) {\n            // In some cases we need to tell the toolkit that\n            // now would be a great time to vsync!\n            if (needsHint && !toolkit.hasNativeSystemVsync()) {\n                toolkit.vsyncHint();\n            }\n\n            Application.GetApplication().notifyRenderingFinished();\n\n            // If pulse logging is enabled, then we must call renderEnd now\n            // that we know that all of the scene's being rendered are finished\n            if (PULSE_LOGGING_ENABLED) {\n                PulseLogger.renderEnd();\n            }\n        }\n\n        // Count down the latch, indicating that drawing has\n        // completed for some scene.\n        allWorkCompletedLatch.countDown();\n    }"}
{"Number":"135","API Relative Path":"com.sun.media.jfxmedia.Media.java-addTrack(Track)","Corresponding Source":"/**\n     * Adds a <code>Track<\/code>.\n     * @throws <code>IllegalArgumentException<\/code> if <code>track<\/code> is\n     * <code>null<\/code>.\n     */\n    protected void addTrack(Track track) {\n        if (track == null) {\n            throw new IllegalArgumentException(\"track == null!\");\n        }\n        synchronized(tracks) {\n            this.tracks.add(track);\n        }\n    }"}
{"Number":"136","API Relative Path":"com.sun.media.jfxmedia.Media.java-Media(Locator)","Corresponding Source":"/**\n     * Create a <code>Media<\/code> object.\n     *\n     * @param locator <code>Locator<\/code> of the <code>Media<\/code>\n     * @throws <code>IllegalArgumentException<\/code> if <code>locator<\/code>\n     * is <code>null<\/code>.\n     */\n    protected Media(Locator locator) {\n        if (locator == null) {\n            throw new IllegalArgumentException(\"locator == null!\");\n        }\n\n        this.locator = locator;\n    }"}
{"Number":"137","API Relative Path":"com.sun.media.jfxmedia.MediaManager.java-canPlayProtocol(String)","Corresponding Source":"/**\n     * Whether a media source having the indicated protocol may be\n     * played.\n     *\n     * @throws IllegalArgumentException if <code>contentType<\/code> is\n     * <code>null<\/code>.\n     */\n    public static boolean canPlayProtocol(String protocol) {\n        if (protocol == null) {\n            throw new IllegalArgumentException(\"protocol == null!\");\n        }\n        return NativeMediaManager.getDefaultInstance().canPlayProtocol(protocol);\n    }"}
{"Number":"138","API Relative Path":"com.sun.media.jfxmedia.track.Track.java-Track(boolean-long-String-Locale-Encoding)","Corresponding Source":"/**\n     * Constructor.\n     *\n     * @param enabled Whether this track is enabled by default or not (if the container supports it)\n     * @param trackID A unique identifier for this track.\n     * @param name The name of the track.\n     * @param locale The language information for this track.\n     * @param encoding The encoding of the track.\n     * @throws IllegalArgumentException if <code>name<\/code> or\n     * <code>encoding<\/code> is <code>null<\/code>.\n     */\n    protected Track(boolean enabled, long trackID, String name, Locale locale, Encoding encoding)\n    {\n        if (name == null) {\n            throw new IllegalArgumentException(\"name == null!\");\n        } else if (encoding == null) {\n            throw new IllegalArgumentException(\"encoding == null!\");\n        }\n\n        trackEnabled = enabled;\n        this.trackID = trackID;\n        this.locale = locale;\n        this.encoding = encoding;\n        this.name = name;\n    }"}
{"Number":"139","API Relative Path":"com.sun.media.jfxmedia.track.VideoResolution.java-VideoResolution(int-int)","Corresponding Source":"/**\n     * Constructor.\n     *\n     * @param width The video width in pixels.\n     * @param height The video height in pixels.\n     * @throws IllegalArgumentException if <code>width<\/code> or <code>height<\/code> is\n     * non-positive.\n     */\n    public VideoResolution(int width, int height) {\n        if (width <= 0)\n            throw new IllegalArgumentException(\"width <= 0\");\n        if (height <= 0)\n            throw new IllegalArgumentException(\"height <= 0\");\n        this.width = width;\n        this.height = height;\n    }"}
{"Number":"140","API Relative Path":"com.sun.media.jfxmedia.track.VideoResolution.java-VideoResolution(int-int)","Corresponding Source":"/**\n     * Constructor.\n     *\n     * @param width The video width in pixels.\n     * @param height The video height in pixels.\n     * @throws IllegalArgumentException if <code>width<\/code> or <code>height<\/code> is\n     * non-positive.\n     */\n    public VideoResolution(int width, int height) {\n        if (width <= 0)\n            throw new IllegalArgumentException(\"width <= 0\");\n        if (height <= 0)\n            throw new IllegalArgumentException(\"height <= 0\");\n        this.width = width;\n        this.height = height;\n    }"}
{"Number":"141","API Relative Path":"com.sun.media.jfxmedia.track.VideoTrack.java-VideoTrack(boolean-long-String-Locale-Encoding-VideoResolution-float-boolean)","Corresponding Source":"/**\n     * Constructor.\n     *\n     * @param enabled Whether this track is enabled by default or not (if the container supports it)\n     * @param trackID A unique identifier for this track.\n     * @param name The name of the track.\n     * @param locale The language information for this track, can be null.\n     * @param encoding The encoding of the track.\n     * @param frameSize The dimensions of the video frames in the track.\n     * @param encodedFrameRate The encoded frame rate of the track.\n     * @param hasAlphaChannel Whether the video frames contain an alpha channel.\n     * @throws IllegalArgumentException if <code>name<\/code>,\n     * <code>encoding<\/code>, or <code>frameSize<\/code> is <code>null<\/code>.\n     * @throws IllegalArgumentException if <code>encodedFrameRate<\/code>\n     * is negative.\n     * @throws IllegalArgumentException if either frame dimension is\n     * non-positive.\n     */\n    public VideoTrack(boolean enabled, long trackID, String name, Locale locale,\n                      Encoding encoding, VideoResolution frameSize,\n                      float encodedFrameRate, boolean hasAlphaChannel)\n    {\n        super(enabled, trackID, name, locale, encoding);\n\n        if (frameSize == null) {\n            throw new IllegalArgumentException(\"frameSize == null!\");\n        }\n        if (frameSize.width <= 0) {\n            throw new IllegalArgumentException(\"frameSize.width <= 0!\");\n        }\n        if (frameSize.height <= 0) {\n            throw new IllegalArgumentException(\"frameSize.height <= 0!\");\n        }\n        // encodedFrameRate will be zero if it's unknown\n        if (encodedFrameRate < 0.0F) {\n            throw new IllegalArgumentException(\"encodedFrameRate < 0.0!\");\n        }\n\n        this.frameSize = frameSize;\n        this.encodedFrameRate = encodedFrameRate;\n        this.hasAlphaChannel = hasAlphaChannel;\n    }"}
{"Number":"142","API Relative Path":"com.sun.media.jfxmedia.track.VideoTrack.java-VideoTrack(boolean-long-String-Locale-Encoding-VideoResolution-float-boolean)","Corresponding Source":"/**\n     * Constructor.\n     *\n     * @param enabled Whether this track is enabled by default or not (if the container supports it)\n     * @param trackID A unique identifier for this track.\n     * @param name The name of the track.\n     * @param locale The language information for this track, can be null.\n     * @param encoding The encoding of the track.\n     * @param frameSize The dimensions of the video frames in the track.\n     * @param encodedFrameRate The encoded frame rate of the track.\n     * @param hasAlphaChannel Whether the video frames contain an alpha channel.\n     * @throws IllegalArgumentException if <code>name<\/code>,\n     * <code>encoding<\/code>, or <code>frameSize<\/code> is <code>null<\/code>.\n     * @throws IllegalArgumentException if <code>encodedFrameRate<\/code>\n     * is negative.\n     * @throws IllegalArgumentException if either frame dimension is\n     * non-positive.\n     */\n    public VideoTrack(boolean enabled, long trackID, String name, Locale locale,\n                      Encoding encoding, VideoResolution frameSize,\n                      float encodedFrameRate, boolean hasAlphaChannel)\n    {\n        super(enabled, trackID, name, locale, encoding);\n\n        if (frameSize == null) {\n            throw new IllegalArgumentException(\"frameSize == null!\");\n        }\n        if (frameSize.width <= 0) {\n            throw new IllegalArgumentException(\"frameSize.width <= 0!\");\n        }\n        if (frameSize.height <= 0) {\n            throw new IllegalArgumentException(\"frameSize.height <= 0!\");\n        }\n        // encodedFrameRate will be zero if it's unknown\n        if (encodedFrameRate < 0.0F) {\n            throw new IllegalArgumentException(\"encodedFrameRate < 0.0!\");\n        }\n\n        this.frameSize = frameSize;\n        this.encodedFrameRate = encodedFrameRate;\n        this.hasAlphaChannel = hasAlphaChannel;\n    }"}
{"Number":"143","API Relative Path":"com.sun.media.jfxmediaimpl.MediaUtils.java-fileSignatureToContentType(byte[]-int)","Corresponding Source":"/**\n     * Attempt to determine the content type from the file signature.\n     *\n     * @param buf File signature of size <code>MAX_FILE_SIGNATURE_LENGTH<\/code>\n     * @return The content type or {@link Locator#DEFAULT_CONTENT_TYPE} if not\n     * able to be determined or unsupported.\n     */\n    public static String fileSignatureToContentType(byte[] buf, int size) throws MediaException {\n        String contentType = Locator.DEFAULT_CONTENT_TYPE;\n\n        if (size < MAX_FILE_SIGNATURE_LENGTH) {\n            throw new MediaException(\"Empty signature!\");\n        } else if (buf.length < MAX_FILE_SIGNATURE_LENGTH) {\n            return contentType;\n        } else if ((buf[0] & 0xff) == 0x46\n                && (buf[1] & 0xff) == 0x4c\n                && (buf[2] & 0xff) == 0x56) { // \"FLV\"\n            contentType = CONTENT_TYPE_JFX;\n        } else if ((((buf[0] & 0xff) << 24)\n                | ((buf[1] & 0xff) << 16)\n                | ((buf[2] & 0xff) << 8)\n                | (buf[3] & 0xff)) == 0x52494646 && // \"RIFF\"\n                (((buf[8] & 0xff) << 24)\n                | ((buf[9] & 0xff) << 16)\n                | ((buf[10] & 0xff) << 8)\n                | (buf[11] & 0xff)) == 0x57415645 && // \"WAVE\n                (((buf[12] & 0xff) << 24)\n                | ((buf[13] & 0xff) << 16)\n                | ((buf[14] & 0xff) << 8)\n                | (buf[15] & 0xff)) == 0x666d7420) { // \"fmt\"\n            if (((buf[20] & 0xff) == 0x01 && (buf[21] & 0xff) == 0x00) || ((buf[20] & 0xff) == 0x03 && (buf[21] & 0xff) == 0x00)) { // PCM or IEEE float\n                contentType = CONTENT_TYPE_WAV;\n            } else {\n                throw new MediaException(\"Compressed WAVE is not supported!\");\n            }\n        } else if ((((buf[0] & 0xff) << 24)\n                | ((buf[1] & 0xff) << 16)\n                | ((buf[2] & 0xff) << 8)\n                | (buf[3] & 0xff)) == 0x52494646 && // \"RIFF\"\n                (((buf[8] & 0xff) << 24)\n                | ((buf[9] & 0xff) << 16)\n                | ((buf[10] & 0xff) << 8)\n                | (buf[11] & 0xff)) == 0x57415645) // \"WAVE\n        {\n            contentType = CONTENT_TYPE_WAV; // It is WAV for sure, but we cannot detect format, so format detection will be left to native part\n        } else if ((((buf[0] & 0xff) << 24)\n                | ((buf[1] & 0xff) << 16)\n                | ((buf[2] & 0xff) << 8)\n                | (buf[3] & 0xff)) == 0x464f524d && // \"FORM\"\n                (((buf[8] & 0xff) << 24)\n                | ((buf[9] & 0xff) << 16)\n                | ((buf[10] & 0xff) << 8)\n                | (buf[11] & 0xff)) == 0x41494646 && // \"AIFF\n                (((buf[12] & 0xff) << 24)\n                | ((buf[13] & 0xff) << 16)\n                | ((buf[14] & 0xff) << 8)\n                | (buf[15] & 0xff)) == 0x434f4d4d) { // \"COMM\"\n            contentType = CONTENT_TYPE_AIFF;\n        } else if ((buf[0] & 0xff) == 0x49\n                && (buf[1] & 0xff) == 0x44\n                && (buf[2] & 0xff) == 0x33) { // \"ID3\"\n            contentType = CONTENT_TYPE_MPA;\n        } else if ((buf[0] & 0xff) == 0xff && (buf[1] & 0xe0) == 0xe0 && // sync\n                (buf[2] & 0x18) != 0x08 && // not reserved version\n                (buf[3] & 0x06) != 0x00) { // not reserved layer\n            contentType = CONTENT_TYPE_MPA;\n        } else if ((((buf[4] & 0xff) << 24)\n                | ((buf[5] & 0xff) << 16)\n                | ((buf[6] & 0xff) << 8)\n                | (buf[7] & 0xff)) == 0x66747970) { // \"ftyp\"\n            if ((buf[8] & 0xff) == 0x4D && (buf[9] & 0xff) == 0x34 && (buf[10] & 0xff) == 0x41 && (buf[11] & 0xff) == 0x20) // 'M4A '\n                contentType = CONTENT_TYPE_M4A;\n            else if ((buf[8] & 0xff) == 0x4D && (buf[9] & 0xff) == 0x34 && (buf[10] & 0xff) == 0x56 && (buf[11] & 0xff) == 0x20) // 'M4V '\n                contentType = CONTENT_TYPE_M4V;\n            else if ((buf[8] & 0xff) == 0x6D && (buf[9] & 0xff) == 0x70 && (buf[10] & 0xff) == 0x34 && (buf[11] & 0xff) == 0x32) // 'mp42'\n                contentType = CONTENT_TYPE_MP4;\n            else if ((buf[8] & 0xff) == 0x69 && (buf[9] & 0xff) == 0x73 && (buf[10] & 0xff) == 0x6F && (buf[11] & 0xff) == 0x6D) // 'isom'\n                contentType = CONTENT_TYPE_MP4;\n            else if ((buf[8] & 0xff) == 0x4D && (buf[9] & 0xff) == 0x50 && (buf[10] & 0xff) == 0x34 && (buf[11] & 0xff) == 0x20) // 'MP4 '\n                contentType = CONTENT_TYPE_MP4;\n        } else {\n            throw new MediaException(\"Unrecognized file signature!\");\n        }\n\n        return contentType;\n    }"}
{"Number":"144","API Relative Path":"com.sun.media.jfxmediaimpl.MediaUtils.java-fileSignatureToContentType(byte[]-int)","Corresponding Source":"/**\n     * Attempt to determine the content type from the file signature.\n     *\n     * @param buf File signature of size <code>MAX_FILE_SIGNATURE_LENGTH<\/code>\n     * @return The content type or {@link Locator#DEFAULT_CONTENT_TYPE} if not\n     * able to be determined or unsupported.\n     */\n    public static String fileSignatureToContentType(byte[] buf, int size) throws MediaException {\n        String contentType = Locator.DEFAULT_CONTENT_TYPE;\n\n        if (size < MAX_FILE_SIGNATURE_LENGTH) {\n            throw new MediaException(\"Empty signature!\");\n        } else if (buf.length < MAX_FILE_SIGNATURE_LENGTH) {\n            return contentType;\n        } else if ((buf[0] & 0xff) == 0x46\n                && (buf[1] & 0xff) == 0x4c\n                && (buf[2] & 0xff) == 0x56) { // \"FLV\"\n            contentType = CONTENT_TYPE_JFX;\n        } else if ((((buf[0] & 0xff) << 24)\n                | ((buf[1] & 0xff) << 16)\n                | ((buf[2] & 0xff) << 8)\n                | (buf[3] & 0xff)) == 0x52494646 && // \"RIFF\"\n                (((buf[8] & 0xff) << 24)\n                | ((buf[9] & 0xff) << 16)\n                | ((buf[10] & 0xff) << 8)\n                | (buf[11] & 0xff)) == 0x57415645 && // \"WAVE\n                (((buf[12] & 0xff) << 24)\n                | ((buf[13] & 0xff) << 16)\n                | ((buf[14] & 0xff) << 8)\n                | (buf[15] & 0xff)) == 0x666d7420) { // \"fmt\"\n            if (((buf[20] & 0xff) == 0x01 && (buf[21] & 0xff) == 0x00) || ((buf[20] & 0xff) == 0x03 && (buf[21] & 0xff) == 0x00)) { // PCM or IEEE float\n                contentType = CONTENT_TYPE_WAV;\n            } else {\n                throw new MediaException(\"Compressed WAVE is not supported!\");\n            }\n        } else if ((((buf[0] & 0xff) << 24)\n                | ((buf[1] & 0xff) << 16)\n                | ((buf[2] & 0xff) << 8)\n                | (buf[3] & 0xff)) == 0x52494646 && // \"RIFF\"\n                (((buf[8] & 0xff) << 24)\n                | ((buf[9] & 0xff) << 16)\n                | ((buf[10] & 0xff) << 8)\n                | (buf[11] & 0xff)) == 0x57415645) // \"WAVE\n        {\n            contentType = CONTENT_TYPE_WAV; // It is WAV for sure, but we cannot detect format, so format detection will be left to native part\n        } else if ((((buf[0] & 0xff) << 24)\n                | ((buf[1] & 0xff) << 16)\n                | ((buf[2] & 0xff) << 8)\n                | (buf[3] & 0xff)) == 0x464f524d && // \"FORM\"\n                (((buf[8] & 0xff) << 24)\n                | ((buf[9] & 0xff) << 16)\n                | ((buf[10] & 0xff) << 8)\n                | (buf[11] & 0xff)) == 0x41494646 && // \"AIFF\n                (((buf[12] & 0xff) << 24)\n                | ((buf[13] & 0xff) << 16)\n                | ((buf[14] & 0xff) << 8)\n                | (buf[15] & 0xff)) == 0x434f4d4d) { // \"COMM\"\n            contentType = CONTENT_TYPE_AIFF;\n        } else if ((buf[0] & 0xff) == 0x49\n                && (buf[1] & 0xff) == 0x44\n                && (buf[2] & 0xff) == 0x33) { // \"ID3\"\n            contentType = CONTENT_TYPE_MPA;\n        } else if ((buf[0] & 0xff) == 0xff && (buf[1] & 0xe0) == 0xe0 && // sync\n                (buf[2] & 0x18) != 0x08 && // not reserved version\n                (buf[3] & 0x06) != 0x00) { // not reserved layer\n            contentType = CONTENT_TYPE_MPA;\n        } else if ((((buf[4] & 0xff) << 24)\n                | ((buf[5] & 0xff) << 16)\n                | ((buf[6] & 0xff) << 8)\n                | (buf[7] & 0xff)) == 0x66747970) { // \"ftyp\"\n            if ((buf[8] & 0xff) == 0x4D && (buf[9] & 0xff) == 0x34 && (buf[10] & 0xff) == 0x41 && (buf[11] & 0xff) == 0x20) // 'M4A '\n                contentType = CONTENT_TYPE_M4A;\n            else if ((buf[8] & 0xff) == 0x4D && (buf[9] & 0xff) == 0x34 && (buf[10] & 0xff) == 0x56 && (buf[11] & 0xff) == 0x20) // 'M4V '\n                contentType = CONTENT_TYPE_M4V;\n            else if ((buf[8] & 0xff) == 0x6D && (buf[9] & 0xff) == 0x70 && (buf[10] & 0xff) == 0x34 && (buf[11] & 0xff) == 0x32) // 'mp42'\n                contentType = CONTENT_TYPE_MP4;\n            else if ((buf[8] & 0xff) == 0x69 && (buf[9] & 0xff) == 0x73 && (buf[10] & 0xff) == 0x6F && (buf[11] & 0xff) == 0x6D) // 'isom'\n                contentType = CONTENT_TYPE_MP4;\n            else if ((buf[8] & 0xff) == 0x4D && (buf[9] & 0xff) == 0x50 && (buf[10] & 0xff) == 0x34 && (buf[11] & 0xff) == 0x20) // 'MP4 '\n                contentType = CONTENT_TYPE_MP4;\n        } else {\n            throw new MediaException(\"Unrecognized file signature!\");\n        }\n\n        return contentType;\n    }"}
{"Number":"145","API Relative Path":"com.sun.media.jfxmediaimpl.MediaUtils.java-fileSignatureToContentType(byte[]-int)","Corresponding Source":"/**\n     * Attempt to determine the content type from the file signature.\n     *\n     * @param buf File signature of size <code>MAX_FILE_SIGNATURE_LENGTH<\/code>\n     * @return The content type or {@link Locator#DEFAULT_CONTENT_TYPE} if not\n     * able to be determined or unsupported.\n     */\n    public static String fileSignatureToContentType(byte[] buf, int size) throws MediaException {\n        String contentType = Locator.DEFAULT_CONTENT_TYPE;\n\n        if (size < MAX_FILE_SIGNATURE_LENGTH) {\n            throw new MediaException(\"Empty signature!\");\n        } else if (buf.length < MAX_FILE_SIGNATURE_LENGTH) {\n            return contentType;\n        } else if ((buf[0] & 0xff) == 0x46\n                && (buf[1] & 0xff) == 0x4c\n                && (buf[2] & 0xff) == 0x56) { // \"FLV\"\n            contentType = CONTENT_TYPE_JFX;\n        } else if ((((buf[0] & 0xff) << 24)\n                | ((buf[1] & 0xff) << 16)\n                | ((buf[2] & 0xff) << 8)\n                | (buf[3] & 0xff)) == 0x52494646 && // \"RIFF\"\n                (((buf[8] & 0xff) << 24)\n                | ((buf[9] & 0xff) << 16)\n                | ((buf[10] & 0xff) << 8)\n                | (buf[11] & 0xff)) == 0x57415645 && // \"WAVE\n                (((buf[12] & 0xff) << 24)\n                | ((buf[13] & 0xff) << 16)\n                | ((buf[14] & 0xff) << 8)\n                | (buf[15] & 0xff)) == 0x666d7420) { // \"fmt\"\n            if (((buf[20] & 0xff) == 0x01 && (buf[21] & 0xff) == 0x00) || ((buf[20] & 0xff) == 0x03 && (buf[21] & 0xff) == 0x00)) { // PCM or IEEE float\n                contentType = CONTENT_TYPE_WAV;\n            } else {\n                throw new MediaException(\"Compressed WAVE is not supported!\");\n            }\n        } else if ((((buf[0] & 0xff) << 24)\n                | ((buf[1] & 0xff) << 16)\n                | ((buf[2] & 0xff) << 8)\n                | (buf[3] & 0xff)) == 0x52494646 && // \"RIFF\"\n                (((buf[8] & 0xff) << 24)\n                | ((buf[9] & 0xff) << 16)\n                | ((buf[10] & 0xff) << 8)\n                | (buf[11] & 0xff)) == 0x57415645) // \"WAVE\n        {\n            contentType = CONTENT_TYPE_WAV; // It is WAV for sure, but we cannot detect format, so format detection will be left to native part\n        } else if ((((buf[0] & 0xff) << 24)\n                | ((buf[1] & 0xff) << 16)\n                | ((buf[2] & 0xff) << 8)\n                | (buf[3] & 0xff)) == 0x464f524d && // \"FORM\"\n                (((buf[8] & 0xff) << 24)\n                | ((buf[9] & 0xff) << 16)\n                | ((buf[10] & 0xff) << 8)\n                | (buf[11] & 0xff)) == 0x41494646 && // \"AIFF\n                (((buf[12] & 0xff) << 24)\n                | ((buf[13] & 0xff) << 16)\n                | ((buf[14] & 0xff) << 8)\n                | (buf[15] & 0xff)) == 0x434f4d4d) { // \"COMM\"\n            contentType = CONTENT_TYPE_AIFF;\n        } else if ((buf[0] & 0xff) == 0x49\n                && (buf[1] & 0xff) == 0x44\n                && (buf[2] & 0xff) == 0x33) { // \"ID3\"\n            contentType = CONTENT_TYPE_MPA;\n        } else if ((buf[0] & 0xff) == 0xff && (buf[1] & 0xe0) == 0xe0 && // sync\n                (buf[2] & 0x18) != 0x08 && // not reserved version\n                (buf[3] & 0x06) != 0x00) { // not reserved layer\n            contentType = CONTENT_TYPE_MPA;\n        } else if ((((buf[4] & 0xff) << 24)\n                | ((buf[5] & 0xff) << 16)\n                | ((buf[6] & 0xff) << 8)\n                | (buf[7] & 0xff)) == 0x66747970) { // \"ftyp\"\n            if ((buf[8] & 0xff) == 0x4D && (buf[9] & 0xff) == 0x34 && (buf[10] & 0xff) == 0x41 && (buf[11] & 0xff) == 0x20) // 'M4A '\n                contentType = CONTENT_TYPE_M4A;\n            else if ((buf[8] & 0xff) == 0x4D && (buf[9] & 0xff) == 0x34 && (buf[10] & 0xff) == 0x56 && (buf[11] & 0xff) == 0x20) // 'M4V '\n                contentType = CONTENT_TYPE_M4V;\n            else if ((buf[8] & 0xff) == 0x6D && (buf[9] & 0xff) == 0x70 && (buf[10] & 0xff) == 0x34 && (buf[11] & 0xff) == 0x32) // 'mp42'\n                contentType = CONTENT_TYPE_MP4;\n            else if ((buf[8] & 0xff) == 0x69 && (buf[9] & 0xff) == 0x73 && (buf[10] & 0xff) == 0x6F && (buf[11] & 0xff) == 0x6D) // 'isom'\n                contentType = CONTENT_TYPE_MP4;\n            else if ((buf[8] & 0xff) == 0x4D && (buf[9] & 0xff) == 0x50 && (buf[10] & 0xff) == 0x34 && (buf[11] & 0xff) == 0x20) // 'MP4 '\n                contentType = CONTENT_TYPE_MP4;\n        } else {\n            throw new MediaException(\"Unrecognized file signature!\");\n        }\n\n        return contentType;\n    }"}
{"Number":"146","API Relative Path":"com.sun.media.jfxmediaimpl.MediaUtils.java-warning(Object-String)","Corresponding Source":"/**\n     * Forward warnings to the global listeners registered with the\n     * {@link NativeMediaManager}. This method may be invoked from either the\n     * Java or the native layer.\n     *\n     * @param source the source of the warning, likely the object calling this\n     * method.\n     * @param message a <code>String<\/code> containing the warning.\n     */\n    public static void warning(Object source, String message) {\n        // Log the warning.\n        if (source != null & message != null) {\n            Logger.logMsg(Logger.WARNING,\n                    source.getClass().getName() + \": \" + message);\n        }\n    }"}
{"Number":"147","API Relative Path":"com.sun.media.jfxmediaimpl.NativeAudioEqualizer.java-NativeAudioEqualizer(long)","Corresponding Source":"//**************************************************************************\n    //***** Constructors\n    //**************************************************************************\n\n    /**\n     * Constructor.\n     * @param nativeRef A reference to the native component.\n     */\n    NativeAudioEqualizer(long nativeRef) {\n        if (nativeRef == 0) {\n            throw new IllegalArgumentException(\"Invalid native media reference\");\n        }\n\n        this.nativeRef = nativeRef;\n    }"}
{"Number":"148","API Relative Path":"com.sun.media.jfxmediaimpl.NativeAudioSpectrum.java-NativeAudioSpectrum(long)","Corresponding Source":"//**************************************************************************\n    //***** Constructors\n    //**************************************************************************\n\n    /**\n     * Constructor.\n     * @param refNativePlayer A reference to the native player.\n     */\n    NativeAudioSpectrum(long refMedia) {\n        if (refMedia == 0) {\n            throw new IllegalArgumentException(\"Invalid native media reference\");\n        }\n\n        this.nativeRef = refMedia;\n        setBandCount(DEFAULT_BANDS);\n    }"}
{"Number":"149","API Relative Path":"com.sun.media.jfxmediaimpl.NativeMediaManager.java-addMediaErrorListener(MediaErrorListener)","Corresponding Source":"/**\n     * @see\n     * MediaManager#addMediaErrorListener(com.sun.media.jfxmedia.events.MediaErrorListener)\n     */\n    public void addMediaErrorListener(MediaErrorListener listener) {\n        if (listener != null) {\n            // Since we have only one instance of NativeMediaManager, all media players\n            // created during application lifecycle will keep weak references to error\n            // listeners in errorListeners. Lets clean up unused references.\n            // FIXME: change to WeakHashMap<MEL,Boolean> as it's more efficient\n            for (ListIterator<WeakReference<MediaErrorListener>> it = errorListeners.listIterator(); it.hasNext();) {\n                MediaErrorListener l = it.next().get();\n                if (l == null) {\n                    it.remove();\n                }\n            }\n\n            this.errorListeners.add(new WeakReference<MediaErrorListener>(listener));\n        }\n    }"}
{"Number":"150","API Relative Path":"com.sun.media.jfxmediaimpl.NativeMediaManager.java-removeMediaErrorListener(MediaErrorListener)","Corresponding Source":"/**\n     * @see\n     * MediaManager#removeMediaErrorListener(com.sun.media.jfxmedia.events.MediaErrorListener)\n     */\n    public void removeMediaErrorListener(MediaErrorListener listener) {\n        if (listener != null) {\n            // FIXME: change to WeakHashMap<MEL,Boolean> as it's more efficient\n            for (ListIterator<WeakReference<MediaErrorListener>> it = errorListeners.listIterator(); it.hasNext();) {\n                MediaErrorListener l = it.next().get();\n                if (l == null || l == listener) {\n                    it.remove();\n            }\n        }\n    }\n        }"}
{"Number":"151","API Relative Path":"com.sun.pisces.PiscesRenderer.java-setColor(int-int-int-int)","Corresponding Source":"/**\n     * Sets the current paint color.\n     *\n     * @param red a value between 0 and 255.\n     * @param green a value between 0 and 255.\n     * @param blue a value between 0 and 255.\n     * @param alpha a value between 0 and 255.\n     */\n    public void setColor(int red, int green, int blue, int alpha) {\n        checkColorRange(red, \"RED\");\n        checkColorRange(green, \"GREEN\");\n        checkColorRange(blue, \"BLUE\");\n        checkColorRange(alpha, \"ALPHA\");\n        this.setColorImpl(red, green, blue, alpha);\n    }"}
{"Number":"152","API Relative Path":"com.sun.pisces.PiscesRenderer.java-setCompositeRule(int)","Corresponding Source":"/**\n     * Sets current Compositing Rule (Porter-Duff) to be used in following rendering operation. Note that <code>compositeAlpha<\/code>\n     * is not changed.\n     * @param compositeRule one of <code>RendererBase.COMPOSITE_*<\/code> constants.\n     */\n    public void setCompositeRule(int compositeRule) {\n        if (compositeRule != RendererBase.COMPOSITE_CLEAR &&\n            compositeRule != RendererBase.COMPOSITE_SRC &&\n            compositeRule != RendererBase.COMPOSITE_SRC_OVER)\n        {\n            throw new IllegalArgumentException(\"Invalid value for Composite-Rule\");\n        }\n        this.setCompositeRuleImpl(compositeRule);\n    }"}
{"Number":"153","API Relative Path":"com.sun.prism.es2.BufferFactory.java-getArray(Object)","Corresponding Source":"/** Helper routine to return the array backing store reference from\n      a Buffer object.  */\n   static Object getArray(Object buf) {\n     if (buf == null) {\n       return null;\n     }\n     if(buf instanceof ByteBuffer) {\n       return ((ByteBuffer) buf).array();\n     } else if (buf instanceof FloatBuffer) {\n       return ((FloatBuffer) buf).array();\n     } else if (buf instanceof IntBuffer) {\n       return ((IntBuffer) buf).array();\n     } else if (buf instanceof ShortBuffer) {\n       return ((ShortBuffer) buf).array();\n     } else if (buf instanceof DoubleBuffer) {\n       return ((DoubleBuffer) buf).array();\n     } else if (buf instanceof LongBuffer) {\n       return ((LongBuffer) buf).array();\n     } else if (buf instanceof CharBuffer) {\n       return ((CharBuffer) buf).array();\n     }\n     throw new RuntimeException(\"Disallowed array backing store type in buffer \"\n                                + buf.getClass().getName());\n   }"}
{"Number":"154","API Relative Path":"com.sun.prism.Image.java-createPackedBuffer(Buffer-PixelFormat-int-int-int-int-int)","Corresponding Source":"/**\n     * Returns a new {@code Buffer} instance that contains a tightly packed\n     * copy of the given {@code Buffer}'s pixel data.  This method is useful\n     * in cases where having extra pixels at the end of a scanline is not\n     * desirable.\n     *\n     * @param pixels the buffer containing the pixels to copy\n     * @param format the format of the given buffer\n     * @param minX the x offset of the upper-left corner of the pixel region\n     * @param minY the y offset of the upper-left corner of the pixel region\n     * @param width the width of the pixel region to be copied, in pixels\n     * @param height the height of the pixel region to be copied, in pixels\n     * @param scanlineStride the scanline stride of the given buffer, in bytes\n     * @return a new, tightly packed copy of the given {@code Buffer}\n     */\n    public static Buffer createPackedBuffer(Buffer pixels,\n                                            PixelFormat format,\n                                            int minX, int minY,\n                                            int width, int height,\n                                            int scanlineStride)\n    {\n        if (scanlineStride % format.getBytesPerPixelUnit() != 0) {\n            throw new IllegalArgumentException(\n                \"Image scanlineStride must be a multiple of the pixel stride\");\n        }\n        if (format == PixelFormat.MULTI_YCbCr_420) {\n            throw new IllegalArgumentException(\"Format unsupported \"+format);\n        }\n\n        int elemsPerPixel = format.getElemsPerPixelUnit();\n        int oldRowLength = scanlineStride / format.getBytesPerPixelUnit();\n        int oldElemsPerRow = oldRowLength * elemsPerPixel;\n        int newElemsPerRow = width * elemsPerPixel;\n        int newSizeInElems = newElemsPerRow * height;\n        int oldpos = (minX*elemsPerPixel) + (minY*oldElemsPerRow);\n        int newpos = 0;\n\n        Buffer newBuf;\n        switch (format.getDataType()) {\n        case BYTE:\n            ByteBuffer oldbbuf = (ByteBuffer)pixels;\n            ByteBuffer newbbuf = BufferUtil.newByteBuffer(newSizeInElems);\n            for (int y = 0; y < height; y++) {\n                oldbbuf.limit(oldpos + newElemsPerRow);\n                oldbbuf.position(oldpos);\n                newbbuf.limit(newpos + newElemsPerRow);\n                newbbuf.position(newpos);\n                newbbuf.put(oldbbuf);\n                oldpos += oldElemsPerRow;\n                newpos += newElemsPerRow;\n            }\n            newBuf = newbbuf;\n            break;\n        case INT:\n            IntBuffer oldibuf = (IntBuffer)pixels;\n            IntBuffer newibuf = BufferUtil.newIntBuffer(newSizeInElems);\n            for (int y = 0; y < height; y++) {\n                oldibuf.limit(oldpos + newElemsPerRow);\n                oldibuf.position(oldpos);\n                newibuf.limit(newpos + newElemsPerRow);\n                newibuf.position(newpos);\n                newibuf.put(oldibuf);\n                oldpos += oldElemsPerRow;\n                newpos += newElemsPerRow;\n            }\n            newBuf = newibuf;\n            break;\n        case FLOAT:\n            FloatBuffer oldfbuf = (FloatBuffer)pixels;\n            FloatBuffer newfbuf = BufferUtil.newFloatBuffer(newSizeInElems);\n            for (int y = 0; y < height; y++) {\n                oldfbuf.limit(oldpos + newElemsPerRow);\n                oldfbuf.position(oldpos);\n                newfbuf.limit(newpos + newElemsPerRow);\n                newfbuf.position(newpos);\n                newfbuf.put(oldfbuf);\n                oldpos += oldElemsPerRow;\n                newpos += newElemsPerRow;\n            }\n            newBuf = newfbuf;\n            break;\n        default:\n            throw new InternalError(\"Unknown data type\");\n        }\n\n        pixels.limit(pixels.capacity());\n        pixels.rewind();\n        newBuf.limit(newBuf.capacity());\n        newBuf.rewind();\n\n        return newBuf;\n    }"}
{"Number":"155","API Relative Path":"com.sun.prism.Image.java-createSubImage(int-int-int-int)","Corresponding Source":"/**\n     * Returns a new {@code Image} instance that shares the underlying pixel\n     * buffer of this {@code Image}.  The new image will have the same\n     * scanline stride, pixel format, etc of the original image, except\n     * with the provided minX/minY and dimensions.\n     *\n     * @param x the x offset of the upper-left corner of the new subimage,\n     * relative to the minX of this image\n     * @param y the y offset of the upper-left corner of the new subimage,\n     * relative to the minY of this image\n     * @param w the width of the new subimage\n     * @param h the height of the new subimage\n     * @return a new {@code Image} representing a sub-region of this image\n     */\n    public Image createSubImage(int x, int y, int w, int h) {\n        if (w <= 0 || h <= 0) {\n            throw new IllegalArgumentException(\"Subimage dimensions must be > 0\");\n        }\n        if (x < 0 || y < 0) {\n            throw new IllegalArgumentException(\"Subimage minX and minY must be >= 0\");\n        }\n        if (x+w > this.width) {\n            throw new IllegalArgumentException(\n                \"Subimage minX+width must be <= width of parent image\");\n        }\n        if (y+h > this.height) {\n            throw new IllegalArgumentException(\n                \"Subimage minY+height must be <= height of parent image\");\n        }\n        Image subimg = new Image(pixelFormat, pixelBuffer, w, h,\n                                 minX+x, minY+y, scanlineStride);\n        subimg.serial = this.serial;\n        return subimg;\n    }"}
{"Number":"156","API Relative Path":"com.sun.prism.Image.java-createSubImage(int-int-int-int)","Corresponding Source":"/**\n     * Returns a new {@code Image} instance that shares the underlying pixel\n     * buffer of this {@code Image}.  The new image will have the same\n     * scanline stride, pixel format, etc of the original image, except\n     * with the provided minX/minY and dimensions.\n     *\n     * @param x the x offset of the upper-left corner of the new subimage,\n     * relative to the minX of this image\n     * @param y the y offset of the upper-left corner of the new subimage,\n     * relative to the minY of this image\n     * @param w the width of the new subimage\n     * @param h the height of the new subimage\n     * @return a new {@code Image} representing a sub-region of this image\n     */\n    public Image createSubImage(int x, int y, int w, int h) {\n        if (w <= 0 || h <= 0) {\n            throw new IllegalArgumentException(\"Subimage dimensions must be > 0\");\n        }\n        if (x < 0 || y < 0) {\n            throw new IllegalArgumentException(\"Subimage minX and minY must be >= 0\");\n        }\n        if (x+w > this.width) {\n            throw new IllegalArgumentException(\n                \"Subimage minX+width must be <= width of parent image\");\n        }\n        if (y+h > this.height) {\n            throw new IllegalArgumentException(\n                \"Subimage minY+height must be <= height of parent image\");\n        }\n        Image subimg = new Image(pixelFormat, pixelBuffer, w, h,\n                                 minX+x, minY+y, scanlineStride);\n        subimg.serial = this.serial;\n        return subimg;\n    }"}
{"Number":"157","API Relative Path":"com.sun.prism.Image.java-createSubImage(int-int-int-int)","Corresponding Source":"/**\n     * Returns a new {@code Image} instance that shares the underlying pixel\n     * buffer of this {@code Image}.  The new image will have the same\n     * scanline stride, pixel format, etc of the original image, except\n     * with the provided minX/minY and dimensions.\n     *\n     * @param x the x offset of the upper-left corner of the new subimage,\n     * relative to the minX of this image\n     * @param y the y offset of the upper-left corner of the new subimage,\n     * relative to the minY of this image\n     * @param w the width of the new subimage\n     * @param h the height of the new subimage\n     * @return a new {@code Image} representing a sub-region of this image\n     */\n    public Image createSubImage(int x, int y, int w, int h) {\n        if (w <= 0 || h <= 0) {\n            throw new IllegalArgumentException(\"Subimage dimensions must be > 0\");\n        }\n        if (x < 0 || y < 0) {\n            throw new IllegalArgumentException(\"Subimage minX and minY must be >= 0\");\n        }\n        if (x+w > this.width) {\n            throw new IllegalArgumentException(\n                \"Subimage minX+width must be <= width of parent image\");\n        }\n        if (y+h > this.height) {\n            throw new IllegalArgumentException(\n                \"Subimage minY+height must be <= height of parent image\");\n        }\n        Image subimg = new Image(pixelFormat, pixelBuffer, w, h,\n                                 minX+x, minY+y, scanlineStride);\n        subimg.serial = this.serial;\n        return subimg;\n    }"}
{"Number":"158","API Relative Path":"com.sun.prism.Image.java-createSubImage(int-int-int-int)","Corresponding Source":"/**\n     * Returns a new {@code Image} instance that shares the underlying pixel\n     * buffer of this {@code Image}.  The new image will have the same\n     * scanline stride, pixel format, etc of the original image, except\n     * with the provided minX/minY and dimensions.\n     *\n     * @param x the x offset of the upper-left corner of the new subimage,\n     * relative to the minX of this image\n     * @param y the y offset of the upper-left corner of the new subimage,\n     * relative to the minY of this image\n     * @param w the width of the new subimage\n     * @param h the height of the new subimage\n     * @return a new {@code Image} representing a sub-region of this image\n     */\n    public Image createSubImage(int x, int y, int w, int h) {\n        if (w <= 0 || h <= 0) {\n            throw new IllegalArgumentException(\"Subimage dimensions must be > 0\");\n        }\n        if (x < 0 || y < 0) {\n            throw new IllegalArgumentException(\"Subimage minX and minY must be >= 0\");\n        }\n        if (x+w > this.width) {\n            throw new IllegalArgumentException(\n                \"Subimage minX+width must be <= width of parent image\");\n        }\n        if (y+h > this.height) {\n            throw new IllegalArgumentException(\n                \"Subimage minY+height must be <= height of parent image\");\n        }\n        Image subimg = new Image(pixelFormat, pixelBuffer, w, h,\n                                 minX+x, minY+y, scanlineStride);\n        subimg.serial = this.serial;\n        return subimg;\n    }"}
{"Number":"159","API Relative Path":"com.sun.prism.impl.paint.MultipleGradientContext.java-MultipleGradientContext(Gradient-BaseTransform-float[]-Color[]-int)","Corresponding Source":"/**\n     * Constructor for MultipleGradientContext superclass.\n     */\n    protected MultipleGradientContext(Gradient mgp,\n                                      BaseTransform t,\n                                      float[] fractions,\n                                      Color[] colors,\n                                      int cycleMethod)\n    {\n        if (t == null) {\n            throw new NullPointerException(\"Transform cannot be null\");\n        }\n\n        // The inverse transform is needed to go from device to user space.\n        // Get all the components of the inverse transform matrix.\n        BaseTransform tInv;\n        try {\n            // the following assumes that the caller has copied the incoming\n            // transform and is not concerned about it being modified\n            tInv = t.createInverse();\n        } catch (NoninvertibleTransformException e) {\n            // just use identity transform in this case; better to show\n            // (incorrect) results than to throw an exception and/or no-op\n            tInv = BaseTransform.IDENTITY_TRANSFORM;\n        }\n        a00 = (float)tInv.getMxx();\n        a10 = (float)tInv.getMyx();\n        a01 = (float)tInv.getMxy();\n        a11 = (float)tInv.getMyy();\n        a02 = (float)tInv.getMxt();\n        a12 = (float)tInv.getMyt();\n\n        // copy some flags\n        this.cycleMethod = cycleMethod;\n\n        // we can avoid copying this array since we do not modify its values\n        this.fractions = fractions;\n\n        calculateLookupData(colors);\n\n//        // note that only one of these values can ever be non-null (we either\n//        // store the fast gradient array or the slow one, but never both\n//        // at the same time)\n//        int[] gradient =\n//            (mgp.gradient != null) ? mgp.gradient.get() : null;\n//        int[][] gradients =\n//            (mgp.gradients != null) ? mgp.gradients.get() : null;\n//\n//        if (gradient == null && gradients == null) {\n//            // we need to (re)create the appropriate values\n//            calculateLookupData(colors);\n//\n//            // now cache the calculated values in the\n//            // MultipleGradientPaint instance for future use\n//            mgp.model               = this.model;\n//            mgp.normalizedIntervals = this.normalizedIntervals;\n//            mgp.isSimpleLookup      = this.isSimpleLookup;\n//            if (isSimpleLookup) {\n//                // only cache the fast array\n//                mgp.fastGradientArraySize = this.fastGradientArraySize;\n//                mgp.gradient = new SoftReference<int[]>(this.gradient);\n//            } else {\n//                // only cache the slow array\n//                mgp.gradients = new SoftReference<int[][]>(this.gradients);\n//            }\n//        } else {\n//            // use the values cached in the MultipleGradientPaint instance\n//            this.model                 = mgp.model;\n//            this.normalizedIntervals   = mgp.normalizedIntervals;\n//            this.isSimpleLookup        = mgp.isSimpleLookup;\n//            this.gradient              = gradient;\n//            this.fastGradientArraySize = mgp.fastGradientArraySize;\n//            this.gradients             = gradients;\n//        }\n    }"}
{"Number":"160","API Relative Path":"com.sun.prism.j2d.paint.MultipleGradientPaint.java-MultipleGradientPaint(float[]-Color[]-CycleMethod-ColorSpaceType-AffineTransform)","Corresponding Source":"/**\n     * Package-private constructor.\n     *\n     * @param fractions numbers ranging from 0.0 to 1.0 specifying the\n     *                  distribution of colors along the gradient\n     * @param colors array of colors corresponding to each fractional value\n     * @param cycleMethod either {@code NO_CYCLE}, {@code REFLECT},\n     *                    or {@code REPEAT}\n     * @param colorSpace which color space to use for interpolation,\n     *                   either {@code SRGB} or {@code LINEAR_RGB}\n     * @param gradientTransform transform to apply to the gradient\n     *\n     * @throws NullPointerException\n     * if {@code fractions} array is null,\n     * or {@code colors} array is null,\n     * or {@code gradientTransform} is null,\n     * or {@code cycleMethod} is null,\n     * or {@code colorSpace} is null\n     * @throws IllegalArgumentException\n     * if {@code fractions.length != colors.length},\n     * or {@code colors} is less than 2 in size,\n     * or a {@code fractions} value is less than 0.0 or greater than 1.0,\n     * or the {@code fractions} are not provided in strictly increasing order\n     */\n    MultipleGradientPaint(float[] fractions,\n                          Color[] colors,\n                          CycleMethod cycleMethod,\n                          ColorSpaceType colorSpace,\n                          AffineTransform gradientTransform)\n    {\n        if (fractions == null) {\n            throw new NullPointerException(\"Fractions array cannot be null\");\n        }\n\n        if (colors == null) {\n            throw new NullPointerException(\"Colors array cannot be null\");\n        }\n\n        if (cycleMethod == null) {\n            throw new NullPointerException(\"Cycle method cannot be null\");\n        }\n\n        if (colorSpace == null) {\n            throw new NullPointerException(\"Color space cannot be null\");\n        }\n\n        if (gradientTransform == null) {\n            throw new NullPointerException(\"Gradient transform cannot be \"+\n                                           \"null\");\n        }\n\n        if (fractions.length != colors.length) {\n            throw new IllegalArgumentException(\"Colors and fractions must \" +\n                                               \"have equal size\");\n        }\n\n        if (colors.length < 2) {\n            throw new IllegalArgumentException(\"User must specify at least \" +\n                                               \"2 colors\");\n        }\n\n        // check that values are in the proper range and progress\n        // in increasing order from 0 to 1\n        float previousFraction = -1.0f;\n        for (float currentFraction : fractions) {\n            if (currentFraction < 0f || currentFraction > 1f) {\n                throw new IllegalArgumentException(\"Fraction values must \" +\n                                                   \"be in the range 0 to 1: \" +\n                                                   currentFraction);\n            }\n\n            if (currentFraction <= previousFraction) {\n                throw new IllegalArgumentException(\"Keyframe fractions \" +\n                                                   \"must be increasing: \" +\n                                                   currentFraction);\n            }\n\n            previousFraction = currentFraction;\n        }\n\n        // We have to deal with the cases where the first gradient stop is not\n        // equal to 0 and/or the last gradient stop is not equal to 1.\n        // In both cases, create a new point and replicate the previous\n        // extreme point's color.\n        boolean fixFirst = false;\n        boolean fixLast = false;\n        int len = fractions.length;\n        int off = 0;\n\n        if (fractions[0] != 0f) {\n            // first stop is not equal to zero, fix this condition\n            fixFirst = true;\n            len++;\n            off++;\n        }\n        if (fractions[fractions.length-1] != 1f) {\n            // last stop is not equal to one, fix this condition\n            fixLast = true;\n            len++;\n        }\n\n        this.fractions = new float[len];\n        System.arraycopy(fractions, 0, this.fractions, off, fractions.length);\n        this.colors = new Color[len];\n        System.arraycopy(colors, 0, this.colors, off, colors.length);\n\n        if (fixFirst) {\n            this.fractions[0] = 0f;\n            this.colors[0] = colors[0];\n        }\n        if (fixLast) {\n            this.fractions[len-1] = 1f;\n            this.colors[len-1] = colors[colors.length - 1];\n        }\n\n        // copy some flags\n        this.colorSpace = colorSpace;\n        this.cycleMethod = cycleMethod;\n\n        // copy the gradient transform\n        this.gradientTransform = new AffineTransform(gradientTransform);\n\n        // determine transparency\n        boolean opaque = true;\n        for (int i = 0; i < colors.length; i++){\n            opaque = opaque && (colors[i].getAlpha() == 0xff);\n        }\n        this.transparency = opaque ? OPAQUE : TRANSLUCENT;\n    }"}
{"Number":"161","API Relative Path":"com.sun.prism.j2d.paint.MultipleGradientPaint.java-MultipleGradientPaint(float[]-Color[]-CycleMethod-ColorSpaceType-AffineTransform)","Corresponding Source":"/**\n     * Package-private constructor.\n     *\n     * @param fractions numbers ranging from 0.0 to 1.0 specifying the\n     *                  distribution of colors along the gradient\n     * @param colors array of colors corresponding to each fractional value\n     * @param cycleMethod either {@code NO_CYCLE}, {@code REFLECT},\n     *                    or {@code REPEAT}\n     * @param colorSpace which color space to use for interpolation,\n     *                   either {@code SRGB} or {@code LINEAR_RGB}\n     * @param gradientTransform transform to apply to the gradient\n     *\n     * @throws NullPointerException\n     * if {@code fractions} array is null,\n     * or {@code colors} array is null,\n     * or {@code gradientTransform} is null,\n     * or {@code cycleMethod} is null,\n     * or {@code colorSpace} is null\n     * @throws IllegalArgumentException\n     * if {@code fractions.length != colors.length},\n     * or {@code colors} is less than 2 in size,\n     * or a {@code fractions} value is less than 0.0 or greater than 1.0,\n     * or the {@code fractions} are not provided in strictly increasing order\n     */\n    MultipleGradientPaint(float[] fractions,\n                          Color[] colors,\n                          CycleMethod cycleMethod,\n                          ColorSpaceType colorSpace,\n                          AffineTransform gradientTransform)\n    {\n        if (fractions == null) {\n            throw new NullPointerException(\"Fractions array cannot be null\");\n        }\n\n        if (colors == null) {\n            throw new NullPointerException(\"Colors array cannot be null\");\n        }\n\n        if (cycleMethod == null) {\n            throw new NullPointerException(\"Cycle method cannot be null\");\n        }\n\n        if (colorSpace == null) {\n            throw new NullPointerException(\"Color space cannot be null\");\n        }\n\n        if (gradientTransform == null) {\n            throw new NullPointerException(\"Gradient transform cannot be \"+\n                                           \"null\");\n        }\n\n        if (fractions.length != colors.length) {\n            throw new IllegalArgumentException(\"Colors and fractions must \" +\n                                               \"have equal size\");\n        }\n\n        if (colors.length < 2) {\n            throw new IllegalArgumentException(\"User must specify at least \" +\n                                               \"2 colors\");\n        }\n\n        // check that values are in the proper range and progress\n        // in increasing order from 0 to 1\n        float previousFraction = -1.0f;\n        for (float currentFraction : fractions) {\n            if (currentFraction < 0f || currentFraction > 1f) {\n                throw new IllegalArgumentException(\"Fraction values must \" +\n                                                   \"be in the range 0 to 1: \" +\n                                                   currentFraction);\n            }\n\n            if (currentFraction <= previousFraction) {\n                throw new IllegalArgumentException(\"Keyframe fractions \" +\n                                                   \"must be increasing: \" +\n                                                   currentFraction);\n            }\n\n            previousFraction = currentFraction;\n        }\n\n        // We have to deal with the cases where the first gradient stop is not\n        // equal to 0 and/or the last gradient stop is not equal to 1.\n        // In both cases, create a new point and replicate the previous\n        // extreme point's color.\n        boolean fixFirst = false;\n        boolean fixLast = false;\n        int len = fractions.length;\n        int off = 0;\n\n        if (fractions[0] != 0f) {\n            // first stop is not equal to zero, fix this condition\n            fixFirst = true;\n            len++;\n            off++;\n        }\n        if (fractions[fractions.length-1] != 1f) {\n            // last stop is not equal to one, fix this condition\n            fixLast = true;\n            len++;\n        }\n\n        this.fractions = new float[len];\n        System.arraycopy(fractions, 0, this.fractions, off, fractions.length);\n        this.colors = new Color[len];\n        System.arraycopy(colors, 0, this.colors, off, colors.length);\n\n        if (fixFirst) {\n            this.fractions[0] = 0f;\n            this.colors[0] = colors[0];\n        }\n        if (fixLast) {\n            this.fractions[len-1] = 1f;\n            this.colors[len-1] = colors[colors.length - 1];\n        }\n\n        // copy some flags\n        this.colorSpace = colorSpace;\n        this.cycleMethod = cycleMethod;\n\n        // copy the gradient transform\n        this.gradientTransform = new AffineTransform(gradientTransform);\n\n        // determine transparency\n        boolean opaque = true;\n        for (int i = 0; i < colors.length; i++){\n            opaque = opaque && (colors[i].getAlpha() == 0xff);\n        }\n        this.transparency = opaque ? OPAQUE : TRANSLUCENT;\n    }"}
{"Number":"162","API Relative Path":"com.sun.prism.j2d.paint.MultipleGradientPaintContext.java-MultipleGradientPaintContext(MultipleGradientPaint-ColorModel-Rectangle-Rectangle2D-AffineTransform-RenderingHints-float[]-Color[]-CycleMethod-ColorSpaceType)","Corresponding Source":"/**\n     * Constructor for MultipleGradientPaintContext superclass.\n     */\n    protected MultipleGradientPaintContext(MultipleGradientPaint mgp,\n                                           ColorModel cm,\n                                           Rectangle deviceBounds,\n                                           Rectangle2D userBounds,\n                                           AffineTransform t,\n                                           RenderingHints hints,\n                                           float[] fractions,\n                                           Color[] colors,\n                                           CycleMethod cycleMethod,\n                                           ColorSpaceType colorSpace)\n    {\n        if (deviceBounds == null) {\n            throw new NullPointerException(\"Device bounds cannot be null\");\n        }\n\n        if (userBounds == null) {\n            throw new NullPointerException(\"User bounds cannot be null\");\n        }\n\n        if (t == null) {\n            throw new NullPointerException(\"Transform cannot be null\");\n        }\n\n        // The inverse transform is needed to go from device to user space.\n        // Get all the components of the inverse transform matrix.\n        AffineTransform tInv;\n        try {\n            // the following assumes that the caller has copied the incoming\n            // transform and is not concerned about it being modified\n            tInv = t.createInverse();\n        } catch (NoninvertibleTransformException e) {\n            // just use identity transform in this case; better to show\n            // (incorrect) results than to throw an exception and/or no-op\n            tInv = new AffineTransform();\n        }\n        double m[] = new double[6];\n        tInv.getMatrix(m);\n        a00 = (float)m[0];\n        a10 = (float)m[1];\n        a01 = (float)m[2];\n        a11 = (float)m[3];\n        a02 = (float)m[4];\n        a12 = (float)m[5];\n\n        // copy some flags\n        this.cycleMethod = cycleMethod;\n        this.colorSpace = colorSpace;\n\n        // we can avoid copying this array since we do not modify its values\n        this.fractions = fractions;\n\n        // note that only one of these values can ever be non-null (we either\n        // store the fast gradient array or the slow one, but never both\n        // at the same time)\n        this.gradient =\n            (mgp.gradient != null) ? mgp.gradient.get() : null;\n        this.gradients =\n            (mgp.gradients != null) ? mgp.gradients.get() : null;\n\n        if (gradient == null && gradients == null) {\n            // we need to (re)create the appropriate values\n            calculateLookupData(colors);\n\n            // now cache the calculated values in the\n            // MultipleGradientPaint instance for future use\n            mgp.model               = this.model;\n            mgp.normalizedIntervals = this.normalizedIntervals;\n            mgp.isSimpleLookup      = this.isSimpleLookup;\n            if (isSimpleLookup) {\n                // only cache the fast array\n                mgp.fastGradientArraySize = this.fastGradientArraySize;\n                mgp.gradient = new SoftReference<int[]>(this.gradient);\n            } else {\n                // only cache the slow array\n                mgp.gradients = new SoftReference<int[][]>(this.gradients);\n            }\n        } else {\n            // use the values cached in the MultipleGradientPaint instance\n            this.model                 = mgp.model;\n            this.normalizedIntervals   = mgp.normalizedIntervals;\n            this.isSimpleLookup        = mgp.isSimpleLookup;\n            this.fastGradientArraySize = mgp.fastGradientArraySize;\n        }\n    }"}
{"Number":"163","API Relative Path":"com.sun.prism.j2d.paint.MultipleGradientPaintContext.java-MultipleGradientPaintContext(MultipleGradientPaint-ColorModel-Rectangle-Rectangle2D-AffineTransform-RenderingHints-float[]-Color[]-CycleMethod-ColorSpaceType)","Corresponding Source":"/**\n     * Constructor for MultipleGradientPaintContext superclass.\n     */\n    protected MultipleGradientPaintContext(MultipleGradientPaint mgp,\n                                           ColorModel cm,\n                                           Rectangle deviceBounds,\n                                           Rectangle2D userBounds,\n                                           AffineTransform t,\n                                           RenderingHints hints,\n                                           float[] fractions,\n                                           Color[] colors,\n                                           CycleMethod cycleMethod,\n                                           ColorSpaceType colorSpace)\n    {\n        if (deviceBounds == null) {\n            throw new NullPointerException(\"Device bounds cannot be null\");\n        }\n\n        if (userBounds == null) {\n            throw new NullPointerException(\"User bounds cannot be null\");\n        }\n\n        if (t == null) {\n            throw new NullPointerException(\"Transform cannot be null\");\n        }\n\n        // The inverse transform is needed to go from device to user space.\n        // Get all the components of the inverse transform matrix.\n        AffineTransform tInv;\n        try {\n            // the following assumes that the caller has copied the incoming\n            // transform and is not concerned about it being modified\n            tInv = t.createInverse();\n        } catch (NoninvertibleTransformException e) {\n            // just use identity transform in this case; better to show\n            // (incorrect) results than to throw an exception and/or no-op\n            tInv = new AffineTransform();\n        }\n        double m[] = new double[6];\n        tInv.getMatrix(m);\n        a00 = (float)m[0];\n        a10 = (float)m[1];\n        a01 = (float)m[2];\n        a11 = (float)m[3];\n        a02 = (float)m[4];\n        a12 = (float)m[5];\n\n        // copy some flags\n        this.cycleMethod = cycleMethod;\n        this.colorSpace = colorSpace;\n\n        // we can avoid copying this array since we do not modify its values\n        this.fractions = fractions;\n\n        // note that only one of these values can ever be non-null (we either\n        // store the fast gradient array or the slow one, but never both\n        // at the same time)\n        this.gradient =\n            (mgp.gradient != null) ? mgp.gradient.get() : null;\n        this.gradients =\n            (mgp.gradients != null) ? mgp.gradients.get() : null;\n\n        if (gradient == null && gradients == null) {\n            // we need to (re)create the appropriate values\n            calculateLookupData(colors);\n\n            // now cache the calculated values in the\n            // MultipleGradientPaint instance for future use\n            mgp.model               = this.model;\n            mgp.normalizedIntervals = this.normalizedIntervals;\n            mgp.isSimpleLookup      = this.isSimpleLookup;\n            if (isSimpleLookup) {\n                // only cache the fast array\n                mgp.fastGradientArraySize = this.fastGradientArraySize;\n                mgp.gradient = new SoftReference<int[]>(this.gradient);\n            } else {\n                // only cache the slow array\n                mgp.gradients = new SoftReference<int[][]>(this.gradients);\n            }\n        } else {\n            // use the values cached in the MultipleGradientPaint instance\n            this.model                 = mgp.model;\n            this.normalizedIntervals   = mgp.normalizedIntervals;\n            this.isSimpleLookup        = mgp.isSimpleLookup;\n            this.fastGradientArraySize = mgp.fastGradientArraySize;\n        }\n    }"}
{"Number":"164","API Relative Path":"com.sun.prism.j2d.paint.MultipleGradientPaintContext.java-MultipleGradientPaintContext(MultipleGradientPaint-ColorModel-Rectangle-Rectangle2D-AffineTransform-RenderingHints-float[]-Color[]-CycleMethod-ColorSpaceType)","Corresponding Source":"/**\n     * Constructor for MultipleGradientPaintContext superclass.\n     */\n    protected MultipleGradientPaintContext(MultipleGradientPaint mgp,\n                                           ColorModel cm,\n                                           Rectangle deviceBounds,\n                                           Rectangle2D userBounds,\n                                           AffineTransform t,\n                                           RenderingHints hints,\n                                           float[] fractions,\n                                           Color[] colors,\n                                           CycleMethod cycleMethod,\n                                           ColorSpaceType colorSpace)\n    {\n        if (deviceBounds == null) {\n            throw new NullPointerException(\"Device bounds cannot be null\");\n        }\n\n        if (userBounds == null) {\n            throw new NullPointerException(\"User bounds cannot be null\");\n        }\n\n        if (t == null) {\n            throw new NullPointerException(\"Transform cannot be null\");\n        }\n\n        // The inverse transform is needed to go from device to user space.\n        // Get all the components of the inverse transform matrix.\n        AffineTransform tInv;\n        try {\n            // the following assumes that the caller has copied the incoming\n            // transform and is not concerned about it being modified\n            tInv = t.createInverse();\n        } catch (NoninvertibleTransformException e) {\n            // just use identity transform in this case; better to show\n            // (incorrect) results than to throw an exception and/or no-op\n            tInv = new AffineTransform();\n        }\n        double m[] = new double[6];\n        tInv.getMatrix(m);\n        a00 = (float)m[0];\n        a10 = (float)m[1];\n        a01 = (float)m[2];\n        a11 = (float)m[3];\n        a02 = (float)m[4];\n        a12 = (float)m[5];\n\n        // copy some flags\n        this.cycleMethod = cycleMethod;\n        this.colorSpace = colorSpace;\n\n        // we can avoid copying this array since we do not modify its values\n        this.fractions = fractions;\n\n        // note that only one of these values can ever be non-null (we either\n        // store the fast gradient array or the slow one, but never both\n        // at the same time)\n        this.gradient =\n            (mgp.gradient != null) ? mgp.gradient.get() : null;\n        this.gradients =\n            (mgp.gradients != null) ? mgp.gradients.get() : null;\n\n        if (gradient == null && gradients == null) {\n            // we need to (re)create the appropriate values\n            calculateLookupData(colors);\n\n            // now cache the calculated values in the\n            // MultipleGradientPaint instance for future use\n            mgp.model               = this.model;\n            mgp.normalizedIntervals = this.normalizedIntervals;\n            mgp.isSimpleLookup      = this.isSimpleLookup;\n            if (isSimpleLookup) {\n                // only cache the fast array\n                mgp.fastGradientArraySize = this.fastGradientArraySize;\n                mgp.gradient = new SoftReference<int[]>(this.gradient);\n            } else {\n                // only cache the slow array\n                mgp.gradients = new SoftReference<int[][]>(this.gradients);\n            }\n        } else {\n            // use the values cached in the MultipleGradientPaint instance\n            this.model                 = mgp.model;\n            this.normalizedIntervals   = mgp.normalizedIntervals;\n            this.isSimpleLookup        = mgp.isSimpleLookup;\n            this.fastGradientArraySize = mgp.fastGradientArraySize;\n        }\n    }"}
{"Number":"165","API Relative Path":"com.sun.prism.j2d.paint.RadialGradientPaint.java-RadialGradientPaint(Point2D-float-Point2D-float[]-Color[]-CycleMethod-ColorSpaceType-AffineTransform)","Corresponding Source":"/**\n     * Constructs a {@code RadialGradientPaint}.\n     *\n     * @param center the center point in user space of the circle defining the\n     *               gradient.  The last color of the gradient is mapped to\n     *               the perimeter of this circle.\n     * @param radius the radius of the circle defining the extents of the\n     *               color gradient\n     * @param focus the point in user space to which the first color is mapped\n     * @param fractions numbers ranging from 0.0 to 1.0 specifying the\n     *                  distribution of colors along the gradient\n     * @param colors array of colors to use in the gradient.  The first color\n     *               is used at the focus point, the last color around the\n     *               perimeter of the circle.\n     * @param cycleMethod either {@code NO_CYCLE}, {@code REFLECT},\n     *                    or {@code REPEAT}\n     * @param colorSpace which color space to use for interpolation,\n     *                   either {@code SRGB} or {@code LINEAR_RGB}\n     * @param gradientTransform transform to apply to the gradient\n     *\n     * @throws NullPointerException\n     * if one of the points is null,\n     * or {@code fractions} array is null,\n     * or {@code colors} array is null,\n     * or {@code cycleMethod} is null,\n     * or {@code colorSpace} is null,\n     * or {@code gradientTransform} is null\n     * @throws IllegalArgumentException\n     * if {@code radius} is non-positive,\n     * or {@code fractions.length != colors.length},\n     * or {@code colors} is less than 2 in size,\n     * or a {@code fractions} value is less than 0.0 or greater than 1.0,\n     * or the {@code fractions} are not provided in strictly increasing order\n     */\n    public RadialGradientPaint(Point2D center,\n                               float radius,\n                               Point2D focus,\n                               float[] fractions, Color[] colors,\n                               CycleMethod cycleMethod,\n                               ColorSpaceType colorSpace,\n                               AffineTransform gradientTransform)\n    {\n        super(fractions, colors, cycleMethod, colorSpace, gradientTransform);\n\n        // check input arguments\n        if (center == null) {\n            throw new NullPointerException(\"Center point must be non-null\");\n        }\n\n        if (focus == null) {\n            throw new NullPointerException(\"Focus point must be non-null\");\n        }\n\n        if (radius < 0) {\n            throw new IllegalArgumentException(\"Radius must be non-negative\");\n        }\n\n        // copy parameters\n        this.center = new Point2D.Double(center.getX(), center.getY());\n        this.focus = new Point2D.Double(focus.getX(), focus.getY());\n        this.radius = radius;\n    }"}
{"Number":"166","API Relative Path":"com.sun.prism.j2d.paint.RadialGradientPaint.java-RadialGradientPaint(Point2D-float-Point2D-float[]-Color[]-CycleMethod-ColorSpaceType-AffineTransform)","Corresponding Source":"/**\n     * Constructs a {@code RadialGradientPaint}.\n     *\n     * @param center the center point in user space of the circle defining the\n     *               gradient.  The last color of the gradient is mapped to\n     *               the perimeter of this circle.\n     * @param radius the radius of the circle defining the extents of the\n     *               color gradient\n     * @param focus the point in user space to which the first color is mapped\n     * @param fractions numbers ranging from 0.0 to 1.0 specifying the\n     *                  distribution of colors along the gradient\n     * @param colors array of colors to use in the gradient.  The first color\n     *               is used at the focus point, the last color around the\n     *               perimeter of the circle.\n     * @param cycleMethod either {@code NO_CYCLE}, {@code REFLECT},\n     *                    or {@code REPEAT}\n     * @param colorSpace which color space to use for interpolation,\n     *                   either {@code SRGB} or {@code LINEAR_RGB}\n     * @param gradientTransform transform to apply to the gradient\n     *\n     * @throws NullPointerException\n     * if one of the points is null,\n     * or {@code fractions} array is null,\n     * or {@code colors} array is null,\n     * or {@code cycleMethod} is null,\n     * or {@code colorSpace} is null,\n     * or {@code gradientTransform} is null\n     * @throws IllegalArgumentException\n     * if {@code radius} is non-positive,\n     * or {@code fractions.length != colors.length},\n     * or {@code colors} is less than 2 in size,\n     * or a {@code fractions} value is less than 0.0 or greater than 1.0,\n     * or the {@code fractions} are not provided in strictly increasing order\n     */\n    public RadialGradientPaint(Point2D center,\n                               float radius,\n                               Point2D focus,\n                               float[] fractions, Color[] colors,\n                               CycleMethod cycleMethod,\n                               ColorSpaceType colorSpace,\n                               AffineTransform gradientTransform)\n    {\n        super(fractions, colors, cycleMethod, colorSpace, gradientTransform);\n\n        // check input arguments\n        if (center == null) {\n            throw new NullPointerException(\"Center point must be non-null\");\n        }\n\n        if (focus == null) {\n            throw new NullPointerException(\"Focus point must be non-null\");\n        }\n\n        if (radius < 0) {\n            throw new IllegalArgumentException(\"Radius must be non-negative\");\n        }\n\n        // copy parameters\n        this.center = new Point2D.Double(center.getX(), center.getY());\n        this.focus = new Point2D.Double(focus.getX(), focus.getY());\n        this.radius = radius;\n    }"}
{"Number":"167","API Relative Path":"com.sun.prism.j2d.paint.RadialGradientPaint.java-RadialGradientPaint(Point2D-float-Point2D-float[]-Color[]-CycleMethod-ColorSpaceType-AffineTransform)","Corresponding Source":"/**\n     * Constructs a {@code RadialGradientPaint}.\n     *\n     * @param center the center point in user space of the circle defining the\n     *               gradient.  The last color of the gradient is mapped to\n     *               the perimeter of this circle.\n     * @param radius the radius of the circle defining the extents of the\n     *               color gradient\n     * @param focus the point in user space to which the first color is mapped\n     * @param fractions numbers ranging from 0.0 to 1.0 specifying the\n     *                  distribution of colors along the gradient\n     * @param colors array of colors to use in the gradient.  The first color\n     *               is used at the focus point, the last color around the\n     *               perimeter of the circle.\n     * @param cycleMethod either {@code NO_CYCLE}, {@code REFLECT},\n     *                    or {@code REPEAT}\n     * @param colorSpace which color space to use for interpolation,\n     *                   either {@code SRGB} or {@code LINEAR_RGB}\n     * @param gradientTransform transform to apply to the gradient\n     *\n     * @throws NullPointerException\n     * if one of the points is null,\n     * or {@code fractions} array is null,\n     * or {@code colors} array is null,\n     * or {@code cycleMethod} is null,\n     * or {@code colorSpace} is null,\n     * or {@code gradientTransform} is null\n     * @throws IllegalArgumentException\n     * if {@code radius} is non-positive,\n     * or {@code fractions.length != colors.length},\n     * or {@code colors} is less than 2 in size,\n     * or a {@code fractions} value is less than 0.0 or greater than 1.0,\n     * or the {@code fractions} are not provided in strictly increasing order\n     */\n    public RadialGradientPaint(Point2D center,\n                               float radius,\n                               Point2D focus,\n                               float[] fractions, Color[] colors,\n                               CycleMethod cycleMethod,\n                               ColorSpaceType colorSpace,\n                               AffineTransform gradientTransform)\n    {\n        super(fractions, colors, cycleMethod, colorSpace, gradientTransform);\n\n        // check input arguments\n        if (center == null) {\n            throw new NullPointerException(\"Center point must be non-null\");\n        }\n\n        if (focus == null) {\n            throw new NullPointerException(\"Focus point must be non-null\");\n        }\n\n        if (radius < 0) {\n            throw new IllegalArgumentException(\"Radius must be non-negative\");\n        }\n\n        // copy parameters\n        this.center = new Point2D.Double(center.getX(), center.getY());\n        this.focus = new Point2D.Double(focus.getX(), focus.getY());\n        this.radius = radius;\n    }"}
{"Number":"168","API Relative Path":"com.sun.scenario.animation.SplineInterpolator.java-curve(double)","Corresponding Source":"/**\n     * Returns the y-value of the cubic bezier curve that corresponds to the x\n     * input.\n     *\n     * @param x\n     *            is x-value of cubic bezier curve, in range [0,1]\n     * @return corresponding y-value of cubic bezier curve -- in range [0,1]\n     */\n    @Override\n    public double curve(double x) {\n        // check user input for precondition\n        if (x < 0 || x > 1) {\n            throw new IllegalArgumentException(\"x must be in range [0,1]\");\n        }\n\n        // check quick exit identity cases (linear curve or curve endpoints)\n        if (isCurveLinear || x == 0 || x == 1) {\n            return x;\n        }\n\n        // find the t parameter for a given x value, and use this t to calculate\n        // the corresponding y value\n        return eval(findTForX(x), y1, y2);\n    }"}
{"Number":"169","API Relative Path":"com.sun.scenario.animation.SplineInterpolator.java-SplineInterpolator(double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance with control points (0,0) (px1,py1) (px2,py2)\n     * (1,1) -- px1, py1, px2, py2 all in range [0,1].\n     *\n     * @param px1\n     *            X coordinate of first control point, in range [0,1]\n     * @param py1\n     *            Y coordinate of first control point, in range [0,1]\n     * @param px2\n     *            X coordinate of second control point, in range [0,1]\n     * @param py2\n     *            Y coordinate of second control point, in range [0,1]\n     */\n    public SplineInterpolator(double px1, double py1, double px2, double py2) {\n        // check user input for precondition\n        if (px1 < 0 || px1 > 1 || py1 < 0 || py1 > 1 || px2 < 0 || px2 > 1\n                || py2 < 0 || py2 > 1) {\n            throw new IllegalArgumentException(\n                    \"Control point coordinates must \" + \"all be in range [0,1]\");\n        }\n\n        // save control point data\n        this.x1 = px1;\n        this.y1 = py1;\n        this.x2 = px2;\n        this.y2 = py2;\n\n        // calc linearity/identity curve\n        isCurveLinear = ((x1 == y1) && (x2 == y2));\n\n        // make the array of x value samples\n        if (!isCurveLinear) {\n            for (int i = 0; i < SAMPLE_SIZE + 1; ++i) {\n                xSamples[i] = eval(i * SAMPLE_INCREMENT, x1, x2);\n            }\n        }\n    }"}
{"Number":"170","API Relative Path":"com.sun.scenario.effect.BoxBlur.java-BoxBlur(int-int-int-Effect)","Corresponding Source":"/**\n     * Constructs a new {@code BoxBlur} effect with\n     * the given blur sizes\n     * and number of passes,\n     * using the output of the specified effect for source data.\n     *\n     * @param hsize the horizontal size of the BoxBlur kernel\n     * @param vsize the vertical size of the BoxBlur kernel\n     * @param passes the number of blur passes to execute\n     * @param input the single input {@code Effect}\n     * @throws IllegalArgumentException if either {@code hsize}\n     * or {@code vsize} or {@code passes}\n     * is outside the allowable range\n     */\n    public BoxBlur(int hsize, int vsize, int passes, Effect input) {\n        super(input);\n        setHorizontalSize(hsize);\n        setVerticalSize(vsize);\n        setPasses(passes);\n    }"}
{"Number":"171","API Relative Path":"com.sun.scenario.effect.BoxBlur.java-BoxBlur(int-int-int-Effect)","Corresponding Source":"/**\n     * Constructs a new {@code BoxBlur} effect with\n     * the given blur sizes\n     * and number of passes,\n     * using the output of the specified effect for source data.\n     *\n     * @param hsize the horizontal size of the BoxBlur kernel\n     * @param vsize the vertical size of the BoxBlur kernel\n     * @param passes the number of blur passes to execute\n     * @param input the single input {@code Effect}\n     * @throws IllegalArgumentException if either {@code hsize}\n     * or {@code vsize} or {@code passes}\n     * is outside the allowable range\n     */\n    public BoxBlur(int hsize, int vsize, int passes, Effect input) {\n        super(input);\n        setHorizontalSize(hsize);\n        setVerticalSize(vsize);\n        setPasses(passes);\n    }"}
{"Number":"172","API Relative Path":"com.sun.scenario.effect.BoxBlur.java-BoxBlur(int-int-int-Effect)","Corresponding Source":"/**\n     * Constructs a new {@code BoxBlur} effect with\n     * the given blur sizes\n     * and number of passes,\n     * using the output of the specified effect for source data.\n     *\n     * @param hsize the horizontal size of the BoxBlur kernel\n     * @param vsize the vertical size of the BoxBlur kernel\n     * @param passes the number of blur passes to execute\n     * @param input the single input {@code Effect}\n     * @throws IllegalArgumentException if either {@code hsize}\n     * or {@code vsize} or {@code passes}\n     * is outside the allowable range\n     */\n    public BoxBlur(int hsize, int vsize, int passes, Effect input) {\n        super(input);\n        setHorizontalSize(hsize);\n        setVerticalSize(vsize);\n        setPasses(passes);\n    }"}
{"Number":"173","API Relative Path":"com.sun.scenario.effect.BoxBlur.java-setHorizontalSize(int)","Corresponding Source":"/**\n     * Sets the horizontal size of the effect kernel.\n     * <pre>\n     *       Min:   0\n     *       Max: 255\n     *   Default:   1\n     *  Identity:   0\n     * <\/pre>\n     *\n     * @param hsize the horizontal size of the effect kernel\n     * @throws IllegalArgumentException if {@code hsize}\n     * is outside the allowable range\n     */\n    public final void setHorizontalSize(int hsize) {\n        state.setHsize(hsize);\n    }"}
{"Number":"174","API Relative Path":"com.sun.scenario.effect.BoxBlur.java-setPasses(int)","Corresponding Source":"/**\n     * Sets the number of passes of the effect kernel to control the\n     * quality of the blur.\n     * <pre>\n     *       Min:   0\n     *       Max:   3\n     *   Default:   1\n     *  Identity:   0\n     * <\/pre>\n     * A setting of 1 creates a low quality blur.  A setting of 3 creates\n     * a blur that is very close to a Gaussian blur.\n     *\n     * @param passes\n     * @throws IllegalArgumentException if {@code passes} is outside the\n     * allowable range\n     */\n    public final void setPasses(int passes) {\n        state.setBlurPasses(passes);\n    }"}
{"Number":"175","API Relative Path":"com.sun.scenario.effect.BoxBlur.java-setVerticalSize(int)","Corresponding Source":"/**\n     * Sets the vertical size of the effect kernel.\n     * <pre>\n     *       Min:   0\n     *       Max: 255\n     *   Default:   1\n     *  Identity:   0\n     * <\/pre>\n     *\n     * @param vsize the vertical size of the effect kernel\n     * @throws IllegalArgumentException if {@code vsize}\n     * is outside the allowable range\n     */\n    public final void setVerticalSize(int vsize) {\n        state.setVsize(vsize);\n    }"}
{"Number":"176","API Relative Path":"com.sun.scenario.effect.BoxShadow.java-BoxShadow(int-int-int-Effect)","Corresponding Source":"/**\n     * Constructs a new {@code BoxShadow} effect with\n     * the given blur sizes\n     * and number of passes,\n     * using the output of the specified effect for source data.\n     *\n     * @param hsize the horizontal size of the BoxShadow kernel\n     * @param vsize the vertical size of the BoxShadow kernel\n     * @param passes the number of blur passes to execute\n     * @param input the single input {@code Effect}\n     * @throws IllegalArgumentException if either {@code hsize}\n     * or {@code vsize} or {@code passes}\n     * is outside the allowable range\n     */\n    public BoxShadow(int hsize, int vsize, int passes, Effect input) {\n        super(input);\n        setHorizontalSize(hsize);\n        setVerticalSize(vsize);\n        setPasses(passes);\n        setColor(Color4f.BLACK);\n        setSpread(0f);\n    }"}
{"Number":"177","API Relative Path":"com.sun.scenario.effect.BoxShadow.java-BoxShadow(int-int-int-Effect)","Corresponding Source":"/**\n     * Constructs a new {@code BoxShadow} effect with\n     * the given blur sizes\n     * and number of passes,\n     * using the output of the specified effect for source data.\n     *\n     * @param hsize the horizontal size of the BoxShadow kernel\n     * @param vsize the vertical size of the BoxShadow kernel\n     * @param passes the number of blur passes to execute\n     * @param input the single input {@code Effect}\n     * @throws IllegalArgumentException if either {@code hsize}\n     * or {@code vsize} or {@code passes}\n     * is outside the allowable range\n     */\n    public BoxShadow(int hsize, int vsize, int passes, Effect input) {\n        super(input);\n        setHorizontalSize(hsize);\n        setVerticalSize(vsize);\n        setPasses(passes);\n        setColor(Color4f.BLACK);\n        setSpread(0f);\n    }"}
{"Number":"178","API Relative Path":"com.sun.scenario.effect.BoxShadow.java-BoxShadow(int-int-int-Effect)","Corresponding Source":"/**\n     * Constructs a new {@code BoxShadow} effect with\n     * the given blur sizes\n     * and number of passes,\n     * using the output of the specified effect for source data.\n     *\n     * @param hsize the horizontal size of the BoxShadow kernel\n     * @param vsize the vertical size of the BoxShadow kernel\n     * @param passes the number of blur passes to execute\n     * @param input the single input {@code Effect}\n     * @throws IllegalArgumentException if either {@code hsize}\n     * or {@code vsize} or {@code passes}\n     * is outside the allowable range\n     */\n    public BoxShadow(int hsize, int vsize, int passes, Effect input) {\n        super(input);\n        setHorizontalSize(hsize);\n        setVerticalSize(vsize);\n        setPasses(passes);\n        setColor(Color4f.BLACK);\n        setSpread(0f);\n    }"}
{"Number":"179","API Relative Path":"com.sun.scenario.effect.BoxShadow.java-setHorizontalSize(int)","Corresponding Source":"/**\n     * Sets the horizontal size of the effect kernel.\n     * <pre>\n     *       Min:   0\n     *       Max: 255\n     *   Default:   1\n     *  Identity:   0\n     * <\/pre>\n     *\n     * @param hsize the horizontal size of the effect kernel\n     * @throws IllegalArgumentException if {@code hsize}\n     * is outside the allowable range\n     */\n    public final void setHorizontalSize(int hsize) {\n        state.setHsize(hsize);\n    }"}
{"Number":"180","API Relative Path":"com.sun.scenario.effect.BoxShadow.java-setPasses(int)","Corresponding Source":"/**\n     * Sets the number of passes of the effect kernel to control the\n     * quality of the blur.\n     * <pre>\n     *       Min:   0\n     *       Max:   3\n     *   Default:   1\n     *  Identity:   0\n     * <\/pre>\n     * A setting of 1 creates a low quality blur.  A setting of 3 creates\n     * a blur that is very close to a Gaussian blur.\n     *\n     * @param passes\n     * @throws IllegalArgumentException if {@code passes} is outside the\n     * allowable range\n     */\n    public final void setPasses(int passes) {\n        state.setBlurPasses(passes);\n    }"}
{"Number":"181","API Relative Path":"com.sun.scenario.effect.BoxShadow.java-setVerticalSize(int)","Corresponding Source":"/**\n     * Sets the vertical size of the effect kernel.\n     * <pre>\n     *       Min:   0\n     *       Max: 255\n     *   Default:   1\n     *  Identity:   0\n     * <\/pre>\n     *\n     * @param vsize the vertical size of the effect kernel\n     * @throws IllegalArgumentException if {@code vsize}\n     * is outside the allowable range\n     */\n    public final void setVerticalSize(int vsize) {\n        state.setVsize(vsize);\n    }"}
{"Number":"182","API Relative Path":"com.sun.scenario.effect.Effect.java-createCompatibleImage(FilterContext-int-int)","Corresponding Source":"/**\n     * Returns a new image that is most compatible with the\n     * given {@code FilterContext}.  This method will select the image\n     * type that is most appropriate for use with the current rendering\n     * pipeline, graphics hardware, and screen pixel layout.\n     * The image will be cleared prior to being returned.\n     *\n     * This method may return {@code null} if the image can't be created so\n     * callers have to check for return value.\n     *\n     * @param fctx the {@code FilterContext} for the target screen device\n     * @param w the width of the image\n     * @param h the height of the image\n     * @return a new image with the given dimensions, or null if one\n     * can't be created\n     * @throws IllegalArgumentException if {@code gc} is null, or if\n     * either {@code w} or {@code h} is non-positive\n     */\n    public static Filterable createCompatibleImage(FilterContext fctx, int w, int h) {\n        return Renderer.getRenderer(fctx).createCompatibleImage(w, h);\n    }"}
{"Number":"183","API Relative Path":"com.sun.scenario.effect.Effect.java-getCompatibleImage(FilterContext-int-int)","Corresponding Source":"/**\n     * Returns an image that is most compatible with the\n     * given {@code FilterContext}.  This method will select the image\n     * type that is most appropriate for use with the current rendering\n     * pipeline, graphics hardware, and screen pixel layout.\n     * The image will be cleared prior to being returned.\n     * <p>\n     * Note that the framework attempts to pool images for recycling purposes\n     * whenever possible.  Therefore, when finished using an image returned\n     * by this method, it is highly recommended that you\n     * {@link #releaseCompatibleImage release} the image back to the\n     * shared pool for others to use.\n     *\n     * This method may return {@code null} if the image can't be created so\n     * callers have to check for return value.\n     *\n     * @param fctx the {@code FilterContext} for the target screen device\n     * @param w the width of the image\n     * @param h the height of the image\n     * @return an image with the given dimensions or null if one can't\n     * be created\n     * @throws IllegalArgumentException if {@code gc} is null, or if\n     * either {@code w} or {@code h} is non-positive\n     * @see #releaseCompatibleImage\n     */\n    public static Filterable getCompatibleImage(FilterContext fctx, int w, int h) {\n        return Renderer.getRenderer(fctx).getCompatibleImage(w, h);\n    }"}
{"Number":"184","API Relative Path":"com.sun.scenario.effect.Effect.java-releaseCompatibleImage(FilterContext-Filterable)","Corresponding Source":"/**\n     * Releases an image created by the\n     * {@link #getCompatibleImage getCompatibleImage()} method\n     * back into the shared pool.\n     *\n     * @param fctx the {@code FilterContext} for the target screen device\n     * @param image the image to be released\n     * @see #getCompatibleImage\n     */\n    public static void releaseCompatibleImage(FilterContext fctx, Filterable image) {\n        Renderer.getRenderer(fctx).releaseCompatibleImage(image);\n    }"}
{"Number":"185","API Relative Path":"com.sun.scenario.effect.Effect.java-setInput(int-Effect)","Corresponding Source":"/**\n     * Sets the indexed input for this {@code Effect} to a specific\n     * {@code Effect} or to the default input if {@code input} is\n     * {@code null}.\n     *\n     * @param index the index of the input {@code Effect}\n     * @param input the input {@code Effect}\n     * @throws IllegalArgumentException if {@code index} is less than\n     * zero or greater than or equal to the number of inputs specified\n     * at construction time\n     */\n    protected void setInput(int index, Effect input) {\n        if (index < 0 || index >= maxInputs) {\n            throw new IllegalArgumentException(\"Index must be within allowable range\");\n        }\n\n        if (index < inputs.size()) {\n            inputs.set(index, input);\n        } else {\n            inputs.add(input);\n        }\n    }"}
{"Number":"186","API Relative Path":"com.sun.scenario.effect.FloatMap.java-FloatMap(int-int)","Corresponding Source":"/**\n     * Constructs a new {@code FloatMap} of the given width and height.\n     *\n     * @param width the width of the map, in pixels\n     * @param height the height of the map, in pixels\n     * @throws IllegalArgumentException if either {@code width} or\n     * {@code height} is outside the range [1, 4096]\n     */\n    public FloatMap(int width, int height) {\n        if (width <= 0 || width > 4096 || height <= 0 || height > 4096) {\n            throw new IllegalArgumentException(\"Width and height must be in the range [1, 4096]\");\n        }\n        this.width = width;\n        this.height = height;\n        int size = width * height * 4;\n        // We allocate a heap-based (indirect) FloatBuffer here because\n        // some Decora backends aren't yet prepared to deal with direct\n        // FloatBuffers (and to that end we've exposed the getData() method,\n        // whose return value is float[]).  Note that we use wrap() instead of\n        // allocate() since the latter is not supported on CDC (specifically\n        // the NIO subset from JSR 239).  The byte order of the FloatBuffer\n        // will be the native order of the underlying hardware, which is what\n        // the various Decora backends expect.\n        this.buf = FloatBuffer.wrap(new float[size]);\n    }"}
{"Number":"187","API Relative Path":"com.sun.scenario.effect.ImageData.java-validate(FilterContext)","Corresponding Source":"/**\n     * Validates this image data for the use with the passed\n     * {@link FilterContext}.\n     *\n     * @param fctx context to validate against\n     * @return {@code true} if this object is valid and compatible with\n     * the passed {@code FilterContext}, {@code false} otherwise.\n     */\n    public boolean validate(FilterContext fctx) {\n        return image != null &&\n               Renderer.getRenderer(fctx).isImageDataCompatible(this);\n    }"}
{"Number":"188","API Relative Path":"com.sun.scenario.effect.impl.Renderer.java-getRenderer(FilterContext)","Corresponding Source":"/**\n     * Returns a renderer associated with given filter context based on the\n     * environment and flags set.\n     *\n     * Renderers are per filter context cached.\n     *\n     * @param fctx context to create the renderer for\n     * @return renderer\n     */\n    public static synchronized Renderer getRenderer(FilterContext fctx) {\n        if (fctx == null) {\n            throw new IllegalArgumentException(\"FilterContext must be non-null\");\n        }\n\n        Renderer r = rendererMap.get(fctx);\n        if (r != null) {\n            if (r.getRendererState() == RendererState.OK) {\n                return r;\n            }\n            if (r.getRendererState() == RendererState.LOST) {\n                // use the backup while the renderer is in lost state, until\n                // it is disposed (or forever if it can't be disposed/reset)\n                // Note: we don't add it to the cache to prevent permanent\n                // association of the backup renderer and this filter context.\n                return r.getBackupRenderer();\n            }\n            if (r.getRendererState() == RendererState.DISPOSED) {\n                r = null;\n                // we remove disposed renderers below instead of here to cover\n                // cases where we never use a context which the disposed\n                // renderer is associated with\n            }\n        }\n\n        if (r == null) {\n            // clean up all disposed renderers first\n            Collection<Renderer> renderers = rendererMap.values();\n            for (Iterator<Renderer> iter = renderers.iterator(); iter.hasNext();)\n            {\n                Renderer ren = iter.next();\n                if (ren.getRendererState() == RendererState.DISPOSED) {\n                    ren.imagePool.dispose();\n                    iter.remove();\n                }\n            }\n\n            r = RendererFactory.createRenderer(fctx);\n            if (r == null) {\n                throw new RuntimeException(\"Error creating a Renderer\");\n            } else {\n                if (verbose) {\n                    String klassName = r.getClass().getName();\n                    String rname = klassName.substring(klassName.lastIndexOf(\".\")+1);\n                    Object screen = fctx.getReferent();\n                    System.out.println(\"Created \" + rname +\n                        \" (AccelType=\" + r.getAccelType() +\n                        \") for \" + screen);\n                }\n            }\n            rendererMap.put(fctx, r);\n        }\n        return r;\n    }"}
{"Number":"189","API Relative Path":"com.sun.scenario.effect.light.Light.java-Light(Type-Color4f)","Corresponding Source":"/**\n     * Package-private constructor.\n     *\n     * @param type the type of the light\n     * @param color the color of the light\n     * @throws IllegalArgumentException if {@code color} is null\n     */\n    Light(Type type, Color4f color) {\n        if (type == null) {\n            throw new InternalError(\"Light type must be non-null\");\n        }\n        this.type = type;\n        setColor(color);\n    }"}
{"Number":"190","API Relative Path":"com.sun.scenario.effect.light.SpotLight.java-setSpecularExponent(float)","Corresponding Source":"/**\n     * Sets the specular exponent, which controls the focus of this\n     * light source.\n     * <pre>\n     *       Min: 0.0\n     *       Max: 4.0\n     *   Default: 1.0\n     *  Identity: 1.0\n     * <\/pre>\n     *\n     * @param specularExponent the specular exponent of this light\n     */\n    public void setSpecularExponent(float specularExponent) {\n        if (specularExponent < 0f || specularExponent > 4f) {\n            throw new IllegalArgumentException(\"Specular exponent must be in the range [0,4]\");\n        }\n        this.specularExponent = specularExponent;\n    }"}
{"Number":"191","API Relative Path":"com.sun.scenario.effect.ZoomRadialBlur.java-setRadius(int)","Corresponding Source":"/**\n     * Sets the radius of the effect kernel.\n     * <pre>\n     *       Min:   1\n     *       Max:  64\n     *   Default:   1\n     *  Identity: n/a\n     * <\/pre>\n     *\n     * @param radius the radius of the effect kernel\n     * @throws IllegalArgumentException if {@code radius} is outside the\n     * allowable range\n     */\n    public void setRadius(int radius) {\n        if (radius < 1 || radius > 64) {\n            throw new IllegalArgumentException(\"Radius must be in the range [1,64]\");\n        }\n        int old = this.r;\n        this.r = radius;\n        state.invalidateDeltas();\n        updatePeer();\n    }"}
{"Number":"192","API Relative Path":"com.sun.scenario.effect.ZoomRadialBlur.java-ZoomRadialBlur(int-Effect)","Corresponding Source":"/**\n     * Constructs a new {@code ZoomRadialBlur} effect with the given radius.\n     *\n     * @param radius of ZoomRadialBlur\n     * @param input the single input {@code Effect}\n     * @throws IllegalArgumentException if {@code radius} is outside the\n     * allowable range\n     */\n    public ZoomRadialBlur(int radius, Effect input) {\n        super(input);\n        setRadius(radius);\n    }"}
{"Number":"193","API Relative Path":"com.sun.scenario.Settings.java-get(String)","Corresponding Source":"/**\n     * Retrieve the value for the given key.\n     *\n     * If the key is not present in Settings or its value is null, this methods\n     * then checks to see if a value for this key is present in the System\n     * Properties (provided you have sufficient privileges).\n     *\n     * If no value can be found for the given key, this method returns null.\n     *\n     * If key is \"\" or null, this methods throws an IllegalArgumentException.\n     */\n    public static String get(String key) {\n        return getInstance().getImpl(key);\n    }"}
{"Number":"194","API Relative Path":"com.sun.scenario.Settings.java-get(String)","Corresponding Source":"/**\n     * Retrieve the value for the given key.\n     *\n     * If the key is not present in Settings or its value is null, this methods\n     * then checks to see if a value for this key is present in the System\n     * Properties (provided you have sufficient privileges).\n     *\n     * If no value can be found for the given key, this method returns null.\n     *\n     * If key is \"\" or null, this methods throws an IllegalArgumentException.\n     */\n    public static String get(String key) {\n        return getInstance().getImpl(key);\n    }"}
{"Number":"195","API Relative Path":"com.sun.scenario.Settings.java-getBoolean(String)","Corresponding Source":"/**\n     * Convenience method for boolean settings.\n     *\n     * If the setting exists and its value is \"true\", true is returned.\n     * Otherwise, false is returned.\n     *\n     * If key is \"\" or null, this methods throws an IllegalArgumentException.\n     */\n    public static boolean getBoolean(String key) {\n        return getInstance().getBooleanImpl(key);\n    }"}
{"Number":"196","API Relative Path":"com.sun.scenario.Settings.java-getBoolean(String)","Corresponding Source":"/**\n     * Convenience method for boolean settings.\n     *\n     * If the setting exists and its value is \"true\", true is returned.\n     * Otherwise, false is returned.\n     *\n     * If key is \"\" or null, this methods throws an IllegalArgumentException.\n     */\n    public static boolean getBoolean(String key) {\n        return getInstance().getBooleanImpl(key);\n    }"}
{"Number":"197","API Relative Path":"com.sun.scenario.Settings.java-getBoolean(String-boolean)","Corresponding Source":"/**\n     * Convenience method for boolean settings.\n     *\n     * If the setting is set to \"true\", true is returned. If the setting is set\n     * to \"false\", false is returned. It the setting is set to anything else,\n     * defaultVal is returned.\n     *\n     * If key is \"\" or null, this methods throws an IllegalArgumentException.\n     */\n    public static boolean getBoolean(String key, boolean defaultVal) {\n        return getInstance().getBooleanImpl(key, defaultVal);\n    }"}
{"Number":"198","API Relative Path":"com.sun.scenario.Settings.java-getBoolean(String-boolean)","Corresponding Source":"/**\n     * Convenience method for boolean settings.\n     *\n     * If the setting is set to \"true\", true is returned. If the setting is set\n     * to \"false\", false is returned. It the setting is set to anything else,\n     * defaultVal is returned.\n     *\n     * If key is \"\" or null, this methods throws an IllegalArgumentException.\n     */\n    public static boolean getBoolean(String key, boolean defaultVal) {\n        return getInstance().getBooleanImpl(key, defaultVal);\n    }"}
{"Number":"199","API Relative Path":"com.sun.scenario.Settings.java-getInt(String-int)","Corresponding Source":"/**\n     * Convenience method for int settings.\n     *\n     * If the setting exists and its value can be parsed to an int, the int\n     * value is returned. Otherwise, the default value is returned.\n     *\n     * If key is \"\" or null, this methods throws an IllegalArgumentException.\n     */\n    public static int getInt(String key, int defaultVal) {\n        return getInstance().getIntImpl(key, defaultVal);\n    }"}
{"Number":"200","API Relative Path":"com.sun.scenario.Settings.java-getInt(String-int)","Corresponding Source":"/**\n     * Convenience method for int settings.\n     *\n     * If the setting exists and its value can be parsed to an int, the int\n     * value is returned. Otherwise, the default value is returned.\n     *\n     * If key is \"\" or null, this methods throws an IllegalArgumentException.\n     */\n    public static int getInt(String key, int defaultVal) {\n        return getInstance().getIntImpl(key, defaultVal);\n    }"}
{"Number":"201","API Relative Path":"com.sun.scenario.Settings.java-set(String-String)","Corresponding Source":"/**\n     * Add a new key-value setting.\n     *\n     * Passing a value of null indicates that the value for this key should be\n     * looked for in the System Properties.\n     *\n     * If PropertyChangeListeners have been registered for the given key, they\n     * will be notified of a change in value.\n     *\n     * If key is \"\" or null, this methods throws an IllegalArgumentException.\n     */\n    public static void set(String key, String value) {\n        getInstance().setImpl(key, value);\n    }"}
{"Number":"202","API Relative Path":"com.sun.scenario.Settings.java-set(String-String)","Corresponding Source":"/**\n     * Add a new key-value setting.\n     *\n     * Passing a value of null indicates that the value for this key should be\n     * looked for in the System Properties.\n     *\n     * If PropertyChangeListeners have been registered for the given key, they\n     * will be notified of a change in value.\n     *\n     * If key is \"\" or null, this methods throws an IllegalArgumentException.\n     */\n    public static void set(String key, String value) {\n        getInstance().setImpl(key, value);\n    }"}
{"Number":"203","API Relative Path":"com.sun.webkit.network.CookieManager.java-get(URI-Map)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public Map<String,List<String>> get(URI uri,\n            Map<String,List<String>> requestHeaders)\n    {\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.log(Level.FINEST, \"uri: [{0}], requestHeaders: {1}\",\n                    new Object[] {uri, toLogString(requestHeaders)});\n        }\n\n        if (uri == null) {\n            throw new IllegalArgumentException(\"uri is null\");\n        }\n        if (requestHeaders == null) {\n            throw new IllegalArgumentException(\"requestHeaders is null\");\n        }\n\n        String cookieString = get(uri);\n\n        Map<String,List<String>> result;\n        if (cookieString != null) {\n            result = new HashMap<String,List<String>>();\n            result.put(\"Cookie\", Arrays.asList(cookieString));\n        } else {\n            result = Collections.emptyMap();\n        }\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.log(Level.FINEST, \"result: {0}\", toLogString(result));\n        }\n        return result;\n    }"}
{"Number":"204","API Relative Path":"com.sun.webkit.network.CookieManager.java-get(URI-Map)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public Map<String,List<String>> get(URI uri,\n            Map<String,List<String>> requestHeaders)\n    {\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.log(Level.FINEST, \"uri: [{0}], requestHeaders: {1}\",\n                    new Object[] {uri, toLogString(requestHeaders)});\n        }\n\n        if (uri == null) {\n            throw new IllegalArgumentException(\"uri is null\");\n        }\n        if (requestHeaders == null) {\n            throw new IllegalArgumentException(\"requestHeaders is null\");\n        }\n\n        String cookieString = get(uri);\n\n        Map<String,List<String>> result;\n        if (cookieString != null) {\n            result = new HashMap<String,List<String>>();\n            result.put(\"Cookie\", Arrays.asList(cookieString));\n        } else {\n            result = Collections.emptyMap();\n        }\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.log(Level.FINEST, \"result: {0}\", toLogString(result));\n        }\n        return result;\n    }"}
{"Number":"205","API Relative Path":"com.sun.webkit.network.CookieManager.java-get(URI-Map)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public Map<String,List<String>> get(URI uri,\n            Map<String,List<String>> requestHeaders)\n    {\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.log(Level.FINEST, \"uri: [{0}], requestHeaders: {1}\",\n                    new Object[] {uri, toLogString(requestHeaders)});\n        }\n\n        if (uri == null) {\n            throw new IllegalArgumentException(\"uri is null\");\n        }\n        if (requestHeaders == null) {\n            throw new IllegalArgumentException(\"requestHeaders is null\");\n        }\n\n        String cookieString = get(uri);\n\n        Map<String,List<String>> result;\n        if (cookieString != null) {\n            result = new HashMap<String,List<String>>();\n            result.put(\"Cookie\", Arrays.asList(cookieString));\n        } else {\n            result = Collections.emptyMap();\n        }\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.log(Level.FINEST, \"result: {0}\", toLogString(result));\n        }\n        return result;\n    }"}
{"Number":"206","API Relative Path":"com.sun.webkit.network.CookieManager.java-put(URI-Map)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void put(URI uri, Map<String,List<String>> responseHeaders) {\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.log(Level.FINEST, \"uri: [{0}], responseHeaders: {1}\",\n                    new Object[] {uri, toLogString(responseHeaders)});\n        }\n\n        if (uri == null) {\n            throw new IllegalArgumentException(\"uri is null\");\n        }\n        if (responseHeaders == null) {\n            throw new IllegalArgumentException(\"responseHeaders is null\");\n        }\n\n        for (Map.Entry<String,List<String>> entry : responseHeaders.entrySet())\n        {\n            String key = entry.getKey();\n            if (!\"Set-Cookie\".equalsIgnoreCase(key)) {\n                continue;\n            }\n            ExtendedTime currentTime = ExtendedTime.currentTime();\n            // RT-15907: Process the list of headers in reverse order,\n            // effectively restoring the order in which the headers were\n            // received from the server. This is a temporary workaround for\n            // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7059532\n            ListIterator<String> it =\n                    entry.getValue().listIterator(entry.getValue().size());\n            while (it.hasPrevious()) {\n                Cookie cookie = Cookie.parse(it.previous(), currentTime);\n                if (cookie != null) {\n                    put(uri, cookie);\n                    currentTime = currentTime.incrementSubtime();\n                }\n            }\n        }\n    }"}
{"Number":"207","API Relative Path":"com.sun.webkit.network.CookieManager.java-put(URI-Map)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void put(URI uri, Map<String,List<String>> responseHeaders) {\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.log(Level.FINEST, \"uri: [{0}], responseHeaders: {1}\",\n                    new Object[] {uri, toLogString(responseHeaders)});\n        }\n\n        if (uri == null) {\n            throw new IllegalArgumentException(\"uri is null\");\n        }\n        if (responseHeaders == null) {\n            throw new IllegalArgumentException(\"responseHeaders is null\");\n        }\n\n        for (Map.Entry<String,List<String>> entry : responseHeaders.entrySet())\n        {\n            String key = entry.getKey();\n            if (!\"Set-Cookie\".equalsIgnoreCase(key)) {\n                continue;\n            }\n            ExtendedTime currentTime = ExtendedTime.currentTime();\n            // RT-15907: Process the list of headers in reverse order,\n            // effectively restoring the order in which the headers were\n            // received from the server. This is a temporary workaround for\n            // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7059532\n            ListIterator<String> it =\n                    entry.getValue().listIterator(entry.getValue().size());\n            while (it.hasPrevious()) {\n                Cookie cookie = Cookie.parse(it.previous(), currentTime);\n                if (cookie != null) {\n                    put(uri, cookie);\n                    currentTime = currentTime.incrementSubtime();\n                }\n            }\n        }\n    }"}
{"Number":"208","API Relative Path":"com.sun.webkit.network.CookieManager.java-put(URI-Map)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void put(URI uri, Map<String,List<String>> responseHeaders) {\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.log(Level.FINEST, \"uri: [{0}], responseHeaders: {1}\",\n                    new Object[] {uri, toLogString(responseHeaders)});\n        }\n\n        if (uri == null) {\n            throw new IllegalArgumentException(\"uri is null\");\n        }\n        if (responseHeaders == null) {\n            throw new IllegalArgumentException(\"responseHeaders is null\");\n        }\n\n        for (Map.Entry<String,List<String>> entry : responseHeaders.entrySet())\n        {\n            String key = entry.getKey();\n            if (!\"Set-Cookie\".equalsIgnoreCase(key)) {\n                continue;\n            }\n            ExtendedTime currentTime = ExtendedTime.currentTime();\n            // RT-15907: Process the list of headers in reverse order,\n            // effectively restoring the order in which the headers were\n            // received from the server. This is a temporary workaround for\n            // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7059532\n            ListIterator<String> it =\n                    entry.getValue().listIterator(entry.getValue().size());\n            while (it.hasPrevious()) {\n                Cookie cookie = Cookie.parse(it.previous(), currentTime);\n                if (cookie != null) {\n                    put(uri, cookie);\n                    currentTime = currentTime.incrementSubtime();\n                }\n            }\n        }\n    }"}
{"Number":"209","API Relative Path":"java.awt.AlphaComposite.java-derive(int)","Corresponding Source":"/**\n     * Returns a similar <code>AlphaComposite<\/code> object that uses\n     * the specified compositing rule.\n     * If this object already uses the specified compositing rule,\n     * this object is returned.\n     * @return an <code>AlphaComposite<\/code> object derived from\n     * this object that uses the specified compositing rule.\n     * @param rule the compositing rule\n     * @throws IllegalArgumentException if\n     *         <code>rule<\/code> is not one of\n     *         the following:  {@link #CLEAR}, {@link #SRC}, {@link #DST},\n     *         {@link #SRC_OVER}, {@link #DST_OVER}, {@link #SRC_IN},\n     *         {@link #DST_IN}, {@link #SRC_OUT}, {@link #DST_OUT},\n     *         {@link #SRC_ATOP}, {@link #DST_ATOP}, or {@link #XOR}\n     * @since 1.6\n     */\n    public AlphaComposite derive(int rule) {\n        return (this.rule == rule)\n            ? this\n            : getInstance(rule, this.extraAlpha);\n    }"}
{"Number":"210","API Relative Path":"java.awt.AlphaComposite.java-getInstance(int-float)","Corresponding Source":"/**\n     * Creates an <code>AlphaComposite<\/code> object with the specified rule and\n     * the constant alpha to multiply with the alpha of the source.\n     * The source is multiplied with the specified alpha before being composited\n     * with the destination.\n     * @param rule the compositing rule\n     * @param alpha the constant alpha to be multiplied with the alpha of\n     * the source. <code>alpha<\/code> must be a floating point number in the\n     * inclusive range [0.0,&nbsp;1.0].\n     * @throws IllegalArgumentException if\n     *         <code>alpha<\/code> is less than 0.0 or greater than 1.0, or if\n     *         <code>rule<\/code> is not one of\n     *         the following:  {@link #CLEAR}, {@link #SRC}, {@link #DST},\n     *         {@link #SRC_OVER}, {@link #DST_OVER}, {@link #SRC_IN},\n     *         {@link #DST_IN}, {@link #SRC_OUT}, {@link #DST_OUT},\n     *         {@link #SRC_ATOP}, {@link #DST_ATOP}, or {@link #XOR}\n     */\n    public static AlphaComposite getInstance(int rule, float alpha) {\n        if (alpha == 1.0f) {\n            return getInstance(rule);\n        }\n        return new AlphaComposite(rule, alpha);\n    }"}
{"Number":"211","API Relative Path":"java.awt.AWTEventMulticaster.java-remove(ActionListener-ActionListener)","Corresponding Source":"/**\n     * Removes the old action-listener from action-listener-l and\n     * returns the resulting multicast listener.\n     * @param l action-listener-l\n     * @param oldl the action-listener being removed\n     */\n    public static ActionListener remove(ActionListener l, ActionListener oldl) {\n        return (ActionListener) removeInternal(l, oldl);\n    }"}
{"Number":"212","API Relative Path":"java.awt.AWTEventMulticaster.java-remove(AdjustmentListener-AdjustmentListener)","Corresponding Source":"/**\n     * Removes the old adjustment-listener from adjustment-listener-l and\n     * returns the resulting multicast listener.\n     * @param l adjustment-listener-l\n     * @param oldl the adjustment-listener being removed\n     */\n    public static AdjustmentListener remove(AdjustmentListener l, AdjustmentListener oldl) {\n        return (AdjustmentListener) removeInternal(l, oldl);\n    }"}
{"Number":"213","API Relative Path":"java.awt.AWTEventMulticaster.java-remove(ComponentListener-ComponentListener)","Corresponding Source":"/**\n     * Removes the old component-listener from component-listener-l and\n     * returns the resulting multicast listener.\n     * @param l component-listener-l\n     * @param oldl the component-listener being removed\n     */\n    public static ComponentListener remove(ComponentListener l, ComponentListener oldl) {\n        return (ComponentListener) removeInternal(l, oldl);\n    }"}
{"Number":"214","API Relative Path":"java.awt.AWTEventMulticaster.java-remove(ContainerListener-ContainerListener)","Corresponding Source":"/**\n     * Removes the old container-listener from container-listener-l and\n     * returns the resulting multicast listener.\n     * @param l container-listener-l\n     * @param oldl the container-listener being removed\n     */\n    public static ContainerListener remove(ContainerListener l, ContainerListener oldl) {\n        return (ContainerListener) removeInternal(l, oldl);\n    }"}
{"Number":"215","API Relative Path":"java.awt.AWTEventMulticaster.java-remove(FocusListener-FocusListener)","Corresponding Source":"/**\n     * Removes the old focus-listener from focus-listener-l and\n     * returns the resulting multicast listener.\n     * @param l focus-listener-l\n     * @param oldl the focus-listener being removed\n     */\n    public static FocusListener remove(FocusListener l, FocusListener oldl) {\n        return (FocusListener) removeInternal(l, oldl);\n    }"}
{"Number":"216","API Relative Path":"java.awt.AWTEventMulticaster.java-remove(HierarchyBoundsListener-HierarchyBoundsListener)","Corresponding Source":"/**\n     * Removes the old hierarchy-bounds-listener from\n     * hierarchy-bounds-listener-l and returns the resulting multicast\n     * listener.\n     * @param l hierarchy-bounds-listener-l\n     * @param oldl the hierarchy-bounds-listener being removed\n     * @since 1.3\n     */\n    public static HierarchyBoundsListener remove(HierarchyBoundsListener l, HierarchyBoundsListener oldl) {\n        return (HierarchyBoundsListener) removeInternal(l, oldl);\n    }"}
{"Number":"217","API Relative Path":"java.awt.AWTEventMulticaster.java-remove(HierarchyListener-HierarchyListener)","Corresponding Source":"/**\n     * Removes the old hierarchy-listener from hierarchy-listener-l and\n     * returns the resulting multicast listener.\n     * @param l hierarchy-listener-l\n     * @param oldl the hierarchy-listener being removed\n     * @since 1.3\n     */\n    public static HierarchyListener remove(HierarchyListener l, HierarchyListener oldl) {\n        return (HierarchyListener) removeInternal(l, oldl);\n    }"}
{"Number":"218","API Relative Path":"java.awt.AWTEventMulticaster.java-remove(InputMethodListener-InputMethodListener)","Corresponding Source":"/**\n     * Removes the old input-method-listener from input-method-listener-l and\n     * returns the resulting multicast listener.\n     * @param l input-method-listener-l\n     * @param oldl the input-method-listener being removed\n     */\n    public static InputMethodListener remove(InputMethodListener l, InputMethodListener oldl) {\n        return (InputMethodListener) removeInternal(l, oldl);\n    }"}
{"Number":"219","API Relative Path":"java.awt.AWTEventMulticaster.java-remove(ItemListener-ItemListener)","Corresponding Source":"/**\n     * Removes the old item-listener from item-listener-l and\n     * returns the resulting multicast listener.\n     * @param l item-listener-l\n     * @param oldl the item-listener being removed\n     */\n    public static ItemListener remove(ItemListener l, ItemListener oldl) {\n        return (ItemListener) removeInternal(l, oldl);\n    }"}
{"Number":"220","API Relative Path":"java.awt.AWTEventMulticaster.java-remove(KeyListener-KeyListener)","Corresponding Source":"/**\n     * Removes the old key-listener from key-listener-l and\n     * returns the resulting multicast listener.\n     * @param l key-listener-l\n     * @param oldl the key-listener being removed\n     */\n    public static KeyListener remove(KeyListener l, KeyListener oldl) {\n        return (KeyListener) removeInternal(l, oldl);\n    }"}
{"Number":"221","API Relative Path":"java.awt.AWTEventMulticaster.java-remove(MouseListener-MouseListener)","Corresponding Source":"/**\n     * Removes the old mouse-listener from mouse-listener-l and\n     * returns the resulting multicast listener.\n     * @param l mouse-listener-l\n     * @param oldl the mouse-listener being removed\n     */\n    public static MouseListener remove(MouseListener l, MouseListener oldl) {\n        return (MouseListener) removeInternal(l, oldl);\n    }"}
{"Number":"222","API Relative Path":"java.awt.AWTEventMulticaster.java-remove(MouseMotionListener-MouseMotionListener)","Corresponding Source":"/**\n     * Removes the old mouse-motion-listener from mouse-motion-listener-l\n     * and returns the resulting multicast listener.\n     * @param l mouse-motion-listener-l\n     * @param oldl the mouse-motion-listener being removed\n     */\n    public static MouseMotionListener remove(MouseMotionListener l, MouseMotionListener oldl) {\n        return (MouseMotionListener) removeInternal(l, oldl);\n    }"}
{"Number":"223","API Relative Path":"java.awt.AWTEventMulticaster.java-remove(MouseWheelListener-MouseWheelListener)","Corresponding Source":"/**\n     * Removes the old mouse-wheel-listener from mouse-wheel-listener-l\n     * and returns the resulting multicast listener.\n     * @param l mouse-wheel-listener-l\n     * @param oldl the mouse-wheel-listener being removed\n     * @since 1.4\n     */\n    public static MouseWheelListener remove(MouseWheelListener l,\n                                            MouseWheelListener oldl) {\n      return (MouseWheelListener) removeInternal(l, oldl);\n    }"}
{"Number":"224","API Relative Path":"java.awt.AWTEventMulticaster.java-remove(WindowFocusListener-WindowFocusListener)","Corresponding Source":"/**\n     * Removes the old window-focus-listener from window-focus-listener-l\n     * and returns the resulting multicast listener.\n     * @param l window-focus-listener-l\n     * @param oldl the window-focus-listener being removed\n     * @since 1.4\n     */\n    public static WindowFocusListener remove(WindowFocusListener l,\n                                             WindowFocusListener oldl) {\n        return (WindowFocusListener) removeInternal(l, oldl);\n    }"}
{"Number":"225","API Relative Path":"java.awt.AWTEventMulticaster.java-remove(WindowListener-WindowListener)","Corresponding Source":"/**\n     * Removes the old window-listener from window-listener-l and\n     * returns the resulting multicast listener.\n     * @param l window-listener-l\n     * @param oldl the window-listener being removed\n     */\n    public static WindowListener remove(WindowListener l, WindowListener oldl) {\n        return (WindowListener) removeInternal(l, oldl);\n    }"}
{"Number":"226","API Relative Path":"java.awt.AWTEventMulticaster.java-remove(WindowStateListener-WindowStateListener)","Corresponding Source":"/**\n     * Removes the old window-state-listener from window-state-listener-l\n     * and returns the resulting multicast listener.\n     * @param l window-state-listener-l\n     * @param oldl the window-state-listener being removed\n     * @since 1.4\n     */\n    public static WindowStateListener remove(WindowStateListener l,\n                                             WindowStateListener oldl) {\n        return (WindowStateListener) removeInternal(l, oldl);\n    }"}
{"Number":"227","API Relative Path":"java.awt.AWTEventMulticaster.java-removeInternal(EventListener-EventListener)","Corresponding Source":"/**\n     * Returns the resulting multicast listener after removing the\n     * old listener from listener-l.\n     * If listener-l equals the old listener OR listener-l is null,\n     * returns null.\n     * Else if listener-l is an instance of AWTEventMulticaster,\n     * then it removes the old listener from it.\n     * Else, returns listener l.\n     * @param l the listener being removed from\n     * @param oldl the listener being removed\n     */\n    protected static EventListener removeInternal(EventListener l, EventListener oldl) {\n        if (l == oldl || l == null) {\n            return null;\n        } else if (l instanceof AWTEventMulticaster) {\n            return ((AWTEventMulticaster)l).remove(oldl);\n        } else {\n            return l;           // it's not here\n        }\n    }"}
{"Number":"228","API Relative Path":"java.awt.BasicStroke.java-BasicStroke(float-int-int-float-float-float)","Corresponding Source":"/**\n     * Constructs a new <code>BasicStroke<\/code> with the specified\n     * attributes.\n     * @param width the width of this <code>BasicStroke<\/code>.  The\n     *         width must be greater than or equal to 0.0f.  If width is\n     *         set to 0.0f, the stroke is rendered as the thinnest\n     *         possible line for the target device and the antialias\n     *         hint setting.\n     * @param cap the decoration of the ends of a <code>BasicStroke<\/code>\n     * @param join the decoration applied where path segments meet\n     * @param miterlimit the limit to trim the miter join.  The miterlimit\n     *        must be greater than or equal to 1.0f.\n     * @param dash the array representing the dashing pattern\n     * @param dash_phase the offset to start the dashing pattern\n     * @throws IllegalArgumentException if <code>width<\/code> is negative\n     * @throws IllegalArgumentException if <code>cap<\/code> is not either\n     *         CAP_BUTT, CAP_ROUND or CAP_SQUARE\n     * @throws IllegalArgumentException if <code>miterlimit<\/code> is less\n     *         than 1 and <code>join<\/code> is JOIN_MITER\n     * @throws IllegalArgumentException if <code>join<\/code> is not\n     *         either JOIN_ROUND, JOIN_BEVEL, or JOIN_MITER\n     * @throws IllegalArgumentException if <code>dash_phase<\/code>\n     *         is negative and <code>dash<\/code> is not <code>null<\/code>\n     * @throws IllegalArgumentException if the length of\n     *         <code>dash<\/code> is zero\n     * @throws IllegalArgumentException if dash lengths are all zero.\n     */\n    @ConstructorProperties({ \"lineWidth\", \"endCap\", \"lineJoin\", \"miterLimit\", \"dashArray\", \"dashPhase\" })\n    public BasicStroke(float width, int cap, int join, float miterlimit,\n                       float dash[], float dash_phase) {\n        if (width < 0.0f) {\n            throw new IllegalArgumentException(\"negative width\");\n        }\n        if (cap != CAP_BUTT && cap != CAP_ROUND && cap != CAP_SQUARE) {\n            throw new IllegalArgumentException(\"illegal end cap value\");\n        }\n        if (join == JOIN_MITER) {\n            if (miterlimit < 1.0f) {\n                throw new IllegalArgumentException(\"miter limit < 1\");\n            }\n        } else if (join != JOIN_ROUND && join != JOIN_BEVEL) {\n            throw new IllegalArgumentException(\"illegal line join value\");\n        }\n        if (dash != null) {\n            if (dash_phase < 0.0f) {\n                throw new IllegalArgumentException(\"negative dash phase\");\n            }\n            boolean allzero = true;\n            for (int i = 0; i < dash.length; i++) {\n                float d = dash[i];\n                if (d > 0.0) {\n                    allzero = false;\n                } else if (d < 0.0) {\n                    throw new IllegalArgumentException(\"negative dash length\");\n                }\n            }\n            if (allzero) {\n                throw new IllegalArgumentException(\"dash lengths all zero\");\n            }\n        }\n        this.width      = width;\n        this.cap        = cap;\n        this.join       = join;\n        this.miterlimit = miterlimit;\n        if (dash != null) {\n            this.dash = (float []) dash.clone();\n        }\n        this.dash_phase = dash_phase;\n    }"}
{"Number":"229","API Relative Path":"java.awt.BasicStroke.java-BasicStroke(float-int-int-float-float-float)","Corresponding Source":"/**\n     * Constructs a new <code>BasicStroke<\/code> with the specified\n     * attributes.\n     * @param width the width of this <code>BasicStroke<\/code>.  The\n     *         width must be greater than or equal to 0.0f.  If width is\n     *         set to 0.0f, the stroke is rendered as the thinnest\n     *         possible line for the target device and the antialias\n     *         hint setting.\n     * @param cap the decoration of the ends of a <code>BasicStroke<\/code>\n     * @param join the decoration applied where path segments meet\n     * @param miterlimit the limit to trim the miter join.  The miterlimit\n     *        must be greater than or equal to 1.0f.\n     * @param dash the array representing the dashing pattern\n     * @param dash_phase the offset to start the dashing pattern\n     * @throws IllegalArgumentException if <code>width<\/code> is negative\n     * @throws IllegalArgumentException if <code>cap<\/code> is not either\n     *         CAP_BUTT, CAP_ROUND or CAP_SQUARE\n     * @throws IllegalArgumentException if <code>miterlimit<\/code> is less\n     *         than 1 and <code>join<\/code> is JOIN_MITER\n     * @throws IllegalArgumentException if <code>join<\/code> is not\n     *         either JOIN_ROUND, JOIN_BEVEL, or JOIN_MITER\n     * @throws IllegalArgumentException if <code>dash_phase<\/code>\n     *         is negative and <code>dash<\/code> is not <code>null<\/code>\n     * @throws IllegalArgumentException if the length of\n     *         <code>dash<\/code> is zero\n     * @throws IllegalArgumentException if dash lengths are all zero.\n     */\n    @ConstructorProperties({ \"lineWidth\", \"endCap\", \"lineJoin\", \"miterLimit\", \"dashArray\", \"dashPhase\" })\n    public BasicStroke(float width, int cap, int join, float miterlimit,\n                       float dash[], float dash_phase) {\n        if (width < 0.0f) {\n            throw new IllegalArgumentException(\"negative width\");\n        }\n        if (cap != CAP_BUTT && cap != CAP_ROUND && cap != CAP_SQUARE) {\n            throw new IllegalArgumentException(\"illegal end cap value\");\n        }\n        if (join == JOIN_MITER) {\n            if (miterlimit < 1.0f) {\n                throw new IllegalArgumentException(\"miter limit < 1\");\n            }\n        } else if (join != JOIN_ROUND && join != JOIN_BEVEL) {\n            throw new IllegalArgumentException(\"illegal line join value\");\n        }\n        if (dash != null) {\n            if (dash_phase < 0.0f) {\n                throw new IllegalArgumentException(\"negative dash phase\");\n            }\n            boolean allzero = true;\n            for (int i = 0; i < dash.length; i++) {\n                float d = dash[i];\n                if (d > 0.0) {\n                    allzero = false;\n                } else if (d < 0.0) {\n                    throw new IllegalArgumentException(\"negative dash length\");\n                }\n            }\n            if (allzero) {\n                throw new IllegalArgumentException(\"dash lengths all zero\");\n            }\n        }\n        this.width      = width;\n        this.cap        = cap;\n        this.join       = join;\n        this.miterlimit = miterlimit;\n        if (dash != null) {\n            this.dash = (float []) dash.clone();\n        }\n        this.dash_phase = dash_phase;\n    }"}
{"Number":"230","API Relative Path":"java.awt.BorderLayout.java-addLayoutComponent(Component-Object)","Corresponding Source":"/**\n     * Adds the specified component to the layout, using the specified\n     * constraint object.  For border layouts, the constraint must be\n     * one of the following constants:  <code>NORTH<\/code>,\n     * <code>SOUTH<\/code>, <code>EAST<\/code>,\n     * <code>WEST<\/code>, or <code>CENTER<\/code>.\n     * <p>\n     * Most applications do not call this method directly. This method\n     * is called when a component is added to a container using the\n     * <code>Container.add<\/code> method with the same argument types.\n     * @param   comp         the component to be added.\n     * @param   constraints  an object that specifies how and where\n     *                       the component is added to the layout.\n     * @see     java.awt.Container#add(java.awt.Component, java.lang.Object)\n     * @exception   IllegalArgumentException  if the constraint object is not\n     *                 a string, or if it not one of the five specified\n         *              constants.\n     * @since   JDK1.1\n     */\n    public void addLayoutComponent(Component comp, Object constraints) {\n      synchronized (comp.getTreeLock()) {\n        if ((constraints == null) || (constraints instanceof String)) {\n            addLayoutComponent((String)constraints, comp);\n        } else {\n            throw new IllegalArgumentException(\"cannot add to layout: constraint must be a string (or null)\");\n        }\n      }\n    }"}
{"Number":"231","API Relative Path":"java.awt.BorderLayout.java-getConstraints(Component)","Corresponding Source":"/**\n     * Gets the constraints for the specified component\n     *\n     * @param   comp the component to be queried\n     * @return  the constraint for the specified component,\n     *          or null if component is null or is not present\n     *          in this layout\n     * @see #addLayoutComponent(java.awt.Component, java.lang.Object)\n     * @since 1.5\n     */\n    public Object getConstraints(Component comp) {\n        //fix for 6242148 : API method java.awt.BorderLayout.getConstraints(null) should return null\n        if (comp == null){\n            return null;\n        }\n        if (comp == center) {\n            return CENTER;\n        } else if (comp == north) {\n            return NORTH;\n        } else if (comp == south) {\n            return SOUTH;\n        } else if (comp == west) {\n            return WEST;\n        } else if (comp == east) {\n            return EAST;\n        } else if (comp == firstLine) {\n            return PAGE_START;\n        } else if (comp == lastLine) {\n            return PAGE_END;\n        } else if (comp == firstItem) {\n            return LINE_START;\n        } else if (comp == lastItem) {\n            return LINE_END;\n        }\n        return null;\n    }"}
{"Number":"232","API Relative Path":"java.awt.Button.java-addActionListener(ActionListener)","Corresponding Source":"/**\n     * Adds the specified action listener to receive action events from\n     * this button. Action events occur when a user presses or releases\n     * the mouse over this button.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param         l the action listener\n     * @see           #removeActionListener\n     * @see           #getActionListeners\n     * @see           java.awt.event.ActionListener\n     * @since         JDK1.1\n     */\n    public synchronized void addActionListener(ActionListener l) {\n        if (l == null) {\n            return;\n        }\n        actionListener = AWTEventMulticaster.add(actionListener, l);\n        newEventsOnly = true;\n    }"}
{"Number":"233","API Relative Path":"java.awt.Button.java-removeActionListener(ActionListener)","Corresponding Source":"/**\n     * Removes the specified action listener so that it no longer\n     * receives action events from this button. Action events occur\n     * when a user presses or releases the mouse over this button.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param           l     the action listener\n     * @see             #addActionListener\n     * @see             #getActionListeners\n     * @see             java.awt.event.ActionListener\n     * @since           JDK1.1\n     */\n    public synchronized void removeActionListener(ActionListener l) {\n        if (l == null) {\n            return;\n        }\n        actionListener = AWTEventMulticaster.remove(actionListener, l);\n    }"}
{"Number":"234","API Relative Path":"java.awt.Button.java-removeActionListener(ActionListener)","Corresponding Source":"/**\n     * Removes the specified action listener so that it no longer\n     * receives action events from this button. Action events occur\n     * when a user presses or releases the mouse over this button.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param           l     the action listener\n     * @see             #addActionListener\n     * @see             #getActionListeners\n     * @see             java.awt.event.ActionListener\n     * @since           JDK1.1\n     */\n    public synchronized void removeActionListener(ActionListener l) {\n        if (l == null) {\n            return;\n        }\n        actionListener = AWTEventMulticaster.remove(actionListener, l);\n    }"}
{"Number":"235","API Relative Path":"java.awt.CardLayout.java-addLayoutComponent(Component-Object)","Corresponding Source":"/**\n     * Adds the specified component to this card layout's internal\n     * table of names. The object specified by <code>constraints<\/code>\n     * must be a string. The card layout stores this string as a key-value\n     * pair that can be used for random access to a particular card.\n     * By calling the <code>show<\/code> method, an application can\n     * display the component with the specified name.\n     * @param     comp          the component to be added.\n     * @param     constraints   a tag that identifies a particular\n     *                                        card in the layout.\n     * @see       java.awt.CardLayout#show(java.awt.Container, java.lang.String)\n     * @exception  IllegalArgumentException  if the constraint is not a string.\n     */\n    public void addLayoutComponent(Component comp, Object constraints) {\n      synchronized (comp.getTreeLock()) {\n          if (constraints == null){\n              constraints = \"\";\n          }\n        if (constraints instanceof String) {\n            addLayoutComponent((String)constraints, comp);\n        } else {\n            throw new IllegalArgumentException(\"cannot add to layout: constraint must be a string\");\n        }\n      }\n    }"}
{"Number":"236","API Relative Path":"java.awt.Checkbox.java-addItemListener(ItemListener)","Corresponding Source":"/**\n     * Adds the specified item listener to receive item events from\n     * this check box.  Item events are sent to listeners in response\n     * to user input, but not in response to calls to setState().\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param         l    the item listener\n     * @see           #removeItemListener\n     * @see           #getItemListeners\n     * @see           #setState\n     * @see           java.awt.event.ItemEvent\n     * @see           java.awt.event.ItemListener\n     * @since         JDK1.1\n     */\n    public synchronized void addItemListener(ItemListener l) {\n        if (l == null) {\n            return;\n        }\n        itemListener = AWTEventMulticaster.add(itemListener, l);\n        newEventsOnly = true;\n    }"}
{"Number":"237","API Relative Path":"java.awt.Checkbox.java-removeItemListener(ItemListener)","Corresponding Source":"/**\n     * Removes the specified item listener so that the item listener\n     * no longer receives item events from this check box.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param         l    the item listener\n     * @see           #addItemListener\n     * @see           #getItemListeners\n     * @see           java.awt.event.ItemEvent\n     * @see           java.awt.event.ItemListener\n     * @since         JDK1.1\n     */\n    public synchronized void removeItemListener(ItemListener l) {\n        if (l == null) {\n            return;\n        }\n        itemListener = AWTEventMulticaster.remove(itemListener, l);\n    }"}
{"Number":"238","API Relative Path":"java.awt.Checkbox.java-removeItemListener(ItemListener)","Corresponding Source":"/**\n     * Removes the specified item listener so that the item listener\n     * no longer receives item events from this check box.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param         l    the item listener\n     * @see           #addItemListener\n     * @see           #getItemListeners\n     * @see           java.awt.event.ItemEvent\n     * @see           java.awt.event.ItemListener\n     * @since         JDK1.1\n     */\n    public synchronized void removeItemListener(ItemListener l) {\n        if (l == null) {\n            return;\n        }\n        itemListener = AWTEventMulticaster.remove(itemListener, l);\n    }"}
{"Number":"239","API Relative Path":"java.awt.CheckboxGroup.java-setCurrent(Checkbox)","Corresponding Source":"/**\n     * @deprecated As of JDK version 1.1,\n     * replaced by <code>setSelectedCheckbox(Checkbox)<\/code>.\n     */\n    @Deprecated\n    public synchronized void setCurrent(Checkbox box) {\n        if (box != null && box.group != this) {\n            return;\n        }\n        Checkbox oldChoice = this.selectedCheckbox;\n        this.selectedCheckbox = box;\n        if (oldChoice != null && oldChoice != box && oldChoice.group == this) {\n            oldChoice.setState(false);\n        }\n        if (box != null && oldChoice != box && !box.getState()) {\n            box.setStateInternal(true);\n        }\n    }"}
{"Number":"240","API Relative Path":"java.awt.CheckboxGroup.java-setSelectedCheckbox(Checkbox)","Corresponding Source":"/**\n     * Sets the currently selected check box in this group\n     * to be the specified check box.\n     * This method sets the state of that check box to \"on\" and\n     * sets all other check boxes in the group to be off.\n     * <p>\n     * If the check box argument is <tt>null<\/tt>, all check boxes\n     * in this check box group are deselected. If the check box argument\n     * belongs to a different check box group, this method does\n     * nothing.\n     * @param     box   the <code>Checkbox<\/code> to set as the\n     *                      current selection.\n     * @see      java.awt.Checkbox\n     * @see      java.awt.CheckboxGroup#getSelectedCheckbox\n     * @since    JDK1.1\n     */\n    public void setSelectedCheckbox(Checkbox box) {\n        setCurrent(box);\n    }"}
{"Number":"241","API Relative Path":"java.awt.CheckboxMenuItem.java-addItemListener(ItemListener)","Corresponding Source":"/**\n     * Adds the specified item listener to receive item events from\n     * this check box menu item.  Item events are sent in response to user\n     * actions, but not in response to calls to setState().\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param         l the item listener\n     * @see           #removeItemListener\n     * @see           #getItemListeners\n     * @see           #setState\n     * @see           java.awt.event.ItemEvent\n     * @see           java.awt.event.ItemListener\n     * @since         JDK1.1\n     */\n    public synchronized void addItemListener(ItemListener l) {\n        if (l == null) {\n            return;\n        }\n        itemListener = AWTEventMulticaster.add(itemListener, l);\n        newEventsOnly = true;\n    }"}
{"Number":"242","API Relative Path":"java.awt.CheckboxMenuItem.java-removeItemListener(ItemListener)","Corresponding Source":"/**\n     * Removes the specified item listener so that it no longer receives\n     * item events from this check box menu item.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param         l the item listener\n     * @see           #addItemListener\n     * @see           #getItemListeners\n     * @see           java.awt.event.ItemEvent\n     * @see           java.awt.event.ItemListener\n     * @since         JDK1.1\n     */\n    public synchronized void removeItemListener(ItemListener l) {\n        if (l == null) {\n            return;\n        }\n        itemListener = AWTEventMulticaster.remove(itemListener, l);\n    }"}
{"Number":"243","API Relative Path":"java.awt.CheckboxMenuItem.java-removeItemListener(ItemListener)","Corresponding Source":"/**\n     * Removes the specified item listener so that it no longer receives\n     * item events from this check box menu item.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param         l the item listener\n     * @see           #addItemListener\n     * @see           #getItemListeners\n     * @see           java.awt.event.ItemEvent\n     * @see           java.awt.event.ItemListener\n     * @since         JDK1.1\n     */\n    public synchronized void removeItemListener(ItemListener l) {\n        if (l == null) {\n            return;\n        }\n        itemListener = AWTEventMulticaster.remove(itemListener, l);\n    }"}
{"Number":"244","API Relative Path":"java.awt.Choice.java-addItemListener(ItemListener)","Corresponding Source":"/**\n     * Adds the specified item listener to receive item events from\n     * this <code>Choice<\/code> menu.  Item events are sent in response\n     * to user input, but not in response to calls to <code>select<\/code>.\n     * If l is <code>null<\/code>, no exception is thrown and no action\n     * is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     * @param         l    the item listener\n     * @see           #removeItemListener\n     * @see           #getItemListeners\n     * @see           #select\n     * @see           java.awt.event.ItemEvent\n     * @see           java.awt.event.ItemListener\n     * @since         JDK1.1\n     */\n    public synchronized void addItemListener(ItemListener l) {\n        if (l == null) {\n           return;\n        }\n        itemListener = AWTEventMulticaster.add(itemListener, l);\n        newEventsOnly = true;\n    }"}
{"Number":"245","API Relative Path":"java.awt.Choice.java-insert(String-int)","Corresponding Source":"/**\n     * Inserts the item into this choice at the specified position.\n     * Existing items at an index greater than or equal to\n     * <code>index<\/code> are shifted up by one to accommodate\n     * the new item.  If <code>index<\/code> is greater than or\n     * equal to the number of items in this choice,\n     * <code>item<\/code> is added to the end of this choice.\n     * <p>\n     * If the item is the first one being added to the choice,\n     * then the item becomes selected.  Otherwise, if the\n     * selected item was one of the items shifted, the first\n     * item in the choice becomes the selected item.  If the\n     * selected item was no among those shifted, it remains\n     * the selected item.\n     * @param item the non-<code>null<\/code> item to be inserted\n     * @param index the position at which the item should be inserted\n     * @exception IllegalArgumentException if index is less than 0\n     */\n    public void insert(String item, int index) {\n        synchronized (this) {\n            if (index < 0) {\n                throw new IllegalArgumentException(\"index less than zero.\");\n            }\n            /* if the index greater than item count, add item to the end */\n            index = Math.min(index, pItems.size());\n\n            insertNoInvalidate(item, index);\n        }\n\n        // This could change the preferred size of the Component.\n        invalidateIfValid();\n    }"}
{"Number":"246","API Relative Path":"java.awt.Choice.java-removeItemListener(ItemListener)","Corresponding Source":"/**\n     * Removes the specified item listener so that it no longer receives\n     * item events from this <code>Choice<\/code> menu.\n     * If l is <code>null<\/code>, no exception is thrown and no\n     * action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     * @param         l    the item listener\n     * @see           #addItemListener\n     * @see           #getItemListeners\n     * @see           java.awt.event.ItemEvent\n     * @see           java.awt.event.ItemListener\n     * @since         JDK1.1\n     */\n    public synchronized void removeItemListener(ItemListener l) {\n        if (l == null) {\n            return;\n        }\n        itemListener = AWTEventMulticaster.remove(itemListener, l);\n    }"}
{"Number":"247","API Relative Path":"java.awt.Choice.java-removeItemListener(ItemListener)","Corresponding Source":"/**\n     * Removes the specified item listener so that it no longer receives\n     * item events from this <code>Choice<\/code> menu.\n     * If l is <code>null<\/code>, no exception is thrown and no\n     * action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     * @param         l    the item listener\n     * @see           #addItemListener\n     * @see           #getItemListeners\n     * @see           java.awt.event.ItemEvent\n     * @see           java.awt.event.ItemListener\n     * @since         JDK1.1\n     */\n    public synchronized void removeItemListener(ItemListener l) {\n        if (l == null) {\n            return;\n        }\n        itemListener = AWTEventMulticaster.remove(itemListener, l);\n    }"}
{"Number":"248","API Relative Path":"java.awt.Choice.java-select(int)","Corresponding Source":"/**\n     * Sets the selected item in this <code>Choice<\/code> menu to be the\n     * item at the specified position.\n     *\n     * <p>Note that this method should be primarily used to\n     * initially select an item in this component.\n     * Programmatically calling this method will <i>not<\/i> trigger\n     * an <code>ItemEvent<\/code>.  The only way to trigger an\n     * <code>ItemEvent<\/code> is by user interaction.\n     *\n     * @param      pos      the position of the selected item\n     * @exception  IllegalArgumentException if the specified\n     *                            position is greater than the\n     *                            number of items or less than zero\n     * @see        #getSelectedItem\n     * @see        #getSelectedIndex\n     */\n    public synchronized void select(int pos) {\n        if ((pos >= pItems.size()) || (pos < 0)) {\n            throw new IllegalArgumentException(\"illegal Choice item position: \" + pos);\n        }\n        if (pItems.size() > 0) {\n            selectedIndex = pos;\n            ChoicePeer peer = (ChoicePeer)this.peer;\n            if (peer != null) {\n                peer.select(pos);\n            }\n        }\n    }"}
{"Number":"249","API Relative Path":"java.awt.color.ICC_ColorSpace.java-getMaxValue(int)","Corresponding Source":"/**\n     * Returns the maximum normalized color component value for the\n     * specified component.  For TYPE_XYZ spaces, this method returns\n     * maximum values of 1.0 + (32767.0 / 32768.0) for all components.\n     * For TYPE_Lab spaces,\n     * this method returns 100.0 for L and 127.0 for a and b components.\n     * This is consistent with the encoding of the XYZ and Lab Profile\n     * Connection Spaces in the ICC specification.  For all other types, this\n     * method returns 1.0 for all components.  When using an ICC_ColorSpace\n     * with a profile that requires different maximum component values,\n     * it is necessary to subclass this class and override this method.\n     * @param component The component index.\n     * @return The maximum normalized component value.\n     * @throws IllegalArgumentException if component is less than 0 or\n     *         greater than numComponents - 1.\n     * @since 1.4\n     */\n    public float getMaxValue(int component) {\n        if ((component < 0) || (component > this.getNumComponents() - 1)) {\n            throw new IllegalArgumentException(\n                \"Component index out of range: + component\");\n        }\n        return maxVal[component];\n    }"}
{"Number":"250","API Relative Path":"java.awt.color.ICC_ColorSpace.java-getMinValue(int)","Corresponding Source":"/**\n     * Returns the minimum normalized color component value for the\n     * specified component.  For TYPE_XYZ spaces, this method returns\n     * minimum values of 0.0 for all components.  For TYPE_Lab spaces,\n     * this method returns 0.0 for L and -128.0 for a and b components.\n     * This is consistent with the encoding of the XYZ and Lab Profile\n     * Connection Spaces in the ICC specification.  For all other types, this\n     * method returns 0.0 for all components.  When using an ICC_ColorSpace\n     * with a profile that requires different minimum component values,\n     * it is necessary to subclass this class and override this method.\n     * @param component The component index.\n     * @return The minimum normalized component value.\n     * @throws IllegalArgumentException if component is less than 0 or\n     *         greater than numComponents - 1.\n     * @since 1.4\n     */\n    public float getMinValue(int component) {\n        if ((component < 0) || (component > this.getNumComponents() - 1)) {\n            throw new IllegalArgumentException(\n                \"Component index out of range: + component\");\n        }\n        return minVal[component];\n    }"}
{"Number":"251","API Relative Path":"java.awt.Component.java-addComponentListener(ComponentListener)","Corresponding Source":"// Event source interfaces\n\n    /**\n     * Adds the specified component listener to receive component events from\n     * this component.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the component listener\n     * @see      java.awt.event.ComponentEvent\n     * @see      java.awt.event.ComponentListener\n     * @see      #removeComponentListener\n     * @see      #getComponentListeners\n     * @since    JDK1.1\n     */\n    public synchronized void addComponentListener(ComponentListener l) {\n        if (l == null) {\n            return;\n        }\n        componentListener = AWTEventMulticaster.add(componentListener, l);\n        newEventsOnly = true;\n    }"}
{"Number":"252","API Relative Path":"java.awt.Component.java-addFocusListener(FocusListener)","Corresponding Source":"/**\n     * Adds the specified focus listener to receive focus events from\n     * this component when this component gains input focus.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the focus listener\n     * @see      java.awt.event.FocusEvent\n     * @see      java.awt.event.FocusListener\n     * @see      #removeFocusListener\n     * @see      #getFocusListeners\n     * @since    JDK1.1\n     */\n    public synchronized void addFocusListener(FocusListener l) {\n        if (l == null) {\n            return;\n        }\n        focusListener = AWTEventMulticaster.add(focusListener, l);\n        newEventsOnly = true;\n\n        // if this is a lightweight component, enable focus events\n        // in the native container.\n        if (peer instanceof LightweightPeer) {\n            parent.proxyEnableEvents(AWTEvent.FOCUS_EVENT_MASK);\n        }\n    }"}
{"Number":"253","API Relative Path":"java.awt.Component.java-addHierarchyBoundsListener(HierarchyBoundsListener)","Corresponding Source":"/**\n     * Adds the specified hierarchy bounds listener to receive hierarchy\n     * bounds events from this component when the hierarchy to which this\n     * container belongs changes.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the hierarchy bounds listener\n     * @see      java.awt.event.HierarchyEvent\n     * @see      java.awt.event.HierarchyBoundsListener\n     * @see      #removeHierarchyBoundsListener\n     * @see      #getHierarchyBoundsListeners\n     * @since    1.3\n     */\n    public void addHierarchyBoundsListener(HierarchyBoundsListener l) {\n        if (l == null) {\n            return;\n        }\n        boolean notifyAncestors;\n        synchronized (this) {\n            notifyAncestors =\n                (hierarchyBoundsListener == null &&\n                 (eventMask & AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) == 0);\n            hierarchyBoundsListener =\n                AWTEventMulticaster.add(hierarchyBoundsListener, l);\n            notifyAncestors = (notifyAncestors &&\n                               hierarchyBoundsListener != null);\n            newEventsOnly = true;\n        }\n        if (notifyAncestors) {\n            synchronized (getTreeLock()) {\n                adjustListeningChildrenOnParent(\n                                                AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK, 1);\n            }\n        }\n    }"}
{"Number":"254","API Relative Path":"java.awt.Component.java-addHierarchyListener(HierarchyListener)","Corresponding Source":"/**\n     * Adds the specified hierarchy listener to receive hierarchy changed\n     * events from this component when the hierarchy to which this container\n     * belongs changes.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the hierarchy listener\n     * @see      java.awt.event.HierarchyEvent\n     * @see      java.awt.event.HierarchyListener\n     * @see      #removeHierarchyListener\n     * @see      #getHierarchyListeners\n     * @since    1.3\n     */\n    public void addHierarchyListener(HierarchyListener l) {\n        if (l == null) {\n            return;\n        }\n        boolean notifyAncestors;\n        synchronized (this) {\n            notifyAncestors =\n                (hierarchyListener == null &&\n                 (eventMask & AWTEvent.HIERARCHY_EVENT_MASK) == 0);\n            hierarchyListener = AWTEventMulticaster.add(hierarchyListener, l);\n            notifyAncestors = (notifyAncestors && hierarchyListener != null);\n            newEventsOnly = true;\n        }\n        if (notifyAncestors) {\n            synchronized (getTreeLock()) {\n                adjustListeningChildrenOnParent(AWTEvent.HIERARCHY_EVENT_MASK,\n                                                1);\n            }\n        }\n    }"}
{"Number":"255","API Relative Path":"java.awt.Component.java-addInputMethodListener(InputMethodListener)","Corresponding Source":"/**\n     * Adds the specified input method listener to receive\n     * input method events from this component. A component will\n     * only receive input method events from input methods\n     * if it also overrides <code>getInputMethodRequests<\/code> to return an\n     * <code>InputMethodRequests<\/code> instance.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"{@docRoot}/java/awt/doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the input method listener\n     * @see      java.awt.event.InputMethodEvent\n     * @see      java.awt.event.InputMethodListener\n     * @see      #removeInputMethodListener\n     * @see      #getInputMethodListeners\n     * @see      #getInputMethodRequests\n     * @since    1.2\n     */\n    public synchronized void addInputMethodListener(InputMethodListener l) {\n        if (l == null) {\n            return;\n        }\n        inputMethodListener = AWTEventMulticaster.add(inputMethodListener, l);\n        newEventsOnly = true;\n    }"}
{"Number":"256","API Relative Path":"java.awt.Component.java-addKeyListener(KeyListener)","Corresponding Source":"/**\n     * Adds the specified key listener to receive key events from\n     * this component.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the key listener.\n     * @see      java.awt.event.KeyEvent\n     * @see      java.awt.event.KeyListener\n     * @see      #removeKeyListener\n     * @see      #getKeyListeners\n     * @since    JDK1.1\n     */\n    public synchronized void addKeyListener(KeyListener l) {\n        if (l == null) {\n            return;\n        }\n        keyListener = AWTEventMulticaster.add(keyListener, l);\n        newEventsOnly = true;\n\n        // if this is a lightweight component, enable key events\n        // in the native container.\n        if (peer instanceof LightweightPeer) {\n            parent.proxyEnableEvents(AWTEvent.KEY_EVENT_MASK);\n        }\n    }"}
{"Number":"257","API Relative Path":"java.awt.Component.java-addMouseListener(MouseListener)","Corresponding Source":"/**\n     * Adds the specified mouse listener to receive mouse events from\n     * this component.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the mouse listener\n     * @see      java.awt.event.MouseEvent\n     * @see      java.awt.event.MouseListener\n     * @see      #removeMouseListener\n     * @see      #getMouseListeners\n     * @since    JDK1.1\n     */\n    public synchronized void addMouseListener(MouseListener l) {\n        if (l == null) {\n            return;\n        }\n        mouseListener = AWTEventMulticaster.add(mouseListener,l);\n        newEventsOnly = true;\n\n        // if this is a lightweight component, enable mouse events\n        // in the native container.\n        if (peer instanceof LightweightPeer) {\n            parent.proxyEnableEvents(AWTEvent.MOUSE_EVENT_MASK);\n        }\n    }"}
{"Number":"258","API Relative Path":"java.awt.Component.java-addMouseMotionListener(MouseMotionListener)","Corresponding Source":"/**\n     * Adds the specified mouse motion listener to receive mouse motion\n     * events from this component.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the mouse motion listener\n     * @see      java.awt.event.MouseEvent\n     * @see      java.awt.event.MouseMotionListener\n     * @see      #removeMouseMotionListener\n     * @see      #getMouseMotionListeners\n     * @since    JDK1.1\n     */\n    public synchronized void addMouseMotionListener(MouseMotionListener l) {\n        if (l == null) {\n            return;\n        }\n        mouseMotionListener = AWTEventMulticaster.add(mouseMotionListener,l);\n        newEventsOnly = true;\n\n        // if this is a lightweight component, enable mouse events\n        // in the native container.\n        if (peer instanceof LightweightPeer) {\n            parent.proxyEnableEvents(AWTEvent.MOUSE_MOTION_EVENT_MASK);\n        }\n    }"}
{"Number":"259","API Relative Path":"java.awt.Component.java-addMouseWheelListener(MouseWheelListener)","Corresponding Source":"/**\n     * Adds the specified mouse wheel listener to receive mouse wheel events\n     * from this component.  Containers also receive mouse wheel events from\n     * sub-components.\n     * <p>\n     * For information on how mouse wheel events are dispatched, see\n     * the class description for {@link MouseWheelEvent}.\n     * <p>\n     * If l is <code>null<\/code>, no exception is thrown and no\n     * action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the mouse wheel listener\n     * @see      java.awt.event.MouseWheelEvent\n     * @see      java.awt.event.MouseWheelListener\n     * @see      #removeMouseWheelListener\n     * @see      #getMouseWheelListeners\n     * @since    1.4\n     */\n    public synchronized void addMouseWheelListener(MouseWheelListener l) {\n        if (l == null) {\n            return;\n        }\n        mouseWheelListener = AWTEventMulticaster.add(mouseWheelListener,l);\n        newEventsOnly = true;\n\n        // if this is a lightweight component, enable mouse events\n        // in the native container.\n        if (peer instanceof LightweightPeer) {\n            parent.proxyEnableEvents(AWTEvent.MOUSE_WHEEL_EVENT_MASK);\n        }\n    }"}
{"Number":"260","API Relative Path":"java.awt.Component.java-addPropertyChangeListener(PropertyChangeListener)","Corresponding Source":"/**\n     * Adds a PropertyChangeListener to the listener list. The listener is\n     * registered for all bound properties of this class, including the\n     * following:\n     * <ul>\n     *    <li>this Component's font (\"font\")<\/li>\n     *    <li>this Component's background color (\"background\")<\/li>\n     *    <li>this Component's foreground color (\"foreground\")<\/li>\n     *    <li>this Component's focusability (\"focusable\")<\/li>\n     *    <li>this Component's focus traversal keys enabled state\n     *        (\"focusTraversalKeysEnabled\")<\/li>\n     *    <li>this Component's Set of FORWARD_TRAVERSAL_KEYS\n     *        (\"forwardFocusTraversalKeys\")<\/li>\n     *    <li>this Component's Set of BACKWARD_TRAVERSAL_KEYS\n     *        (\"backwardFocusTraversalKeys\")<\/li>\n     *    <li>this Component's Set of UP_CYCLE_TRAVERSAL_KEYS\n     *        (\"upCycleFocusTraversalKeys\")<\/li>\n     *    <li>this Component's preferred size (\"preferredSize\")<\/li>\n     *    <li>this Component's minimum size (\"minimumSize\")<\/li>\n     *    <li>this Component's maximum size (\"maximumSize\")<\/li>\n     *    <li>this Component's name (\"name\")<\/li>\n     * <\/ul>\n     * Note that if this <code>Component<\/code> is inheriting a bound property, then no\n     * event will be fired in response to a change in the inherited property.\n     * <p>\n     * If <code>listener<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     *\n     * @param    listener  the property change listener to be added\n     *\n     * @see #removePropertyChangeListener\n     * @see #getPropertyChangeListeners\n     * @see #addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)\n     */\n    public void addPropertyChangeListener(\n                                                       PropertyChangeListener listener) {\n        synchronized (getObjectLock()) {\n            if (listener == null) {\n                return;\n            }\n            if (changeSupport == null) {\n                changeSupport = new PropertyChangeSupport(this);\n            }\n            changeSupport.addPropertyChangeListener(listener);\n        }\n    }"}
{"Number":"261","API Relative Path":"java.awt.Component.java-addPropertyChangeListener(String-PropertyChangeListener)","Corresponding Source":"/**\n     * Adds a PropertyChangeListener to the listener list for a specific\n     * property. The specified property may be user-defined, or one of the\n     * following:\n     * <ul>\n     *    <li>this Component's font (\"font\")<\/li>\n     *    <li>this Component's background color (\"background\")<\/li>\n     *    <li>this Component's foreground color (\"foreground\")<\/li>\n     *    <li>this Component's focusability (\"focusable\")<\/li>\n     *    <li>this Component's focus traversal keys enabled state\n     *        (\"focusTraversalKeysEnabled\")<\/li>\n     *    <li>this Component's Set of FORWARD_TRAVERSAL_KEYS\n     *        (\"forwardFocusTraversalKeys\")<\/li>\n     *    <li>this Component's Set of BACKWARD_TRAVERSAL_KEYS\n     *        (\"backwardFocusTraversalKeys\")<\/li>\n     *    <li>this Component's Set of UP_CYCLE_TRAVERSAL_KEYS\n     *        (\"upCycleFocusTraversalKeys\")<\/li>\n     * <\/ul>\n     * Note that if this <code>Component<\/code> is inheriting a bound property, then no\n     * event will be fired in response to a change in the inherited property.\n     * <p>\n     * If <code>propertyName<\/code> or <code>listener<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is taken.\n     *\n     * @param propertyName one of the property names listed above\n     * @param listener the property change listener to be added\n     *\n     * @see #removePropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)\n     * @see #getPropertyChangeListeners(java.lang.String)\n     * @see #addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)\n     */\n    public void addPropertyChangeListener(\n                                                       String propertyName,\n                                                       PropertyChangeListener listener) {\n        synchronized (getObjectLock()) {\n            if (listener == null) {\n                return;\n            }\n            if (changeSupport == null) {\n                changeSupport = new PropertyChangeSupport(this);\n            }\n            changeSupport.addPropertyChangeListener(propertyName, listener);\n        }\n    }"}
{"Number":"262","API Relative Path":"java.awt.Component.java-areFocusTraversalKeysSet(int)","Corresponding Source":"/**\n     * Returns whether the Set of focus traversal keys for the given focus\n     * traversal operation has been explicitly defined for this Component. If\n     * this method returns <code>false<\/code>, this Component is inheriting the\n     * Set from an ancestor, or from the current KeyboardFocusManager.\n     *\n     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or\n     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS\n     * @return <code>true<\/code> if the the Set of focus traversal keys for the\n     *         given focus traversal operation has been explicitly defined for\n     *         this Component; <code>false<\/code> otherwise.\n     * @throws IllegalArgumentException if id is not one of\n     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or\n     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS\n     * @since 1.4\n     */\n    public boolean areFocusTraversalKeysSet(int id) {\n        if (id < 0 || id >= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH - 1) {\n            throw new IllegalArgumentException(\"invalid focus traversal key identifier\");\n        }\n\n        return (focusTraversalKeys != null && focusTraversalKeys[id] != null);\n    }"}
{"Number":"263","API Relative Path":"java.awt.Component.java-getFocusTraversalKeys(int)","Corresponding Source":"/**\n     * Returns the Set of focus traversal keys for a given traversal operation\n     * for this Component. (See\n     * <code>setFocusTraversalKeys<\/code> for a full description of each key.)\n     * <p>\n     * If a Set of traversal keys has not been explicitly defined for this\n     * Component, then this Component's parent's Set is returned. If no Set\n     * has been explicitly defined for any of this Component's ancestors, then\n     * the current KeyboardFocusManager's default Set is returned.\n     *\n     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or\n     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS\n     * @return the Set of AWTKeyStrokes for the specified operation. The Set\n     *         will be unmodifiable, and may be empty. null will never be\n     *         returned.\n     * @see #setFocusTraversalKeys\n     * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS\n     * @throws IllegalArgumentException if id is not one of\n     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or\n     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS\n     * @since 1.4\n     */\n    public Set<AWTKeyStroke> getFocusTraversalKeys(int id) {\n        if (id < 0 || id >= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH - 1) {\n            throw new IllegalArgumentException(\"invalid focus traversal key identifier\");\n        }\n\n        return getFocusTraversalKeys_NoIDCheck(id);\n    }"}
{"Number":"264","API Relative Path":"java.awt.Component.java-getFocusTraversalKeys(int)","Corresponding Source":"/**\n     * Returns the Set of focus traversal keys for a given traversal operation\n     * for this Component. (See\n     * <code>setFocusTraversalKeys<\/code> for a full description of each key.)\n     * <p>\n     * If a Set of traversal keys has not been explicitly defined for this\n     * Component, then this Component's parent's Set is returned. If no Set\n     * has been explicitly defined for any of this Component's ancestors, then\n     * the current KeyboardFocusManager's default Set is returned.\n     *\n     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or\n     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS\n     * @return the Set of AWTKeyStrokes for the specified operation. The Set\n     *         will be unmodifiable, and may be empty. null will never be\n     *         returned.\n     * @see #setFocusTraversalKeys\n     * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS\n     * @throws IllegalArgumentException if id is not one of\n     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or\n     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS\n     * @since 1.4\n     */\n    public Set<AWTKeyStroke> getFocusTraversalKeys(int id) {\n        if (id < 0 || id >= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH - 1) {\n            throw new IllegalArgumentException(\"invalid focus traversal key identifier\");\n        }\n\n        return getFocusTraversalKeys_NoIDCheck(id);\n    }"}
{"Number":"265","API Relative Path":"java.awt.Component.java-getFocusTraversalKeys(int)","Corresponding Source":"/**\n     * Returns the Set of focus traversal keys for a given traversal operation\n     * for this Component. (See\n     * <code>setFocusTraversalKeys<\/code> for a full description of each key.)\n     * <p>\n     * If a Set of traversal keys has not been explicitly defined for this\n     * Component, then this Component's parent's Set is returned. If no Set\n     * has been explicitly defined for any of this Component's ancestors, then\n     * the current KeyboardFocusManager's default Set is returned.\n     *\n     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or\n     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS\n     * @return the Set of AWTKeyStrokes for the specified operation. The Set\n     *         will be unmodifiable, and may be empty. null will never be\n     *         returned.\n     * @see #setFocusTraversalKeys\n     * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS\n     * @throws IllegalArgumentException if id is not one of\n     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or\n     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS\n     * @since 1.4\n     */\n    public Set<AWTKeyStroke> getFocusTraversalKeys(int id) {\n        if (id < 0 || id >= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH - 1) {\n            throw new IllegalArgumentException(\"invalid focus traversal key identifier\");\n        }\n\n        return getFocusTraversalKeys_NoIDCheck(id);\n    }"}
{"Number":"266","API Relative Path":"java.awt.Component.java-removeComponentListener(ComponentListener)","Corresponding Source":"/**\n     * Removes the specified component listener so that it no longer\n     * receives component events from this component. This method performs\n     * no function, nor does it throw an exception, if the listener\n     * specified by the argument was not previously added to this component.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     * @param    l   the component listener\n     * @see      java.awt.event.ComponentEvent\n     * @see      java.awt.event.ComponentListener\n     * @see      #addComponentListener\n     * @see      #getComponentListeners\n     * @since    JDK1.1\n     */\n    public synchronized void removeComponentListener(ComponentListener l) {\n        if (l == null) {\n            return;\n        }\n        componentListener = AWTEventMulticaster.remove(componentListener, l);\n    }"}
{"Number":"267","API Relative Path":"java.awt.Component.java-removeComponentListener(ComponentListener)","Corresponding Source":"/**\n     * Removes the specified component listener so that it no longer\n     * receives component events from this component. This method performs\n     * no function, nor does it throw an exception, if the listener\n     * specified by the argument was not previously added to this component.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     * @param    l   the component listener\n     * @see      java.awt.event.ComponentEvent\n     * @see      java.awt.event.ComponentListener\n     * @see      #addComponentListener\n     * @see      #getComponentListeners\n     * @since    JDK1.1\n     */\n    public synchronized void removeComponentListener(ComponentListener l) {\n        if (l == null) {\n            return;\n        }\n        componentListener = AWTEventMulticaster.remove(componentListener, l);\n    }"}
{"Number":"268","API Relative Path":"java.awt.Component.java-removeFocusListener(FocusListener)","Corresponding Source":"/**\n     * Removes the specified focus listener so that it no longer\n     * receives focus events from this component. This method performs\n     * no function, nor does it throw an exception, if the listener\n     * specified by the argument was not previously added to this component.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the focus listener\n     * @see      java.awt.event.FocusEvent\n     * @see      java.awt.event.FocusListener\n     * @see      #addFocusListener\n     * @see      #getFocusListeners\n     * @since    JDK1.1\n     */\n    public synchronized void removeFocusListener(FocusListener l) {\n        if (l == null) {\n            return;\n        }\n        focusListener = AWTEventMulticaster.remove(focusListener, l);\n    }"}
{"Number":"269","API Relative Path":"java.awt.Component.java-removeFocusListener(FocusListener)","Corresponding Source":"/**\n     * Removes the specified focus listener so that it no longer\n     * receives focus events from this component. This method performs\n     * no function, nor does it throw an exception, if the listener\n     * specified by the argument was not previously added to this component.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the focus listener\n     * @see      java.awt.event.FocusEvent\n     * @see      java.awt.event.FocusListener\n     * @see      #addFocusListener\n     * @see      #getFocusListeners\n     * @since    JDK1.1\n     */\n    public synchronized void removeFocusListener(FocusListener l) {\n        if (l == null) {\n            return;\n        }\n        focusListener = AWTEventMulticaster.remove(focusListener, l);\n    }"}
{"Number":"270","API Relative Path":"java.awt.Component.java-removeHierarchyBoundsListener(HierarchyBoundsListener)","Corresponding Source":"/**\n     * Removes the specified hierarchy bounds listener so that it no longer\n     * receives hierarchy bounds events from this component. This method\n     * performs no function, nor does it throw an exception, if the listener\n     * specified by the argument was not previously added to this component.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the hierarchy bounds listener\n     * @see      java.awt.event.HierarchyEvent\n     * @see      java.awt.event.HierarchyBoundsListener\n     * @see      #addHierarchyBoundsListener\n     * @see      #getHierarchyBoundsListeners\n     * @since    1.3\n     */\n    public void removeHierarchyBoundsListener(HierarchyBoundsListener l) {\n        if (l == null) {\n            return;\n        }\n        boolean notifyAncestors;\n        synchronized (this) {\n            notifyAncestors =\n                (hierarchyBoundsListener != null &&\n                 (eventMask & AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) == 0);\n            hierarchyBoundsListener =\n                AWTEventMulticaster.remove(hierarchyBoundsListener, l);\n            notifyAncestors = (notifyAncestors &&\n                               hierarchyBoundsListener == null);\n        }\n        if (notifyAncestors) {\n            synchronized (getTreeLock()) {\n                adjustListeningChildrenOnParent(\n                                                AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK, -1);\n            }\n        }\n    }"}
{"Number":"271","API Relative Path":"java.awt.Component.java-removeHierarchyBoundsListener(HierarchyBoundsListener)","Corresponding Source":"/**\n     * Removes the specified hierarchy bounds listener so that it no longer\n     * receives hierarchy bounds events from this component. This method\n     * performs no function, nor does it throw an exception, if the listener\n     * specified by the argument was not previously added to this component.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the hierarchy bounds listener\n     * @see      java.awt.event.HierarchyEvent\n     * @see      java.awt.event.HierarchyBoundsListener\n     * @see      #addHierarchyBoundsListener\n     * @see      #getHierarchyBoundsListeners\n     * @since    1.3\n     */\n    public void removeHierarchyBoundsListener(HierarchyBoundsListener l) {\n        if (l == null) {\n            return;\n        }\n        boolean notifyAncestors;\n        synchronized (this) {\n            notifyAncestors =\n                (hierarchyBoundsListener != null &&\n                 (eventMask & AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) == 0);\n            hierarchyBoundsListener =\n                AWTEventMulticaster.remove(hierarchyBoundsListener, l);\n            notifyAncestors = (notifyAncestors &&\n                               hierarchyBoundsListener == null);\n        }\n        if (notifyAncestors) {\n            synchronized (getTreeLock()) {\n                adjustListeningChildrenOnParent(\n                                                AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK, -1);\n            }\n        }\n    }"}
{"Number":"272","API Relative Path":"java.awt.Component.java-removeHierarchyListener(HierarchyListener)","Corresponding Source":"/**\n     * Removes the specified hierarchy listener so that it no longer\n     * receives hierarchy changed events from this component. This method\n     * performs no function, nor does it throw an exception, if the listener\n     * specified by the argument was not previously added to this component.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the hierarchy listener\n     * @see      java.awt.event.HierarchyEvent\n     * @see      java.awt.event.HierarchyListener\n     * @see      #addHierarchyListener\n     * @see      #getHierarchyListeners\n     * @since    1.3\n     */\n    public void removeHierarchyListener(HierarchyListener l) {\n        if (l == null) {\n            return;\n        }\n        boolean notifyAncestors;\n        synchronized (this) {\n            notifyAncestors =\n                (hierarchyListener != null &&\n                 (eventMask & AWTEvent.HIERARCHY_EVENT_MASK) == 0);\n            hierarchyListener =\n                AWTEventMulticaster.remove(hierarchyListener, l);\n            notifyAncestors = (notifyAncestors && hierarchyListener == null);\n        }\n        if (notifyAncestors) {\n            synchronized (getTreeLock()) {\n                adjustListeningChildrenOnParent(AWTEvent.HIERARCHY_EVENT_MASK,\n                                                -1);\n            }\n        }\n    }"}
{"Number":"273","API Relative Path":"java.awt.Component.java-removeHierarchyListener(HierarchyListener)","Corresponding Source":"/**\n     * Removes the specified hierarchy listener so that it no longer\n     * receives hierarchy changed events from this component. This method\n     * performs no function, nor does it throw an exception, if the listener\n     * specified by the argument was not previously added to this component.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the hierarchy listener\n     * @see      java.awt.event.HierarchyEvent\n     * @see      java.awt.event.HierarchyListener\n     * @see      #addHierarchyListener\n     * @see      #getHierarchyListeners\n     * @since    1.3\n     */\n    public void removeHierarchyListener(HierarchyListener l) {\n        if (l == null) {\n            return;\n        }\n        boolean notifyAncestors;\n        synchronized (this) {\n            notifyAncestors =\n                (hierarchyListener != null &&\n                 (eventMask & AWTEvent.HIERARCHY_EVENT_MASK) == 0);\n            hierarchyListener =\n                AWTEventMulticaster.remove(hierarchyListener, l);\n            notifyAncestors = (notifyAncestors && hierarchyListener == null);\n        }\n        if (notifyAncestors) {\n            synchronized (getTreeLock()) {\n                adjustListeningChildrenOnParent(AWTEvent.HIERARCHY_EVENT_MASK,\n                                                -1);\n            }\n        }\n    }"}
{"Number":"274","API Relative Path":"java.awt.Component.java-removeInputMethodListener(InputMethodListener)","Corresponding Source":"/**\n     * Removes the specified input method listener so that it no longer\n     * receives input method events from this component. This method performs\n     * no function, nor does it throw an exception, if the listener\n     * specified by the argument was not previously added to this component.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the input method listener\n     * @see      java.awt.event.InputMethodEvent\n     * @see      java.awt.event.InputMethodListener\n     * @see      #addInputMethodListener\n     * @see      #getInputMethodListeners\n     * @since    1.2\n     */\n    public synchronized void removeInputMethodListener(InputMethodListener l) {\n        if (l == null) {\n            return;\n        }\n        inputMethodListener = AWTEventMulticaster.remove(inputMethodListener, l);\n    }"}
{"Number":"275","API Relative Path":"java.awt.Component.java-removeInputMethodListener(InputMethodListener)","Corresponding Source":"/**\n     * Removes the specified input method listener so that it no longer\n     * receives input method events from this component. This method performs\n     * no function, nor does it throw an exception, if the listener\n     * specified by the argument was not previously added to this component.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the input method listener\n     * @see      java.awt.event.InputMethodEvent\n     * @see      java.awt.event.InputMethodListener\n     * @see      #addInputMethodListener\n     * @see      #getInputMethodListeners\n     * @since    1.2\n     */\n    public synchronized void removeInputMethodListener(InputMethodListener l) {\n        if (l == null) {\n            return;\n        }\n        inputMethodListener = AWTEventMulticaster.remove(inputMethodListener, l);\n    }"}
{"Number":"276","API Relative Path":"java.awt.Component.java-removeKeyListener(KeyListener)","Corresponding Source":"/**\n     * Removes the specified key listener so that it no longer\n     * receives key events from this component. This method performs\n     * no function, nor does it throw an exception, if the listener\n     * specified by the argument was not previously added to this component.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the key listener\n     * @see      java.awt.event.KeyEvent\n     * @see      java.awt.event.KeyListener\n     * @see      #addKeyListener\n     * @see      #getKeyListeners\n     * @since    JDK1.1\n     */\n    public synchronized void removeKeyListener(KeyListener l) {\n        if (l == null) {\n            return;\n        }\n        keyListener = AWTEventMulticaster.remove(keyListener, l);\n    }"}
{"Number":"277","API Relative Path":"java.awt.Component.java-removeKeyListener(KeyListener)","Corresponding Source":"/**\n     * Removes the specified key listener so that it no longer\n     * receives key events from this component. This method performs\n     * no function, nor does it throw an exception, if the listener\n     * specified by the argument was not previously added to this component.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the key listener\n     * @see      java.awt.event.KeyEvent\n     * @see      java.awt.event.KeyListener\n     * @see      #addKeyListener\n     * @see      #getKeyListeners\n     * @since    JDK1.1\n     */\n    public synchronized void removeKeyListener(KeyListener l) {\n        if (l == null) {\n            return;\n        }\n        keyListener = AWTEventMulticaster.remove(keyListener, l);\n    }"}
{"Number":"278","API Relative Path":"java.awt.Component.java-removeMouseListener(MouseListener)","Corresponding Source":"/**\n     * Removes the specified mouse listener so that it no longer\n     * receives mouse events from this component. This method performs\n     * no function, nor does it throw an exception, if the listener\n     * specified by the argument was not previously added to this component.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the mouse listener\n     * @see      java.awt.event.MouseEvent\n     * @see      java.awt.event.MouseListener\n     * @see      #addMouseListener\n     * @see      #getMouseListeners\n     * @since    JDK1.1\n     */\n    public synchronized void removeMouseListener(MouseListener l) {\n        if (l == null) {\n            return;\n        }\n        mouseListener = AWTEventMulticaster.remove(mouseListener, l);\n    }"}
{"Number":"279","API Relative Path":"java.awt.Component.java-removeMouseListener(MouseListener)","Corresponding Source":"/**\n     * Removes the specified mouse listener so that it no longer\n     * receives mouse events from this component. This method performs\n     * no function, nor does it throw an exception, if the listener\n     * specified by the argument was not previously added to this component.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the mouse listener\n     * @see      java.awt.event.MouseEvent\n     * @see      java.awt.event.MouseListener\n     * @see      #addMouseListener\n     * @see      #getMouseListeners\n     * @since    JDK1.1\n     */\n    public synchronized void removeMouseListener(MouseListener l) {\n        if (l == null) {\n            return;\n        }\n        mouseListener = AWTEventMulticaster.remove(mouseListener, l);\n    }"}
{"Number":"280","API Relative Path":"java.awt.Component.java-removeMouseMotionListener(MouseMotionListener)","Corresponding Source":"/**\n     * Removes the specified mouse motion listener so that it no longer\n     * receives mouse motion events from this component. This method performs\n     * no function, nor does it throw an exception, if the listener\n     * specified by the argument was not previously added to this component.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the mouse motion listener\n     * @see      java.awt.event.MouseEvent\n     * @see      java.awt.event.MouseMotionListener\n     * @see      #addMouseMotionListener\n     * @see      #getMouseMotionListeners\n     * @since    JDK1.1\n     */\n    public synchronized void removeMouseMotionListener(MouseMotionListener l) {\n        if (l == null) {\n            return;\n        }\n        mouseMotionListener = AWTEventMulticaster.remove(mouseMotionListener, l);\n    }"}
{"Number":"281","API Relative Path":"java.awt.Component.java-removeMouseMotionListener(MouseMotionListener)","Corresponding Source":"/**\n     * Removes the specified mouse motion listener so that it no longer\n     * receives mouse motion events from this component. This method performs\n     * no function, nor does it throw an exception, if the listener\n     * specified by the argument was not previously added to this component.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the mouse motion listener\n     * @see      java.awt.event.MouseEvent\n     * @see      java.awt.event.MouseMotionListener\n     * @see      #addMouseMotionListener\n     * @see      #getMouseMotionListeners\n     * @since    JDK1.1\n     */\n    public synchronized void removeMouseMotionListener(MouseMotionListener l) {\n        if (l == null) {\n            return;\n        }\n        mouseMotionListener = AWTEventMulticaster.remove(mouseMotionListener, l);\n    }"}
{"Number":"282","API Relative Path":"java.awt.Component.java-removeMouseWheelListener(MouseWheelListener)","Corresponding Source":"/**\n     * Removes the specified mouse wheel listener so that it no longer\n     * receives mouse wheel events from this component. This method performs\n     * no function, nor does it throw an exception, if the listener\n     * specified by the argument was not previously added to this component.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the mouse wheel listener.\n     * @see      java.awt.event.MouseWheelEvent\n     * @see      java.awt.event.MouseWheelListener\n     * @see      #addMouseWheelListener\n     * @see      #getMouseWheelListeners\n     * @since    1.4\n     */\n    public synchronized void removeMouseWheelListener(MouseWheelListener l) {\n        if (l == null) {\n            return;\n        }\n        mouseWheelListener = AWTEventMulticaster.remove(mouseWheelListener, l);\n    }"}
{"Number":"283","API Relative Path":"java.awt.Component.java-removeMouseWheelListener(MouseWheelListener)","Corresponding Source":"/**\n     * Removes the specified mouse wheel listener so that it no longer\n     * receives mouse wheel events from this component. This method performs\n     * no function, nor does it throw an exception, if the listener\n     * specified by the argument was not previously added to this component.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the mouse wheel listener.\n     * @see      java.awt.event.MouseWheelEvent\n     * @see      java.awt.event.MouseWheelListener\n     * @see      #addMouseWheelListener\n     * @see      #getMouseWheelListeners\n     * @since    1.4\n     */\n    public synchronized void removeMouseWheelListener(MouseWheelListener l) {\n        if (l == null) {\n            return;\n        }\n        mouseWheelListener = AWTEventMulticaster.remove(mouseWheelListener, l);\n    }"}
{"Number":"284","API Relative Path":"java.awt.Component.java-removePropertyChangeListener(PropertyChangeListener)","Corresponding Source":"/**\n     * Removes a PropertyChangeListener from the listener list. This method\n     * should be used to remove PropertyChangeListeners that were registered\n     * for all bound properties of this class.\n     * <p>\n     * If listener is null, no exception is thrown and no action is performed.\n     *\n     * @param listener the PropertyChangeListener to be removed\n     *\n     * @see #addPropertyChangeListener\n     * @see #getPropertyChangeListeners\n     * @see #removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)\n     */\n    public void removePropertyChangeListener(\n                                                          PropertyChangeListener listener) {\n        synchronized (getObjectLock()) {\n            if (listener == null || changeSupport == null) {\n                return;\n            }\n            changeSupport.removePropertyChangeListener(listener);\n        }\n    }"}
{"Number":"285","API Relative Path":"java.awt.Component.java-removePropertyChangeListener(String-PropertyChangeListener)","Corresponding Source":"/**\n     * Removes a <code>PropertyChangeListener<\/code> from the listener\n     * list for a specific property. This method should be used to remove\n     * <code>PropertyChangeListener<\/code>s\n     * that were registered for a specific bound property.\n     * <p>\n     * If <code>propertyName<\/code> or <code>listener<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is taken.\n     *\n     * @param propertyName a valid property name\n     * @param listener the PropertyChangeListener to be removed\n     *\n     * @see #addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)\n     * @see #getPropertyChangeListeners(java.lang.String)\n     * @see #removePropertyChangeListener(java.beans.PropertyChangeListener)\n     */\n    public void removePropertyChangeListener(\n                                                          String propertyName,\n                                                          PropertyChangeListener listener) {\n        synchronized (getObjectLock()) {\n            if (listener == null || changeSupport == null) {\n                return;\n            }\n            changeSupport.removePropertyChangeListener(propertyName, listener);\n        }\n    }"}
{"Number":"286","API Relative Path":"java.awt.Component.java-setFocusTraversalKeys(int-Set)","Corresponding Source":"/**\n     * Sets the focus traversal keys for a given traversal operation for this\n     * Component.\n     * <p>\n     * The default values for a Component's focus traversal keys are\n     * implementation-dependent. Sun recommends that all implementations for a\n     * particular native platform use the same default values. The\n     * recommendations for Windows and Unix are listed below. These\n     * recommendations are used in the Sun AWT implementations.\n     *\n     * <table border=1 summary=\"Recommended default values for a Component's focus traversal keys\">\n     * <tr>\n     *    <th>Identifier<\/th>\n     *    <th>Meaning<\/th>\n     *    <th>Default<\/th>\n     * <\/tr>\n     * <tr>\n     *    <td>KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS<\/td>\n     *    <td>Normal forward keyboard traversal<\/td>\n     *    <td>TAB on KEY_PRESSED, CTRL-TAB on KEY_PRESSED<\/td>\n     * <\/tr>\n     * <tr>\n     *    <td>KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS<\/td>\n     *    <td>Normal reverse keyboard traversal<\/td>\n     *    <td>SHIFT-TAB on KEY_PRESSED, CTRL-SHIFT-TAB on KEY_PRESSED<\/td>\n     * <\/tr>\n     * <tr>\n     *    <td>KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS<\/td>\n     *    <td>Go up one focus traversal cycle<\/td>\n     *    <td>none<\/td>\n     * <\/tr>\n     * <\/table>\n     *\n     * To disable a traversal key, use an empty Set; Collections.EMPTY_SET is\n     * recommended.\n     * <p>\n     * Using the AWTKeyStroke API, client code can specify on which of two\n     * specific KeyEvents, KEY_PRESSED or KEY_RELEASED, the focus traversal\n     * operation will occur. Regardless of which KeyEvent is specified,\n     * however, all KeyEvents related to the focus traversal key, including the\n     * associated KEY_TYPED event, will be consumed, and will not be dispatched\n     * to any Component. It is a runtime error to specify a KEY_TYPED event as\n     * mapping to a focus traversal operation, or to map the same event to\n     * multiple default focus traversal operations.\n     * <p>\n     * If a value of null is specified for the Set, this Component inherits the\n     * Set from its parent. If all ancestors of this Component have null\n     * specified for the Set, then the current KeyboardFocusManager's default\n     * Set is used.\n     * <p>\n     * This method may throw a {@code ClassCastException} if any {@code Object}\n     * in {@code keystrokes} is not an {@code AWTKeyStroke}.\n     *\n     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or\n     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS\n     * @param keystrokes the Set of AWTKeyStroke for the specified operation\n     * @see #getFocusTraversalKeys\n     * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS\n     * @throws IllegalArgumentException if id is not one of\n     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or\n     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or if keystrokes\n     *         contains null, or if any keystroke represents a KEY_TYPED event,\n     *         or if any keystroke already maps to another focus traversal\n     *         operation for this Component\n     * @since 1.4\n     * @beaninfo\n     *       bound: true\n     */\n    public void setFocusTraversalKeys(int id,\n                                      Set<? extends AWTKeyStroke> keystrokes)\n    {\n        if (id < 0 || id >= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH - 1) {\n            throw new IllegalArgumentException(\"invalid focus traversal key identifier\");\n        }\n\n        setFocusTraversalKeys_NoIDCheck(id, keystrokes);\n    }"}
{"Number":"287","API Relative Path":"java.awt.Container.java-add(Component)","Corresponding Source":"/**\n     * Appends the specified component to the end of this container.\n     * This is a convenience method for {@link #addImpl}.\n     * <p>\n     * This method changes layout-related information, and therefore,\n     * invalidates the component hierarchy. If the container has already been\n     * displayed, the hierarchy must be validated thereafter in order to\n     * display the added component.\n     *\n     * @param     comp   the component to be added\n     * @exception NullPointerException if {@code comp} is {@code null}\n     * @see #addImpl\n     * @see #invalidate\n     * @see #validate\n     * @see javax.swing.JComponent#revalidate()\n     * @return    the component argument\n     */\n    public Component add(Component comp) {\n        addImpl(comp, null, -1);\n        return comp;\n    }"}
{"Number":"288","API Relative Path":"java.awt.Container.java-add(Component)","Corresponding Source":"/**\n     * Appends the specified component to the end of this container.\n     * This is a convenience method for {@link #addImpl}.\n     * <p>\n     * This method changes layout-related information, and therefore,\n     * invalidates the component hierarchy. If the container has already been\n     * displayed, the hierarchy must be validated thereafter in order to\n     * display the added component.\n     *\n     * @param     comp   the component to be added\n     * @exception NullPointerException if {@code comp} is {@code null}\n     * @see #addImpl\n     * @see #invalidate\n     * @see #validate\n     * @see javax.swing.JComponent#revalidate()\n     * @return    the component argument\n     */\n    public Component add(Component comp) {\n        addImpl(comp, null, -1);\n        return comp;\n    }"}
{"Number":"289","API Relative Path":"java.awt.Container.java-add(Component-int)","Corresponding Source":"/**\n     * Adds the specified component to this container at the given\n     * position.\n     * This is a convenience method for {@link #addImpl}.\n     * <p>\n     * This method changes layout-related information, and therefore,\n     * invalidates the component hierarchy. If the container has already been\n     * displayed, the hierarchy must be validated thereafter in order to\n     * display the added component.\n     *\n     *\n     * @param     comp   the component to be added\n     * @param     index    the position at which to insert the component,\n     *                   or <code>-1<\/code> to append the component to the end\n     * @exception NullPointerException if {@code comp} is {@code null}\n     * @exception IllegalArgumentException if {@code index} is invalid (see\n     *            {@link #addImpl} for details)\n     * @return    the component <code>comp<\/code>\n     * @see #addImpl\n     * @see #remove\n     * @see #invalidate\n     * @see #validate\n     * @see javax.swing.JComponent#revalidate()\n     */\n    public Component add(Component comp, int index) {\n        addImpl(comp, null, index);\n        return comp;\n    }"}
{"Number":"290","API Relative Path":"java.awt.Container.java-add(Component-int)","Corresponding Source":"/**\n     * Adds the specified component to this container at the given\n     * position.\n     * This is a convenience method for {@link #addImpl}.\n     * <p>\n     * This method changes layout-related information, and therefore,\n     * invalidates the component hierarchy. If the container has already been\n     * displayed, the hierarchy must be validated thereafter in order to\n     * display the added component.\n     *\n     *\n     * @param     comp   the component to be added\n     * @param     index    the position at which to insert the component,\n     *                   or <code>-1<\/code> to append the component to the end\n     * @exception NullPointerException if {@code comp} is {@code null}\n     * @exception IllegalArgumentException if {@code index} is invalid (see\n     *            {@link #addImpl} for details)\n     * @return    the component <code>comp<\/code>\n     * @see #addImpl\n     * @see #remove\n     * @see #invalidate\n     * @see #validate\n     * @see javax.swing.JComponent#revalidate()\n     */\n    public Component add(Component comp, int index) {\n        addImpl(comp, null, index);\n        return comp;\n    }"}
{"Number":"291","API Relative Path":"java.awt.Container.java-add(Component-int)","Corresponding Source":"/**\n     * Adds the specified component to this container at the given\n     * position.\n     * This is a convenience method for {@link #addImpl}.\n     * <p>\n     * This method changes layout-related information, and therefore,\n     * invalidates the component hierarchy. If the container has already been\n     * displayed, the hierarchy must be validated thereafter in order to\n     * display the added component.\n     *\n     *\n     * @param     comp   the component to be added\n     * @param     index    the position at which to insert the component,\n     *                   or <code>-1<\/code> to append the component to the end\n     * @exception NullPointerException if {@code comp} is {@code null}\n     * @exception IllegalArgumentException if {@code index} is invalid (see\n     *            {@link #addImpl} for details)\n     * @return    the component <code>comp<\/code>\n     * @see #addImpl\n     * @see #remove\n     * @see #invalidate\n     * @see #validate\n     * @see javax.swing.JComponent#revalidate()\n     */\n    public Component add(Component comp, int index) {\n        addImpl(comp, null, index);\n        return comp;\n    }"}
{"Number":"292","API Relative Path":"java.awt.Container.java-add(Component-Object)","Corresponding Source":"/**\n     * Adds the specified component to the end of this container.\n     * Also notifies the layout manager to add the component to\n     * this container's layout using the specified constraints object.\n     * This is a convenience method for {@link #addImpl}.\n     * <p>\n     * This method changes layout-related information, and therefore,\n     * invalidates the component hierarchy. If the container has already been\n     * displayed, the hierarchy must be validated thereafter in order to\n     * display the added component.\n     *\n     *\n     * @param     comp the component to be added\n     * @param     constraints an object expressing\n     *                  layout constraints for this component\n     * @exception NullPointerException if {@code comp} is {@code null}\n     * @see #addImpl\n     * @see #invalidate\n     * @see #validate\n     * @see javax.swing.JComponent#revalidate()\n     * @see       LayoutManager\n     * @since     JDK1.1\n     */\n    public void add(Component comp, Object constraints) {\n        addImpl(comp, constraints, -1);\n    }"}
{"Number":"293","API Relative Path":"java.awt.Container.java-add(Component-Object)","Corresponding Source":"/**\n     * Adds the specified component to the end of this container.\n     * Also notifies the layout manager to add the component to\n     * this container's layout using the specified constraints object.\n     * This is a convenience method for {@link #addImpl}.\n     * <p>\n     * This method changes layout-related information, and therefore,\n     * invalidates the component hierarchy. If the container has already been\n     * displayed, the hierarchy must be validated thereafter in order to\n     * display the added component.\n     *\n     *\n     * @param     comp the component to be added\n     * @param     constraints an object expressing\n     *                  layout constraints for this component\n     * @exception NullPointerException if {@code comp} is {@code null}\n     * @see #addImpl\n     * @see #invalidate\n     * @see #validate\n     * @see javax.swing.JComponent#revalidate()\n     * @see       LayoutManager\n     * @since     JDK1.1\n     */\n    public void add(Component comp, Object constraints) {\n        addImpl(comp, constraints, -1);\n    }"}
{"Number":"294","API Relative Path":"java.awt.Container.java-add(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified component to this container with the specified\n     * constraints at the specified index.  Also notifies the layout\n     * manager to add the component to the this container's layout using\n     * the specified constraints object.\n     * This is a convenience method for {@link #addImpl}.\n     * <p>\n     * This method changes layout-related information, and therefore,\n     * invalidates the component hierarchy. If the container has already been\n     * displayed, the hierarchy must be validated thereafter in order to\n     * display the added component.\n     *\n     *\n     * @param comp the component to be added\n     * @param constraints an object expressing layout constraints for this\n     * @param index the position in the container's list at which to insert\n     * the component; <code>-1<\/code> means insert at the end\n     * component\n     * @exception NullPointerException if {@code comp} is {@code null}\n     * @exception IllegalArgumentException if {@code index} is invalid (see\n     *            {@link #addImpl} for details)\n     * @see #addImpl\n     * @see #invalidate\n     * @see #validate\n     * @see javax.swing.JComponent#revalidate()\n     * @see #remove\n     * @see LayoutManager\n     */\n    public void add(Component comp, Object constraints, int index) {\n       addImpl(comp, constraints, index);\n    }"}
{"Number":"295","API Relative Path":"java.awt.Container.java-add(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified component to this container with the specified\n     * constraints at the specified index.  Also notifies the layout\n     * manager to add the component to the this container's layout using\n     * the specified constraints object.\n     * This is a convenience method for {@link #addImpl}.\n     * <p>\n     * This method changes layout-related information, and therefore,\n     * invalidates the component hierarchy. If the container has already been\n     * displayed, the hierarchy must be validated thereafter in order to\n     * display the added component.\n     *\n     *\n     * @param comp the component to be added\n     * @param constraints an object expressing layout constraints for this\n     * @param index the position in the container's list at which to insert\n     * the component; <code>-1<\/code> means insert at the end\n     * component\n     * @exception NullPointerException if {@code comp} is {@code null}\n     * @exception IllegalArgumentException if {@code index} is invalid (see\n     *            {@link #addImpl} for details)\n     * @see #addImpl\n     * @see #invalidate\n     * @see #validate\n     * @see javax.swing.JComponent#revalidate()\n     * @see #remove\n     * @see LayoutManager\n     */\n    public void add(Component comp, Object constraints, int index) {\n       addImpl(comp, constraints, index);\n    }"}
{"Number":"296","API Relative Path":"java.awt.Container.java-add(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified component to this container with the specified\n     * constraints at the specified index.  Also notifies the layout\n     * manager to add the component to the this container's layout using\n     * the specified constraints object.\n     * This is a convenience method for {@link #addImpl}.\n     * <p>\n     * This method changes layout-related information, and therefore,\n     * invalidates the component hierarchy. If the container has already been\n     * displayed, the hierarchy must be validated thereafter in order to\n     * display the added component.\n     *\n     *\n     * @param comp the component to be added\n     * @param constraints an object expressing layout constraints for this\n     * @param index the position in the container's list at which to insert\n     * the component; <code>-1<\/code> means insert at the end\n     * component\n     * @exception NullPointerException if {@code comp} is {@code null}\n     * @exception IllegalArgumentException if {@code index} is invalid (see\n     *            {@link #addImpl} for details)\n     * @see #addImpl\n     * @see #invalidate\n     * @see #validate\n     * @see javax.swing.JComponent#revalidate()\n     * @see #remove\n     * @see LayoutManager\n     */\n    public void add(Component comp, Object constraints, int index) {\n       addImpl(comp, constraints, index);\n    }"}
{"Number":"297","API Relative Path":"java.awt.Container.java-add(String-Component)","Corresponding Source":"/**\n     * Adds the specified component to this container.\n     * This is a convenience method for {@link #addImpl}.\n     * <p>\n     * This method is obsolete as of 1.1.  Please use the\n     * method <code>add(Component, Object)<\/code> instead.\n     * <p>\n     * This method changes layout-related information, and therefore,\n     * invalidates the component hierarchy. If the container has already been\n     * displayed, the hierarchy must be validated thereafter in order to\n     * display the added component.\n     *\n     * @exception NullPointerException if {@code comp} is {@code null}\n     * @see #add(Component, Object)\n     * @see #invalidate\n     */\n    public Component add(String name, Component comp) {\n        addImpl(comp, name, -1);\n        return comp;\n    }"}
{"Number":"298","API Relative Path":"java.awt.Container.java-add(String-Component)","Corresponding Source":"/**\n     * Adds the specified component to this container.\n     * This is a convenience method for {@link #addImpl}.\n     * <p>\n     * This method is obsolete as of 1.1.  Please use the\n     * method <code>add(Component, Object)<\/code> instead.\n     * <p>\n     * This method changes layout-related information, and therefore,\n     * invalidates the component hierarchy. If the container has already been\n     * displayed, the hierarchy must be validated thereafter in order to\n     * display the added component.\n     *\n     * @exception NullPointerException if {@code comp} is {@code null}\n     * @see #add(Component, Object)\n     * @see #invalidate\n     */\n    public Component add(String name, Component comp) {\n        addImpl(comp, name, -1);\n        return comp;\n    }"}
{"Number":"299","API Relative Path":"java.awt.Container.java-addContainerListener(ContainerListener)","Corresponding Source":"/**\n     * Adds the specified container listener to receive container events\n     * from this container.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l the container listener\n     *\n     * @see #removeContainerListener\n     * @see #getContainerListeners\n     */\n    public synchronized void addContainerListener(ContainerListener l) {\n        if (l == null) {\n            return;\n        }\n        containerListener = AWTEventMulticaster.add(containerListener, l);\n        newEventsOnly = true;\n    }"}
{"Number":"300","API Relative Path":"java.awt.Container.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified component to this container at the specified\n     * index. This method also notifies the layout manager to add\n     * the component to this container's layout using the specified\n     * constraints object via the <code>addLayoutComponent<\/code>\n     * method.\n     * <p>\n     * The constraints are\n     * defined by the particular layout manager being used.  For\n     * example, the <code>BorderLayout<\/code> class defines five\n     * constraints: <code>BorderLayout.NORTH<\/code>,\n     * <code>BorderLayout.SOUTH<\/code>, <code>BorderLayout.EAST<\/code>,\n     * <code>BorderLayout.WEST<\/code>, and <code>BorderLayout.CENTER<\/code>.\n     * <p>\n     * The <code>GridBagLayout<\/code> class requires a\n     * <code>GridBagConstraints<\/code> object.  Failure to pass\n     * the correct type of constraints object results in an\n     * <code>IllegalArgumentException<\/code>.\n     * <p>\n     * If the current layout manager implements {@code LayoutManager2}, then\n     * {@link LayoutManager2#addLayoutComponent(Component,Object)} is invoked on\n     * it. If the current layout manager does not implement\n     * {@code LayoutManager2}, and constraints is a {@code String}, then\n     * {@link LayoutManager#addLayoutComponent(String,Component)} is invoked on it.\n     * <p>\n     * If the component is not an ancestor of this container and has a non-null\n     * parent, it is removed from its current parent before it is added to this\n     * container.\n     * <p>\n     * This is the method to override if a program needs to track\n     * every add request to a container as all other add methods defer\n     * to this one. An overriding method should\n     * usually include a call to the superclass's version of the method:\n     *\n     * <blockquote>\n     * <code>super.addImpl(comp, constraints, index)<\/code>\n     * <\/blockquote>\n     * <p>\n     * This method changes layout-related information, and therefore,\n     * invalidates the component hierarchy. If the container has already been\n     * displayed, the hierarchy must be validated thereafter in order to\n     * display the added component.\n     *\n     * @param     comp       the component to be added\n     * @param     constraints an object expressing layout constraints\n     *                 for this component\n     * @param     index the position in the container's list at which to\n     *                 insert the component, where <code>-1<\/code>\n     *                 means append to the end\n     * @exception IllegalArgumentException if {@code index} is invalid;\n     *            if {@code comp} is a child of this container, the valid\n     *            range is {@code [-1, getComponentCount()-1]}; if component is\n     *            not a child of this container, the valid range is\n     *            {@code [-1, getComponentCount()]}\n     *\n     * @exception IllegalArgumentException if {@code comp} is an ancestor of\n     *                                     this container\n     * @exception IllegalArgumentException if adding a window to a container\n     * @exception NullPointerException if {@code comp} is {@code null}\n     * @see       #add(Component)\n     * @see       #add(Component, int)\n     * @see       #add(Component, java.lang.Object)\n     * @see #invalidate\n     * @see       LayoutManager\n     * @see       LayoutManager2\n     * @since     JDK1.1\n     */\n    protected void addImpl(Component comp, Object constraints, int index) {\n        synchronized (getTreeLock()) {\n            /* Check for correct arguments:  index in bounds,\n             * comp cannot be one of this container's parents,\n             * and comp cannot be a window.\n             * comp and container must be on the same GraphicsDevice.\n             * if comp is container, all sub-components must be on\n             * same GraphicsDevice.\n             */\n            GraphicsConfiguration thisGC = this.getGraphicsConfiguration();\n\n            if (index > component.size() || (index < 0 && index != -1)) {\n                throw new IllegalArgumentException(\n                          \"illegal component position\");\n            }\n            checkAddToSelf(comp);\n            checkNotAWindow(comp);\n            if (thisGC != null) {\n                comp.checkGD(thisGC.getDevice().getIDstring());\n            }\n\n            /* Reparent the component and tidy up the tree's state. */\n            if (comp.parent != null) {\n                comp.parent.remove(comp);\n                    if (index > component.size()) {\n                        throw new IllegalArgumentException(\"illegal component position\");\n                    }\n            }\n\n            //index == -1 means add to the end.\n            if (index == -1) {\n                component.add(comp);\n            } else {\n                component.add(index, comp);\n            }\n            comp.parent = this;\n            comp.setGraphicsConfiguration(thisGC);\n\n            adjustListeningChildren(AWTEvent.HIERARCHY_EVENT_MASK,\n                comp.numListening(AWTEvent.HIERARCHY_EVENT_MASK));\n            adjustListeningChildren(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK,\n                comp.numListening(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK));\n            adjustDescendants(comp.countHierarchyMembers());\n\n            invalidateIfValid();\n            if (peer != null) {\n                comp.addNotify();\n            }\n\n            /* Notify the layout manager of the added component. */\n            if (layoutMgr != null) {\n                if (layoutMgr instanceof LayoutManager2) {\n                    ((LayoutManager2)layoutMgr).addLayoutComponent(comp, constraints);\n                } else if (constraints instanceof String) {\n                    layoutMgr.addLayoutComponent((String)constraints, comp);\n                }\n            }\n            if (containerListener != null ||\n                (eventMask & AWTEvent.CONTAINER_EVENT_MASK) != 0 ||\n                Toolkit.enabledOnToolkit(AWTEvent.CONTAINER_EVENT_MASK)) {\n                ContainerEvent e = new ContainerEvent(this,\n                                     ContainerEvent.COMPONENT_ADDED,\n                                     comp);\n                dispatchEvent(e);\n            }\n\n            comp.createHierarchyEvents(HierarchyEvent.HIERARCHY_CHANGED, comp,\n                                       this, HierarchyEvent.PARENT_CHANGED,\n                                       Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_EVENT_MASK));\n            if (peer != null && layoutMgr == null && isVisible()) {\n                updateCursorImmediately();\n            }\n        }\n    }"}
{"Number":"301","API Relative Path":"java.awt.Container.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified component to this container at the specified\n     * index. This method also notifies the layout manager to add\n     * the component to this container's layout using the specified\n     * constraints object via the <code>addLayoutComponent<\/code>\n     * method.\n     * <p>\n     * The constraints are\n     * defined by the particular layout manager being used.  For\n     * example, the <code>BorderLayout<\/code> class defines five\n     * constraints: <code>BorderLayout.NORTH<\/code>,\n     * <code>BorderLayout.SOUTH<\/code>, <code>BorderLayout.EAST<\/code>,\n     * <code>BorderLayout.WEST<\/code>, and <code>BorderLayout.CENTER<\/code>.\n     * <p>\n     * The <code>GridBagLayout<\/code> class requires a\n     * <code>GridBagConstraints<\/code> object.  Failure to pass\n     * the correct type of constraints object results in an\n     * <code>IllegalArgumentException<\/code>.\n     * <p>\n     * If the current layout manager implements {@code LayoutManager2}, then\n     * {@link LayoutManager2#addLayoutComponent(Component,Object)} is invoked on\n     * it. If the current layout manager does not implement\n     * {@code LayoutManager2}, and constraints is a {@code String}, then\n     * {@link LayoutManager#addLayoutComponent(String,Component)} is invoked on it.\n     * <p>\n     * If the component is not an ancestor of this container and has a non-null\n     * parent, it is removed from its current parent before it is added to this\n     * container.\n     * <p>\n     * This is the method to override if a program needs to track\n     * every add request to a container as all other add methods defer\n     * to this one. An overriding method should\n     * usually include a call to the superclass's version of the method:\n     *\n     * <blockquote>\n     * <code>super.addImpl(comp, constraints, index)<\/code>\n     * <\/blockquote>\n     * <p>\n     * This method changes layout-related information, and therefore,\n     * invalidates the component hierarchy. If the container has already been\n     * displayed, the hierarchy must be validated thereafter in order to\n     * display the added component.\n     *\n     * @param     comp       the component to be added\n     * @param     constraints an object expressing layout constraints\n     *                 for this component\n     * @param     index the position in the container's list at which to\n     *                 insert the component, where <code>-1<\/code>\n     *                 means append to the end\n     * @exception IllegalArgumentException if {@code index} is invalid;\n     *            if {@code comp} is a child of this container, the valid\n     *            range is {@code [-1, getComponentCount()-1]}; if component is\n     *            not a child of this container, the valid range is\n     *            {@code [-1, getComponentCount()]}\n     *\n     * @exception IllegalArgumentException if {@code comp} is an ancestor of\n     *                                     this container\n     * @exception IllegalArgumentException if adding a window to a container\n     * @exception NullPointerException if {@code comp} is {@code null}\n     * @see       #add(Component)\n     * @see       #add(Component, int)\n     * @see       #add(Component, java.lang.Object)\n     * @see #invalidate\n     * @see       LayoutManager\n     * @see       LayoutManager2\n     * @since     JDK1.1\n     */\n    protected void addImpl(Component comp, Object constraints, int index) {\n        synchronized (getTreeLock()) {\n            /* Check for correct arguments:  index in bounds,\n             * comp cannot be one of this container's parents,\n             * and comp cannot be a window.\n             * comp and container must be on the same GraphicsDevice.\n             * if comp is container, all sub-components must be on\n             * same GraphicsDevice.\n             */\n            GraphicsConfiguration thisGC = this.getGraphicsConfiguration();\n\n            if (index > component.size() || (index < 0 && index != -1)) {\n                throw new IllegalArgumentException(\n                          \"illegal component position\");\n            }\n            checkAddToSelf(comp);\n            checkNotAWindow(comp);\n            if (thisGC != null) {\n                comp.checkGD(thisGC.getDevice().getIDstring());\n            }\n\n            /* Reparent the component and tidy up the tree's state. */\n            if (comp.parent != null) {\n                comp.parent.remove(comp);\n                    if (index > component.size()) {\n                        throw new IllegalArgumentException(\"illegal component position\");\n                    }\n            }\n\n            //index == -1 means add to the end.\n            if (index == -1) {\n                component.add(comp);\n            } else {\n                component.add(index, comp);\n            }\n            comp.parent = this;\n            comp.setGraphicsConfiguration(thisGC);\n\n            adjustListeningChildren(AWTEvent.HIERARCHY_EVENT_MASK,\n                comp.numListening(AWTEvent.HIERARCHY_EVENT_MASK));\n            adjustListeningChildren(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK,\n                comp.numListening(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK));\n            adjustDescendants(comp.countHierarchyMembers());\n\n            invalidateIfValid();\n            if (peer != null) {\n                comp.addNotify();\n            }\n\n            /* Notify the layout manager of the added component. */\n            if (layoutMgr != null) {\n                if (layoutMgr instanceof LayoutManager2) {\n                    ((LayoutManager2)layoutMgr).addLayoutComponent(comp, constraints);\n                } else if (constraints instanceof String) {\n                    layoutMgr.addLayoutComponent((String)constraints, comp);\n                }\n            }\n            if (containerListener != null ||\n                (eventMask & AWTEvent.CONTAINER_EVENT_MASK) != 0 ||\n                Toolkit.enabledOnToolkit(AWTEvent.CONTAINER_EVENT_MASK)) {\n                ContainerEvent e = new ContainerEvent(this,\n                                     ContainerEvent.COMPONENT_ADDED,\n                                     comp);\n                dispatchEvent(e);\n            }\n\n            comp.createHierarchyEvents(HierarchyEvent.HIERARCHY_CHANGED, comp,\n                                       this, HierarchyEvent.PARENT_CHANGED,\n                                       Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_EVENT_MASK));\n            if (peer != null && layoutMgr == null && isVisible()) {\n                updateCursorImmediately();\n            }\n        }\n    }"}
{"Number":"302","API Relative Path":"java.awt.Container.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified component to this container at the specified\n     * index. This method also notifies the layout manager to add\n     * the component to this container's layout using the specified\n     * constraints object via the <code>addLayoutComponent<\/code>\n     * method.\n     * <p>\n     * The constraints are\n     * defined by the particular layout manager being used.  For\n     * example, the <code>BorderLayout<\/code> class defines five\n     * constraints: <code>BorderLayout.NORTH<\/code>,\n     * <code>BorderLayout.SOUTH<\/code>, <code>BorderLayout.EAST<\/code>,\n     * <code>BorderLayout.WEST<\/code>, and <code>BorderLayout.CENTER<\/code>.\n     * <p>\n     * The <code>GridBagLayout<\/code> class requires a\n     * <code>GridBagConstraints<\/code> object.  Failure to pass\n     * the correct type of constraints object results in an\n     * <code>IllegalArgumentException<\/code>.\n     * <p>\n     * If the current layout manager implements {@code LayoutManager2}, then\n     * {@link LayoutManager2#addLayoutComponent(Component,Object)} is invoked on\n     * it. If the current layout manager does not implement\n     * {@code LayoutManager2}, and constraints is a {@code String}, then\n     * {@link LayoutManager#addLayoutComponent(String,Component)} is invoked on it.\n     * <p>\n     * If the component is not an ancestor of this container and has a non-null\n     * parent, it is removed from its current parent before it is added to this\n     * container.\n     * <p>\n     * This is the method to override if a program needs to track\n     * every add request to a container as all other add methods defer\n     * to this one. An overriding method should\n     * usually include a call to the superclass's version of the method:\n     *\n     * <blockquote>\n     * <code>super.addImpl(comp, constraints, index)<\/code>\n     * <\/blockquote>\n     * <p>\n     * This method changes layout-related information, and therefore,\n     * invalidates the component hierarchy. If the container has already been\n     * displayed, the hierarchy must be validated thereafter in order to\n     * display the added component.\n     *\n     * @param     comp       the component to be added\n     * @param     constraints an object expressing layout constraints\n     *                 for this component\n     * @param     index the position in the container's list at which to\n     *                 insert the component, where <code>-1<\/code>\n     *                 means append to the end\n     * @exception IllegalArgumentException if {@code index} is invalid;\n     *            if {@code comp} is a child of this container, the valid\n     *            range is {@code [-1, getComponentCount()-1]}; if component is\n     *            not a child of this container, the valid range is\n     *            {@code [-1, getComponentCount()]}\n     *\n     * @exception IllegalArgumentException if {@code comp} is an ancestor of\n     *                                     this container\n     * @exception IllegalArgumentException if adding a window to a container\n     * @exception NullPointerException if {@code comp} is {@code null}\n     * @see       #add(Component)\n     * @see       #add(Component, int)\n     * @see       #add(Component, java.lang.Object)\n     * @see #invalidate\n     * @see       LayoutManager\n     * @see       LayoutManager2\n     * @since     JDK1.1\n     */\n    protected void addImpl(Component comp, Object constraints, int index) {\n        synchronized (getTreeLock()) {\n            /* Check for correct arguments:  index in bounds,\n             * comp cannot be one of this container's parents,\n             * and comp cannot be a window.\n             * comp and container must be on the same GraphicsDevice.\n             * if comp is container, all sub-components must be on\n             * same GraphicsDevice.\n             */\n            GraphicsConfiguration thisGC = this.getGraphicsConfiguration();\n\n            if (index > component.size() || (index < 0 && index != -1)) {\n                throw new IllegalArgumentException(\n                          \"illegal component position\");\n            }\n            checkAddToSelf(comp);\n            checkNotAWindow(comp);\n            if (thisGC != null) {\n                comp.checkGD(thisGC.getDevice().getIDstring());\n            }\n\n            /* Reparent the component and tidy up the tree's state. */\n            if (comp.parent != null) {\n                comp.parent.remove(comp);\n                    if (index > component.size()) {\n                        throw new IllegalArgumentException(\"illegal component position\");\n                    }\n            }\n\n            //index == -1 means add to the end.\n            if (index == -1) {\n                component.add(comp);\n            } else {\n                component.add(index, comp);\n            }\n            comp.parent = this;\n            comp.setGraphicsConfiguration(thisGC);\n\n            adjustListeningChildren(AWTEvent.HIERARCHY_EVENT_MASK,\n                comp.numListening(AWTEvent.HIERARCHY_EVENT_MASK));\n            adjustListeningChildren(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK,\n                comp.numListening(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK));\n            adjustDescendants(comp.countHierarchyMembers());\n\n            invalidateIfValid();\n            if (peer != null) {\n                comp.addNotify();\n            }\n\n            /* Notify the layout manager of the added component. */\n            if (layoutMgr != null) {\n                if (layoutMgr instanceof LayoutManager2) {\n                    ((LayoutManager2)layoutMgr).addLayoutComponent(comp, constraints);\n                } else if (constraints instanceof String) {\n                    layoutMgr.addLayoutComponent((String)constraints, comp);\n                }\n            }\n            if (containerListener != null ||\n                (eventMask & AWTEvent.CONTAINER_EVENT_MASK) != 0 ||\n                Toolkit.enabledOnToolkit(AWTEvent.CONTAINER_EVENT_MASK)) {\n                ContainerEvent e = new ContainerEvent(this,\n                                     ContainerEvent.COMPONENT_ADDED,\n                                     comp);\n                dispatchEvent(e);\n            }\n\n            comp.createHierarchyEvents(HierarchyEvent.HIERARCHY_CHANGED, comp,\n                                       this, HierarchyEvent.PARENT_CHANGED,\n                                       Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_EVENT_MASK));\n            if (peer != null && layoutMgr == null && isVisible()) {\n                updateCursorImmediately();\n            }\n        }\n    }"}
{"Number":"303","API Relative Path":"java.awt.Container.java-areFocusTraversalKeysSet(int)","Corresponding Source":"/**\n     * Returns whether the Set of focus traversal keys for the given focus\n     * traversal operation has been explicitly defined for this Container. If\n     * this method returns <code>false<\/code>, this Container is inheriting the\n     * Set from an ancestor, or from the current KeyboardFocusManager.\n     *\n     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,\n     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or\n     *        KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS\n     * @return <code>true<\/code> if the the Set of focus traversal keys for the\n     *         given focus traversal operation has been explicitly defined for\n     *         this Component; <code>false<\/code> otherwise.\n     * @throws IllegalArgumentException if id is not one of\n     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,\n     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or\n     *        KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS\n     * @since 1.4\n     */\n    public boolean areFocusTraversalKeysSet(int id) {\n        if (id < 0 || id >= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH) {\n            throw new IllegalArgumentException(\"invalid focus traversal key identifier\");\n        }\n\n        return (focusTraversalKeys != null && focusTraversalKeys[id] != null);\n    }"}
{"Number":"304","API Relative Path":"java.awt.Container.java-getFocusTraversalKeys(int)","Corresponding Source":"/**\n     * Returns the Set of focus traversal keys for a given traversal operation\n     * for this Container. (See\n     * <code>setFocusTraversalKeys<\/code> for a full description of each key.)\n     * <p>\n     * If a Set of traversal keys has not been explicitly defined for this\n     * Container, then this Container's parent's Set is returned. If no Set\n     * has been explicitly defined for any of this Container's ancestors, then\n     * the current KeyboardFocusManager's default Set is returned.\n     *\n     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,\n     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or\n     *        KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS\n     * @return the Set of AWTKeyStrokes for the specified operation. The Set\n     *         will be unmodifiable, and may be empty. null will never be\n     *         returned.\n     * @see #setFocusTraversalKeys\n     * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#DOWN_CYCLE_TRAVERSAL_KEYS\n     * @throws IllegalArgumentException if id is not one of\n     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or\n     *         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS\n     * @since 1.4\n     */\n    public Set<AWTKeyStroke> getFocusTraversalKeys(int id) {\n        if (id < 0 || id >= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH) {\n            throw new IllegalArgumentException(\"invalid focus traversal key identifier\");\n        }\n\n        // Don't call super.getFocusTraversalKey. The Component parameter check\n        // does not allow DOWN_CYCLE_TRAVERSAL_KEY, but we do.\n        return getFocusTraversalKeys_NoIDCheck(id);\n    }"}
{"Number":"305","API Relative Path":"java.awt.Container.java-getFocusTraversalKeys(int)","Corresponding Source":"/**\n     * Returns the Set of focus traversal keys for a given traversal operation\n     * for this Container. (See\n     * <code>setFocusTraversalKeys<\/code> for a full description of each key.)\n     * <p>\n     * If a Set of traversal keys has not been explicitly defined for this\n     * Container, then this Container's parent's Set is returned. If no Set\n     * has been explicitly defined for any of this Container's ancestors, then\n     * the current KeyboardFocusManager's default Set is returned.\n     *\n     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,\n     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or\n     *        KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS\n     * @return the Set of AWTKeyStrokes for the specified operation. The Set\n     *         will be unmodifiable, and may be empty. null will never be\n     *         returned.\n     * @see #setFocusTraversalKeys\n     * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#DOWN_CYCLE_TRAVERSAL_KEYS\n     * @throws IllegalArgumentException if id is not one of\n     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or\n     *         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS\n     * @since 1.4\n     */\n    public Set<AWTKeyStroke> getFocusTraversalKeys(int id) {\n        if (id < 0 || id >= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH) {\n            throw new IllegalArgumentException(\"invalid focus traversal key identifier\");\n        }\n\n        // Don't call super.getFocusTraversalKey. The Component parameter check\n        // does not allow DOWN_CYCLE_TRAVERSAL_KEY, but we do.\n        return getFocusTraversalKeys_NoIDCheck(id);\n    }"}
{"Number":"306","API Relative Path":"java.awt.Container.java-getFocusTraversalKeys(int)","Corresponding Source":"/**\n     * Returns the Set of focus traversal keys for a given traversal operation\n     * for this Container. (See\n     * <code>setFocusTraversalKeys<\/code> for a full description of each key.)\n     * <p>\n     * If a Set of traversal keys has not been explicitly defined for this\n     * Container, then this Container's parent's Set is returned. If no Set\n     * has been explicitly defined for any of this Container's ancestors, then\n     * the current KeyboardFocusManager's default Set is returned.\n     *\n     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,\n     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or\n     *        KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS\n     * @return the Set of AWTKeyStrokes for the specified operation. The Set\n     *         will be unmodifiable, and may be empty. null will never be\n     *         returned.\n     * @see #setFocusTraversalKeys\n     * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#DOWN_CYCLE_TRAVERSAL_KEYS\n     * @throws IllegalArgumentException if id is not one of\n     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or\n     *         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS\n     * @since 1.4\n     */\n    public Set<AWTKeyStroke> getFocusTraversalKeys(int id) {\n        if (id < 0 || id >= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH) {\n            throw new IllegalArgumentException(\"invalid focus traversal key identifier\");\n        }\n\n        // Don't call super.getFocusTraversalKey. The Component parameter check\n        // does not allow DOWN_CYCLE_TRAVERSAL_KEY, but we do.\n        return getFocusTraversalKeys_NoIDCheck(id);\n    }"}
{"Number":"307","API Relative Path":"java.awt.Container.java-remove(int)","Corresponding Source":"/**\n     * Removes the component, specified by <code>index<\/code>,\n     * from this container.\n     * This method also notifies the layout manager to remove the\n     * component from this container's layout via the\n     * <code>removeLayoutComponent<\/code> method.\n     * <p>\n     * This method changes layout-related information, and therefore,\n     * invalidates the component hierarchy. If the container has already been\n     * displayed, the hierarchy must be validated thereafter in order to\n     * reflect the changes.\n     *\n     *\n     * @param     index   the index of the component to be removed\n     * @throws ArrayIndexOutOfBoundsException if {@code index} is not in\n     *         range {@code [0, getComponentCount()-1]}\n     * @see #add\n     * @see #invalidate\n     * @see #validate\n     * @see #getComponentCount\n     * @since JDK1.1\n     */\n    public void remove(int index) {\n        synchronized (getTreeLock()) {\n            if (index < 0  || index >= component.size()) {\n                throw new ArrayIndexOutOfBoundsException(index);\n            }\n            Component comp = component.get(index);\n            if (peer != null) {\n                comp.removeNotify();\n            }\n            if (layoutMgr != null) {\n                layoutMgr.removeLayoutComponent(comp);\n            }\n\n            adjustListeningChildren(AWTEvent.HIERARCHY_EVENT_MASK,\n                -comp.numListening(AWTEvent.HIERARCHY_EVENT_MASK));\n            adjustListeningChildren(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK,\n                -comp.numListening(AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK));\n            adjustDescendants(-(comp.countHierarchyMembers()));\n\n            comp.parent = null;\n            component.remove(index);\n            comp.setGraphicsConfiguration(null);\n\n            invalidateIfValid();\n            if (containerListener != null ||\n                (eventMask & AWTEvent.CONTAINER_EVENT_MASK) != 0 ||\n                Toolkit.enabledOnToolkit(AWTEvent.CONTAINER_EVENT_MASK)) {\n                ContainerEvent e = new ContainerEvent(this,\n                                     ContainerEvent.COMPONENT_REMOVED,\n                                     comp);\n                dispatchEvent(e);\n            }\n\n            comp.createHierarchyEvents(HierarchyEvent.HIERARCHY_CHANGED, comp,\n                                       this, HierarchyEvent.PARENT_CHANGED,\n                                       Toolkit.enabledOnToolkit(AWTEvent.HIERARCHY_EVENT_MASK));\n            if (peer != null && layoutMgr == null && isVisible()) {\n                updateCursorImmediately();\n            }\n        }\n    }"}
{"Number":"308","API Relative Path":"java.awt.Container.java-removeContainerListener(ContainerListener)","Corresponding Source":"/**\n     * Removes the specified container listener so it no longer receives\n     * container events from this container.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param   l the container listener\n     *\n     * @see #addContainerListener\n     * @see #getContainerListeners\n     */\n    public synchronized void removeContainerListener(ContainerListener l) {\n        if (l == null) {\n            return;\n        }\n        containerListener = AWTEventMulticaster.remove(containerListener, l);\n    }"}
{"Number":"309","API Relative Path":"java.awt.Container.java-removeContainerListener(ContainerListener)","Corresponding Source":"/**\n     * Removes the specified container listener so it no longer receives\n     * container events from this container.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param   l the container listener\n     *\n     * @see #addContainerListener\n     * @see #getContainerListeners\n     */\n    public synchronized void removeContainerListener(ContainerListener l) {\n        if (l == null) {\n            return;\n        }\n        containerListener = AWTEventMulticaster.remove(containerListener, l);\n    }"}
{"Number":"310","API Relative Path":"java.awt.Container.java-setComponentZOrder(Component-int)","Corresponding Source":"/**\n     * Moves the specified component to the specified z-order index in\n     * the container. The z-order determines the order that components\n     * are painted; the component with the highest z-order paints first\n     * and the component with the lowest z-order paints last.\n     * Where components overlap, the component with the lower\n     * z-order paints over the component with the higher z-order.\n     * <p>\n     * If the component is a child of some other container, it is\n     * removed from that container before being added to this container.\n     * The important difference between this method and\n     * <code>java.awt.Container.add(Component, int)<\/code> is that this method\n     * doesn't call <code>removeNotify<\/code> on the component while\n     * removing it from its previous container unless necessary and when\n     * allowed by the underlying native windowing system. This way, if the\n     * component has the keyboard focus, it maintains the focus when\n     * moved to the new position.\n     * <p>\n     * This property is guaranteed to apply only to lightweight\n     * non-<code>Container<\/code> components.\n     * <p>\n     * This method changes layout-related information, and therefore,\n     * invalidates the component hierarchy.\n     * <p>\n     * <b>Note<\/b>: Not all platforms support changing the z-order of\n     * heavyweight components from one container into another without\n     * the call to <code>removeNotify<\/code>. There is no way to detect\n     * whether a platform supports this, so developers shouldn't make\n     * any assumptions.\n     *\n     * @param     comp the component to be moved\n     * @param     index the position in the container's list to\n     *            insert the component, where <code>getComponentCount()<\/code>\n     *            appends to the end\n     * @exception NullPointerException if <code>comp<\/code> is\n     *            <code>null<\/code>\n     * @exception IllegalArgumentException if <code>comp<\/code> is one of the\n     *            container's parents\n     * @exception IllegalArgumentException if <code>index<\/code> is not in\n     *            the range <code>[0, getComponentCount()]<\/code> for moving\n     *            between containers, or not in the range\n     *            <code>[0, getComponentCount()-1]<\/code> for moving inside\n     *            a container\n     * @exception IllegalArgumentException if adding a container to itself\n     * @exception IllegalArgumentException if adding a <code>Window<\/code>\n     *            to a container\n     * @see #getComponentZOrder(java.awt.Component)\n     * @see #invalidate\n     * @since 1.5\n     */\n    public void setComponentZOrder(Component comp, int index) {\n         synchronized (getTreeLock()) {\n             // Store parent because remove will clear it\n             Container curParent = comp.parent;\n             int oldZindex = getComponentZOrder(comp);\n\n             if (curParent == this && index == oldZindex) {\n                 return;\n             }\n             checkAdding(comp, index);\n\n             boolean peerRecreated = (curParent != null) ?\n                 curParent.removeDelicately(comp, this, index) : false;\n\n             addDelicately(comp, curParent, index);\n\n             // If the oldZindex == -1, the component gets inserted,\n             // rather than it changes its z-order.\n             if (!peerRecreated && oldZindex != -1) {\n                 // The new 'index' cannot be == -1.\n                 // It gets checked at the checkAdding() method.\n                 // Therefore both oldZIndex and index denote\n                 // some existing positions at this point and\n                 // this is actually a Z-order changing.\n                 comp.mixOnZOrderChanging(oldZindex, index);\n             }\n         }\n    }"}
{"Number":"311","API Relative Path":"java.awt.Container.java-setComponentZOrder(Component-int)","Corresponding Source":"/**\n     * Moves the specified component to the specified z-order index in\n     * the container. The z-order determines the order that components\n     * are painted; the component with the highest z-order paints first\n     * and the component with the lowest z-order paints last.\n     * Where components overlap, the component with the lower\n     * z-order paints over the component with the higher z-order.\n     * <p>\n     * If the component is a child of some other container, it is\n     * removed from that container before being added to this container.\n     * The important difference between this method and\n     * <code>java.awt.Container.add(Component, int)<\/code> is that this method\n     * doesn't call <code>removeNotify<\/code> on the component while\n     * removing it from its previous container unless necessary and when\n     * allowed by the underlying native windowing system. This way, if the\n     * component has the keyboard focus, it maintains the focus when\n     * moved to the new position.\n     * <p>\n     * This property is guaranteed to apply only to lightweight\n     * non-<code>Container<\/code> components.\n     * <p>\n     * This method changes layout-related information, and therefore,\n     * invalidates the component hierarchy.\n     * <p>\n     * <b>Note<\/b>: Not all platforms support changing the z-order of\n     * heavyweight components from one container into another without\n     * the call to <code>removeNotify<\/code>. There is no way to detect\n     * whether a platform supports this, so developers shouldn't make\n     * any assumptions.\n     *\n     * @param     comp the component to be moved\n     * @param     index the position in the container's list to\n     *            insert the component, where <code>getComponentCount()<\/code>\n     *            appends to the end\n     * @exception NullPointerException if <code>comp<\/code> is\n     *            <code>null<\/code>\n     * @exception IllegalArgumentException if <code>comp<\/code> is one of the\n     *            container's parents\n     * @exception IllegalArgumentException if <code>index<\/code> is not in\n     *            the range <code>[0, getComponentCount()]<\/code> for moving\n     *            between containers, or not in the range\n     *            <code>[0, getComponentCount()-1]<\/code> for moving inside\n     *            a container\n     * @exception IllegalArgumentException if adding a container to itself\n     * @exception IllegalArgumentException if adding a <code>Window<\/code>\n     *            to a container\n     * @see #getComponentZOrder(java.awt.Component)\n     * @see #invalidate\n     * @since 1.5\n     */\n    public void setComponentZOrder(Component comp, int index) {\n         synchronized (getTreeLock()) {\n             // Store parent because remove will clear it\n             Container curParent = comp.parent;\n             int oldZindex = getComponentZOrder(comp);\n\n             if (curParent == this && index == oldZindex) {\n                 return;\n             }\n             checkAdding(comp, index);\n\n             boolean peerRecreated = (curParent != null) ?\n                 curParent.removeDelicately(comp, this, index) : false;\n\n             addDelicately(comp, curParent, index);\n\n             // If the oldZindex == -1, the component gets inserted,\n             // rather than it changes its z-order.\n             if (!peerRecreated && oldZindex != -1) {\n                 // The new 'index' cannot be == -1.\n                 // It gets checked at the checkAdding() method.\n                 // Therefore both oldZIndex and index denote\n                 // some existing positions at this point and\n                 // this is actually a Z-order changing.\n                 comp.mixOnZOrderChanging(oldZindex, index);\n             }\n         }\n    }"}
{"Number":"312","API Relative Path":"java.awt.Container.java-setComponentZOrder(Component-int)","Corresponding Source":"/**\n     * Moves the specified component to the specified z-order index in\n     * the container. The z-order determines the order that components\n     * are painted; the component with the highest z-order paints first\n     * and the component with the lowest z-order paints last.\n     * Where components overlap, the component with the lower\n     * z-order paints over the component with the higher z-order.\n     * <p>\n     * If the component is a child of some other container, it is\n     * removed from that container before being added to this container.\n     * The important difference between this method and\n     * <code>java.awt.Container.add(Component, int)<\/code> is that this method\n     * doesn't call <code>removeNotify<\/code> on the component while\n     * removing it from its previous container unless necessary and when\n     * allowed by the underlying native windowing system. This way, if the\n     * component has the keyboard focus, it maintains the focus when\n     * moved to the new position.\n     * <p>\n     * This property is guaranteed to apply only to lightweight\n     * non-<code>Container<\/code> components.\n     * <p>\n     * This method changes layout-related information, and therefore,\n     * invalidates the component hierarchy.\n     * <p>\n     * <b>Note<\/b>: Not all platforms support changing the z-order of\n     * heavyweight components from one container into another without\n     * the call to <code>removeNotify<\/code>. There is no way to detect\n     * whether a platform supports this, so developers shouldn't make\n     * any assumptions.\n     *\n     * @param     comp the component to be moved\n     * @param     index the position in the container's list to\n     *            insert the component, where <code>getComponentCount()<\/code>\n     *            appends to the end\n     * @exception NullPointerException if <code>comp<\/code> is\n     *            <code>null<\/code>\n     * @exception IllegalArgumentException if <code>comp<\/code> is one of the\n     *            container's parents\n     * @exception IllegalArgumentException if <code>index<\/code> is not in\n     *            the range <code>[0, getComponentCount()]<\/code> for moving\n     *            between containers, or not in the range\n     *            <code>[0, getComponentCount()-1]<\/code> for moving inside\n     *            a container\n     * @exception IllegalArgumentException if adding a container to itself\n     * @exception IllegalArgumentException if adding a <code>Window<\/code>\n     *            to a container\n     * @see #getComponentZOrder(java.awt.Component)\n     * @see #invalidate\n     * @since 1.5\n     */\n    public void setComponentZOrder(Component comp, int index) {\n         synchronized (getTreeLock()) {\n             // Store parent because remove will clear it\n             Container curParent = comp.parent;\n             int oldZindex = getComponentZOrder(comp);\n\n             if (curParent == this && index == oldZindex) {\n                 return;\n             }\n             checkAdding(comp, index);\n\n             boolean peerRecreated = (curParent != null) ?\n                 curParent.removeDelicately(comp, this, index) : false;\n\n             addDelicately(comp, curParent, index);\n\n             // If the oldZindex == -1, the component gets inserted,\n             // rather than it changes its z-order.\n             if (!peerRecreated && oldZindex != -1) {\n                 // The new 'index' cannot be == -1.\n                 // It gets checked at the checkAdding() method.\n                 // Therefore both oldZIndex and index denote\n                 // some existing positions at this point and\n                 // this is actually a Z-order changing.\n                 comp.mixOnZOrderChanging(oldZindex, index);\n             }\n         }\n    }"}
{"Number":"313","API Relative Path":"java.awt.Container.java-setFocusTraversalKeys(int-Set)","Corresponding Source":"/**\n     * Sets the focus traversal keys for a given traversal operation for this\n     * Container.\n     * <p>\n     * The default values for a Container's focus traversal keys are\n     * implementation-dependent. Sun recommends that all implementations for a\n     * particular native platform use the same default values. The\n     * recommendations for Windows and Unix are listed below. These\n     * recommendations are used in the Sun AWT implementations.\n     *\n     * <table border=1 summary=\"Recommended default values for a Container's focus traversal keys\">\n     * <tr>\n     *    <th>Identifier<\/th>\n     *    <th>Meaning<\/th>\n     *    <th>Default<\/th>\n     * <\/tr>\n     * <tr>\n     *    <td>KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS<\/td>\n     *    <td>Normal forward keyboard traversal<\/td>\n     *    <td>TAB on KEY_PRESSED, CTRL-TAB on KEY_PRESSED<\/td>\n     * <\/tr>\n     * <tr>\n     *    <td>KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS<\/td>\n     *    <td>Normal reverse keyboard traversal<\/td>\n     *    <td>SHIFT-TAB on KEY_PRESSED, CTRL-SHIFT-TAB on KEY_PRESSED<\/td>\n     * <\/tr>\n     * <tr>\n     *    <td>KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS<\/td>\n     *    <td>Go up one focus traversal cycle<\/td>\n     *    <td>none<\/td>\n     * <\/tr>\n     * <tr>\n     *    <td>KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS<td>\n     *    <td>Go down one focus traversal cycle<\/td>\n     *    <td>none<\/td>\n     * <\/tr>\n     * <\/table>\n     *\n     * To disable a traversal key, use an empty Set; Collections.EMPTY_SET is\n     * recommended.\n     * <p>\n     * Using the AWTKeyStroke API, client code can specify on which of two\n     * specific KeyEvents, KEY_PRESSED or KEY_RELEASED, the focus traversal\n     * operation will occur. Regardless of which KeyEvent is specified,\n     * however, all KeyEvents related to the focus traversal key, including the\n     * associated KEY_TYPED event, will be consumed, and will not be dispatched\n     * to any Container. It is a runtime error to specify a KEY_TYPED event as\n     * mapping to a focus traversal operation, or to map the same event to\n     * multiple default focus traversal operations.\n     * <p>\n     * If a value of null is specified for the Set, this Container inherits the\n     * Set from its parent. If all ancestors of this Container have null\n     * specified for the Set, then the current KeyboardFocusManager's default\n     * Set is used.\n     * <p>\n     * This method may throw a {@code ClassCastException} if any {@code Object}\n     * in {@code keystrokes} is not an {@code AWTKeyStroke}.\n     *\n     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,\n     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or\n     *        KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS\n     * @param keystrokes the Set of AWTKeyStroke for the specified operation\n     * @see #getFocusTraversalKeys\n     * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#DOWN_CYCLE_TRAVERSAL_KEYS\n     * @throws IllegalArgumentException if id is not one of\n     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or\n     *         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS, or if keystrokes\n     *         contains null, or if any keystroke represents a KEY_TYPED event,\n     *         or if any keystroke already maps to another focus traversal\n     *         operation for this Container\n     * @since 1.4\n     * @beaninfo\n     *       bound: true\n     */\n    public void setFocusTraversalKeys(int id,\n                                      Set<? extends AWTKeyStroke> keystrokes)\n    {\n        if (id < 0 || id >= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH) {\n            throw new IllegalArgumentException(\"invalid focus traversal key identifier\");\n        }\n\n        // Don't call super.setFocusTraversalKey. The Component parameter check\n        // does not allow DOWN_CYCLE_TRAVERSAL_KEYS, but we do.\n        setFocusTraversalKeys_NoIDCheck(id, keystrokes);\n    }"}
{"Number":"314","API Relative Path":"java.awt.Cursor.java-Cursor(int)","Corresponding Source":"/**\n     * Creates a new cursor object with the specified type.\n     * @param type the type of cursor\n     * @throws IllegalArgumentException if the specified cursor type\n     * is invalid\n     */\n    @ConstructorProperties({\"type\"})\n    public Cursor(int type) {\n        if (type < Cursor.DEFAULT_CURSOR || type > Cursor.MOVE_CURSOR) {\n            throw new IllegalArgumentException(\"illegal cursor type\");\n        }\n        this.type = type;\n\n        // Lookup localized name.\n        name = Toolkit.getProperty(cursorProperties[type][0],\n                                   cursorProperties[type][1]);\n    }"}
{"Number":"315","API Relative Path":"java.awt.Cursor.java-getPredefinedCursor(int)","Corresponding Source":"/**\n     * Returns a cursor object with the specified predefined type.\n     *\n     * @param type the type of predefined cursor\n     * @return the specified predefined cursor\n     * @throws IllegalArgumentException if the specified cursor type is\n     *         invalid\n     */\n    static public Cursor getPredefinedCursor(int type) {\n        if (type < Cursor.DEFAULT_CURSOR || type > Cursor.MOVE_CURSOR) {\n            throw new IllegalArgumentException(\"illegal cursor type\");\n        }\n        Cursor c = predefinedPrivate[type];\n        if (c == null) {\n            predefinedPrivate[type] = c = new Cursor(type);\n        }\n        // fill 'predefined' array for backwards compatibility.\n        if (predefined[type] == null) {\n            predefined[type] = c;\n        }\n        return c;\n    }"}
{"Number":"316","API Relative Path":"java.awt.Cursor.java-getPredefinedCursor(int)","Corresponding Source":"/**\n     * Returns a cursor object with the specified predefined type.\n     *\n     * @param type the type of predefined cursor\n     * @return the specified predefined cursor\n     * @throws IllegalArgumentException if the specified cursor type is\n     *         invalid\n     */\n    static public Cursor getPredefinedCursor(int type) {\n        if (type < Cursor.DEFAULT_CURSOR || type > Cursor.MOVE_CURSOR) {\n            throw new IllegalArgumentException(\"illegal cursor type\");\n        }\n        Cursor c = predefinedPrivate[type];\n        if (c == null) {\n            predefinedPrivate[type] = c = new Cursor(type);\n        }\n        // fill 'predefined' array for backwards compatibility.\n        if (predefined[type] == null) {\n            predefined[type] = c;\n        }\n        return c;\n    }"}
{"Number":"317","API Relative Path":"java.awt.datatransfer.Clipboard.java-addFlavorListener(FlavorListener)","Corresponding Source":"/**\n     * Registers the specified <code>FlavorListener<\/code> to receive\n     * <code>FlavorEvent<\/code>s from this clipboard.\n     * If <code>listener<\/code> is <code>null<\/code>, no exception\n     * is thrown and no action is performed.\n     *\n     * @param listener the listener to be added\n     *\n     * @see #removeFlavorListener\n     * @see #getFlavorListeners\n     * @see FlavorListener\n     * @see FlavorEvent\n     * @since 1.5\n     */\n    public synchronized void addFlavorListener(FlavorListener listener) {\n        if (listener == null) {\n            return;\n        }\n        if (flavorListeners == null) {\n            currentDataFlavors = getAvailableDataFlavorSet();\n            flavorListeners = new EventListenerAggregate(FlavorListener.class);\n        }\n        flavorListeners.add(listener);\n    }"}
{"Number":"318","API Relative Path":"java.awt.datatransfer.Clipboard.java-removeFlavorListener(FlavorListener)","Corresponding Source":"/**\n     * Removes the specified <code>FlavorListener<\/code> so that it no longer\n     * receives <code>FlavorEvent<\/code>s from this <code>Clipboard<\/code>.\n     * This method performs no function, nor does it throw an exception, if\n     * the listener specified by the argument was not previously added to this\n     * <code>Clipboard<\/code>.\n     * If <code>listener<\/code> is <code>null<\/code>, no exception\n     * is thrown and no action is performed.\n     *\n     * @param listener the listener to be removed\n     *\n     * @see #addFlavorListener\n     * @see #getFlavorListeners\n     * @see FlavorListener\n     * @see FlavorEvent\n     * @since 1.5\n     */\n    public synchronized void removeFlavorListener(FlavorListener listener) {\n        if (listener == null || flavorListeners == null) {\n            return;\n        }\n        flavorListeners.remove(listener);\n    }"}
{"Number":"319","API Relative Path":"java.awt.datatransfer.DataFlavor.java-equals(String)","Corresponding Source":"/**\n     * Compares only the <code>mimeType<\/code> against the passed in\n     * <code>String<\/code> and <code>representationClass<\/code> is\n     * not considered in the comparison.\n     *\n     * If <code>representationClass<\/code> needs to be compared, then\n     * <code>equals(new DataFlavor(s))<\/code> may be used.\n     * @deprecated As inconsistent with <code>hashCode()<\/code> contract,\n     *             use <code>isMimeTypeEqual(String)<\/code> instead.\n     * @param s the {@code mimeType} to compare.\n     * @return true if the String (MimeType) is equal; false otherwise or if\n     *         {@code s} is {@code null}\n     */\n    @Deprecated\n    public boolean equals(String s) {\n        if (s == null || mimeType == null)\n            return false;\n        return isMimeTypeEqual(s);\n    }"}
{"Number":"320","API Relative Path":"java.awt.datatransfer.DataFlavor.java-selectBestTextFlavor(DataFlavor[])","Corresponding Source":"/**\n     * Selects the best text <code>DataFlavor<\/code> from an array of <code>\n     * DataFlavor<\/code>s. Only <code>DataFlavor.stringFlavor<\/code>, and\n     * equivalent flavors, and flavors that have a primary MIME type of \"text\",\n     * are considered for selection.\n     * <p>\n     * Flavors are first sorted by their MIME types in the following order:\n     * <ul>\n     * <li>\"text/sgml\"\n     * <li>\"text/xml\"\n     * <li>\"text/html\"\n     * <li>\"text/rtf\"\n     * <li>\"text/enriched\"\n     * <li>\"text/richtext\"\n     * <li>\"text/uri-list\"\n     * <li>\"text/tab-separated-values\"\n     * <li>\"text/t140\"\n     * <li>\"text/rfc822-headers\"\n     * <li>\"text/parityfec\"\n     * <li>\"text/directory\"\n     * <li>\"text/css\"\n     * <li>\"text/calendar\"\n     * <li>\"application/x-java-serialized-object\"\n     * <li>\"text/plain\"\n     * <li>\"text/&lt;other&gt;\"\n     * <\/ul>\n     * <p>For example, \"text/sgml\" will be selected over\n     * \"text/html\", and <code>DataFlavor.stringFlavor<\/code> will be chosen\n     * over <code>DataFlavor.plainTextFlavor<\/code>.\n     * <p>\n     * If two or more flavors share the best MIME type in the array, then that\n     * MIME type will be checked to see if it supports the charset parameter.\n     * <p>\n     * The following MIME types support, or are treated as though they support,\n     * the charset parameter:\n     * <ul>\n     * <li>\"text/sgml\"\n     * <li>\"text/xml\"\n     * <li>\"text/html\"\n     * <li>\"text/enriched\"\n     * <li>\"text/richtext\"\n     * <li>\"text/uri-list\"\n     * <li>\"text/directory\"\n     * <li>\"text/css\"\n     * <li>\"text/calendar\"\n     * <li>\"application/x-java-serialized-object\"\n     * <li>\"text/plain\"\n     * <\/ul>\n     * The following MIME types do not support, or are treated as though they\n     * do not support, the charset parameter:\n     * <ul>\n     * <li>\"text/rtf\"\n     * <li>\"text/tab-separated-values\"\n     * <li>\"text/t140\"\n     * <li>\"text/rfc822-headers\"\n     * <li>\"text/parityfec\"\n     * <\/ul>\n     * For \"text/&lt;other&gt;\" MIME types, the first time the JRE needs to\n     * determine whether the MIME type supports the charset parameter, it will\n     * check whether the parameter is explicitly listed in an arbitrarily\n     * chosen <code>DataFlavor<\/code> which uses that MIME type. If so, the JRE\n     * will assume from that point on that the MIME type supports the charset\n     * parameter and will not check again. If the parameter is not explicitly\n     * listed, the JRE will assume from that point on that the MIME type does\n     * not support the charset parameter and will not check again. Because\n     * this check is performed on an arbitrarily chosen\n     * <code>DataFlavor<\/code>, developers must ensure that all\n     * <code>DataFlavor<\/code>s with a \"text/&lt;other&gt;\" MIME type specify\n     * the charset parameter if it is supported by that MIME type. Developers\n     * should never rely on the JRE to substitute the platform's default\n     * charset for a \"text/&lt;other&gt;\" DataFlavor. Failure to adhere to this\n     * restriction will lead to undefined behavior.\n     * <p>\n     * If the best MIME type in the array does not support the charset\n     * parameter, the flavors which share that MIME type will then be sorted by\n     * their representation classes in the following order:\n     * <code>java.io.InputStream<\/code>, <code>java.nio.ByteBuffer<\/code>,\n     * <code>[B<\/code>, &lt;all others&gt;.\n     * <p>\n     * If two or more flavors share the best representation class, or if no\n     * flavor has one of the three specified representations, then one of those\n     * flavors will be chosen non-deterministically.\n     * <p>\n     * If the best MIME type in the array does support the charset parameter,\n     * the flavors which share that MIME type will then be sorted by their\n     * representation classes in the following order:\n     * <code>java.io.Reader<\/code>, <code>java.lang.String<\/code>,\n     * <code>java.nio.CharBuffer<\/code>, <code>[C<\/code>, &lt;all others&gt;.\n     * <p>\n     * If two or more flavors share the best representation class, and that\n     * representation is one of the four explicitly listed, then one of those\n     * flavors will be chosen non-deterministically. If, however, no flavor has\n     * one of the four specified representations, the flavors will then be\n     * sorted by their charsets. Unicode charsets, such as \"UTF-16\", \"UTF-8\",\n     * \"UTF-16BE\", \"UTF-16LE\", and their aliases, are considered best. After\n     * them, the platform default charset and its aliases are selected.\n     * \"US-ASCII\" and its aliases are worst. All other charsets are chosen in\n     * alphabetical order, but only charsets supported by this implementation\n     * of the Java platform will be considered.\n     * <p>\n     * If two or more flavors share the best charset, the flavors will then\n     * again be sorted by their representation classes in the following order:\n     * <code>java.io.InputStream<\/code>, <code>java.nio.ByteBuffer<\/code>,\n     * <code>[B<\/code>, &lt;all others&gt;.\n     * <p>\n     * If two or more flavors share the best representation class, or if no\n     * flavor has one of the three specified representations, then one of those\n     * flavors will be chosen non-deterministically.\n     *\n     * @param availableFlavors an array of available <code>DataFlavor<\/code>s\n     * @return the best (highest fidelity) flavor according to the rules\n     *         specified above, or <code>null<\/code>,\n     *         if <code>availableFlavors<\/code> is <code>null<\/code>,\n     *         has zero length, or contains no text flavors\n     * @since 1.3\n     */\n    public static final DataFlavor selectBestTextFlavor(\n                                       DataFlavor[] availableFlavors) {\n        if (availableFlavors == null || availableFlavors.length == 0) {\n            return null;\n        }\n\n        if (textFlavorComparator == null) {\n            textFlavorComparator = new TextFlavorComparator();\n        }\n\n        DataFlavor bestFlavor =\n            (DataFlavor)Collections.max(Arrays.asList(availableFlavors),\n                                        textFlavorComparator);\n\n        if (!bestFlavor.isFlavorTextType()) {\n            return null;\n        }\n\n        return bestFlavor;\n    }"}
{"Number":"321","API Relative Path":"java.awt.datatransfer.MimeTypeParameterList.java-parse(String)","Corresponding Source":"/**\n     * A routine for parsing the parameter list out of a String.\n     */\n    protected void parse(String rawdata) throws MimeTypeParseException {\n        int length = rawdata.length();\n        if(length > 0) {\n            int currentIndex = skipWhiteSpace(rawdata, 0);\n            int lastIndex = 0;\n\n            if(currentIndex < length) {\n                char currentChar = rawdata.charAt(currentIndex);\n                while ((currentIndex < length) && (currentChar == ';')) {\n                    String name;\n                    String value;\n                    boolean foundit;\n\n                    //    eat the ';'\n                    ++currentIndex;\n\n                    //    now parse the parameter name\n\n                    //    skip whitespace\n                    currentIndex = skipWhiteSpace(rawdata, currentIndex);\n\n                    if(currentIndex < length) {\n                        //    find the end of the token char run\n                        lastIndex = currentIndex;\n                        currentChar = rawdata.charAt(currentIndex);\n                        while((currentIndex < length) && isTokenChar(currentChar)) {\n                            ++currentIndex;\n                            currentChar = rawdata.charAt(currentIndex);\n                        }\n                        name = rawdata.substring(lastIndex, currentIndex).toLowerCase();\n\n                        //    now parse the '=' that separates the name from the value\n\n                        //    skip whitespace\n                        currentIndex = skipWhiteSpace(rawdata, currentIndex);\n\n                        if((currentIndex < length) && (rawdata.charAt(currentIndex) == '='))  {\n                            //    eat it and parse the parameter value\n                            ++currentIndex;\n\n                            //    skip whitespace\n                            currentIndex = skipWhiteSpace(rawdata, currentIndex);\n\n                            if(currentIndex < length) {\n                                //    now find out whether or not we have a quoted value\n                                currentChar = rawdata.charAt(currentIndex);\n                                if(currentChar == '\"') {\n                                    //    yup it's quoted so eat it and capture the quoted string\n                                    ++currentIndex;\n                                    lastIndex = currentIndex;\n\n                                    if(currentIndex < length) {\n                                        //    find the next unescqped quote\n                                        foundit = false;\n                                        while((currentIndex < length) && !foundit) {\n                                            currentChar = rawdata.charAt(currentIndex);\n                                            if(currentChar == '\\\\') {\n                                                //    found an escape sequence so pass this and the next character\n                                                currentIndex += 2;\n                                            } else if(currentChar == '\"') {\n                                                //    foundit!\n                                                foundit = true;\n                                            } else {\n                                                ++currentIndex;\n                                            }\n                                        }\n                                        if(currentChar == '\"') {\n                                            value = unquote(rawdata.substring(lastIndex, currentIndex));\n                                            //    eat the quote\n                                            ++currentIndex;\n                                        } else {\n                                            throw new MimeTypeParseException(\"Encountered unterminated quoted parameter value.\");\n                                        }\n                                    } else {\n                                        throw new MimeTypeParseException(\"Encountered unterminated quoted parameter value.\");\n                                    }\n                                } else if(isTokenChar(currentChar)) {\n                                    //    nope it's an ordinary token so it ends with a non-token char\n                                    lastIndex = currentIndex;\n                                    foundit = false;\n                                    while((currentIndex < length) && !foundit) {\n                                        currentChar = rawdata.charAt(currentIndex);\n\n                                        if(isTokenChar(currentChar)) {\n                                            ++currentIndex;\n                                        } else {\n                                            foundit = true;\n                                        }\n                                    }\n                                    value = rawdata.substring(lastIndex, currentIndex);\n                                } else {\n                                    //    it ain't a value\n                                    throw new MimeTypeParseException(\"Unexpected character encountered at index \" + currentIndex);\n                                }\n\n                                //    now put the data into the hashtable\n                                parameters.put(name, value);\n                            } else {\n                                throw new MimeTypeParseException(\"Couldn't find a value for parameter named \" + name);\n                            }\n                        } else {\n                            throw new MimeTypeParseException(\"Couldn't find the '=' that separates a parameter name from its value.\");\n                        }\n                    } else {\n                        throw new MimeTypeParseException(\"Couldn't find parameter name\");\n                    }\n\n                    //    setup the next iteration\n                    currentIndex = skipWhiteSpace(rawdata, currentIndex);\n                    if(currentIndex < length) {\n                        currentChar = rawdata.charAt(currentIndex);\n                    }\n                }\n                if(currentIndex < length) {\n                    throw new MimeTypeParseException(\"More characters encountered in input than expected.\");\n                }\n            }\n        }\n    }"}
{"Number":"322","API Relative Path":"java.awt.datatransfer.MimeTypeParameterList.java-parse(String)","Corresponding Source":"/**\n     * A routine for parsing the parameter list out of a String.\n     */\n    protected void parse(String rawdata) throws MimeTypeParseException {\n        int length = rawdata.length();\n        if(length > 0) {\n            int currentIndex = skipWhiteSpace(rawdata, 0);\n            int lastIndex = 0;\n\n            if(currentIndex < length) {\n                char currentChar = rawdata.charAt(currentIndex);\n                while ((currentIndex < length) && (currentChar == ';')) {\n                    String name;\n                    String value;\n                    boolean foundit;\n\n                    //    eat the ';'\n                    ++currentIndex;\n\n                    //    now parse the parameter name\n\n                    //    skip whitespace\n                    currentIndex = skipWhiteSpace(rawdata, currentIndex);\n\n                    if(currentIndex < length) {\n                        //    find the end of the token char run\n                        lastIndex = currentIndex;\n                        currentChar = rawdata.charAt(currentIndex);\n                        while((currentIndex < length) && isTokenChar(currentChar)) {\n                            ++currentIndex;\n                            currentChar = rawdata.charAt(currentIndex);\n                        }\n                        name = rawdata.substring(lastIndex, currentIndex).toLowerCase();\n\n                        //    now parse the '=' that separates the name from the value\n\n                        //    skip whitespace\n                        currentIndex = skipWhiteSpace(rawdata, currentIndex);\n\n                        if((currentIndex < length) && (rawdata.charAt(currentIndex) == '='))  {\n                            //    eat it and parse the parameter value\n                            ++currentIndex;\n\n                            //    skip whitespace\n                            currentIndex = skipWhiteSpace(rawdata, currentIndex);\n\n                            if(currentIndex < length) {\n                                //    now find out whether or not we have a quoted value\n                                currentChar = rawdata.charAt(currentIndex);\n                                if(currentChar == '\"') {\n                                    //    yup it's quoted so eat it and capture the quoted string\n                                    ++currentIndex;\n                                    lastIndex = currentIndex;\n\n                                    if(currentIndex < length) {\n                                        //    find the next unescqped quote\n                                        foundit = false;\n                                        while((currentIndex < length) && !foundit) {\n                                            currentChar = rawdata.charAt(currentIndex);\n                                            if(currentChar == '\\\\') {\n                                                //    found an escape sequence so pass this and the next character\n                                                currentIndex += 2;\n                                            } else if(currentChar == '\"') {\n                                                //    foundit!\n                                                foundit = true;\n                                            } else {\n                                                ++currentIndex;\n                                            }\n                                        }\n                                        if(currentChar == '\"') {\n                                            value = unquote(rawdata.substring(lastIndex, currentIndex));\n                                            //    eat the quote\n                                            ++currentIndex;\n                                        } else {\n                                            throw new MimeTypeParseException(\"Encountered unterminated quoted parameter value.\");\n                                        }\n                                    } else {\n                                        throw new MimeTypeParseException(\"Encountered unterminated quoted parameter value.\");\n                                    }\n                                } else if(isTokenChar(currentChar)) {\n                                    //    nope it's an ordinary token so it ends with a non-token char\n                                    lastIndex = currentIndex;\n                                    foundit = false;\n                                    while((currentIndex < length) && !foundit) {\n                                        currentChar = rawdata.charAt(currentIndex);\n\n                                        if(isTokenChar(currentChar)) {\n                                            ++currentIndex;\n                                        } else {\n                                            foundit = true;\n                                        }\n                                    }\n                                    value = rawdata.substring(lastIndex, currentIndex);\n                                } else {\n                                    //    it ain't a value\n                                    throw new MimeTypeParseException(\"Unexpected character encountered at index \" + currentIndex);\n                                }\n\n                                //    now put the data into the hashtable\n                                parameters.put(name, value);\n                            } else {\n                                throw new MimeTypeParseException(\"Couldn't find a value for parameter named \" + name);\n                            }\n                        } else {\n                            throw new MimeTypeParseException(\"Couldn't find the '=' that separates a parameter name from its value.\");\n                        }\n                    } else {\n                        throw new MimeTypeParseException(\"Couldn't find parameter name\");\n                    }\n\n                    //    setup the next iteration\n                    currentIndex = skipWhiteSpace(rawdata, currentIndex);\n                    if(currentIndex < length) {\n                        currentChar = rawdata.charAt(currentIndex);\n                    }\n                }\n                if(currentIndex < length) {\n                    throw new MimeTypeParseException(\"More characters encountered in input than expected.\");\n                }\n            }\n        }\n    }"}
{"Number":"323","API Relative Path":"java.awt.datatransfer.MimeTypeParameterList.java-parse(String)","Corresponding Source":"/**\n     * A routine for parsing the parameter list out of a String.\n     */\n    protected void parse(String rawdata) throws MimeTypeParseException {\n        int length = rawdata.length();\n        if(length > 0) {\n            int currentIndex = skipWhiteSpace(rawdata, 0);\n            int lastIndex = 0;\n\n            if(currentIndex < length) {\n                char currentChar = rawdata.charAt(currentIndex);\n                while ((currentIndex < length) && (currentChar == ';')) {\n                    String name;\n                    String value;\n                    boolean foundit;\n\n                    //    eat the ';'\n                    ++currentIndex;\n\n                    //    now parse the parameter name\n\n                    //    skip whitespace\n                    currentIndex = skipWhiteSpace(rawdata, currentIndex);\n\n                    if(currentIndex < length) {\n                        //    find the end of the token char run\n                        lastIndex = currentIndex;\n                        currentChar = rawdata.charAt(currentIndex);\n                        while((currentIndex < length) && isTokenChar(currentChar)) {\n                            ++currentIndex;\n                            currentChar = rawdata.charAt(currentIndex);\n                        }\n                        name = rawdata.substring(lastIndex, currentIndex).toLowerCase();\n\n                        //    now parse the '=' that separates the name from the value\n\n                        //    skip whitespace\n                        currentIndex = skipWhiteSpace(rawdata, currentIndex);\n\n                        if((currentIndex < length) && (rawdata.charAt(currentIndex) == '='))  {\n                            //    eat it and parse the parameter value\n                            ++currentIndex;\n\n                            //    skip whitespace\n                            currentIndex = skipWhiteSpace(rawdata, currentIndex);\n\n                            if(currentIndex < length) {\n                                //    now find out whether or not we have a quoted value\n                                currentChar = rawdata.charAt(currentIndex);\n                                if(currentChar == '\"') {\n                                    //    yup it's quoted so eat it and capture the quoted string\n                                    ++currentIndex;\n                                    lastIndex = currentIndex;\n\n                                    if(currentIndex < length) {\n                                        //    find the next unescqped quote\n                                        foundit = false;\n                                        while((currentIndex < length) && !foundit) {\n                                            currentChar = rawdata.charAt(currentIndex);\n                                            if(currentChar == '\\\\') {\n                                                //    found an escape sequence so pass this and the next character\n                                                currentIndex += 2;\n                                            } else if(currentChar == '\"') {\n                                                //    foundit!\n                                                foundit = true;\n                                            } else {\n                                                ++currentIndex;\n                                            }\n                                        }\n                                        if(currentChar == '\"') {\n                                            value = unquote(rawdata.substring(lastIndex, currentIndex));\n                                            //    eat the quote\n                                            ++currentIndex;\n                                        } else {\n                                            throw new MimeTypeParseException(\"Encountered unterminated quoted parameter value.\");\n                                        }\n                                    } else {\n                                        throw new MimeTypeParseException(\"Encountered unterminated quoted parameter value.\");\n                                    }\n                                } else if(isTokenChar(currentChar)) {\n                                    //    nope it's an ordinary token so it ends with a non-token char\n                                    lastIndex = currentIndex;\n                                    foundit = false;\n                                    while((currentIndex < length) && !foundit) {\n                                        currentChar = rawdata.charAt(currentIndex);\n\n                                        if(isTokenChar(currentChar)) {\n                                            ++currentIndex;\n                                        } else {\n                                            foundit = true;\n                                        }\n                                    }\n                                    value = rawdata.substring(lastIndex, currentIndex);\n                                } else {\n                                    //    it ain't a value\n                                    throw new MimeTypeParseException(\"Unexpected character encountered at index \" + currentIndex);\n                                }\n\n                                //    now put the data into the hashtable\n                                parameters.put(name, value);\n                            } else {\n                                throw new MimeTypeParseException(\"Couldn't find a value for parameter named \" + name);\n                            }\n                        } else {\n                            throw new MimeTypeParseException(\"Couldn't find the '=' that separates a parameter name from its value.\");\n                        }\n                    } else {\n                        throw new MimeTypeParseException(\"Couldn't find parameter name\");\n                    }\n\n                    //    setup the next iteration\n                    currentIndex = skipWhiteSpace(rawdata, currentIndex);\n                    if(currentIndex < length) {\n                        currentChar = rawdata.charAt(currentIndex);\n                    }\n                }\n                if(currentIndex < length) {\n                    throw new MimeTypeParseException(\"More characters encountered in input than expected.\");\n                }\n            }\n        }\n    }"}
{"Number":"324","API Relative Path":"java.awt.datatransfer.MimeTypeParameterList.java-parse(String)","Corresponding Source":"/**\n     * A routine for parsing the parameter list out of a String.\n     */\n    protected void parse(String rawdata) throws MimeTypeParseException {\n        int length = rawdata.length();\n        if(length > 0) {\n            int currentIndex = skipWhiteSpace(rawdata, 0);\n            int lastIndex = 0;\n\n            if(currentIndex < length) {\n                char currentChar = rawdata.charAt(currentIndex);\n                while ((currentIndex < length) && (currentChar == ';')) {\n                    String name;\n                    String value;\n                    boolean foundit;\n\n                    //    eat the ';'\n                    ++currentIndex;\n\n                    //    now parse the parameter name\n\n                    //    skip whitespace\n                    currentIndex = skipWhiteSpace(rawdata, currentIndex);\n\n                    if(currentIndex < length) {\n                        //    find the end of the token char run\n                        lastIndex = currentIndex;\n                        currentChar = rawdata.charAt(currentIndex);\n                        while((currentIndex < length) && isTokenChar(currentChar)) {\n                            ++currentIndex;\n                            currentChar = rawdata.charAt(currentIndex);\n                        }\n                        name = rawdata.substring(lastIndex, currentIndex).toLowerCase();\n\n                        //    now parse the '=' that separates the name from the value\n\n                        //    skip whitespace\n                        currentIndex = skipWhiteSpace(rawdata, currentIndex);\n\n                        if((currentIndex < length) && (rawdata.charAt(currentIndex) == '='))  {\n                            //    eat it and parse the parameter value\n                            ++currentIndex;\n\n                            //    skip whitespace\n                            currentIndex = skipWhiteSpace(rawdata, currentIndex);\n\n                            if(currentIndex < length) {\n                                //    now find out whether or not we have a quoted value\n                                currentChar = rawdata.charAt(currentIndex);\n                                if(currentChar == '\"') {\n                                    //    yup it's quoted so eat it and capture the quoted string\n                                    ++currentIndex;\n                                    lastIndex = currentIndex;\n\n                                    if(currentIndex < length) {\n                                        //    find the next unescqped quote\n                                        foundit = false;\n                                        while((currentIndex < length) && !foundit) {\n                                            currentChar = rawdata.charAt(currentIndex);\n                                            if(currentChar == '\\\\') {\n                                                //    found an escape sequence so pass this and the next character\n                                                currentIndex += 2;\n                                            } else if(currentChar == '\"') {\n                                                //    foundit!\n                                                foundit = true;\n                                            } else {\n                                                ++currentIndex;\n                                            }\n                                        }\n                                        if(currentChar == '\"') {\n                                            value = unquote(rawdata.substring(lastIndex, currentIndex));\n                                            //    eat the quote\n                                            ++currentIndex;\n                                        } else {\n                                            throw new MimeTypeParseException(\"Encountered unterminated quoted parameter value.\");\n                                        }\n                                    } else {\n                                        throw new MimeTypeParseException(\"Encountered unterminated quoted parameter value.\");\n                                    }\n                                } else if(isTokenChar(currentChar)) {\n                                    //    nope it's an ordinary token so it ends with a non-token char\n                                    lastIndex = currentIndex;\n                                    foundit = false;\n                                    while((currentIndex < length) && !foundit) {\n                                        currentChar = rawdata.charAt(currentIndex);\n\n                                        if(isTokenChar(currentChar)) {\n                                            ++currentIndex;\n                                        } else {\n                                            foundit = true;\n                                        }\n                                    }\n                                    value = rawdata.substring(lastIndex, currentIndex);\n                                } else {\n                                    //    it ain't a value\n                                    throw new MimeTypeParseException(\"Unexpected character encountered at index \" + currentIndex);\n                                }\n\n                                //    now put the data into the hashtable\n                                parameters.put(name, value);\n                            } else {\n                                throw new MimeTypeParseException(\"Couldn't find a value for parameter named \" + name);\n                            }\n                        } else {\n                            throw new MimeTypeParseException(\"Couldn't find the '=' that separates a parameter name from its value.\");\n                        }\n                    } else {\n                        throw new MimeTypeParseException(\"Couldn't find parameter name\");\n                    }\n\n                    //    setup the next iteration\n                    currentIndex = skipWhiteSpace(rawdata, currentIndex);\n                    if(currentIndex < length) {\n                        currentChar = rawdata.charAt(currentIndex);\n                    }\n                }\n                if(currentIndex < length) {\n                    throw new MimeTypeParseException(\"More characters encountered in input than expected.\");\n                }\n            }\n        }\n    }"}
{"Number":"325","API Relative Path":"java.awt.datatransfer.MimeTypeParameterList.java-parse(String)","Corresponding Source":"/**\n     * A routine for parsing the parameter list out of a String.\n     */\n    protected void parse(String rawdata) throws MimeTypeParseException {\n        int length = rawdata.length();\n        if(length > 0) {\n            int currentIndex = skipWhiteSpace(rawdata, 0);\n            int lastIndex = 0;\n\n            if(currentIndex < length) {\n                char currentChar = rawdata.charAt(currentIndex);\n                while ((currentIndex < length) && (currentChar == ';')) {\n                    String name;\n                    String value;\n                    boolean foundit;\n\n                    //    eat the ';'\n                    ++currentIndex;\n\n                    //    now parse the parameter name\n\n                    //    skip whitespace\n                    currentIndex = skipWhiteSpace(rawdata, currentIndex);\n\n                    if(currentIndex < length) {\n                        //    find the end of the token char run\n                        lastIndex = currentIndex;\n                        currentChar = rawdata.charAt(currentIndex);\n                        while((currentIndex < length) && isTokenChar(currentChar)) {\n                            ++currentIndex;\n                            currentChar = rawdata.charAt(currentIndex);\n                        }\n                        name = rawdata.substring(lastIndex, currentIndex).toLowerCase();\n\n                        //    now parse the '=' that separates the name from the value\n\n                        //    skip whitespace\n                        currentIndex = skipWhiteSpace(rawdata, currentIndex);\n\n                        if((currentIndex < length) && (rawdata.charAt(currentIndex) == '='))  {\n                            //    eat it and parse the parameter value\n                            ++currentIndex;\n\n                            //    skip whitespace\n                            currentIndex = skipWhiteSpace(rawdata, currentIndex);\n\n                            if(currentIndex < length) {\n                                //    now find out whether or not we have a quoted value\n                                currentChar = rawdata.charAt(currentIndex);\n                                if(currentChar == '\"') {\n                                    //    yup it's quoted so eat it and capture the quoted string\n                                    ++currentIndex;\n                                    lastIndex = currentIndex;\n\n                                    if(currentIndex < length) {\n                                        //    find the next unescqped quote\n                                        foundit = false;\n                                        while((currentIndex < length) && !foundit) {\n                                            currentChar = rawdata.charAt(currentIndex);\n                                            if(currentChar == '\\\\') {\n                                                //    found an escape sequence so pass this and the next character\n                                                currentIndex += 2;\n                                            } else if(currentChar == '\"') {\n                                                //    foundit!\n                                                foundit = true;\n                                            } else {\n                                                ++currentIndex;\n                                            }\n                                        }\n                                        if(currentChar == '\"') {\n                                            value = unquote(rawdata.substring(lastIndex, currentIndex));\n                                            //    eat the quote\n                                            ++currentIndex;\n                                        } else {\n                                            throw new MimeTypeParseException(\"Encountered unterminated quoted parameter value.\");\n                                        }\n                                    } else {\n                                        throw new MimeTypeParseException(\"Encountered unterminated quoted parameter value.\");\n                                    }\n                                } else if(isTokenChar(currentChar)) {\n                                    //    nope it's an ordinary token so it ends with a non-token char\n                                    lastIndex = currentIndex;\n                                    foundit = false;\n                                    while((currentIndex < length) && !foundit) {\n                                        currentChar = rawdata.charAt(currentIndex);\n\n                                        if(isTokenChar(currentChar)) {\n                                            ++currentIndex;\n                                        } else {\n                                            foundit = true;\n                                        }\n                                    }\n                                    value = rawdata.substring(lastIndex, currentIndex);\n                                } else {\n                                    //    it ain't a value\n                                    throw new MimeTypeParseException(\"Unexpected character encountered at index \" + currentIndex);\n                                }\n\n                                //    now put the data into the hashtable\n                                parameters.put(name, value);\n                            } else {\n                                throw new MimeTypeParseException(\"Couldn't find a value for parameter named \" + name);\n                            }\n                        } else {\n                            throw new MimeTypeParseException(\"Couldn't find the '=' that separates a parameter name from its value.\");\n                        }\n                    } else {\n                        throw new MimeTypeParseException(\"Couldn't find parameter name\");\n                    }\n\n                    //    setup the next iteration\n                    currentIndex = skipWhiteSpace(rawdata, currentIndex);\n                    if(currentIndex < length) {\n                        currentChar = rawdata.charAt(currentIndex);\n                    }\n                }\n                if(currentIndex < length) {\n                    throw new MimeTypeParseException(\"More characters encountered in input than expected.\");\n                }\n            }\n        }\n    }"}
{"Number":"326","API Relative Path":"java.awt.DefaultKeyboardFocusManager.java-dequeueKeyEvents(long-Component)","Corresponding Source":"/**\n     * Releases for normal dispatching to the current focus owner all\n     * KeyEvents which were enqueued because of a call to\n     * <code>enqueueKeyEvents<\/code> with the same timestamp and Component.\n     * If the given timestamp is less than zero, the outstanding enqueue\n     * request for the given Component with the <b>oldest<\/b> timestamp (if\n     * any) should be cancelled.\n     *\n     * @param after the timestamp specified in the call to\n     *        <code>enqueueKeyEvents<\/code>, or any value &lt; 0\n     * @param untilFocused the Component specified in the call to\n     *        <code>enqueueKeyEvents<\/code>\n     * @see #enqueueKeyEvents\n     * @see #discardKeyEvents\n     */\n    protected synchronized void dequeueKeyEvents(long after,\n                                                 Component untilFocused) {\n        if (untilFocused == null) {\n            return;\n        }\n\n        if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {\n            focusLog.finer(\"Dequeue at {0} for {1}\",\n                       after, untilFocused);\n        }\n\n        TypeAheadMarker marker;\n        ListIterator<TypeAheadMarker> iter = typeAheadMarkers.listIterator\n            ((after >= 0) ? typeAheadMarkers.size() : 0);\n\n        if (after < 0) {\n            while (iter.hasNext()) {\n                marker = iter.next();\n                if (marker.untilFocused == untilFocused)\n                {\n                    iter.remove();\n                    return;\n                }\n            }\n        } else {\n            while (iter.hasPrevious()) {\n                marker = iter.previous();\n                if (marker.untilFocused == untilFocused &&\n                    marker.after == after)\n                {\n                    iter.remove();\n                    return;\n                }\n            }\n        }\n    }"}
{"Number":"327","API Relative Path":"java.awt.DefaultKeyboardFocusManager.java-discardKeyEvents(Component)","Corresponding Source":"/**\n     * Discards all KeyEvents which were enqueued because of one or more calls\n     * to <code>enqueueKeyEvents<\/code> with the specified Component, or one of\n     * its descendants.\n     *\n     * @param comp the Component specified in one or more calls to\n     *        <code>enqueueKeyEvents<\/code>, or a parent of such a Component\n     * @see #enqueueKeyEvents\n     * @see #dequeueKeyEvents\n     */\n    protected synchronized void discardKeyEvents(Component comp) {\n        if (comp == null) {\n            return;\n        }\n\n        long start = -1;\n\n        for (Iterator<TypeAheadMarker> iter = typeAheadMarkers.iterator(); iter.hasNext(); ) {\n            TypeAheadMarker marker = iter.next();\n            Component toTest = marker.untilFocused;\n            boolean match = (toTest == comp);\n            while (!match && toTest != null && !(toTest instanceof Window)) {\n                toTest = toTest.getParent();\n                match = (toTest == comp);\n            }\n            if (match) {\n                if (start < 0) {\n                    start = marker.after;\n                }\n                iter.remove();\n            } else if (start >= 0) {\n                purgeStampedEvents(start, marker.after);\n                start = -1;\n            }\n        }\n\n        purgeStampedEvents(start, -1);\n    }"}
{"Number":"328","API Relative Path":"java.awt.DefaultKeyboardFocusManager.java-downFocusCycle(Container)","Corresponding Source":"/**\n     * Moves the focus down one focus traversal cycle. If aContainer is a focus\n     * cycle root, then the focus owner is set to aContainer's default\n     * Component to focus, and the current focus cycle root is set to\n     * aContainer. If aContainer is not a focus cycle root, then no focus\n     * traversal operation occurs.\n     *\n     * @param aContainer the Container that is the basis for the focus\n     *        traversal operation\n     * @see Container#transferFocusDownCycle\n     */\n    public void downFocusCycle(Container aContainer) {\n        if (aContainer != null && aContainer.isFocusCycleRoot()) {\n            aContainer.transferFocusDownCycle();\n        }\n    }"}
{"Number":"329","API Relative Path":"java.awt.DefaultKeyboardFocusManager.java-enqueueKeyEvents(long-Component)","Corresponding Source":"/**\n     * Delays dispatching of KeyEvents until the specified Component becomes\n     * the focus owner. KeyEvents with timestamps later than the specified\n     * timestamp will be enqueued until the specified Component receives a\n     * FOCUS_GAINED event, or the AWT cancels the delay request by invoking\n     * <code>dequeueKeyEvents<\/code> or <code>discardKeyEvents<\/code>.\n     *\n     * @param after timestamp of current event, or the current, system time if\n     *        the current event has no timestamp, or the AWT cannot determine\n     *        which event is currently being handled\n     * @param untilFocused Component which will receive a FOCUS_GAINED event\n     *        before any pending KeyEvents\n     * @see #dequeueKeyEvents\n     * @see #discardKeyEvents\n     */\n    protected synchronized void enqueueKeyEvents(long after,\n                                                 Component untilFocused) {\n        if (untilFocused == null) {\n            return;\n        }\n\n        if (focusLog.isLoggable(PlatformLogger.Level.FINER)) {\n            focusLog.finer(\"Enqueue at {0} for {1}\",\n                       after, untilFocused);\n        }\n\n        int insertionIndex = 0,\n            i = typeAheadMarkers.size();\n        ListIterator<TypeAheadMarker> iter = typeAheadMarkers.listIterator(i);\n\n        for (; i > 0; i--) {\n            TypeAheadMarker marker = iter.previous();\n            if (marker.after <= after) {\n                insertionIndex = i;\n                break;\n            }\n        }\n\n        typeAheadMarkers.add(insertionIndex,\n                             new TypeAheadMarker(after, untilFocused));\n    }"}
{"Number":"330","API Relative Path":"java.awt.DefaultKeyboardFocusManager.java-focusNextComponent(Component)","Corresponding Source":"/**\n     * Focuses the Component after aComponent, typically based on a\n     * FocusTraversalPolicy.\n     *\n     * @param aComponent the Component that is the basis for the focus\n     *        traversal operation\n     * @see FocusTraversalPolicy\n     * @see Component#transferFocus\n     */\n    public void focusNextComponent(Component aComponent) {\n        if (aComponent != null) {\n            aComponent.transferFocus();\n        }\n    }"}
{"Number":"331","API Relative Path":"java.awt.DefaultKeyboardFocusManager.java-focusPreviousComponent(Component)","Corresponding Source":"/**\n     * Focuses the Component before aComponent, typically based on a\n     * FocusTraversalPolicy.\n     *\n     * @param aComponent the Component that is the basis for the focus\n     *        traversal operation\n     * @see FocusTraversalPolicy\n     * @see Component#transferFocusBackward\n     */\n    public void focusPreviousComponent(Component aComponent) {\n        if (aComponent != null) {\n            aComponent.transferFocusBackward();\n        }\n    }"}
{"Number":"332","API Relative Path":"java.awt.DefaultKeyboardFocusManager.java-processKeyEvent(Component-KeyEvent)","Corresponding Source":"/**\n     * This method initiates a focus traversal operation if and only if the\n     * KeyEvent represents a focus traversal key for the specified\n     * focusedComponent. It is expected that focusedComponent is the current\n     * focus owner, although this need not be the case. If it is not,\n     * focus traversal will nevertheless proceed as if focusedComponent\n     * were the focus owner.\n     *\n     * @param focusedComponent the Component that is the basis for a focus\n     *        traversal operation if the specified event represents a focus\n     *        traversal key for the Component\n     * @param e the event that may represent a focus traversal key\n     */\n    public void processKeyEvent(Component focusedComponent, KeyEvent e) {\n        // consume processed event if needed\n        if (consumeProcessedKeyEvent(e)) {\n            return;\n        }\n\n        // KEY_TYPED events cannot be focus traversal keys\n        if (e.getID() == KeyEvent.KEY_TYPED) {\n            return;\n        }\n\n        if (focusedComponent.getFocusTraversalKeysEnabled() &&\n            !e.isConsumed())\n        {\n            AWTKeyStroke stroke = AWTKeyStroke.getAWTKeyStrokeForEvent(e),\n                oppStroke = AWTKeyStroke.getAWTKeyStroke(stroke.getKeyCode(),\n                                                 stroke.getModifiers(),\n                                                 !stroke.isOnKeyRelease());\n            Set<AWTKeyStroke> toTest;\n            boolean contains, containsOpp;\n\n            toTest = focusedComponent.getFocusTraversalKeys(\n                KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS);\n            contains = toTest.contains(stroke);\n            containsOpp = toTest.contains(oppStroke);\n\n            if (contains || containsOpp) {\n                consumeTraversalKey(e);\n                if (contains) {\n                    focusNextComponent(focusedComponent);\n                }\n                return;\n            } else if (e.getID() == KeyEvent.KEY_PRESSED) {\n                // Fix for 6637607: consumeNextKeyTyped should be reset.\n                consumeNextKeyTyped = false;\n            }\n\n            toTest = focusedComponent.getFocusTraversalKeys(\n                KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS);\n            contains = toTest.contains(stroke);\n            containsOpp = toTest.contains(oppStroke);\n\n            if (contains || containsOpp) {\n                consumeTraversalKey(e);\n                if (contains) {\n                    focusPreviousComponent(focusedComponent);\n                }\n                return;\n            }\n\n            toTest = focusedComponent.getFocusTraversalKeys(\n                KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS);\n            contains = toTest.contains(stroke);\n            containsOpp = toTest.contains(oppStroke);\n\n            if (contains || containsOpp) {\n                consumeTraversalKey(e);\n                if (contains) {\n                    upFocusCycle(focusedComponent);\n                }\n                return;\n            }\n\n            if (!((focusedComponent instanceof Container) &&\n                  ((Container)focusedComponent).isFocusCycleRoot())) {\n                return;\n            }\n\n            toTest = focusedComponent.getFocusTraversalKeys(\n                KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS);\n            contains = toTest.contains(stroke);\n            containsOpp = toTest.contains(oppStroke);\n\n            if (contains || containsOpp) {\n                consumeTraversalKey(e);\n                if (contains) {\n                    downFocusCycle((Container)focusedComponent);\n                }\n            }\n        }\n    }"}
{"Number":"333","API Relative Path":"java.awt.DefaultKeyboardFocusManager.java-processKeyEvent(Component-KeyEvent)","Corresponding Source":"/**\n     * This method initiates a focus traversal operation if and only if the\n     * KeyEvent represents a focus traversal key for the specified\n     * focusedComponent. It is expected that focusedComponent is the current\n     * focus owner, although this need not be the case. If it is not,\n     * focus traversal will nevertheless proceed as if focusedComponent\n     * were the focus owner.\n     *\n     * @param focusedComponent the Component that is the basis for a focus\n     *        traversal operation if the specified event represents a focus\n     *        traversal key for the Component\n     * @param e the event that may represent a focus traversal key\n     */\n    public void processKeyEvent(Component focusedComponent, KeyEvent e) {\n        // consume processed event if needed\n        if (consumeProcessedKeyEvent(e)) {\n            return;\n        }\n\n        // KEY_TYPED events cannot be focus traversal keys\n        if (e.getID() == KeyEvent.KEY_TYPED) {\n            return;\n        }\n\n        if (focusedComponent.getFocusTraversalKeysEnabled() &&\n            !e.isConsumed())\n        {\n            AWTKeyStroke stroke = AWTKeyStroke.getAWTKeyStrokeForEvent(e),\n                oppStroke = AWTKeyStroke.getAWTKeyStroke(stroke.getKeyCode(),\n                                                 stroke.getModifiers(),\n                                                 !stroke.isOnKeyRelease());\n            Set<AWTKeyStroke> toTest;\n            boolean contains, containsOpp;\n\n            toTest = focusedComponent.getFocusTraversalKeys(\n                KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS);\n            contains = toTest.contains(stroke);\n            containsOpp = toTest.contains(oppStroke);\n\n            if (contains || containsOpp) {\n                consumeTraversalKey(e);\n                if (contains) {\n                    focusNextComponent(focusedComponent);\n                }\n                return;\n            } else if (e.getID() == KeyEvent.KEY_PRESSED) {\n                // Fix for 6637607: consumeNextKeyTyped should be reset.\n                consumeNextKeyTyped = false;\n            }\n\n            toTest = focusedComponent.getFocusTraversalKeys(\n                KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS);\n            contains = toTest.contains(stroke);\n            containsOpp = toTest.contains(oppStroke);\n\n            if (contains || containsOpp) {\n                consumeTraversalKey(e);\n                if (contains) {\n                    focusPreviousComponent(focusedComponent);\n                }\n                return;\n            }\n\n            toTest = focusedComponent.getFocusTraversalKeys(\n                KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS);\n            contains = toTest.contains(stroke);\n            containsOpp = toTest.contains(oppStroke);\n\n            if (contains || containsOpp) {\n                consumeTraversalKey(e);\n                if (contains) {\n                    upFocusCycle(focusedComponent);\n                }\n                return;\n            }\n\n            if (!((focusedComponent instanceof Container) &&\n                  ((Container)focusedComponent).isFocusCycleRoot())) {\n                return;\n            }\n\n            toTest = focusedComponent.getFocusTraversalKeys(\n                KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS);\n            contains = toTest.contains(stroke);\n            containsOpp = toTest.contains(oppStroke);\n\n            if (contains || containsOpp) {\n                consumeTraversalKey(e);\n                if (contains) {\n                    downFocusCycle((Container)focusedComponent);\n                }\n            }\n        }\n    }"}
{"Number":"334","API Relative Path":"java.awt.DefaultKeyboardFocusManager.java-processKeyEvent(Component-KeyEvent)","Corresponding Source":"/**\n     * This method initiates a focus traversal operation if and only if the\n     * KeyEvent represents a focus traversal key for the specified\n     * focusedComponent. It is expected that focusedComponent is the current\n     * focus owner, although this need not be the case. If it is not,\n     * focus traversal will nevertheless proceed as if focusedComponent\n     * were the focus owner.\n     *\n     * @param focusedComponent the Component that is the basis for a focus\n     *        traversal operation if the specified event represents a focus\n     *        traversal key for the Component\n     * @param e the event that may represent a focus traversal key\n     */\n    public void processKeyEvent(Component focusedComponent, KeyEvent e) {\n        // consume processed event if needed\n        if (consumeProcessedKeyEvent(e)) {\n            return;\n        }\n\n        // KEY_TYPED events cannot be focus traversal keys\n        if (e.getID() == KeyEvent.KEY_TYPED) {\n            return;\n        }\n\n        if (focusedComponent.getFocusTraversalKeysEnabled() &&\n            !e.isConsumed())\n        {\n            AWTKeyStroke stroke = AWTKeyStroke.getAWTKeyStrokeForEvent(e),\n                oppStroke = AWTKeyStroke.getAWTKeyStroke(stroke.getKeyCode(),\n                                                 stroke.getModifiers(),\n                                                 !stroke.isOnKeyRelease());\n            Set<AWTKeyStroke> toTest;\n            boolean contains, containsOpp;\n\n            toTest = focusedComponent.getFocusTraversalKeys(\n                KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS);\n            contains = toTest.contains(stroke);\n            containsOpp = toTest.contains(oppStroke);\n\n            if (contains || containsOpp) {\n                consumeTraversalKey(e);\n                if (contains) {\n                    focusNextComponent(focusedComponent);\n                }\n                return;\n            } else if (e.getID() == KeyEvent.KEY_PRESSED) {\n                // Fix for 6637607: consumeNextKeyTyped should be reset.\n                consumeNextKeyTyped = false;\n            }\n\n            toTest = focusedComponent.getFocusTraversalKeys(\n                KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS);\n            contains = toTest.contains(stroke);\n            containsOpp = toTest.contains(oppStroke);\n\n            if (contains || containsOpp) {\n                consumeTraversalKey(e);\n                if (contains) {\n                    focusPreviousComponent(focusedComponent);\n                }\n                return;\n            }\n\n            toTest = focusedComponent.getFocusTraversalKeys(\n                KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS);\n            contains = toTest.contains(stroke);\n            containsOpp = toTest.contains(oppStroke);\n\n            if (contains || containsOpp) {\n                consumeTraversalKey(e);\n                if (contains) {\n                    upFocusCycle(focusedComponent);\n                }\n                return;\n            }\n\n            if (!((focusedComponent instanceof Container) &&\n                  ((Container)focusedComponent).isFocusCycleRoot())) {\n                return;\n            }\n\n            toTest = focusedComponent.getFocusTraversalKeys(\n                KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS);\n            contains = toTest.contains(stroke);\n            containsOpp = toTest.contains(oppStroke);\n\n            if (contains || containsOpp) {\n                consumeTraversalKey(e);\n                if (contains) {\n                    downFocusCycle((Container)focusedComponent);\n                }\n            }\n        }\n    }"}
{"Number":"335","API Relative Path":"java.awt.DefaultKeyboardFocusManager.java-upFocusCycle(Component)","Corresponding Source":"/**\n     * Moves the focus up one focus traversal cycle. Typically, the focus owner\n     * is set to aComponent's focus cycle root, and the current focus cycle\n     * root is set to the new focus owner's focus cycle root. If, however,\n     * aComponent's focus cycle root is a Window, then the focus owner is set\n     * to the focus cycle root's default Component to focus, and the current\n     * focus cycle root is unchanged.\n     *\n     * @param aComponent the Component that is the basis for the focus\n     *        traversal operation\n     * @see Component#transferFocusUpCycle\n     */\n    public void upFocusCycle(Component aComponent) {\n        if (aComponent != null) {\n            aComponent.transferFocusUpCycle();\n        }\n    }"}
{"Number":"336","API Relative Path":"java.awt.Dialog.java-Dialog(Window-String-ModalityType)","Corresponding Source":"/**\n     * Constructs an initially invisible <code>Dialog<\/code> with the\n     * specified owner <code>Window<\/code>, title and modality.\n     *\n     * @param owner the owner of the dialog. The owner must be an instance of\n     *     {@link java.awt.Dialog Dialog}, {@link java.awt.Frame Frame}, any\n     *     of their descendents or <code>null<\/code>\n     * @param title the title of the dialog or <code>null<\/code> if this dialog\n     *     has no title\n     * @param modalityType specifies whether dialog blocks input to other\n     *    windows when shown. <code>null<\/code> value and unsupported modality\n     *    types are equivalent to <code>MODELESS<\/code>\n     *\n     * @exception java.lang.IllegalArgumentException if the <code>owner<\/code>\n     *     is not an instance of {@link java.awt.Dialog Dialog} or {@link\n     *     java.awt.Frame Frame}\n     * @exception java.lang.IllegalArgumentException if the <code>owner<\/code>'s\n     *     <code>GraphicsConfiguration<\/code> is not from a screen device\n     * @exception HeadlessException when\n     *     <code>GraphicsEnvironment.isHeadless()<\/code> returns <code>true<\/code>\n     * @exception SecurityException if the calling thread does not have permission\n     *     to create modal dialogs with the given <code>modalityType<\/code>\n     *\n     * @see java.awt.Dialog.ModalityType\n     * @see java.awt.Dialog#setModal\n     * @see java.awt.Dialog#setModalityType\n     * @see java.awt.GraphicsEnvironment#isHeadless\n     * @see java.awt.Toolkit#isModalityTypeSupported\n     *\n     * @since 1.6\n     */\n    public Dialog(Window owner, String title, ModalityType modalityType) {\n        super(owner);\n\n        if ((owner != null) &&\n            !(owner instanceof Frame) &&\n            !(owner instanceof Dialog))\n        {\n            throw new IllegalArgumentException(\"Wrong parent window\");\n        }\n\n        this.title = title;\n        setModalityType(modalityType);\n        SunToolkit.checkAndSetPolicy(this);\n        initialized = true;\n    }"}
{"Number":"337","API Relative Path":"java.awt.Dialog.java-Dialog(Window-String-ModalityType-GraphicsConfiguration)","Corresponding Source":"/**\n     * Constructs an initially invisible <code>Dialog<\/code> with the\n     * specified owner <code>Window<\/code>, title, modality and\n     * <code>GraphicsConfiguration<\/code>.\n     *\n     * @param owner the owner of the dialog. The owner must be an instance of\n     *     {@link java.awt.Dialog Dialog}, {@link java.awt.Frame Frame}, any\n     *     of their descendents or <code>null<\/code>\n     * @param title the title of the dialog or <code>null<\/code> if this dialog\n     *     has no title\n     * @param modalityType specifies whether dialog blocks input to other\n     *    windows when shown. <code>null<\/code> value and unsupported modality\n     *    types are equivalent to <code>MODELESS<\/code>\n     * @param gc the <code>GraphicsConfiguration<\/code> of the target screen device;\n     *     if <code>null<\/code>, the default system <code>GraphicsConfiguration<\/code>\n     *     is assumed\n     *\n     * @exception java.lang.IllegalArgumentException if the <code>owner<\/code>\n     *     is not an instance of {@link java.awt.Dialog Dialog} or {@link\n     *     java.awt.Frame Frame}\n     * @exception java.lang.IllegalArgumentException if <code>gc<\/code>\n     *     is not from a screen device\n     * @exception HeadlessException when\n     *     <code>GraphicsEnvironment.isHeadless()<\/code> returns <code>true<\/code>\n     * @exception SecurityException if the calling thread does not have permission\n     *     to create modal dialogs with the given <code>modalityType<\/code>\n     *\n     * @see java.awt.Dialog.ModalityType\n     * @see java.awt.Dialog#setModal\n     * @see java.awt.Dialog#setModalityType\n     * @see java.awt.GraphicsEnvironment#isHeadless\n     * @see java.awt.Toolkit#isModalityTypeSupported\n     *\n     * @since 1.6\n     */\n    public Dialog(Window owner, String title, ModalityType modalityType,\n                  GraphicsConfiguration gc) {\n        super(owner, gc);\n\n        if ((owner != null) &&\n            !(owner instanceof Frame) &&\n            !(owner instanceof Dialog))\n        {\n            throw new IllegalArgumentException(\"wrong owner window\");\n        }\n\n        this.title = title;\n        setModalityType(modalityType);\n        SunToolkit.checkAndSetPolicy(this);\n        initialized = true;\n    }"}
{"Number":"338","API Relative Path":"java.awt.Dialog.java-setBackground(Color)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setBackground(Color bgColor) {\n        synchronized (getTreeLock()) {\n            if ((bgColor != null) && (bgColor.getAlpha() < 255) && !isUndecorated()) {\n                throw new IllegalComponentStateException(\"The dialog is decorated\");\n            }\n            super.setBackground(bgColor);\n        }\n    }"}
{"Number":"339","API Relative Path":"java.awt.Dialog.java-setOpacity(float)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setOpacity(float opacity) {\n        synchronized (getTreeLock()) {\n            if ((opacity < 1.0f) && !isUndecorated()) {\n                throw new IllegalComponentStateException(\"The dialog is decorated\");\n            }\n            super.setOpacity(opacity);\n        }\n    }"}
{"Number":"340","API Relative Path":"java.awt.Dialog.java-setShape(Shape)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setShape(Shape shape) {\n        synchronized (getTreeLock()) {\n            if ((shape != null) && !isUndecorated()) {\n                throw new IllegalComponentStateException(\"The dialog is decorated\");\n            }\n            super.setShape(shape);\n        }\n    }"}
{"Number":"341","API Relative Path":"java.awt.Dialog.java-setUndecorated(boolean)","Corresponding Source":"/**\n     * Disables or enables decorations for this dialog.\n     * <p>\n     * This method can only be called while the dialog is not displayable. To\n     * make this dialog decorated, it must be opaque and have the default shape,\n     * otherwise the {@code IllegalComponentStateException} will be thrown.\n     * Refer to {@link Window#setShape}, {@link Window#setOpacity} and {@link\n     * Window#setBackground} for details\n     *\n     * @param  undecorated {@code true} if no dialog decorations are to be\n     *         enabled; {@code false} if dialog decorations are to be enabled\n     *\n     * @throws IllegalComponentStateException if the dialog is displayable\n     * @throws IllegalComponentStateException if {@code undecorated} is\n     *      {@code false}, and this dialog does not have the default shape\n     * @throws IllegalComponentStateException if {@code undecorated} is\n     *      {@code false}, and this dialog opacity is less than {@code 1.0f}\n     * @throws IllegalComponentStateException if {@code undecorated} is\n     *      {@code false}, and the alpha value of this dialog background\n     *      color is less than {@code 1.0f}\n     *\n     * @see    #isUndecorated\n     * @see    Component#isDisplayable\n     * @see    Window#getShape\n     * @see    Window#getOpacity\n     * @see    Window#getBackground\n     *\n     * @since 1.4\n     */\n    public void setUndecorated(boolean undecorated) {\n        /* Make sure we don't run in the middle of peer creation.*/\n        synchronized (getTreeLock()) {\n            if (isDisplayable()) {\n                throw new IllegalComponentStateException(\"The dialog is displayable.\");\n            }\n            if (!undecorated) {\n                if (getOpacity() < 1.0f) {\n                    throw new IllegalComponentStateException(\"The dialog is not opaque\");\n                }\n                if (getShape() != null) {\n                    throw new IllegalComponentStateException(\"The dialog does not have a default shape\");\n                }\n                Color bg = getBackground();\n                if ((bg != null) && (bg.getAlpha() < 255)) {\n                    throw new IllegalComponentStateException(\"The dialog background color is not opaque\");\n                }\n            }\n            this.undecorated = undecorated;\n        }\n    }"}
{"Number":"342","API Relative Path":"java.awt.Dialog.java-setUndecorated(boolean)","Corresponding Source":"/**\n     * Disables or enables decorations for this dialog.\n     * <p>\n     * This method can only be called while the dialog is not displayable. To\n     * make this dialog decorated, it must be opaque and have the default shape,\n     * otherwise the {@code IllegalComponentStateException} will be thrown.\n     * Refer to {@link Window#setShape}, {@link Window#setOpacity} and {@link\n     * Window#setBackground} for details\n     *\n     * @param  undecorated {@code true} if no dialog decorations are to be\n     *         enabled; {@code false} if dialog decorations are to be enabled\n     *\n     * @throws IllegalComponentStateException if the dialog is displayable\n     * @throws IllegalComponentStateException if {@code undecorated} is\n     *      {@code false}, and this dialog does not have the default shape\n     * @throws IllegalComponentStateException if {@code undecorated} is\n     *      {@code false}, and this dialog opacity is less than {@code 1.0f}\n     * @throws IllegalComponentStateException if {@code undecorated} is\n     *      {@code false}, and the alpha value of this dialog background\n     *      color is less than {@code 1.0f}\n     *\n     * @see    #isUndecorated\n     * @see    Component#isDisplayable\n     * @see    Window#getShape\n     * @see    Window#getOpacity\n     * @see    Window#getBackground\n     *\n     * @since 1.4\n     */\n    public void setUndecorated(boolean undecorated) {\n        /* Make sure we don't run in the middle of peer creation.*/\n        synchronized (getTreeLock()) {\n            if (isDisplayable()) {\n                throw new IllegalComponentStateException(\"The dialog is displayable.\");\n            }\n            if (!undecorated) {\n                if (getOpacity() < 1.0f) {\n                    throw new IllegalComponentStateException(\"The dialog is not opaque\");\n                }\n                if (getShape() != null) {\n                    throw new IllegalComponentStateException(\"The dialog does not have a default shape\");\n                }\n                Color bg = getBackground();\n                if ((bg != null) && (bg.getAlpha() < 255)) {\n                    throw new IllegalComponentStateException(\"The dialog background color is not opaque\");\n                }\n            }\n            this.undecorated = undecorated;\n        }\n    }"}
{"Number":"343","API Relative Path":"java.awt.Dialog.java-setUndecorated(boolean)","Corresponding Source":"/**\n     * Disables or enables decorations for this dialog.\n     * <p>\n     * This method can only be called while the dialog is not displayable. To\n     * make this dialog decorated, it must be opaque and have the default shape,\n     * otherwise the {@code IllegalComponentStateException} will be thrown.\n     * Refer to {@link Window#setShape}, {@link Window#setOpacity} and {@link\n     * Window#setBackground} for details\n     *\n     * @param  undecorated {@code true} if no dialog decorations are to be\n     *         enabled; {@code false} if dialog decorations are to be enabled\n     *\n     * @throws IllegalComponentStateException if the dialog is displayable\n     * @throws IllegalComponentStateException if {@code undecorated} is\n     *      {@code false}, and this dialog does not have the default shape\n     * @throws IllegalComponentStateException if {@code undecorated} is\n     *      {@code false}, and this dialog opacity is less than {@code 1.0f}\n     * @throws IllegalComponentStateException if {@code undecorated} is\n     *      {@code false}, and the alpha value of this dialog background\n     *      color is less than {@code 1.0f}\n     *\n     * @see    #isUndecorated\n     * @see    Component#isDisplayable\n     * @see    Window#getShape\n     * @see    Window#getOpacity\n     * @see    Window#getBackground\n     *\n     * @since 1.4\n     */\n    public void setUndecorated(boolean undecorated) {\n        /* Make sure we don't run in the middle of peer creation.*/\n        synchronized (getTreeLock()) {\n            if (isDisplayable()) {\n                throw new IllegalComponentStateException(\"The dialog is displayable.\");\n            }\n            if (!undecorated) {\n                if (getOpacity() < 1.0f) {\n                    throw new IllegalComponentStateException(\"The dialog is not opaque\");\n                }\n                if (getShape() != null) {\n                    throw new IllegalComponentStateException(\"The dialog does not have a default shape\");\n                }\n                Color bg = getBackground();\n                if ((bg != null) && (bg.getAlpha() < 255)) {\n                    throw new IllegalComponentStateException(\"The dialog background color is not opaque\");\n                }\n            }\n            this.undecorated = undecorated;\n        }\n    }"}
{"Number":"344","API Relative Path":"java.awt.dnd.DnDEventMulticaster.java-remove(DragSourceListener-DragSourceListener)","Corresponding Source":"/**\n     * Removes the old drag-source-listener from drag-source-listener-l\n     * and returns the resulting multicast listener.\n     *\n     * @param l drag-source-listener-l\n     * @param oldl the drag-source-listener being removed\n     */\n    public static DragSourceListener remove(DragSourceListener l,\n                                            DragSourceListener oldl) {\n        return (DragSourceListener)removeInternal(l, oldl);\n    }"}
{"Number":"345","API Relative Path":"java.awt.dnd.DnDEventMulticaster.java-remove(DragSourceMotionListener-DragSourceMotionListener)","Corresponding Source":"/**\n     * Removes the old drag-source-motion-listener from\n     * drag-source-motion-listener-l and returns the resulting multicast\n     * listener.\n     *\n     * @param l drag-source-motion-listener-l\n     * @param ol the drag-source-motion-listener being removed\n     */\n    public static DragSourceMotionListener remove(DragSourceMotionListener l,\n                                                  DragSourceMotionListener ol) {\n        return (DragSourceMotionListener)removeInternal(l, ol);\n    }"}
{"Number":"346","API Relative Path":"java.awt.dnd.DnDEventMulticaster.java-removeInternal(EventListener-EventListener)","Corresponding Source":"/**\n     * Returns the resulting multicast listener after removing the\n     * old listener from listener-l.\n     * If listener-l equals the old listener OR listener-l is null,\n     * returns null.\n     * Else if listener-l is an instance of AWTEventMulticaster,\n     * then it removes the old listener from it.\n     * Else, returns listener l.\n     * @param l the listener being removed from\n     * @param oldl the listener being removed\n     */\n    protected static EventListener removeInternal(EventListener l, EventListener oldl) {\n        if (l == oldl || l == null) {\n            return null;\n        } else if (l instanceof DnDEventMulticaster) {\n            return ((DnDEventMulticaster)l).remove(oldl);\n        } else {\n            return l;           // it's not here\n        }\n    }"}
{"Number":"347","API Relative Path":"java.awt.dnd.DragGestureEvent.java-DragGestureEvent(DragGestureRecognizer-int-Point-List)","Corresponding Source":"/**\n     * Constructs a <code>DragGestureEvent<\/code> object given by the\n     * <code>DragGestureRecognizer<\/code> instance firing this event,\n     * an {@code act} parameter representing\n     * the user's preferred action, an {@code ori} parameter\n     * indicating the origin of the drag, and a {@code List} of\n     * events that comprise the gesture({@code evs} parameter).\n     * <P>\n     * @param dgr The <code>DragGestureRecognizer<\/code> firing this event\n     * @param act The user's preferred action.\n     *            For information on allowable values, see\n     *            the class description for {@link DragGestureEvent}\n     * @param ori The origin of the drag\n     * @param evs The <code>List<\/code> of events that comprise the gesture\n     * <P>\n     * @throws IllegalArgumentException if any parameter equals {@code null}\n     * @throws IllegalArgumentException if the act parameter does not comply with\n     *                                  the values given in the class\n     *                                  description for {@link DragGestureEvent}\n     * @see java.awt.dnd.DnDConstants\n     */\n\n    public DragGestureEvent(DragGestureRecognizer dgr, int act, Point ori,\n                            List<? extends InputEvent> evs)\n    {\n        super(dgr);\n\n        if ((component = dgr.getComponent()) == null)\n            throw new IllegalArgumentException(\"null component\");\n        if ((dragSource = dgr.getDragSource()) == null)\n            throw new IllegalArgumentException(\"null DragSource\");\n\n        if (evs == null || evs.isEmpty())\n            throw new IllegalArgumentException(\"null or empty list of events\");\n\n        if (act != DnDConstants.ACTION_COPY &&\n            act != DnDConstants.ACTION_MOVE &&\n            act != DnDConstants.ACTION_LINK)\n            throw new IllegalArgumentException(\"bad action\");\n\n        if (ori == null) throw new IllegalArgumentException(\"null origin\");\n\n        events     = evs;\n        action     = act;\n        origin     = ori;\n    }"}
{"Number":"348","API Relative Path":"java.awt.dnd.DragGestureRecognizer.java-removeDragGestureListener(DragGestureListener)","Corresponding Source":"/**\n     * unregister the current DragGestureListener\n     * <P>\n     * @param dgl the <code>DragGestureListener<\/code> to unregister\n     * from this <code>DragGestureRecognizer<\/code>\n     * <P>\n     * @throws IllegalArgumentException if\n     * dgl is not (equal to) the currently registered <code>DragGestureListener<\/code>.\n     */\n\n    public synchronized void removeDragGestureListener(DragGestureListener dgl) {\n        if (dragGestureListener == null || !dragGestureListener.equals(dgl))\n            throw new IllegalArgumentException();\n        else {\n            dragGestureListener = null;\n\n            if (component != null) unregisterListeners();\n        }\n    }"}
{"Number":"349","API Relative Path":"java.awt.dnd.DragSource.java-addDragSourceListener(DragSourceListener)","Corresponding Source":"/**\n     * Adds the specified <code>DragSourceListener<\/code> to this\n     * <code>DragSource<\/code> to receive drag source events during drag\n     * operations intiated with this <code>DragSource<\/code>.\n     * If a <code>null<\/code> listener is specified, no action is taken and no\n     * exception is thrown.\n     *\n     * @param dsl the <code>DragSourceListener<\/code> to add\n     *\n     * @see      #removeDragSourceListener\n     * @see      #getDragSourceListeners\n     * @since 1.4\n     */\n    public void addDragSourceListener(DragSourceListener dsl) {\n        if (dsl != null) {\n            synchronized (this) {\n                listener = DnDEventMulticaster.add(listener, dsl);\n            }\n        }\n    }"}
{"Number":"350","API Relative Path":"java.awt.dnd.DragSource.java-addDragSourceMotionListener(DragSourceMotionListener)","Corresponding Source":"/**\n     * Adds the specified <code>DragSourceMotionListener<\/code> to this\n     * <code>DragSource<\/code> to receive drag motion events during drag\n     * operations intiated with this <code>DragSource<\/code>.\n     * If a <code>null<\/code> listener is specified, no action is taken and no\n     * exception is thrown.\n     *\n     * @param dsml the <code>DragSourceMotionListener<\/code> to add\n     *\n     * @see      #removeDragSourceMotionListener\n     * @see      #getDragSourceMotionListeners\n     * @since 1.4\n     */\n    public void addDragSourceMotionListener(DragSourceMotionListener dsml) {\n        if (dsml != null) {\n            synchronized (this) {\n                motionListener = DnDEventMulticaster.add(motionListener, dsml);\n            }\n        }\n    }"}
{"Number":"351","API Relative Path":"java.awt.dnd.DragSource.java-removeDragSourceListener(DragSourceListener)","Corresponding Source":"/**\n     * Removes the specified <code>DragSourceListener<\/code> from this\n     * <code>DragSource<\/code>.\n     * If a <code>null<\/code> listener is specified, no action is taken and no\n     * exception is thrown.\n     * If the listener specified by the argument was not previously added to\n     * this <code>DragSource<\/code>, no action is taken and no exception\n     * is thrown.\n     *\n     * @param dsl the <code>DragSourceListener<\/code> to remove\n     *\n     * @see      #addDragSourceListener\n     * @see      #getDragSourceListeners\n     * @since 1.4\n     */\n    public void removeDragSourceListener(DragSourceListener dsl) {\n        if (dsl != null) {\n            synchronized (this) {\n                listener = DnDEventMulticaster.remove(listener, dsl);\n            }\n        }\n    }"}
{"Number":"352","API Relative Path":"java.awt.dnd.DragSource.java-removeDragSourceMotionListener(DragSourceMotionListener)","Corresponding Source":"/**\n     * Removes the specified <code>DragSourceMotionListener<\/code> from this\n     * <code>DragSource<\/code>.\n     * If a <code>null<\/code> listener is specified, no action is taken and no\n     * exception is thrown.\n     * If the listener specified by the argument was not previously added to\n     * this <code>DragSource<\/code>, no action is taken and no exception\n     * is thrown.\n     *\n     * @param dsml the <code>DragSourceMotionListener<\/code> to remove\n     *\n     * @see      #addDragSourceMotionListener\n     * @see      #getDragSourceMotionListeners\n     * @since 1.4\n     */\n    public void removeDragSourceMotionListener(DragSourceMotionListener dsml) {\n        if (dsml != null) {\n            synchronized (this) {\n                motionListener = DnDEventMulticaster.remove(motionListener, dsml);\n            }\n        }\n    }"}
{"Number":"353","API Relative Path":"java.awt.dnd.DragSourceContext.java-removeDragSourceListener(DragSourceListener)","Corresponding Source":"/**\n     * Removes the specified <code>DragSourceListener<\/code>\n     * from  this <code>DragSourceContext<\/code>.\n     *\n     * @param dsl the <code>DragSourceListener<\/code> to remove;\n     *     note that while <code>null<\/code> is not prohibited,\n     *     it is not acceptable as a parameter\n     */\n\n    public synchronized void removeDragSourceListener(DragSourceListener dsl) {\n        if (listener != null && listener.equals(dsl)) {\n            listener = null;\n        } else\n            throw new IllegalArgumentException();\n    }"}
{"Number":"354","API Relative Path":"java.awt.dnd.DragSourceContext.java-setCursor(Cursor)","Corresponding Source":"/**\n     * Sets the cursor for this drag operation to the specified\n     * <code>Cursor<\/code>.  If the specified <code>Cursor<\/code>\n     * is <code>null<\/code>, the default drag cursor behavior is\n     * activated for this drag operation, otherwise it is deactivated.\n     *\n     * @param c     the initial {@code Cursor} for this drag operation,\n     *                       or {@code null} for the default cursor handling;\n     *                       see {@linkplain Cursor class\n     *                       level documentation} for more details\n     *                       on the cursor handling during drag and drop\n     *\n     */\n\n    public synchronized void setCursor(Cursor c) {\n        useCustomCursor = (c != null);\n        setCursorImpl(c);\n    }"}
{"Number":"355","API Relative Path":"java.awt.dnd.DropTarget.java-addDropTargetListener(DropTargetListener)","Corresponding Source":"/**\n     * Adds a new <code>DropTargetListener<\/code> (UNICAST SOURCE).\n     * <P>\n     * @param dtl The new <code>DropTargetListener<\/code>\n     * <P>\n     * @throws TooManyListenersException if a\n     * <code>DropTargetListener<\/code> is already added to this\n     * <code>DropTarget<\/code>.\n     */\n\n    public synchronized void addDropTargetListener(DropTargetListener dtl) throws TooManyListenersException {\n        if (dtl == null) return;\n\n        if (equals(dtl)) throw new IllegalArgumentException(\"DropTarget may not be its own Listener\");\n\n        if (dtListener == null)\n            dtListener = dtl;\n        else\n            throw new TooManyListenersException();\n    }"}
{"Number":"356","API Relative Path":"java.awt.dnd.DropTarget.java-removeDropTargetListener(DropTargetListener)","Corresponding Source":"/**\n     * Removes the current <code>DropTargetListener<\/code> (UNICAST SOURCE).\n     * <P>\n     * @param dtl the DropTargetListener to deregister.\n     */\n\n    public synchronized void removeDropTargetListener(DropTargetListener dtl) {\n        if (dtl != null && dtListener != null) {\n            if(dtListener.equals(dtl))\n                dtListener = null;\n            else\n                throw new IllegalArgumentException(\"listener mismatch\");\n        }\n    }"}
{"Number":"357","API Relative Path":"java.awt.dnd.DropTargetDragEvent.java-DropTargetDragEvent(DropTargetContext-Point-int-int)","Corresponding Source":"/**\n     * Construct a <code>DropTargetDragEvent<\/code> given the\n     * <code>DropTargetContext<\/code> for this operation,\n     * the location of the \"Drag\" <code>Cursor<\/code>'s hotspot\n     * in the <code>Component<\/code>'s coordinates, the\n     * user drop action, and the source drop actions.\n     * <P>\n     * @param dtc        The DropTargetContext for this operation\n     * @param cursorLocn The location of the \"Drag\" Cursor's\n     * hotspot in Component coordinates\n     * @param dropAction The user drop action\n     * @param srcActions The source drop actions\n     *\n     * @throws NullPointerException if cursorLocn is null\n     * @throws IllegalArgumentException if dropAction is not one of\n     *         <code>DnDConstants<\/code>.\n     * @throws IllegalArgumentException if srcActions is not\n     *         a bitwise mask of <code>DnDConstants<\/code>.\n     * @throws IllegalArgumentException if dtc is <code>null<\/code>.\n     */\n\n    public DropTargetDragEvent(DropTargetContext dtc, Point cursorLocn, int dropAction, int srcActions)  {\n        super(dtc);\n\n        if (cursorLocn == null) throw new NullPointerException(\"cursorLocn\");\n\n        if (dropAction != DnDConstants.ACTION_NONE &&\n            dropAction != DnDConstants.ACTION_COPY &&\n            dropAction != DnDConstants.ACTION_MOVE &&\n            dropAction != DnDConstants.ACTION_LINK\n        ) throw new IllegalArgumentException(\"dropAction\" + dropAction);\n\n        if ((srcActions & ~(DnDConstants.ACTION_COPY_OR_MOVE | DnDConstants.ACTION_LINK)) != 0) throw new IllegalArgumentException(\"srcActions\");\n\n        location        = cursorLocn;\n        actions         = srcActions;\n        this.dropAction = dropAction;\n    }"}
{"Number":"358","API Relative Path":"java.awt.dnd.DropTargetDragEvent.java-DropTargetDragEvent(DropTargetContext-Point-int-int)","Corresponding Source":"/**\n     * Construct a <code>DropTargetDragEvent<\/code> given the\n     * <code>DropTargetContext<\/code> for this operation,\n     * the location of the \"Drag\" <code>Cursor<\/code>'s hotspot\n     * in the <code>Component<\/code>'s coordinates, the\n     * user drop action, and the source drop actions.\n     * <P>\n     * @param dtc        The DropTargetContext for this operation\n     * @param cursorLocn The location of the \"Drag\" Cursor's\n     * hotspot in Component coordinates\n     * @param dropAction The user drop action\n     * @param srcActions The source drop actions\n     *\n     * @throws NullPointerException if cursorLocn is null\n     * @throws IllegalArgumentException if dropAction is not one of\n     *         <code>DnDConstants<\/code>.\n     * @throws IllegalArgumentException if srcActions is not\n     *         a bitwise mask of <code>DnDConstants<\/code>.\n     * @throws IllegalArgumentException if dtc is <code>null<\/code>.\n     */\n\n    public DropTargetDragEvent(DropTargetContext dtc, Point cursorLocn, int dropAction, int srcActions)  {\n        super(dtc);\n\n        if (cursorLocn == null) throw new NullPointerException(\"cursorLocn\");\n\n        if (dropAction != DnDConstants.ACTION_NONE &&\n            dropAction != DnDConstants.ACTION_COPY &&\n            dropAction != DnDConstants.ACTION_MOVE &&\n            dropAction != DnDConstants.ACTION_LINK\n        ) throw new IllegalArgumentException(\"dropAction\" + dropAction);\n\n        if ((srcActions & ~(DnDConstants.ACTION_COPY_OR_MOVE | DnDConstants.ACTION_LINK)) != 0) throw new IllegalArgumentException(\"srcActions\");\n\n        location        = cursorLocn;\n        actions         = srcActions;\n        this.dropAction = dropAction;\n    }"}
{"Number":"359","API Relative Path":"java.awt.dnd.DropTargetDropEvent.java-DropTargetDropEvent(DropTargetContext-Point-int-int)","Corresponding Source":"/**\n     * Construct a <code>DropTargetDropEvent<\/code> given\n     * the <code>DropTargetContext<\/code> for this operation,\n     * the location of the drag <code>Cursor<\/code>'s\n     * hotspot in the <code>Component<\/code>'s coordinates,\n     * the currently\n     * selected user drop action, and the current set of\n     * actions supported by the source.\n     * By default, this constructor\n     * assumes that the target is not in the same virtual machine as\n     * the source; that is, {@link #isLocalTransfer()} will\n     * return <code>false<\/code>.\n     * <P>\n     * @param dtc        The <code>DropTargetContext<\/code> for this operation\n     * @param cursorLocn The location of the \"Drag\" Cursor's\n     * hotspot in <code>Component<\/code> coordinates\n     * @param dropAction the user drop action.\n     * @param srcActions the source drop actions.\n     *\n     * @throws NullPointerException\n     * if cursorLocn is <code>null<\/code>\n     * @throws IllegalArgumentException\n     *         if dropAction is not one of  <code>DnDConstants<\/code>.\n     * @throws IllegalArgumentException\n     *         if srcActions is not a bitwise mask of <code>DnDConstants<\/code>.\n     * @throws IllegalArgumentException if dtc is <code>null<\/code>.\n     */\n\n    public DropTargetDropEvent(DropTargetContext dtc, Point cursorLocn, int dropAction, int srcActions)  {\n        super(dtc);\n\n        if (cursorLocn == null) throw new NullPointerException(\"cursorLocn\");\n\n        if (dropAction != DnDConstants.ACTION_NONE &&\n            dropAction != DnDConstants.ACTION_COPY &&\n            dropAction != DnDConstants.ACTION_MOVE &&\n            dropAction != DnDConstants.ACTION_LINK\n        ) throw new IllegalArgumentException(\"dropAction = \" + dropAction);\n\n        if ((srcActions & ~(DnDConstants.ACTION_COPY_OR_MOVE | DnDConstants.ACTION_LINK)) != 0) throw new IllegalArgumentException(\"srcActions\");\n\n        location        = cursorLocn;\n        actions         = srcActions;\n        this.dropAction = dropAction;\n    }"}
{"Number":"360","API Relative Path":"java.awt.dnd.DropTargetDropEvent.java-DropTargetDropEvent(DropTargetContext-Point-int-int)","Corresponding Source":"/**\n     * Construct a <code>DropTargetDropEvent<\/code> given\n     * the <code>DropTargetContext<\/code> for this operation,\n     * the location of the drag <code>Cursor<\/code>'s\n     * hotspot in the <code>Component<\/code>'s coordinates,\n     * the currently\n     * selected user drop action, and the current set of\n     * actions supported by the source.\n     * By default, this constructor\n     * assumes that the target is not in the same virtual machine as\n     * the source; that is, {@link #isLocalTransfer()} will\n     * return <code>false<\/code>.\n     * <P>\n     * @param dtc        The <code>DropTargetContext<\/code> for this operation\n     * @param cursorLocn The location of the \"Drag\" Cursor's\n     * hotspot in <code>Component<\/code> coordinates\n     * @param dropAction the user drop action.\n     * @param srcActions the source drop actions.\n     *\n     * @throws NullPointerException\n     * if cursorLocn is <code>null<\/code>\n     * @throws IllegalArgumentException\n     *         if dropAction is not one of  <code>DnDConstants<\/code>.\n     * @throws IllegalArgumentException\n     *         if srcActions is not a bitwise mask of <code>DnDConstants<\/code>.\n     * @throws IllegalArgumentException if dtc is <code>null<\/code>.\n     */\n\n    public DropTargetDropEvent(DropTargetContext dtc, Point cursorLocn, int dropAction, int srcActions)  {\n        super(dtc);\n\n        if (cursorLocn == null) throw new NullPointerException(\"cursorLocn\");\n\n        if (dropAction != DnDConstants.ACTION_NONE &&\n            dropAction != DnDConstants.ACTION_COPY &&\n            dropAction != DnDConstants.ACTION_MOVE &&\n            dropAction != DnDConstants.ACTION_LINK\n        ) throw new IllegalArgumentException(\"dropAction = \" + dropAction);\n\n        if ((srcActions & ~(DnDConstants.ACTION_COPY_OR_MOVE | DnDConstants.ACTION_LINK)) != 0) throw new IllegalArgumentException(\"srcActions\");\n\n        location        = cursorLocn;\n        actions         = srcActions;\n        this.dropAction = dropAction;\n    }"}
{"Number":"361","API Relative Path":"java.awt.event.InputEvent.java-getMaskForButton(int)","Corresponding Source":"/**\n     * A method to obtain a mask for any existing mouse button.\n     * The returned mask may be used for different purposes. Following are some of them:\n     * <ul>\n     * <li> {@link java.awt.Robot#mousePress(int) mousePress(buttons)} and\n     *      {@link java.awt.Robot#mouseRelease(int) mouseRelease(buttons)}\n     * <li> as a {@code modifiers} parameter when creating a new {@link MouseEvent} instance\n     * <li> to check {@link MouseEvent#getModifiersEx() modifiersEx} of existing {@code MouseEvent}\n     * <\/ul>\n     * @param button is a number to represent a button starting from 1.\n     * For example,\n     * <pre>\n     * int button = InputEvent.getMaskForButton(1);\n     * <\/pre>\n     * will have the same meaning as\n     * <pre>\n     * int button = InputEvent.getMaskForButton(MouseEvent.BUTTON1);\n     * <\/pre>\n     * because {@link MouseEvent#BUTTON1 MouseEvent.BUTTON1} equals to 1.\n     * If a mouse has three enabled buttons(see {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()})\n     * then the values from the left column passed into the method will return\n     * corresponding values from the right column:\n     * <PRE>\n     *    <b>button <\/b>   <b>returned mask<\/b>\n     *    {@link MouseEvent#BUTTON1 BUTTON1}  {@link MouseEvent#BUTTON1_DOWN_MASK BUTTON1_DOWN_MASK}\n     *    {@link MouseEvent#BUTTON2 BUTTON2}  {@link MouseEvent#BUTTON2_DOWN_MASK BUTTON2_DOWN_MASK}\n     *    {@link MouseEvent#BUTTON3 BUTTON3}  {@link MouseEvent#BUTTON3_DOWN_MASK BUTTON3_DOWN_MASK}\n     * <\/PRE>\n     * If a mouse has more than three enabled buttons then more values\n     * are admissible (4, 5, etc.). There is no assigned constants for these extended buttons.\n     * The button masks for the extra buttons returned by this method have no assigned names like the\n     * first three button masks.\n     * <p>\n     * This method has the following implementation restriction.\n     * It returns masks for a limited number of buttons only. The maximum number is\n     * implementation dependent and may vary.\n     * This limit is defined by the relevant number\n     * of buttons that may hypothetically exist on the mouse but it is greater than the\n     * {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()}.\n     * <p>\n     * @throws IllegalArgumentException if {@code button} is less than zero or greater than the number\n     *         of button masks reserved for buttons\n     * @since 7.0\n     * @see java.awt.MouseInfo#getNumberOfButtons()\n     * @see Toolkit#areExtraMouseButtonsEnabled()\n     * @see MouseEvent#getModifiers()\n     * @see MouseEvent#getModifiersEx()\n     */\n    public static int getMaskForButton(int button) {\n        if (button <= 0 || button > BUTTON_DOWN_MASK.length) {\n            throw new IllegalArgumentException(\"button doesn\\'t exist \" + button);\n        }\n        return BUTTON_DOWN_MASK[button - 1];\n    }"}
{"Number":"362","API Relative Path":"java.awt.event.InputMethodEvent.java-InputMethodEvent(Component-int-long-AttributedCharacterIterator-int-TextHitInfo-TextHitInfo)","Corresponding Source":"/**\n     * Constructs an <code>InputMethodEvent<\/code> with the specified\n     * source component, type, time, text, caret, and visiblePosition.\n     * <p>\n     * The offsets of caret and visiblePosition are relative to the current\n     * composed text; that is, the composed text within <code>text<\/code>\n     * if this is an <code>INPUT_METHOD_TEXT_CHANGED<\/code> event,\n     * the composed text within the <code>text<\/code> of the\n     * preceding <code>INPUT_METHOD_TEXT_CHANGED<\/code> event otherwise.\n     * <p>Note that passing in an invalid <code>id<\/code> results in\n     * unspecified behavior. This method throws an\n     * <code>IllegalArgumentException<\/code> if <code>source<\/code>\n     * is <code>null<\/code>.\n     *\n     * @param source the object where the event originated\n     * @param id the event type\n     * @param when a long integer that specifies the time the event occurred\n     * @param text the combined committed and composed text,\n     *      committed text first; must be <code>null<\/code>\n     *      when the event type is <code>CARET_POSITION_CHANGED<\/code>;\n     *      may be <code>null<\/code> for\n     *      <code>INPUT_METHOD_TEXT_CHANGED<\/code> if there's no\n     *      committed or composed text\n     * @param committedCharacterCount the number of committed\n     *      characters in the text\n     * @param caret the caret (a.k.a. insertion point);\n     *      <code>null<\/code> if there's no caret within current\n     *      composed text\n     * @param visiblePosition the position that's most important\n     *      to be visible; <code>null<\/code> if there's no\n     *      recommendation for a visible position within current\n     *      composed text\n     * @throws IllegalArgumentException if <code>id<\/code> is not\n     *      in the range\n     *      <code>INPUT_METHOD_FIRST<\/code>..<code>INPUT_METHOD_LAST<\/code>;\n     *      or if id is <code>CARET_POSITION_CHANGED<\/code> and\n     *      <code>text<\/code> is not <code>null<\/code>;\n     *      or if <code>committedCharacterCount<\/code> is not in the range\n     *      <code>0<\/code>..<code>(text.getEndIndex() - text.getBeginIndex())<\/code>\n     * @throws IllegalArgumentException if <code>source<\/code> is null\n     *\n     * @since 1.4\n     */\n    public InputMethodEvent(Component source, int id, long when,\n            AttributedCharacterIterator text, int committedCharacterCount,\n            TextHitInfo caret, TextHitInfo visiblePosition) {\n        super(source, id);\n        if (id < INPUT_METHOD_FIRST || id > INPUT_METHOD_LAST) {\n            throw new IllegalArgumentException(\"id outside of valid range\");\n        }\n\n        if (id == CARET_POSITION_CHANGED && text != null) {\n            throw new IllegalArgumentException(\"text must be null for CARET_POSITION_CHANGED\");\n        }\n\n        this.when = when;\n        this.text = text;\n        int textLength = 0;\n        if (text != null) {\n            textLength = text.getEndIndex() - text.getBeginIndex();\n        }\n\n        if (committedCharacterCount < 0 || committedCharacterCount > textLength) {\n            throw new IllegalArgumentException(\"committedCharacterCount outside of valid range\");\n        }\n        this.committedCharacterCount = committedCharacterCount;\n\n        this.caret = caret;\n        this.visiblePosition = visiblePosition;\n   }"}
{"Number":"363","API Relative Path":"java.awt.event.InputMethodEvent.java-InputMethodEvent(Component-int-long-AttributedCharacterIterator-int-TextHitInfo-TextHitInfo)","Corresponding Source":"/**\n     * Constructs an <code>InputMethodEvent<\/code> with the specified\n     * source component, type, time, text, caret, and visiblePosition.\n     * <p>\n     * The offsets of caret and visiblePosition are relative to the current\n     * composed text; that is, the composed text within <code>text<\/code>\n     * if this is an <code>INPUT_METHOD_TEXT_CHANGED<\/code> event,\n     * the composed text within the <code>text<\/code> of the\n     * preceding <code>INPUT_METHOD_TEXT_CHANGED<\/code> event otherwise.\n     * <p>Note that passing in an invalid <code>id<\/code> results in\n     * unspecified behavior. This method throws an\n     * <code>IllegalArgumentException<\/code> if <code>source<\/code>\n     * is <code>null<\/code>.\n     *\n     * @param source the object where the event originated\n     * @param id the event type\n     * @param when a long integer that specifies the time the event occurred\n     * @param text the combined committed and composed text,\n     *      committed text first; must be <code>null<\/code>\n     *      when the event type is <code>CARET_POSITION_CHANGED<\/code>;\n     *      may be <code>null<\/code> for\n     *      <code>INPUT_METHOD_TEXT_CHANGED<\/code> if there's no\n     *      committed or composed text\n     * @param committedCharacterCount the number of committed\n     *      characters in the text\n     * @param caret the caret (a.k.a. insertion point);\n     *      <code>null<\/code> if there's no caret within current\n     *      composed text\n     * @param visiblePosition the position that's most important\n     *      to be visible; <code>null<\/code> if there's no\n     *      recommendation for a visible position within current\n     *      composed text\n     * @throws IllegalArgumentException if <code>id<\/code> is not\n     *      in the range\n     *      <code>INPUT_METHOD_FIRST<\/code>..<code>INPUT_METHOD_LAST<\/code>;\n     *      or if id is <code>CARET_POSITION_CHANGED<\/code> and\n     *      <code>text<\/code> is not <code>null<\/code>;\n     *      or if <code>committedCharacterCount<\/code> is not in the range\n     *      <code>0<\/code>..<code>(text.getEndIndex() - text.getBeginIndex())<\/code>\n     * @throws IllegalArgumentException if <code>source<\/code> is null\n     *\n     * @since 1.4\n     */\n    public InputMethodEvent(Component source, int id, long when,\n            AttributedCharacterIterator text, int committedCharacterCount,\n            TextHitInfo caret, TextHitInfo visiblePosition) {\n        super(source, id);\n        if (id < INPUT_METHOD_FIRST || id > INPUT_METHOD_LAST) {\n            throw new IllegalArgumentException(\"id outside of valid range\");\n        }\n\n        if (id == CARET_POSITION_CHANGED && text != null) {\n            throw new IllegalArgumentException(\"text must be null for CARET_POSITION_CHANGED\");\n        }\n\n        this.when = when;\n        this.text = text;\n        int textLength = 0;\n        if (text != null) {\n            textLength = text.getEndIndex() - text.getBeginIndex();\n        }\n\n        if (committedCharacterCount < 0 || committedCharacterCount > textLength) {\n            throw new IllegalArgumentException(\"committedCharacterCount outside of valid range\");\n        }\n        this.committedCharacterCount = committedCharacterCount;\n\n        this.caret = caret;\n        this.visiblePosition = visiblePosition;\n   }"}
{"Number":"364","API Relative Path":"java.awt.event.InputMethodEvent.java-InputMethodEvent(Component-int-long-AttributedCharacterIterator-int-TextHitInfo-TextHitInfo)","Corresponding Source":"/**\n     * Constructs an <code>InputMethodEvent<\/code> with the specified\n     * source component, type, time, text, caret, and visiblePosition.\n     * <p>\n     * The offsets of caret and visiblePosition are relative to the current\n     * composed text; that is, the composed text within <code>text<\/code>\n     * if this is an <code>INPUT_METHOD_TEXT_CHANGED<\/code> event,\n     * the composed text within the <code>text<\/code> of the\n     * preceding <code>INPUT_METHOD_TEXT_CHANGED<\/code> event otherwise.\n     * <p>Note that passing in an invalid <code>id<\/code> results in\n     * unspecified behavior. This method throws an\n     * <code>IllegalArgumentException<\/code> if <code>source<\/code>\n     * is <code>null<\/code>.\n     *\n     * @param source the object where the event originated\n     * @param id the event type\n     * @param when a long integer that specifies the time the event occurred\n     * @param text the combined committed and composed text,\n     *      committed text first; must be <code>null<\/code>\n     *      when the event type is <code>CARET_POSITION_CHANGED<\/code>;\n     *      may be <code>null<\/code> for\n     *      <code>INPUT_METHOD_TEXT_CHANGED<\/code> if there's no\n     *      committed or composed text\n     * @param committedCharacterCount the number of committed\n     *      characters in the text\n     * @param caret the caret (a.k.a. insertion point);\n     *      <code>null<\/code> if there's no caret within current\n     *      composed text\n     * @param visiblePosition the position that's most important\n     *      to be visible; <code>null<\/code> if there's no\n     *      recommendation for a visible position within current\n     *      composed text\n     * @throws IllegalArgumentException if <code>id<\/code> is not\n     *      in the range\n     *      <code>INPUT_METHOD_FIRST<\/code>..<code>INPUT_METHOD_LAST<\/code>;\n     *      or if id is <code>CARET_POSITION_CHANGED<\/code> and\n     *      <code>text<\/code> is not <code>null<\/code>;\n     *      or if <code>committedCharacterCount<\/code> is not in the range\n     *      <code>0<\/code>..<code>(text.getEndIndex() - text.getBeginIndex())<\/code>\n     * @throws IllegalArgumentException if <code>source<\/code> is null\n     *\n     * @since 1.4\n     */\n    public InputMethodEvent(Component source, int id, long when,\n            AttributedCharacterIterator text, int committedCharacterCount,\n            TextHitInfo caret, TextHitInfo visiblePosition) {\n        super(source, id);\n        if (id < INPUT_METHOD_FIRST || id > INPUT_METHOD_LAST) {\n            throw new IllegalArgumentException(\"id outside of valid range\");\n        }\n\n        if (id == CARET_POSITION_CHANGED && text != null) {\n            throw new IllegalArgumentException(\"text must be null for CARET_POSITION_CHANGED\");\n        }\n\n        this.when = when;\n        this.text = text;\n        int textLength = 0;\n        if (text != null) {\n            textLength = text.getEndIndex() - text.getBeginIndex();\n        }\n\n        if (committedCharacterCount < 0 || committedCharacterCount > textLength) {\n            throw new IllegalArgumentException(\"committedCharacterCount outside of valid range\");\n        }\n        this.committedCharacterCount = committedCharacterCount;\n\n        this.caret = caret;\n        this.visiblePosition = visiblePosition;\n   }"}
{"Number":"365","API Relative Path":"java.awt.event.KeyEvent.java-KeyEvent(Component-int-long-int-int-char-int)","Corresponding Source":"/**\n     * Constructs a <code>KeyEvent<\/code> object.\n     * <p>This method throws an\n     * <code>IllegalArgumentException<\/code> if <code>source<\/code>\n     * is <code>null<\/code>.\n     *\n     * @param source    The <code>Component<\/code> that originated the event\n     * @param id              An integer indicating the type of event.\n     *                  For information on allowable values, see\n     *                  the class description for {@link KeyEvent}\n     * @param when      A long integer that specifies the time the event\n     *                  occurred.\n     *                     Passing negative or zero value\n     *                     is not recommended\n     * @param modifiers The modifier keys down during event (shift, ctrl,\n     *                  alt, meta).\n     *                     Passing negative value\n     *                     is not recommended.\n     *                     Zero value means that no modifiers were passed.\n     *                  Use either an extended _DOWN_MASK or old _MASK modifiers,\n     *                  however do not mix models in the one event.\n     *                  The extended modifiers are preferred for using\n     * @param keyCode   The integer code for an actual key, or VK_UNDEFINED\n     *                  (for a key-typed event)\n     * @param keyChar   The Unicode character generated by this event, or\n     *                  CHAR_UNDEFINED (for key-pressed and key-released\n     *                  events which do not map to a valid Unicode character)\n     * @param keyLocation  Identifies the key location.  The only legal\n     *        values are <code>KEY_LOCATION_UNKNOWN<\/code>,\n     *        <code>KEY_LOCATION_STANDARD<\/code>, <code>KEY_LOCATION_LEFT<\/code>,\n     *        <code>KEY_LOCATION_RIGHT<\/code>, and <code>KEY_LOCATION_NUMPAD<\/code>.\n     * @throws IllegalArgumentException\n     *     if <code>id<\/code> is <code>KEY_TYPED<\/code> and\n     *       <code>keyChar<\/code> is <code>CHAR_UNDEFINED<\/code>;\n     *     or if <code>id<\/code> is <code>KEY_TYPED<\/code> and\n     *       <code>keyCode<\/code> is not <code>VK_UNDEFINED<\/code>;\n     *     or if <code>id<\/code> is <code>KEY_TYPED<\/code> and\n     *       <code>keyLocation<\/code> is not <code>KEY_LOCATION_UNKNOWN<\/code>;\n     *     or if <code>keyLocation<\/code> is not one of the legal\n     *       values enumerated above.\n     * @throws IllegalArgumentException if <code>source<\/code> is null\n     * @see #getSource()\n     * @see #getID()\n     * @see #getWhen()\n     * @see #getModifiers()\n     * @see #getKeyCode()\n     * @see #getKeyChar()\n     * @see #getKeyLocation()\n     * @since 1.4\n     */\n    public KeyEvent(Component source, int id, long when, int modifiers,\n                    int keyCode, char keyChar, int keyLocation) {\n        super(source, id, when, modifiers);\n        if (id == KEY_TYPED) {\n            if (keyChar == CHAR_UNDEFINED) {\n                throw new IllegalArgumentException(\"invalid keyChar\");\n            }\n            if (keyCode != VK_UNDEFINED) {\n                throw new IllegalArgumentException(\"invalid keyCode\");\n            }\n            if (keyLocation != KEY_LOCATION_UNKNOWN) {\n                throw new IllegalArgumentException(\"invalid keyLocation\");\n            }\n        }\n\n        this.keyCode = keyCode;\n        this.keyChar = keyChar;\n\n        if ((keyLocation < KEY_LOCATION_UNKNOWN) ||\n            (keyLocation > KEY_LOCATION_NUMPAD)) {\n            throw new IllegalArgumentException(\"invalid keyLocation\");\n        }\n        this.keyLocation = keyLocation;\n        if ((getModifiers() != 0) && (getModifiersEx() == 0)) {\n            setNewModifiers();\n        } else if ((getModifiers() == 0) && (getModifiersEx() != 0)) {\n            setOldModifiers();\n        }\n        originalSource = source;\n    }"}
{"Number":"366","API Relative Path":"java.awt.event.KeyEvent.java-KeyEvent(Component-int-long-int-int-char-int)","Corresponding Source":"/**\n     * Constructs a <code>KeyEvent<\/code> object.\n     * <p>This method throws an\n     * <code>IllegalArgumentException<\/code> if <code>source<\/code>\n     * is <code>null<\/code>.\n     *\n     * @param source    The <code>Component<\/code> that originated the event\n     * @param id              An integer indicating the type of event.\n     *                  For information on allowable values, see\n     *                  the class description for {@link KeyEvent}\n     * @param when      A long integer that specifies the time the event\n     *                  occurred.\n     *                     Passing negative or zero value\n     *                     is not recommended\n     * @param modifiers The modifier keys down during event (shift, ctrl,\n     *                  alt, meta).\n     *                     Passing negative value\n     *                     is not recommended.\n     *                     Zero value means that no modifiers were passed.\n     *                  Use either an extended _DOWN_MASK or old _MASK modifiers,\n     *                  however do not mix models in the one event.\n     *                  The extended modifiers are preferred for using\n     * @param keyCode   The integer code for an actual key, or VK_UNDEFINED\n     *                  (for a key-typed event)\n     * @param keyChar   The Unicode character generated by this event, or\n     *                  CHAR_UNDEFINED (for key-pressed and key-released\n     *                  events which do not map to a valid Unicode character)\n     * @param keyLocation  Identifies the key location.  The only legal\n     *        values are <code>KEY_LOCATION_UNKNOWN<\/code>,\n     *        <code>KEY_LOCATION_STANDARD<\/code>, <code>KEY_LOCATION_LEFT<\/code>,\n     *        <code>KEY_LOCATION_RIGHT<\/code>, and <code>KEY_LOCATION_NUMPAD<\/code>.\n     * @throws IllegalArgumentException\n     *     if <code>id<\/code> is <code>KEY_TYPED<\/code> and\n     *       <code>keyChar<\/code> is <code>CHAR_UNDEFINED<\/code>;\n     *     or if <code>id<\/code> is <code>KEY_TYPED<\/code> and\n     *       <code>keyCode<\/code> is not <code>VK_UNDEFINED<\/code>;\n     *     or if <code>id<\/code> is <code>KEY_TYPED<\/code> and\n     *       <code>keyLocation<\/code> is not <code>KEY_LOCATION_UNKNOWN<\/code>;\n     *     or if <code>keyLocation<\/code> is not one of the legal\n     *       values enumerated above.\n     * @throws IllegalArgumentException if <code>source<\/code> is null\n     * @see #getSource()\n     * @see #getID()\n     * @see #getWhen()\n     * @see #getModifiers()\n     * @see #getKeyCode()\n     * @see #getKeyChar()\n     * @see #getKeyLocation()\n     * @since 1.4\n     */\n    public KeyEvent(Component source, int id, long when, int modifiers,\n                    int keyCode, char keyChar, int keyLocation) {\n        super(source, id, when, modifiers);\n        if (id == KEY_TYPED) {\n            if (keyChar == CHAR_UNDEFINED) {\n                throw new IllegalArgumentException(\"invalid keyChar\");\n            }\n            if (keyCode != VK_UNDEFINED) {\n                throw new IllegalArgumentException(\"invalid keyCode\");\n            }\n            if (keyLocation != KEY_LOCATION_UNKNOWN) {\n                throw new IllegalArgumentException(\"invalid keyLocation\");\n            }\n        }\n\n        this.keyCode = keyCode;\n        this.keyChar = keyChar;\n\n        if ((keyLocation < KEY_LOCATION_UNKNOWN) ||\n            (keyLocation > KEY_LOCATION_NUMPAD)) {\n            throw new IllegalArgumentException(\"invalid keyLocation\");\n        }\n        this.keyLocation = keyLocation;\n        if ((getModifiers() != 0) && (getModifiersEx() == 0)) {\n            setNewModifiers();\n        } else if ((getModifiers() == 0) && (getModifiersEx() != 0)) {\n            setOldModifiers();\n        }\n        originalSource = source;\n    }"}
{"Number":"367","API Relative Path":"java.awt.event.KeyEvent.java-KeyEvent(Component-int-long-int-int-char-int)","Corresponding Source":"/**\n     * Constructs a <code>KeyEvent<\/code> object.\n     * <p>This method throws an\n     * <code>IllegalArgumentException<\/code> if <code>source<\/code>\n     * is <code>null<\/code>.\n     *\n     * @param source    The <code>Component<\/code> that originated the event\n     * @param id              An integer indicating the type of event.\n     *                  For information on allowable values, see\n     *                  the class description for {@link KeyEvent}\n     * @param when      A long integer that specifies the time the event\n     *                  occurred.\n     *                     Passing negative or zero value\n     *                     is not recommended\n     * @param modifiers The modifier keys down during event (shift, ctrl,\n     *                  alt, meta).\n     *                     Passing negative value\n     *                     is not recommended.\n     *                     Zero value means that no modifiers were passed.\n     *                  Use either an extended _DOWN_MASK or old _MASK modifiers,\n     *                  however do not mix models in the one event.\n     *                  The extended modifiers are preferred for using\n     * @param keyCode   The integer code for an actual key, or VK_UNDEFINED\n     *                  (for a key-typed event)\n     * @param keyChar   The Unicode character generated by this event, or\n     *                  CHAR_UNDEFINED (for key-pressed and key-released\n     *                  events which do not map to a valid Unicode character)\n     * @param keyLocation  Identifies the key location.  The only legal\n     *        values are <code>KEY_LOCATION_UNKNOWN<\/code>,\n     *        <code>KEY_LOCATION_STANDARD<\/code>, <code>KEY_LOCATION_LEFT<\/code>,\n     *        <code>KEY_LOCATION_RIGHT<\/code>, and <code>KEY_LOCATION_NUMPAD<\/code>.\n     * @throws IllegalArgumentException\n     *     if <code>id<\/code> is <code>KEY_TYPED<\/code> and\n     *       <code>keyChar<\/code> is <code>CHAR_UNDEFINED<\/code>;\n     *     or if <code>id<\/code> is <code>KEY_TYPED<\/code> and\n     *       <code>keyCode<\/code> is not <code>VK_UNDEFINED<\/code>;\n     *     or if <code>id<\/code> is <code>KEY_TYPED<\/code> and\n     *       <code>keyLocation<\/code> is not <code>KEY_LOCATION_UNKNOWN<\/code>;\n     *     or if <code>keyLocation<\/code> is not one of the legal\n     *       values enumerated above.\n     * @throws IllegalArgumentException if <code>source<\/code> is null\n     * @see #getSource()\n     * @see #getID()\n     * @see #getWhen()\n     * @see #getModifiers()\n     * @see #getKeyCode()\n     * @see #getKeyChar()\n     * @see #getKeyLocation()\n     * @since 1.4\n     */\n    public KeyEvent(Component source, int id, long when, int modifiers,\n                    int keyCode, char keyChar, int keyLocation) {\n        super(source, id, when, modifiers);\n        if (id == KEY_TYPED) {\n            if (keyChar == CHAR_UNDEFINED) {\n                throw new IllegalArgumentException(\"invalid keyChar\");\n            }\n            if (keyCode != VK_UNDEFINED) {\n                throw new IllegalArgumentException(\"invalid keyCode\");\n            }\n            if (keyLocation != KEY_LOCATION_UNKNOWN) {\n                throw new IllegalArgumentException(\"invalid keyLocation\");\n            }\n        }\n\n        this.keyCode = keyCode;\n        this.keyChar = keyChar;\n\n        if ((keyLocation < KEY_LOCATION_UNKNOWN) ||\n            (keyLocation > KEY_LOCATION_NUMPAD)) {\n            throw new IllegalArgumentException(\"invalid keyLocation\");\n        }\n        this.keyLocation = keyLocation;\n        if ((getModifiers() != 0) && (getModifiersEx() == 0)) {\n            setNewModifiers();\n        } else if ((getModifiers() == 0) && (getModifiersEx() != 0)) {\n            setOldModifiers();\n        }\n        originalSource = source;\n    }"}
{"Number":"368","API Relative Path":"java.awt.event.KeyEvent.java-KeyEvent(Component-int-long-int-int-char-int)","Corresponding Source":"/**\n     * Constructs a <code>KeyEvent<\/code> object.\n     * <p>This method throws an\n     * <code>IllegalArgumentException<\/code> if <code>source<\/code>\n     * is <code>null<\/code>.\n     *\n     * @param source    The <code>Component<\/code> that originated the event\n     * @param id              An integer indicating the type of event.\n     *                  For information on allowable values, see\n     *                  the class description for {@link KeyEvent}\n     * @param when      A long integer that specifies the time the event\n     *                  occurred.\n     *                     Passing negative or zero value\n     *                     is not recommended\n     * @param modifiers The modifier keys down during event (shift, ctrl,\n     *                  alt, meta).\n     *                     Passing negative value\n     *                     is not recommended.\n     *                     Zero value means that no modifiers were passed.\n     *                  Use either an extended _DOWN_MASK or old _MASK modifiers,\n     *                  however do not mix models in the one event.\n     *                  The extended modifiers are preferred for using\n     * @param keyCode   The integer code for an actual key, or VK_UNDEFINED\n     *                  (for a key-typed event)\n     * @param keyChar   The Unicode character generated by this event, or\n     *                  CHAR_UNDEFINED (for key-pressed and key-released\n     *                  events which do not map to a valid Unicode character)\n     * @param keyLocation  Identifies the key location.  The only legal\n     *        values are <code>KEY_LOCATION_UNKNOWN<\/code>,\n     *        <code>KEY_LOCATION_STANDARD<\/code>, <code>KEY_LOCATION_LEFT<\/code>,\n     *        <code>KEY_LOCATION_RIGHT<\/code>, and <code>KEY_LOCATION_NUMPAD<\/code>.\n     * @throws IllegalArgumentException\n     *     if <code>id<\/code> is <code>KEY_TYPED<\/code> and\n     *       <code>keyChar<\/code> is <code>CHAR_UNDEFINED<\/code>;\n     *     or if <code>id<\/code> is <code>KEY_TYPED<\/code> and\n     *       <code>keyCode<\/code> is not <code>VK_UNDEFINED<\/code>;\n     *     or if <code>id<\/code> is <code>KEY_TYPED<\/code> and\n     *       <code>keyLocation<\/code> is not <code>KEY_LOCATION_UNKNOWN<\/code>;\n     *     or if <code>keyLocation<\/code> is not one of the legal\n     *       values enumerated above.\n     * @throws IllegalArgumentException if <code>source<\/code> is null\n     * @see #getSource()\n     * @see #getID()\n     * @see #getWhen()\n     * @see #getModifiers()\n     * @see #getKeyCode()\n     * @see #getKeyChar()\n     * @see #getKeyLocation()\n     * @since 1.4\n     */\n    public KeyEvent(Component source, int id, long when, int modifiers,\n                    int keyCode, char keyChar, int keyLocation) {\n        super(source, id, when, modifiers);\n        if (id == KEY_TYPED) {\n            if (keyChar == CHAR_UNDEFINED) {\n                throw new IllegalArgumentException(\"invalid keyChar\");\n            }\n            if (keyCode != VK_UNDEFINED) {\n                throw new IllegalArgumentException(\"invalid keyCode\");\n            }\n            if (keyLocation != KEY_LOCATION_UNKNOWN) {\n                throw new IllegalArgumentException(\"invalid keyLocation\");\n            }\n        }\n\n        this.keyCode = keyCode;\n        this.keyChar = keyChar;\n\n        if ((keyLocation < KEY_LOCATION_UNKNOWN) ||\n            (keyLocation > KEY_LOCATION_NUMPAD)) {\n            throw new IllegalArgumentException(\"invalid keyLocation\");\n        }\n        this.keyLocation = keyLocation;\n        if ((getModifiers() != 0) && (getModifiersEx() == 0)) {\n            setNewModifiers();\n        } else if ((getModifiers() == 0) && (getModifiersEx() != 0)) {\n            setOldModifiers();\n        }\n        originalSource = source;\n    }"}
{"Number":"369","API Relative Path":"java.awt.event.MouseEvent.java-MouseEvent(Component-int-long-int-int-int-int-int-int-boolean-int)","Corresponding Source":"/**\n     * Constructs a <code>MouseEvent<\/code> object with the\n     * specified source component,\n     * type, time, modifiers, coordinates, absolute coordinates, click count, popupTrigger flag,\n     * and button number.\n     * <p>\n     * Creating an invalid event (such\n     * as by using more than one of the old _MASKs, or modifier/button\n     * values which don't match) results in unspecified behavior.\n     * Even if inconsistent values for relative and absolute coordinates are\n     * passed to the constructor, the mouse event instance is still\n     * created and no exception is thrown.\n     * This method throws an\n     * <code>IllegalArgumentException<\/code> if <code>source<\/code>\n     * is <code>null<\/code>.\n     *\n     * @param source       The <code>Component<\/code> that originated the event\n     * @param id              An integer indicating the type of event.\n     *                     For information on allowable values, see\n     *                     the class description for {@link MouseEvent}\n     * @param when         A long integer that gives the time the event occurred.\n     *                     Passing negative or zero value\n     *                     is not recommended\n     * @param modifiers    a modifier mask describing the modifier keys and mouse\n     *                     buttons (for example, shift, ctrl, alt, and meta) that\n     *                     are down during the event.\n     *                     Only extended modifiers are allowed to be used as a\n     *                     value for this parameter (see the {@link InputEvent#getModifiersEx}\n     *                     class for the description of extended modifiers).\n     *                     Passing negative parameter\n     *                     is not recommended.\n     *                     Zero value means that no modifiers were passed\n     * @param x            The horizontal x coordinate for the mouse location.\n     *                       It is allowed to pass negative values\n     * @param y            The vertical y coordinate for the mouse location.\n     *                       It is allowed to pass negative values\n     * @param xAbs           The absolute horizontal x coordinate for the mouse location\n     *                       It is allowed to pass negative values\n     * @param yAbs           The absolute vertical y coordinate for the mouse location\n     *                       It is allowed to pass negative values\n     * @param clickCount   The number of mouse clicks associated with event.\n     *                       Passing negative value\n     *                       is not recommended\n     * @param popupTrigger A boolean that equals {@code true} if this event\n     *                     is a trigger for a popup menu\n     * @param button       An integer that indicates, which of the mouse buttons has\n     *                     changed its state.\n     * The following rules are applied to this parameter:\n     * <ul>\n     * <li>If support for the extended mouse buttons is\n     * {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java\n     * then it is allowed to create {@code MouseEvent} objects only with the standard buttons:\n     * {@code NOBUTTON}, {@code BUTTON1}, {@code BUTTON2}, and\n     * {@code BUTTON3}.\n     * <li> If support for the extended mouse buttons is\n     * {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java\n     * then it is allowed to create {@code MouseEvent} objects with\n     * the standard buttons.\n     * In case the support for extended mouse buttons is\n     * {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java, then\n     * in addition to the standard buttons, {@code MouseEvent} objects can be created\n     * using buttons from the range starting from 4 to\n     * {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()}\n     * if the mouse has more than three buttons.\n     * <\/ul>\n     * @throws IllegalArgumentException if {@code button} is less then zero\n     * @throws IllegalArgumentException if <code>source<\/code> is null\n     * @throws IllegalArgumentException if {@code button} is greater then BUTTON3 and the support for extended mouse buttons is\n     *                                  {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java\n     * @throws IllegalArgumentException if {@code button} is greater then the\n     *                                  {@link java.awt.MouseInfo#getNumberOfButtons() current number of buttons} and the support\n     *                                  for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() enabled}\n     *                                  by Java\n     * @throws IllegalArgumentException if an invalid <code>button<\/code>\n     *            value is passed in\n     * @throws IllegalArgumentException if <code>source<\/code> is null\n     * @see #getSource()\n     * @see #getID()\n     * @see #getWhen()\n     * @see #getModifiers()\n     * @see #getX()\n     * @see #getY()\n     * @see #getXOnScreen()\n     * @see #getYOnScreen()\n     * @see #getClickCount()\n     * @see #isPopupTrigger()\n     * @see #getButton()\n     * @see #button\n     * @see Toolkit#areExtraMouseButtonsEnabled()\n     * @see java.awt.MouseInfo#getNumberOfButtons()\n     * @see InputEvent#getMaskForButton(int)\n     * @since 1.6\n     */\n    public MouseEvent(Component source, int id, long when, int modifiers,\n                      int x, int y, int xAbs, int yAbs,\n                      int clickCount, boolean popupTrigger, int button)\n    {\n        super(source, id, when, modifiers);\n        this.x = x;\n        this.y = y;\n        this.xAbs = xAbs;\n        this.yAbs = yAbs;\n        this.clickCount = clickCount;\n        this.popupTrigger = popupTrigger;\n        if (button < NOBUTTON){\n            throw new IllegalArgumentException(\"Invalid button value :\" + button);\n        }\n        if (button > BUTTON3) {\n            if (!Toolkit.getDefaultToolkit().areExtraMouseButtonsEnabled()){\n                throw new IllegalArgumentException(\"Extra mouse events are disabled \" + button);\n            } else {\n                if (button > cachedNumberOfButtons) {\n                    throw new IllegalArgumentException(\"Nonexistent button \" + button);\n                }\n            }\n            // XToolkit: extra buttons are not reporting about their state correctly.\n            // Being pressed they report the state=0 both on the press and on the release.\n            // For 1-3 buttons the state value equals zero on press and non-zero on release.\n            // Other modifiers like Shift, ALT etc seem report well with extra buttons.\n            // The problem reveals as follows: one button is pressed and then another button is pressed and released.\n            // So, the getModifiersEx() would not be zero due to a first button and we will skip this modifier.\n            // This may have to be moved into the peer code instead if possible.\n\n            if (getModifiersEx() != 0) { //There is at least one more button in a pressed state.\n                if (id == MouseEvent.MOUSE_RELEASED || id == MouseEvent.MOUSE_CLICKED){\n                    shouldExcludeButtonFromExtModifiers = true;\n                }\n            }\n        }\n\n        this.button = button;\n\n        if ((getModifiers() != 0) && (getModifiersEx() == 0)) {\n            setNewModifiers();\n        } else if ((getModifiers() == 0) &&\n                   (getModifiersEx() != 0 || button != NOBUTTON) &&\n                   (button <= BUTTON3))\n        {\n            setOldModifiers();\n        }\n    }"}
{"Number":"370","API Relative Path":"java.awt.event.MouseEvent.java-MouseEvent(Component-int-long-int-int-int-int-int-int-boolean-int)","Corresponding Source":"/**\n     * Constructs a <code>MouseEvent<\/code> object with the\n     * specified source component,\n     * type, time, modifiers, coordinates, absolute coordinates, click count, popupTrigger flag,\n     * and button number.\n     * <p>\n     * Creating an invalid event (such\n     * as by using more than one of the old _MASKs, or modifier/button\n     * values which don't match) results in unspecified behavior.\n     * Even if inconsistent values for relative and absolute coordinates are\n     * passed to the constructor, the mouse event instance is still\n     * created and no exception is thrown.\n     * This method throws an\n     * <code>IllegalArgumentException<\/code> if <code>source<\/code>\n     * is <code>null<\/code>.\n     *\n     * @param source       The <code>Component<\/code> that originated the event\n     * @param id              An integer indicating the type of event.\n     *                     For information on allowable values, see\n     *                     the class description for {@link MouseEvent}\n     * @param when         A long integer that gives the time the event occurred.\n     *                     Passing negative or zero value\n     *                     is not recommended\n     * @param modifiers    a modifier mask describing the modifier keys and mouse\n     *                     buttons (for example, shift, ctrl, alt, and meta) that\n     *                     are down during the event.\n     *                     Only extended modifiers are allowed to be used as a\n     *                     value for this parameter (see the {@link InputEvent#getModifiersEx}\n     *                     class for the description of extended modifiers).\n     *                     Passing negative parameter\n     *                     is not recommended.\n     *                     Zero value means that no modifiers were passed\n     * @param x            The horizontal x coordinate for the mouse location.\n     *                       It is allowed to pass negative values\n     * @param y            The vertical y coordinate for the mouse location.\n     *                       It is allowed to pass negative values\n     * @param xAbs           The absolute horizontal x coordinate for the mouse location\n     *                       It is allowed to pass negative values\n     * @param yAbs           The absolute vertical y coordinate for the mouse location\n     *                       It is allowed to pass negative values\n     * @param clickCount   The number of mouse clicks associated with event.\n     *                       Passing negative value\n     *                       is not recommended\n     * @param popupTrigger A boolean that equals {@code true} if this event\n     *                     is a trigger for a popup menu\n     * @param button       An integer that indicates, which of the mouse buttons has\n     *                     changed its state.\n     * The following rules are applied to this parameter:\n     * <ul>\n     * <li>If support for the extended mouse buttons is\n     * {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java\n     * then it is allowed to create {@code MouseEvent} objects only with the standard buttons:\n     * {@code NOBUTTON}, {@code BUTTON1}, {@code BUTTON2}, and\n     * {@code BUTTON3}.\n     * <li> If support for the extended mouse buttons is\n     * {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java\n     * then it is allowed to create {@code MouseEvent} objects with\n     * the standard buttons.\n     * In case the support for extended mouse buttons is\n     * {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java, then\n     * in addition to the standard buttons, {@code MouseEvent} objects can be created\n     * using buttons from the range starting from 4 to\n     * {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()}\n     * if the mouse has more than three buttons.\n     * <\/ul>\n     * @throws IllegalArgumentException if {@code button} is less then zero\n     * @throws IllegalArgumentException if <code>source<\/code> is null\n     * @throws IllegalArgumentException if {@code button} is greater then BUTTON3 and the support for extended mouse buttons is\n     *                                  {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java\n     * @throws IllegalArgumentException if {@code button} is greater then the\n     *                                  {@link java.awt.MouseInfo#getNumberOfButtons() current number of buttons} and the support\n     *                                  for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() enabled}\n     *                                  by Java\n     * @throws IllegalArgumentException if an invalid <code>button<\/code>\n     *            value is passed in\n     * @throws IllegalArgumentException if <code>source<\/code> is null\n     * @see #getSource()\n     * @see #getID()\n     * @see #getWhen()\n     * @see #getModifiers()\n     * @see #getX()\n     * @see #getY()\n     * @see #getXOnScreen()\n     * @see #getYOnScreen()\n     * @see #getClickCount()\n     * @see #isPopupTrigger()\n     * @see #getButton()\n     * @see #button\n     * @see Toolkit#areExtraMouseButtonsEnabled()\n     * @see java.awt.MouseInfo#getNumberOfButtons()\n     * @see InputEvent#getMaskForButton(int)\n     * @since 1.6\n     */\n    public MouseEvent(Component source, int id, long when, int modifiers,\n                      int x, int y, int xAbs, int yAbs,\n                      int clickCount, boolean popupTrigger, int button)\n    {\n        super(source, id, when, modifiers);\n        this.x = x;\n        this.y = y;\n        this.xAbs = xAbs;\n        this.yAbs = yAbs;\n        this.clickCount = clickCount;\n        this.popupTrigger = popupTrigger;\n        if (button < NOBUTTON){\n            throw new IllegalArgumentException(\"Invalid button value :\" + button);\n        }\n        if (button > BUTTON3) {\n            if (!Toolkit.getDefaultToolkit().areExtraMouseButtonsEnabled()){\n                throw new IllegalArgumentException(\"Extra mouse events are disabled \" + button);\n            } else {\n                if (button > cachedNumberOfButtons) {\n                    throw new IllegalArgumentException(\"Nonexistent button \" + button);\n                }\n            }\n            // XToolkit: extra buttons are not reporting about their state correctly.\n            // Being pressed they report the state=0 both on the press and on the release.\n            // For 1-3 buttons the state value equals zero on press and non-zero on release.\n            // Other modifiers like Shift, ALT etc seem report well with extra buttons.\n            // The problem reveals as follows: one button is pressed and then another button is pressed and released.\n            // So, the getModifiersEx() would not be zero due to a first button and we will skip this modifier.\n            // This may have to be moved into the peer code instead if possible.\n\n            if (getModifiersEx() != 0) { //There is at least one more button in a pressed state.\n                if (id == MouseEvent.MOUSE_RELEASED || id == MouseEvent.MOUSE_CLICKED){\n                    shouldExcludeButtonFromExtModifiers = true;\n                }\n            }\n        }\n\n        this.button = button;\n\n        if ((getModifiers() != 0) && (getModifiersEx() == 0)) {\n            setNewModifiers();\n        } else if ((getModifiers() == 0) &&\n                   (getModifiersEx() != 0 || button != NOBUTTON) &&\n                   (button <= BUTTON3))\n        {\n            setOldModifiers();\n        }\n    }"}
{"Number":"371","API Relative Path":"java.awt.event.MouseEvent.java-MouseEvent(Component-int-long-int-int-int-int-int-int-boolean-int)","Corresponding Source":"/**\n     * Constructs a <code>MouseEvent<\/code> object with the\n     * specified source component,\n     * type, time, modifiers, coordinates, absolute coordinates, click count, popupTrigger flag,\n     * and button number.\n     * <p>\n     * Creating an invalid event (such\n     * as by using more than one of the old _MASKs, or modifier/button\n     * values which don't match) results in unspecified behavior.\n     * Even if inconsistent values for relative and absolute coordinates are\n     * passed to the constructor, the mouse event instance is still\n     * created and no exception is thrown.\n     * This method throws an\n     * <code>IllegalArgumentException<\/code> if <code>source<\/code>\n     * is <code>null<\/code>.\n     *\n     * @param source       The <code>Component<\/code> that originated the event\n     * @param id              An integer indicating the type of event.\n     *                     For information on allowable values, see\n     *                     the class description for {@link MouseEvent}\n     * @param when         A long integer that gives the time the event occurred.\n     *                     Passing negative or zero value\n     *                     is not recommended\n     * @param modifiers    a modifier mask describing the modifier keys and mouse\n     *                     buttons (for example, shift, ctrl, alt, and meta) that\n     *                     are down during the event.\n     *                     Only extended modifiers are allowed to be used as a\n     *                     value for this parameter (see the {@link InputEvent#getModifiersEx}\n     *                     class for the description of extended modifiers).\n     *                     Passing negative parameter\n     *                     is not recommended.\n     *                     Zero value means that no modifiers were passed\n     * @param x            The horizontal x coordinate for the mouse location.\n     *                       It is allowed to pass negative values\n     * @param y            The vertical y coordinate for the mouse location.\n     *                       It is allowed to pass negative values\n     * @param xAbs           The absolute horizontal x coordinate for the mouse location\n     *                       It is allowed to pass negative values\n     * @param yAbs           The absolute vertical y coordinate for the mouse location\n     *                       It is allowed to pass negative values\n     * @param clickCount   The number of mouse clicks associated with event.\n     *                       Passing negative value\n     *                       is not recommended\n     * @param popupTrigger A boolean that equals {@code true} if this event\n     *                     is a trigger for a popup menu\n     * @param button       An integer that indicates, which of the mouse buttons has\n     *                     changed its state.\n     * The following rules are applied to this parameter:\n     * <ul>\n     * <li>If support for the extended mouse buttons is\n     * {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java\n     * then it is allowed to create {@code MouseEvent} objects only with the standard buttons:\n     * {@code NOBUTTON}, {@code BUTTON1}, {@code BUTTON2}, and\n     * {@code BUTTON3}.\n     * <li> If support for the extended mouse buttons is\n     * {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java\n     * then it is allowed to create {@code MouseEvent} objects with\n     * the standard buttons.\n     * In case the support for extended mouse buttons is\n     * {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java, then\n     * in addition to the standard buttons, {@code MouseEvent} objects can be created\n     * using buttons from the range starting from 4 to\n     * {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()}\n     * if the mouse has more than three buttons.\n     * <\/ul>\n     * @throws IllegalArgumentException if {@code button} is less then zero\n     * @throws IllegalArgumentException if <code>source<\/code> is null\n     * @throws IllegalArgumentException if {@code button} is greater then BUTTON3 and the support for extended mouse buttons is\n     *                                  {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java\n     * @throws IllegalArgumentException if {@code button} is greater then the\n     *                                  {@link java.awt.MouseInfo#getNumberOfButtons() current number of buttons} and the support\n     *                                  for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() enabled}\n     *                                  by Java\n     * @throws IllegalArgumentException if an invalid <code>button<\/code>\n     *            value is passed in\n     * @throws IllegalArgumentException if <code>source<\/code> is null\n     * @see #getSource()\n     * @see #getID()\n     * @see #getWhen()\n     * @see #getModifiers()\n     * @see #getX()\n     * @see #getY()\n     * @see #getXOnScreen()\n     * @see #getYOnScreen()\n     * @see #getClickCount()\n     * @see #isPopupTrigger()\n     * @see #getButton()\n     * @see #button\n     * @see Toolkit#areExtraMouseButtonsEnabled()\n     * @see java.awt.MouseInfo#getNumberOfButtons()\n     * @see InputEvent#getMaskForButton(int)\n     * @since 1.6\n     */\n    public MouseEvent(Component source, int id, long when, int modifiers,\n                      int x, int y, int xAbs, int yAbs,\n                      int clickCount, boolean popupTrigger, int button)\n    {\n        super(source, id, when, modifiers);\n        this.x = x;\n        this.y = y;\n        this.xAbs = xAbs;\n        this.yAbs = yAbs;\n        this.clickCount = clickCount;\n        this.popupTrigger = popupTrigger;\n        if (button < NOBUTTON){\n            throw new IllegalArgumentException(\"Invalid button value :\" + button);\n        }\n        if (button > BUTTON3) {\n            if (!Toolkit.getDefaultToolkit().areExtraMouseButtonsEnabled()){\n                throw new IllegalArgumentException(\"Extra mouse events are disabled \" + button);\n            } else {\n                if (button > cachedNumberOfButtons) {\n                    throw new IllegalArgumentException(\"Nonexistent button \" + button);\n                }\n            }\n            // XToolkit: extra buttons are not reporting about their state correctly.\n            // Being pressed they report the state=0 both on the press and on the release.\n            // For 1-3 buttons the state value equals zero on press and non-zero on release.\n            // Other modifiers like Shift, ALT etc seem report well with extra buttons.\n            // The problem reveals as follows: one button is pressed and then another button is pressed and released.\n            // So, the getModifiersEx() would not be zero due to a first button and we will skip this modifier.\n            // This may have to be moved into the peer code instead if possible.\n\n            if (getModifiersEx() != 0) { //There is at least one more button in a pressed state.\n                if (id == MouseEvent.MOUSE_RELEASED || id == MouseEvent.MOUSE_CLICKED){\n                    shouldExcludeButtonFromExtModifiers = true;\n                }\n            }\n        }\n\n        this.button = button;\n\n        if ((getModifiers() != 0) && (getModifiersEx() == 0)) {\n            setNewModifiers();\n        } else if ((getModifiers() == 0) &&\n                   (getModifiersEx() != 0 || button != NOBUTTON) &&\n                   (button <= BUTTON3))\n        {\n            setOldModifiers();\n        }\n    }"}
{"Number":"372","API Relative Path":"java.awt.font.CharArrayIterator.java-setIndex(int)","Corresponding Source":"/**\n     * Sets the position to the specified position in the text and returns that\n     * character.\n     * @param position the position within the text.  Valid values range from\n     * getBeginIndex() to getEndIndex().  An IllegalArgumentException is thrown\n     * if an invalid value is supplied.\n     * @return the character at the specified position or DONE if the specified position is equal to getEndIndex()\n     */\n    public char setIndex(int position) {\n\n        position -= begin;\n        if (position < 0 || position > chars.length) {\n            throw new IllegalArgumentException(\"Invalid index\");\n        }\n        pos = position;\n        return current();\n    }"}
{"Number":"373","API Relative Path":"java.awt.font.GraphicAttribute.java-GraphicAttribute(int)","Corresponding Source":"/**\n     * Constructs a <code>GraphicAttribute<\/code>.\n     * Subclasses use this to define the alignment of the graphic.\n     * @param alignment an int representing one of the\n     * <code>GraphicAttribute<\/code> alignment fields\n     * @throws IllegalArgumentException if alignment is not one of the\n     * five defined values.\n     */\n    protected GraphicAttribute(int alignment) {\n        if (alignment < BOTTOM_ALIGNMENT || alignment > HANGING_BASELINE) {\n          throw new IllegalArgumentException(\"bad alignment\");\n        }\n        fAlignment = alignment;\n    }"}
{"Number":"374","API Relative Path":"java.awt.font.LineBreakMeasurer.java-nextLayout(float-int-boolean)","Corresponding Source":"/**\n     * Returns the next layout, and updates the current position.\n     *\n     * @param wrappingWidth the maximum visible advance permitted\n     *    for the text in the next layout\n     * @param offsetLimit the first character that can not be\n     *    included in the next layout, even if the text after the limit\n     *    would fit within the wrapping width; <code>offsetLimit<\/code>\n     *    must be greater than the current position\n     * @param requireNextWord if <code>true<\/code>, and if the entire word\n     *    at the current position does not fit within the wrapping width,\n     *    <code>null<\/code> is returned. If <code>false<\/code>, a valid\n     *    layout is returned that includes at least the character at the\n     *    current position\n     * @return a <code>TextLayout<\/code>, beginning at the current\n     *    position, that represents the next line fitting within\n     *    <code>wrappingWidth<\/code>.  If the current position is at the end\n     *    of the text used by this <code>LineBreakMeasurer<\/code>,\n     *    <code>null<\/code> is returned\n     */\n    public TextLayout nextLayout(float wrappingWidth, int offsetLimit,\n                                 boolean requireNextWord) {\n\n        if (pos < limit) {\n            int layoutLimit = nextOffset(wrappingWidth, offsetLimit, requireNextWord);\n            if (layoutLimit == pos) {\n                return null;\n            }\n\n            TextLayout result = measurer.getLayout(pos, layoutLimit);\n            pos = layoutLimit;\n\n            return result;\n        } else {\n            return null;\n        }\n    }"}
{"Number":"375","API Relative Path":"java.awt.font.LineBreakMeasurer.java-nextOffset(float-int-boolean)","Corresponding Source":"/**\n     * Returns the position at the end of the next layout.  Does NOT\n     * update the current position of this <code>LineBreakMeasurer<\/code>.\n     *\n     * @param wrappingWidth the maximum visible advance permitted for\n     *    the text in the next layout\n     * @param offsetLimit the first character that can not be included\n     *    in the next layout, even if the text after the limit would fit\n     *    within the wrapping width; <code>offsetLimit<\/code> must be\n     *    greater than the current position\n     * @param requireNextWord if <code>true<\/code>, the current position\n     *    that is returned if the entire next word does not fit within\n     *    <code>wrappingWidth<\/code>; if <code>false<\/code>, the offset\n     *    returned is at least one greater than the current position\n     * @return an offset in the text representing the limit of the\n     *    next <code>TextLayout<\/code>\n     */\n    public int nextOffset(float wrappingWidth, int offsetLimit,\n                          boolean requireNextWord) {\n\n        int nextOffset = pos;\n\n        if (pos < limit) {\n            if (offsetLimit <= pos) {\n                    throw new IllegalArgumentException(\"offsetLimit must be after current position\");\n            }\n\n            int charAtMaxAdvance =\n                            measurer.getLineBreakIndex(pos, wrappingWidth);\n\n            if (charAtMaxAdvance == limit) {\n                nextOffset = limit;\n            }\n            else if (Character.isWhitespace(measurer.getChars()[charAtMaxAdvance-start])) {\n                nextOffset = breakIter.following(charAtMaxAdvance);\n            }\n            else {\n            // Break is in a word;  back up to previous break.\n\n                // NOTE:  I think that breakIter.preceding(limit) should be\n                // equivalent to breakIter.last(), breakIter.previous() but\n                // the authors of BreakIterator thought otherwise...\n                // If they were equivalent then the first branch would be\n                // unnecessary.\n                int testPos = charAtMaxAdvance + 1;\n                if (testPos == limit) {\n                    breakIter.last();\n                    nextOffset = breakIter.previous();\n                }\n                else {\n                    nextOffset = breakIter.preceding(testPos);\n                }\n\n                if (nextOffset <= pos) {\n                    // first word doesn't fit on line\n                    if (requireNextWord) {\n                        nextOffset = pos;\n                    }\n                    else {\n                        nextOffset = Math.max(pos+1, charAtMaxAdvance);\n                    }\n                }\n            }\n        }\n\n        if (nextOffset > offsetLimit) {\n            nextOffset = offsetLimit;\n        }\n\n        return nextOffset;\n    }"}
{"Number":"376","API Relative Path":"java.awt.font.LineBreakMeasurer.java-setPosition(int)","Corresponding Source":"/**\n     * Sets the current position of this <code>LineBreakMeasurer<\/code>.\n     *\n     * @param newPosition the current position of this\n     *    <code>LineBreakMeasurer<\/code>; the position should be within the\n     *    text used to construct this <code>LineBreakMeasurer<\/code> (or in\n     *    the text most recently passed to <code>insertChar<\/code>\n     *    or <code>deleteChar<\/code>\n     * @see #getPosition\n     */\n    public void setPosition(int newPosition) {\n        if (newPosition < start || newPosition > limit) {\n            throw new IllegalArgumentException(\"position is out of range\");\n        }\n        pos = newPosition;\n    }"}
{"Number":"377","API Relative Path":"java.awt.font.NumericShaper.java-getContextualShaper(int-int)","Corresponding Source":"/**\n     * Returns a contextual shaper for the provided unicode range(s).\n     * Latin-1 (EUROPEAN) digits will be converted to the decimal digits\n     * corresponding to the range of the preceding text, if the\n     * range is one of the provided ranges.  Multiple ranges are\n     * represented by or-ing the values together, for example,\n     * <code>NumericShaper.ARABIC | NumericShaper.THAI<\/code>.  The\n     * shaper uses defaultContext as the starting context.\n     * @param ranges the specified Unicode ranges\n     * @param defaultContext the starting context, such as\n     * <code>NumericShaper.EUROPEAN<\/code>\n     * @return a shaper for the specified Unicode ranges.\n     * @throws IllegalArgumentException if the specified\n     * <code>defaultContext<\/code> is not a single valid range.\n     */\n    public static NumericShaper getContextualShaper(int ranges, int defaultContext) {\n        int key = getKeyFromMask(defaultContext);\n        ranges |= CONTEXTUAL_MASK;\n        return new NumericShaper(key, ranges);\n    }"}
{"Number":"378","API Relative Path":"java.awt.font.NumericShaper.java-getShaper(int)","Corresponding Source":"/**\n     * Returns a shaper for the provided unicode range.  All\n     * Latin-1 (EUROPEAN) digits are converted\n     * to the corresponding decimal unicode digits.\n     * @param singleRange the specified Unicode range\n     * @return a non-contextual numeric shaper\n     * @throws IllegalArgumentException if the range is not a single range\n     */\n    public static NumericShaper getShaper(int singleRange) {\n        int key = getKeyFromMask(singleRange);\n        return new NumericShaper(key, singleRange);\n    }"}
{"Number":"379","API Relative Path":"java.awt.font.NumericShaper.java-shape(char[]-int-int)","Corresponding Source":"/**\n     * Converts the digits in the text that occur between start and\n     * start + count.\n     * @param text an array of characters to convert\n     * @param start the index into <code>text<\/code> to start\n     *        converting\n     * @param count the number of characters in <code>text<\/code>\n     *        to convert\n     * @throws IndexOutOfBoundsException if start or start + count is\n     *        out of bounds\n     * @throws NullPointerException if text is null\n     */\n    public void shape(char[] text, int start, int count) {\n        checkParams(text, start, count);\n        if (isContextual()) {\n            if (rangeSet == null) {\n                shapeContextually(text, start, count, key);\n            } else {\n                shapeContextually(text, start, count, shapingRange);\n            }\n        } else {\n            shapeNonContextually(text, start, count);\n        }\n    }"}
{"Number":"380","API Relative Path":"java.awt.font.NumericShaper.java-shape(char[]-int-int-int)","Corresponding Source":"/**\n     * Converts the digits in the text that occur between start and\n     * start + count, using the provided context.\n     * Context is ignored if the shaper is not a contextual shaper.\n     * @param text an array of characters\n     * @param start the index into <code>text<\/code> to start\n     *        converting\n     * @param count the number of characters in <code>text<\/code>\n     *        to convert\n     * @param context the context to which to convert the\n     *        characters, such as <code>NumericShaper.EUROPEAN<\/code>\n     * @throws IndexOutOfBoundsException if start or start + count is\n     *        out of bounds\n     * @throws NullPointerException if text is null\n     * @throws IllegalArgumentException if this is a contextual shaper\n     * and the specified <code>context<\/code> is not a single valid\n     * range.\n     */\n    public void shape(char[] text, int start, int count, int context) {\n        checkParams(text, start, count);\n        if (isContextual()) {\n            int ctxKey = getKeyFromMask(context);\n            if (rangeSet == null) {\n                shapeContextually(text, start, count, ctxKey);\n            } else {\n                shapeContextually(text, start, count, Range.values()[ctxKey]);\n            }\n        } else {\n            shapeNonContextually(text, start, count);\n        }\n    }"}
{"Number":"381","API Relative Path":"java.awt.font.NumericShaper.java-shape(char[]-int-int-int)","Corresponding Source":"/**\n     * Converts the digits in the text that occur between start and\n     * start + count, using the provided context.\n     * Context is ignored if the shaper is not a contextual shaper.\n     * @param text an array of characters\n     * @param start the index into <code>text<\/code> to start\n     *        converting\n     * @param count the number of characters in <code>text<\/code>\n     *        to convert\n     * @param context the context to which to convert the\n     *        characters, such as <code>NumericShaper.EUROPEAN<\/code>\n     * @throws IndexOutOfBoundsException if start or start + count is\n     *        out of bounds\n     * @throws NullPointerException if text is null\n     * @throws IllegalArgumentException if this is a contextual shaper\n     * and the specified <code>context<\/code> is not a single valid\n     * range.\n     */\n    public void shape(char[] text, int start, int count, int context) {\n        checkParams(text, start, count);\n        if (isContextual()) {\n            int ctxKey = getKeyFromMask(context);\n            if (rangeSet == null) {\n                shapeContextually(text, start, count, ctxKey);\n            } else {\n                shapeContextually(text, start, count, Range.values()[ctxKey]);\n            }\n        } else {\n            shapeNonContextually(text, start, count);\n        }\n    }"}
{"Number":"382","API Relative Path":"java.awt.font.NumericShaper.java-shape(char[]-int-int-Range)","Corresponding Source":"/**\n     * Converts the digits in the text that occur between {@code\n     * start} and {@code start + count}, using the provided {@code\n     * context}. {@code Context} is ignored if the shaper is not a\n     * contextual shaper.\n     *\n     * @param text  a {@code char} array\n     * @param start the index into {@code text} to start converting\n     * @param count the number of {@code char}s in {@code text}\n     *              to convert\n     * @param context the context to which to convert the characters,\n     *                such as {@code NumericShaper.Range.EUROPEAN}\n     * @throws IndexOutOfBoundsException\n     *         if {@code start} or {@code start + count} is out of bounds\n     * @throws NullPointerException\n     *         if {@code text} or {@code context} is null\n     * @since 1.7\n     */\n    public void shape(char[] text, int start, int count, Range context) {\n        checkParams(text, start, count);\n        if (context == null) {\n            throw new NullPointerException(\"context is null\");\n        }\n\n        if (isContextual()) {\n            if (rangeSet != null) {\n                shapeContextually(text, start, count, context);\n            } else {\n                int key = Range.toRangeIndex(context);\n                if (key >= 0) {\n                    shapeContextually(text, start, count, key);\n                } else {\n                    shapeContextually(text, start, count, shapingRange);\n                }\n            }\n        } else {\n            shapeNonContextually(text, start, count);\n        }\n    }"}
{"Number":"383","API Relative Path":"java.awt.font.NumericShaper.java-shape(char[]-int-int-Range)","Corresponding Source":"/**\n     * Converts the digits in the text that occur between {@code\n     * start} and {@code start + count}, using the provided {@code\n     * context}. {@code Context} is ignored if the shaper is not a\n     * contextual shaper.\n     *\n     * @param text  a {@code char} array\n     * @param start the index into {@code text} to start converting\n     * @param count the number of {@code char}s in {@code text}\n     *              to convert\n     * @param context the context to which to convert the characters,\n     *                such as {@code NumericShaper.Range.EUROPEAN}\n     * @throws IndexOutOfBoundsException\n     *         if {@code start} or {@code start + count} is out of bounds\n     * @throws NullPointerException\n     *         if {@code text} or {@code context} is null\n     * @since 1.7\n     */\n    public void shape(char[] text, int start, int count, Range context) {\n        checkParams(text, start, count);\n        if (context == null) {\n            throw new NullPointerException(\"context is null\");\n        }\n\n        if (isContextual()) {\n            if (rangeSet != null) {\n                shapeContextually(text, start, count, context);\n            } else {\n                int key = Range.toRangeIndex(context);\n                if (key >= 0) {\n                    shapeContextually(text, start, count, key);\n                } else {\n                    shapeContextually(text, start, count, shapingRange);\n                }\n            }\n        } else {\n            shapeNonContextually(text, start, count);\n        }\n    }"}
{"Number":"384","API Relative Path":"java.awt.font.StyledParagraph.java-getDecorationAt(int)","Corresponding Source":"/**\n     * Return the Decoration in effect at the given index.\n     * @param index a valid index in the paragraph\n     * @return the Decoration at index.\n     */\n    public Decoration getDecorationAt(int index) {\n\n        if (index < 0 || index >= length) {\n            throw new IllegalArgumentException(\"index out of range\");\n        }\n        if (decorations == null) {\n            return decoration;\n        }\n        int run = findRunContaining(index, decorationStarts);\n        return decorations.elementAt(run);\n    }"}
{"Number":"385","API Relative Path":"java.awt.font.StyledParagraph.java-getFontOrGraphicAt(int)","Corresponding Source":"/**\n     * Return the Font or GraphicAttribute in effect at the given index.\n     * The client must test the type of the return value to determine what\n     * it is.\n     * @param index a valid index in the paragraph\n     * @return the Font or GraphicAttribute at index.\n     */\n    public Object getFontOrGraphicAt(int index) {\n\n        if (index < 0 || index >= length) {\n            throw new IllegalArgumentException(\"index out of range\");\n        }\n        if (fonts == null) {\n            return font;\n        }\n        int run = findRunContaining(index, fontStarts);\n        return fonts.elementAt(run);\n    }"}
{"Number":"386","API Relative Path":"java.awt.font.StyledParagraph.java-getRunLimit(int)","Corresponding Source":"/**\n     * Return the index at which there is a different Font, GraphicAttribute, or\n     * Dcoration than at the given index.\n     * @param index a valid index in the paragraph\n     * @return the first index where there is a change in attributes from\n     *      those at index\n     */\n    public int getRunLimit(int index) {\n\n        if (index < 0 || index >= length) {\n            throw new IllegalArgumentException(\"index out of range\");\n        }\n        int limit1 = length;\n        if (decorations != null) {\n            int run = findRunContaining(index, decorationStarts);\n            limit1 = decorationStarts[run+1];\n        }\n        int limit2 = length;\n        if (fonts != null) {\n            int run = findRunContaining(index, fontStarts);\n            limit2 = fontStarts[run+1];\n        }\n        return Math.min(limit1, limit2);\n    }"}
{"Number":"387","API Relative Path":"java.awt.font.TextLayout.java-draw(Graphics2D-float-float)","Corresponding Source":"/**\n     * Renders this <code>TextLayout<\/code> at the specified location in\n     * the specified {@link java.awt.Graphics2D Graphics2D} context.\n     * The origin of the layout is placed at x,&nbsp;y.  Rendering may touch\n     * any point within <code>getBounds()<\/code> of this position.  This\n     * leaves the <code>g2<\/code> unchanged.  Text is rendered along the\n     * baseline path.\n     * @param g2 the <code>Graphics2D<\/code> context into which to render\n     *         the layout\n     * @param x the X coordinate of the origin of this <code>TextLayout<\/code>\n     * @param y the Y coordinate of the origin of this <code>TextLayout<\/code>\n     * @see #getBounds()\n     */\n    public void draw(Graphics2D g2, float x, float y) {\n\n        if (g2 == null) {\n            throw new IllegalArgumentException(\"Null Graphics2D passed to TextLayout.draw()\");\n        }\n\n        textLine.draw(g2, x - dx, y - dy);\n    }"}
{"Number":"388","API Relative Path":"java.awt.font.TextLayout.java-getBlackBoxBounds(int-int)","Corresponding Source":"/**\n     * Returns the black box bounds of the characters in the specified range.\n     * The black box bounds is an area consisting of the union of the bounding\n     * boxes of all the glyphs corresponding to the characters between start\n     * and limit.  This area can be disjoint.\n     * @param firstEndpoint one end of the character range\n     * @param secondEndpoint the other end of the character range.  Can be\n     * less than <code>firstEndpoint<\/code>.\n     * @return a <code>Shape<\/code> enclosing the black box bounds.  This is\n     *     in standard coordinates.\n     */\n    public Shape getBlackBoxBounds(int firstEndpoint, int secondEndpoint) {\n        ensureCache();\n\n        if (firstEndpoint > secondEndpoint) {\n            int t = firstEndpoint;\n            firstEndpoint = secondEndpoint;\n            secondEndpoint = t;\n        }\n\n        if (firstEndpoint < 0 || secondEndpoint > characterCount) {\n            throw new IllegalArgumentException(\"Invalid range passed to TextLayout.getBlackBoxBounds()\");\n        }\n\n        /*\n         * return an area that consists of the bounding boxes of all the\n         * characters from firstEndpoint to limit\n         */\n\n        GeneralPath result = new GeneralPath(GeneralPath.WIND_NON_ZERO);\n\n        if (firstEndpoint < characterCount) {\n            for (int logIndex = firstEndpoint;\n                        logIndex < secondEndpoint;\n                        logIndex++) {\n\n                Rectangle2D r = textLine.getCharBounds(logIndex);\n                if (!r.isEmpty()) {\n                    result.append(r, false);\n                }\n            }\n        }\n\n        if (dx != 0 || dy != 0) {\n            AffineTransform tx = AffineTransform.getTranslateInstance(dx, dy);\n            result = (GeneralPath)tx.createTransformedShape(result);\n        }\n        LayoutPathImpl lp = textLine.getLayoutPath();\n        if (lp != null) {\n            result = (GeneralPath)lp.mapShape(result);\n        }\n\n        //return new Highlight(result, false);\n        return result;\n    }"}
{"Number":"389","API Relative Path":"java.awt.font.TextLayout.java-getCaretInfo(TextHitInfo-Rectangle2D)","Corresponding Source":"/**\n     * Returns information about the caret corresponding to <code>hit<\/code>.\n     * The first element of the array is the intersection of the caret with\n     * the baseline, as a distance along the baseline. The second element\n     * of the array is the inverse slope (run/rise) of the caret, measured\n     * with respect to the baseline at that point.\n     * <p>\n     * This method is meant for informational use.  To display carets, it\n     * is better to use <code>getCaretShapes<\/code>.\n     * @param hit a hit on a character in this <code>TextLayout<\/code>\n     * @param bounds the bounds to which the caret info is constructed.\n     *     The bounds is in baseline-relative coordinates.\n     * @return a two-element array containing the position and slope of\n     * the caret.  The returned caret info is in baseline-relative coordinates.\n     * @see #getCaretShapes(int, Rectangle2D, TextLayout.CaretPolicy)\n     * @see Font#getItalicAngle\n     */\n    public float[] getCaretInfo(TextHitInfo hit, Rectangle2D bounds) {\n        ensureCache();\n        checkTextHit(hit);\n\n        return getCaretInfoTestInternal(hit, bounds);\n    }"}
{"Number":"390","API Relative Path":"java.awt.font.TextLayout.java-getCaretInfo(TextHitInfo-Rectangle2D)","Corresponding Source":"/**\n     * Returns information about the caret corresponding to <code>hit<\/code>.\n     * The first element of the array is the intersection of the caret with\n     * the baseline, as a distance along the baseline. The second element\n     * of the array is the inverse slope (run/rise) of the caret, measured\n     * with respect to the baseline at that point.\n     * <p>\n     * This method is meant for informational use.  To display carets, it\n     * is better to use <code>getCaretShapes<\/code>.\n     * @param hit a hit on a character in this <code>TextLayout<\/code>\n     * @param bounds the bounds to which the caret info is constructed.\n     *     The bounds is in baseline-relative coordinates.\n     * @return a two-element array containing the position and slope of\n     * the caret.  The returned caret info is in baseline-relative coordinates.\n     * @see #getCaretShapes(int, Rectangle2D, TextLayout.CaretPolicy)\n     * @see Font#getItalicAngle\n     */\n    public float[] getCaretInfo(TextHitInfo hit, Rectangle2D bounds) {\n        ensureCache();\n        checkTextHit(hit);\n\n        return getCaretInfoTestInternal(hit, bounds);\n    }"}
{"Number":"391","API Relative Path":"java.awt.font.TextLayout.java-getCaretShape(TextHitInfo-Rectangle2D)","Corresponding Source":"/**\n     * Returns a {@link Shape} representing the caret at the specified\n     * hit inside the specified bounds.\n     * @param hit the hit at which to generate the caret\n     * @param bounds the bounds of the <code>TextLayout<\/code> to use\n     *    in generating the caret.  The bounds is in baseline-relative\n     *    coordinates.\n     * @return a <code>Shape<\/code> representing the caret.  The returned\n     *    shape is in standard coordinates.\n     */\n    public Shape getCaretShape(TextHitInfo hit, Rectangle2D bounds) {\n        ensureCache();\n        checkTextHit(hit);\n\n        if (bounds == null) {\n            throw new IllegalArgumentException(\"Null Rectangle2D passed to TextLayout.getCaret()\");\n        }\n\n        return pathToShape(getCaretPath(hit, bounds), false, textLine.getLayoutPath());\n    }"}
{"Number":"392","API Relative Path":"java.awt.font.TextLayout.java-getCaretShape(TextHitInfo-Rectangle2D)","Corresponding Source":"/**\n     * Returns a {@link Shape} representing the caret at the specified\n     * hit inside the specified bounds.\n     * @param hit the hit at which to generate the caret\n     * @param bounds the bounds of the <code>TextLayout<\/code> to use\n     *    in generating the caret.  The bounds is in baseline-relative\n     *    coordinates.\n     * @return a <code>Shape<\/code> representing the caret.  The returned\n     *    shape is in standard coordinates.\n     */\n    public Shape getCaretShape(TextHitInfo hit, Rectangle2D bounds) {\n        ensureCache();\n        checkTextHit(hit);\n\n        if (bounds == null) {\n            throw new IllegalArgumentException(\"Null Rectangle2D passed to TextLayout.getCaret()\");\n        }\n\n        return pathToShape(getCaretPath(hit, bounds), false, textLine.getLayoutPath());\n    }"}
{"Number":"393","API Relative Path":"java.awt.font.TextLayout.java-getCaretShape(TextHitInfo-Rectangle2D)","Corresponding Source":"/**\n     * Returns a {@link Shape} representing the caret at the specified\n     * hit inside the specified bounds.\n     * @param hit the hit at which to generate the caret\n     * @param bounds the bounds of the <code>TextLayout<\/code> to use\n     *    in generating the caret.  The bounds is in baseline-relative\n     *    coordinates.\n     * @return a <code>Shape<\/code> representing the caret.  The returned\n     *    shape is in standard coordinates.\n     */\n    public Shape getCaretShape(TextHitInfo hit, Rectangle2D bounds) {\n        ensureCache();\n        checkTextHit(hit);\n\n        if (bounds == null) {\n            throw new IllegalArgumentException(\"Null Rectangle2D passed to TextLayout.getCaret()\");\n        }\n\n        return pathToShape(getCaretPath(hit, bounds), false, textLine.getLayoutPath());\n    }"}
{"Number":"394","API Relative Path":"java.awt.font.TextLayout.java-getCaretShapes(int-Rectangle2D-CaretPolicy)","Corresponding Source":"/**\n     * Returns two paths corresponding to the strong and weak caret.\n     * @param offset an offset in this <code>TextLayout<\/code>\n     * @param bounds the bounds to which to extend the carets.  The\n     * bounds is in baseline-relative coordinates.\n     * @param policy the specified <code>CaretPolicy<\/code>\n     * @return an array of two paths.  Element zero is the strong\n     * caret.  If there are two carets, element one is the weak caret,\n     * otherwise it is <code>null<\/code>. The returned shapes\n     * are in standard coordinates.\n     */\n    public Shape[] getCaretShapes(int offset, Rectangle2D bounds, CaretPolicy policy) {\n\n        ensureCache();\n\n        if (offset < 0 || offset > characterCount) {\n            throw new IllegalArgumentException(\"Offset out of bounds in TextLayout.getCaretShapes()\");\n        }\n\n        if (bounds == null) {\n            throw new IllegalArgumentException(\"Null Rectangle2D passed to TextLayout.getCaretShapes()\");\n        }\n\n        if (policy == null) {\n            throw new IllegalArgumentException(\"Null CaretPolicy passed to TextLayout.getCaretShapes()\");\n        }\n\n        Shape[] result = new Shape[2];\n\n        TextHitInfo hit = TextHitInfo.afterOffset(offset);\n\n        int hitCaret = hitToCaret(hit);\n\n        LayoutPathImpl lp = textLine.getLayoutPath();\n        Shape hitShape = pathToShape(getCaretPath(hit, bounds), false, lp);\n        TextHitInfo otherHit = hit.getOtherHit();\n        int otherCaret = hitToCaret(otherHit);\n\n        if (hitCaret == otherCaret) {\n            result[0] = hitShape;\n        }\n        else { // more than one caret\n            Shape otherShape = pathToShape(getCaretPath(otherHit, bounds), false, lp);\n\n            TextHitInfo strongHit = policy.getStrongCaret(hit, otherHit, this);\n            boolean hitIsStrong = strongHit.equals(hit);\n\n            if (hitIsStrong) {// then other is weak\n                result[0] = hitShape;\n                result[1] = otherShape;\n            }\n            else {\n                result[0] = otherShape;\n                result[1] = hitShape;\n            }\n        }\n\n        return result;\n    }"}
{"Number":"395","API Relative Path":"java.awt.font.TextLayout.java-getCaretShapes(int-Rectangle2D-CaretPolicy)","Corresponding Source":"/**\n     * Returns two paths corresponding to the strong and weak caret.\n     * @param offset an offset in this <code>TextLayout<\/code>\n     * @param bounds the bounds to which to extend the carets.  The\n     * bounds is in baseline-relative coordinates.\n     * @param policy the specified <code>CaretPolicy<\/code>\n     * @return an array of two paths.  Element zero is the strong\n     * caret.  If there are two carets, element one is the weak caret,\n     * otherwise it is <code>null<\/code>. The returned shapes\n     * are in standard coordinates.\n     */\n    public Shape[] getCaretShapes(int offset, Rectangle2D bounds, CaretPolicy policy) {\n\n        ensureCache();\n\n        if (offset < 0 || offset > characterCount) {\n            throw new IllegalArgumentException(\"Offset out of bounds in TextLayout.getCaretShapes()\");\n        }\n\n        if (bounds == null) {\n            throw new IllegalArgumentException(\"Null Rectangle2D passed to TextLayout.getCaretShapes()\");\n        }\n\n        if (policy == null) {\n            throw new IllegalArgumentException(\"Null CaretPolicy passed to TextLayout.getCaretShapes()\");\n        }\n\n        Shape[] result = new Shape[2];\n\n        TextHitInfo hit = TextHitInfo.afterOffset(offset);\n\n        int hitCaret = hitToCaret(hit);\n\n        LayoutPathImpl lp = textLine.getLayoutPath();\n        Shape hitShape = pathToShape(getCaretPath(hit, bounds), false, lp);\n        TextHitInfo otherHit = hit.getOtherHit();\n        int otherCaret = hitToCaret(otherHit);\n\n        if (hitCaret == otherCaret) {\n            result[0] = hitShape;\n        }\n        else { // more than one caret\n            Shape otherShape = pathToShape(getCaretPath(otherHit, bounds), false, lp);\n\n            TextHitInfo strongHit = policy.getStrongCaret(hit, otherHit, this);\n            boolean hitIsStrong = strongHit.equals(hit);\n\n            if (hitIsStrong) {// then other is weak\n                result[0] = hitShape;\n                result[1] = otherShape;\n            }\n            else {\n                result[0] = otherShape;\n                result[1] = hitShape;\n            }\n        }\n\n        return result;\n    }"}
{"Number":"396","API Relative Path":"java.awt.font.TextLayout.java-getCaretShapes(int-Rectangle2D-CaretPolicy)","Corresponding Source":"/**\n     * Returns two paths corresponding to the strong and weak caret.\n     * @param offset an offset in this <code>TextLayout<\/code>\n     * @param bounds the bounds to which to extend the carets.  The\n     * bounds is in baseline-relative coordinates.\n     * @param policy the specified <code>CaretPolicy<\/code>\n     * @return an array of two paths.  Element zero is the strong\n     * caret.  If there are two carets, element one is the weak caret,\n     * otherwise it is <code>null<\/code>. The returned shapes\n     * are in standard coordinates.\n     */\n    public Shape[] getCaretShapes(int offset, Rectangle2D bounds, CaretPolicy policy) {\n\n        ensureCache();\n\n        if (offset < 0 || offset > characterCount) {\n            throw new IllegalArgumentException(\"Offset out of bounds in TextLayout.getCaretShapes()\");\n        }\n\n        if (bounds == null) {\n            throw new IllegalArgumentException(\"Null Rectangle2D passed to TextLayout.getCaretShapes()\");\n        }\n\n        if (policy == null) {\n            throw new IllegalArgumentException(\"Null CaretPolicy passed to TextLayout.getCaretShapes()\");\n        }\n\n        Shape[] result = new Shape[2];\n\n        TextHitInfo hit = TextHitInfo.afterOffset(offset);\n\n        int hitCaret = hitToCaret(hit);\n\n        LayoutPathImpl lp = textLine.getLayoutPath();\n        Shape hitShape = pathToShape(getCaretPath(hit, bounds), false, lp);\n        TextHitInfo otherHit = hit.getOtherHit();\n        int otherCaret = hitToCaret(otherHit);\n\n        if (hitCaret == otherCaret) {\n            result[0] = hitShape;\n        }\n        else { // more than one caret\n            Shape otherShape = pathToShape(getCaretPath(otherHit, bounds), false, lp);\n\n            TextHitInfo strongHit = policy.getStrongCaret(hit, otherHit, this);\n            boolean hitIsStrong = strongHit.equals(hit);\n\n            if (hitIsStrong) {// then other is weak\n                result[0] = hitShape;\n                result[1] = otherShape;\n            }\n            else {\n                result[0] = otherShape;\n                result[1] = hitShape;\n            }\n        }\n\n        return result;\n    }"}
{"Number":"397","API Relative Path":"java.awt.font.TextLayout.java-getCharacterLevel(int)","Corresponding Source":"/**\n     * Returns the level of the character at <code>index<\/code>.\n     * Indices -1 and <code>characterCount<\/code> are assigned the base\n     * level of this <code>TextLayout<\/code>.\n     * @param index the index of the character from which to get the level\n     * @return the level of the character at the specified index.\n     */\n    public byte getCharacterLevel(int index) {\n\n        // hmm, allow indices at endpoints?  For now, yes.\n        if (index < -1 || index > characterCount) {\n            throw new IllegalArgumentException(\"Index is out of range in getCharacterLevel.\");\n        }\n\n        ensureCache();\n        if (index == -1 || index == characterCount) {\n             return (byte) (textLine.isDirectionLTR()? 0 : 1);\n        }\n\n        return textLine.getCharLevel(index);\n    }"}
{"Number":"398","API Relative Path":"java.awt.font.TextLayout.java-getJustifiedLayout(float)","Corresponding Source":"/**\n     * Creates a copy of this <code>TextLayout<\/code> justified to the\n     * specified width.\n     * <p>\n     * If this <code>TextLayout<\/code> has already been justified, an\n     * exception is thrown.  If this <code>TextLayout<\/code> object's\n     * justification ratio is zero, a <code>TextLayout<\/code> identical\n     * to this <code>TextLayout<\/code> is returned.\n     * @param justificationWidth the width to use when justifying the line.\n     * For best results, it should not be too different from the current\n     * advance of the line.\n     * @return a <code>TextLayout<\/code> justified to the specified width.\n     * @exception Error if this layout has already been justified, an Error is\n     * thrown.\n     */\n    public TextLayout getJustifiedLayout(float justificationWidth) {\n\n        if (justificationWidth <= 0) {\n            throw new IllegalArgumentException(\"justificationWidth <= 0 passed to TextLayout.getJustifiedLayout()\");\n        }\n\n        if (justifyRatio == ALREADY_JUSTIFIED) {\n            throw new Error(\"Can't justify again.\");\n        }\n\n        ensureCache(); // make sure textLine is not null\n\n        // default justification range to exclude trailing logical whitespace\n        int limit = characterCount;\n        while (limit > 0 && textLine.isCharWhitespace(limit-1)) {\n            --limit;\n        }\n\n        TextLine newLine = textLine.getJustifiedLine(justificationWidth, justifyRatio, 0, limit);\n        if (newLine != null) {\n            return new TextLayout(newLine, baseline, baselineOffsets, ALREADY_JUSTIFIED);\n        }\n\n        return this;\n    }"}
{"Number":"399","API Relative Path":"java.awt.font.TextLayout.java-getLogicalHighlightShape(int-int-Rectangle2D)","Corresponding Source":"/**\n     * Returns a <code>Shape<\/code> enclosing the logical selection in the\n     * specified range, extended to the specified <code>bounds<\/code>.\n     * <p>\n     * If the selection range includes the first logical character, the\n     * selection is extended to the portion of <code>bounds<\/code> before\n     * the start of this <code>TextLayout<\/code>.  If the range includes\n     * the last logical character, the selection is extended to the portion\n     * of <code>bounds<\/code> after the end of this <code>TextLayout<\/code>.\n     * The height (width on vertical lines) of the selection is always\n     * extended to <code>bounds<\/code>.\n     * <p>\n     * The selection can be discontiguous on lines with mixed-direction text.\n     * Only those characters in the logical range between start and limit\n     * appear selected.  For example, consider the text 'ABCdef' where capital\n     * letters indicate right-to-left text, rendered on a right-to-left line,\n     * with a logical selection from 0 to 4 ('ABCd').  The text appears as\n     * follows, with bold standing in for the selection, and underlining for\n     * the extension:\n     * <br><pre>\n     *    <u><b>d<\/b><\/u>ef<u><b>CBA  <\/b><\/u>\n     * <\/pre>\n     * The selection is discontiguous because the selected characters are\n     * visually discontiguous. Also note that since the range includes the\n     * first logical character (A), the selection is extended to the portion\n     * of the <code>bounds<\/code> before the start of the layout, which in\n     * this case (a right-to-left line) is the right portion of the\n     * <code>bounds<\/code>.\n     * @param firstEndpoint an endpoint in the range of characters to select\n     * @param secondEndpoint the other endpoint of the range of characters\n     * to select. Can be less than <code>firstEndpoint<\/code>.  The range\n     * includes the character at min(firstEndpoint, secondEndpoint), but\n     * excludes max(firstEndpoint, secondEndpoint).\n     * @param bounds the bounding rectangle to which to extend the selection.\n     *     This is in baseline-relative coordinates.\n     * @return an area enclosing the selection.  This is in standard\n     *     coordinates.\n     * @see #getVisualHighlightShape(TextHitInfo, TextHitInfo, Rectangle2D)\n     */\n    public Shape getLogicalHighlightShape(int firstEndpoint,\n                                         int secondEndpoint,\n                                         Rectangle2D bounds) {\n        if (bounds == null) {\n            throw new IllegalArgumentException(\"Null Rectangle2D passed to TextLayout.getLogicalHighlightShape()\");\n        }\n\n        ensureCache();\n\n        if (firstEndpoint > secondEndpoint) {\n            int t = firstEndpoint;\n            firstEndpoint = secondEndpoint;\n            secondEndpoint = t;\n        }\n\n        if(firstEndpoint < 0 || secondEndpoint > characterCount) {\n            throw new IllegalArgumentException(\"Range is invalid in TextLayout.getLogicalHighlightShape()\");\n        }\n\n        GeneralPath result = new GeneralPath(GeneralPath.WIND_EVEN_ODD);\n\n        int[] carets = new int[10]; // would this ever not handle all cases?\n        int count = 0;\n\n        if (firstEndpoint < secondEndpoint) {\n            int logIndex = firstEndpoint;\n            do {\n                carets[count++] = hitToCaret(TextHitInfo.leading(logIndex));\n                boolean ltr = textLine.isCharLTR(logIndex);\n\n                do {\n                    logIndex++;\n                } while (logIndex < secondEndpoint && textLine.isCharLTR(logIndex) == ltr);\n\n                int hitCh = logIndex;\n                carets[count++] = hitToCaret(TextHitInfo.trailing(hitCh - 1));\n\n                if (count == carets.length) {\n                    int[] temp = new int[carets.length + 10];\n                    System.arraycopy(carets, 0, temp, 0, count);\n                    carets = temp;\n                }\n            } while (logIndex < secondEndpoint);\n        }\n        else {\n            count = 2;\n            carets[0] = carets[1] = hitToCaret(TextHitInfo.leading(firstEndpoint));\n        }\n\n        // now create paths for pairs of carets\n\n        for (int i = 0; i < count; i += 2) {\n            result.append(caretBoundingShape(carets[i], carets[i+1], bounds),\n                          false);\n        }\n\n        if (firstEndpoint != secondEndpoint) {\n            if ((textLine.isDirectionLTR() && firstEndpoint == 0) || (!textLine.isDirectionLTR() &&\n                                                                      secondEndpoint == characterCount)) {\n                GeneralPath ls = leftShape(bounds);\n                if (!ls.getBounds().isEmpty()) {\n                    result.append(ls, false);\n                }\n            }\n\n            if ((textLine.isDirectionLTR() && secondEndpoint == characterCount) ||\n                (!textLine.isDirectionLTR() && firstEndpoint == 0)) {\n\n                GeneralPath rs = rightShape(bounds);\n                if (!rs.getBounds().isEmpty()) {\n                    result.append(rs, false);\n                }\n            }\n        }\n\n        LayoutPathImpl lp = textLine.getLayoutPath();\n        if (lp != null) {\n            result = (GeneralPath)lp.mapShape(result); // dlf cast safe?\n        }\n        return result;\n    }"}
{"Number":"400","API Relative Path":"java.awt.font.TextLayout.java-getLogicalHighlightShape(int-int-Rectangle2D)","Corresponding Source":"/**\n     * Returns a <code>Shape<\/code> enclosing the logical selection in the\n     * specified range, extended to the specified <code>bounds<\/code>.\n     * <p>\n     * If the selection range includes the first logical character, the\n     * selection is extended to the portion of <code>bounds<\/code> before\n     * the start of this <code>TextLayout<\/code>.  If the range includes\n     * the last logical character, the selection is extended to the portion\n     * of <code>bounds<\/code> after the end of this <code>TextLayout<\/code>.\n     * The height (width on vertical lines) of the selection is always\n     * extended to <code>bounds<\/code>.\n     * <p>\n     * The selection can be discontiguous on lines with mixed-direction text.\n     * Only those characters in the logical range between start and limit\n     * appear selected.  For example, consider the text 'ABCdef' where capital\n     * letters indicate right-to-left text, rendered on a right-to-left line,\n     * with a logical selection from 0 to 4 ('ABCd').  The text appears as\n     * follows, with bold standing in for the selection, and underlining for\n     * the extension:\n     * <br><pre>\n     *    <u><b>d<\/b><\/u>ef<u><b>CBA  <\/b><\/u>\n     * <\/pre>\n     * The selection is discontiguous because the selected characters are\n     * visually discontiguous. Also note that since the range includes the\n     * first logical character (A), the selection is extended to the portion\n     * of the <code>bounds<\/code> before the start of the layout, which in\n     * this case (a right-to-left line) is the right portion of the\n     * <code>bounds<\/code>.\n     * @param firstEndpoint an endpoint in the range of characters to select\n     * @param secondEndpoint the other endpoint of the range of characters\n     * to select. Can be less than <code>firstEndpoint<\/code>.  The range\n     * includes the character at min(firstEndpoint, secondEndpoint), but\n     * excludes max(firstEndpoint, secondEndpoint).\n     * @param bounds the bounding rectangle to which to extend the selection.\n     *     This is in baseline-relative coordinates.\n     * @return an area enclosing the selection.  This is in standard\n     *     coordinates.\n     * @see #getVisualHighlightShape(TextHitInfo, TextHitInfo, Rectangle2D)\n     */\n    public Shape getLogicalHighlightShape(int firstEndpoint,\n                                         int secondEndpoint,\n                                         Rectangle2D bounds) {\n        if (bounds == null) {\n            throw new IllegalArgumentException(\"Null Rectangle2D passed to TextLayout.getLogicalHighlightShape()\");\n        }\n\n        ensureCache();\n\n        if (firstEndpoint > secondEndpoint) {\n            int t = firstEndpoint;\n            firstEndpoint = secondEndpoint;\n            secondEndpoint = t;\n        }\n\n        if(firstEndpoint < 0 || secondEndpoint > characterCount) {\n            throw new IllegalArgumentException(\"Range is invalid in TextLayout.getLogicalHighlightShape()\");\n        }\n\n        GeneralPath result = new GeneralPath(GeneralPath.WIND_EVEN_ODD);\n\n        int[] carets = new int[10]; // would this ever not handle all cases?\n        int count = 0;\n\n        if (firstEndpoint < secondEndpoint) {\n            int logIndex = firstEndpoint;\n            do {\n                carets[count++] = hitToCaret(TextHitInfo.leading(logIndex));\n                boolean ltr = textLine.isCharLTR(logIndex);\n\n                do {\n                    logIndex++;\n                } while (logIndex < secondEndpoint && textLine.isCharLTR(logIndex) == ltr);\n\n                int hitCh = logIndex;\n                carets[count++] = hitToCaret(TextHitInfo.trailing(hitCh - 1));\n\n                if (count == carets.length) {\n                    int[] temp = new int[carets.length + 10];\n                    System.arraycopy(carets, 0, temp, 0, count);\n                    carets = temp;\n                }\n            } while (logIndex < secondEndpoint);\n        }\n        else {\n            count = 2;\n            carets[0] = carets[1] = hitToCaret(TextHitInfo.leading(firstEndpoint));\n        }\n\n        // now create paths for pairs of carets\n\n        for (int i = 0; i < count; i += 2) {\n            result.append(caretBoundingShape(carets[i], carets[i+1], bounds),\n                          false);\n        }\n\n        if (firstEndpoint != secondEndpoint) {\n            if ((textLine.isDirectionLTR() && firstEndpoint == 0) || (!textLine.isDirectionLTR() &&\n                                                                      secondEndpoint == characterCount)) {\n                GeneralPath ls = leftShape(bounds);\n                if (!ls.getBounds().isEmpty()) {\n                    result.append(ls, false);\n                }\n            }\n\n            if ((textLine.isDirectionLTR() && secondEndpoint == characterCount) ||\n                (!textLine.isDirectionLTR() && firstEndpoint == 0)) {\n\n                GeneralPath rs = rightShape(bounds);\n                if (!rs.getBounds().isEmpty()) {\n                    result.append(rs, false);\n                }\n            }\n        }\n\n        LayoutPathImpl lp = textLine.getLayoutPath();\n        if (lp != null) {\n            result = (GeneralPath)lp.mapShape(result); // dlf cast safe?\n        }\n        return result;\n    }"}
{"Number":"401","API Relative Path":"java.awt.font.TextLayout.java-getLogicalRangesForVisualSelection(TextHitInfo-TextHitInfo)","Corresponding Source":"/**\n     * Returns the logical ranges of text corresponding to a visual selection.\n     * @param firstEndpoint an endpoint of the visual range\n     * @param secondEndpoint the other endpoint of the visual range.\n     * This endpoint can be less than <code>firstEndpoint<\/code>.\n     * @return an array of integers representing start/limit pairs for the\n     * selected ranges.\n     * @see #getVisualHighlightShape(TextHitInfo, TextHitInfo, Rectangle2D)\n     */\n    public int[] getLogicalRangesForVisualSelection(TextHitInfo firstEndpoint,\n                                                    TextHitInfo secondEndpoint) {\n        ensureCache();\n\n        checkTextHit(firstEndpoint);\n        checkTextHit(secondEndpoint);\n\n        // !!! probably want to optimize for all LTR text\n\n        boolean[] included = new boolean[characterCount];\n\n        int startIndex = hitToCaret(firstEndpoint);\n        int limitIndex = hitToCaret(secondEndpoint);\n\n        if (startIndex > limitIndex) {\n            int t = startIndex;\n            startIndex = limitIndex;\n            limitIndex = t;\n        }\n\n        /*\n         * now we have the visual indexes of the glyphs at the start and limit\n         * of the selection range walk through runs marking characters that\n         * were included in the visual range there is probably a more efficient\n         * way to do this, but this ought to work, so hey\n         */\n\n        if (startIndex < limitIndex) {\n            int visIndex = startIndex;\n            while (visIndex < limitIndex) {\n                included[textLine.visualToLogical(visIndex)] = true;\n                ++visIndex;\n            }\n        }\n\n        /*\n         * count how many runs we have, ought to be one or two, but perhaps\n         * things are especially weird\n         */\n        int count = 0;\n        boolean inrun = false;\n        for (int i = 0; i < characterCount; i++) {\n            if (included[i] != inrun) {\n                inrun = !inrun;\n                if (inrun) {\n                    count++;\n                }\n            }\n        }\n\n        int[] ranges = new int[count * 2];\n        count = 0;\n        inrun = false;\n        for (int i = 0; i < characterCount; i++) {\n            if (included[i] != inrun) {\n                ranges[count++] = i;\n                inrun = !inrun;\n            }\n        }\n        if (inrun) {\n            ranges[count++] = characterCount;\n        }\n\n        return ranges;\n    }"}
{"Number":"402","API Relative Path":"java.awt.font.TextLayout.java-getNextLeftHit(int-CaretPolicy)","Corresponding Source":"/**\n     * Returns the hit for the next caret to the left (top); if no\n     * such hit, returns <code>null<\/code>.  The hit is to the left of\n     * the strong caret at the specified offset, as determined by the\n     * specified policy.\n     * The returned hit is the stronger of the two possible\n     * hits, as determined by the specified policy.\n     * @param offset an insertion offset in this <code>TextLayout<\/code>.\n     * Cannot be less than 0 or greater than this <code>TextLayout<\/code>\n     * object's character count.\n     * @param policy the policy used to select the strong caret\n     * @return a hit whose caret appears at the next position to the\n     * left (top) of the caret of the provided hit, or <code>null<\/code>.\n     */\n    public TextHitInfo getNextLeftHit(int offset, CaretPolicy policy) {\n\n        if (policy == null) {\n            throw new IllegalArgumentException(\"Null CaretPolicy passed to TextLayout.getNextLeftHit()\");\n        }\n\n        if (offset < 0 || offset > characterCount) {\n            throw new IllegalArgumentException(\"Offset out of bounds in TextLayout.getNextLeftHit()\");\n        }\n\n        TextHitInfo hit1 = TextHitInfo.afterOffset(offset);\n        TextHitInfo hit2 = hit1.getOtherHit();\n\n        TextHitInfo nextHit = getNextLeftHit(policy.getStrongCaret(hit1, hit2, this));\n\n        if (nextHit != null) {\n            TextHitInfo otherHit = getVisualOtherHit(nextHit);\n            return policy.getStrongCaret(otherHit, nextHit, this);\n        }\n        else {\n            return null;\n        }\n    }"}
{"Number":"403","API Relative Path":"java.awt.font.TextLayout.java-getNextLeftHit(int-CaretPolicy)","Corresponding Source":"/**\n     * Returns the hit for the next caret to the left (top); if no\n     * such hit, returns <code>null<\/code>.  The hit is to the left of\n     * the strong caret at the specified offset, as determined by the\n     * specified policy.\n     * The returned hit is the stronger of the two possible\n     * hits, as determined by the specified policy.\n     * @param offset an insertion offset in this <code>TextLayout<\/code>.\n     * Cannot be less than 0 or greater than this <code>TextLayout<\/code>\n     * object's character count.\n     * @param policy the policy used to select the strong caret\n     * @return a hit whose caret appears at the next position to the\n     * left (top) of the caret of the provided hit, or <code>null<\/code>.\n     */\n    public TextHitInfo getNextLeftHit(int offset, CaretPolicy policy) {\n\n        if (policy == null) {\n            throw new IllegalArgumentException(\"Null CaretPolicy passed to TextLayout.getNextLeftHit()\");\n        }\n\n        if (offset < 0 || offset > characterCount) {\n            throw new IllegalArgumentException(\"Offset out of bounds in TextLayout.getNextLeftHit()\");\n        }\n\n        TextHitInfo hit1 = TextHitInfo.afterOffset(offset);\n        TextHitInfo hit2 = hit1.getOtherHit();\n\n        TextHitInfo nextHit = getNextLeftHit(policy.getStrongCaret(hit1, hit2, this));\n\n        if (nextHit != null) {\n            TextHitInfo otherHit = getVisualOtherHit(nextHit);\n            return policy.getStrongCaret(otherHit, nextHit, this);\n        }\n        else {\n            return null;\n        }\n    }"}
{"Number":"404","API Relative Path":"java.awt.font.TextLayout.java-getNextLeftHit(TextHitInfo)","Corresponding Source":"/**\n     * Returns the hit for the next caret to the left (top); if no such\n     * hit, returns <code>null<\/code>.\n     * If the hit character index is out of bounds, an\n     * <code>IllegalArgumentException<\/code> is thrown.\n     * @param hit a hit on a character in this <code>TextLayout<\/code>.\n     * @return a hit whose caret appears at the next position to the\n     * left (top) of the caret of the provided hit, or <code>null<\/code>.\n     */\n    public TextHitInfo getNextLeftHit(TextHitInfo hit) {\n        ensureCache();\n        checkTextHit(hit);\n\n        int caret = hitToCaret(hit);\n\n        if (caret == 0) {\n            return null;\n        }\n\n        do {\n            --caret;\n        } while(!caretIsValid(caret));\n\n        return caretToHit(caret);\n    }"}
{"Number":"405","API Relative Path":"java.awt.font.TextLayout.java-getNextRightHit(int-CaretPolicy)","Corresponding Source":"/**\n     * Returns the hit for the next caret to the right (bottom); if no\n     * such hit, returns <code>null<\/code>.  The hit is to the right of\n     * the strong caret at the specified offset, as determined by the\n     * specified policy.\n     * The returned hit is the stronger of the two possible\n     * hits, as determined by the specified policy.\n     * @param offset an insertion offset in this <code>TextLayout<\/code>.\n     * Cannot be less than 0 or greater than this <code>TextLayout<\/code>\n     * object's character count.\n     * @param policy the policy used to select the strong caret\n     * @return a hit whose caret appears at the next position to the\n     * right (bottom) of the caret of the provided hit, or <code>null<\/code>.\n     */\n    public TextHitInfo getNextRightHit(int offset, CaretPolicy policy) {\n\n        if (offset < 0 || offset > characterCount) {\n            throw new IllegalArgumentException(\"Offset out of bounds in TextLayout.getNextRightHit()\");\n        }\n\n        if (policy == null) {\n            throw new IllegalArgumentException(\"Null CaretPolicy passed to TextLayout.getNextRightHit()\");\n        }\n\n        TextHitInfo hit1 = TextHitInfo.afterOffset(offset);\n        TextHitInfo hit2 = hit1.getOtherHit();\n\n        TextHitInfo nextHit = getNextRightHit(policy.getStrongCaret(hit1, hit2, this));\n\n        if (nextHit != null) {\n            TextHitInfo otherHit = getVisualOtherHit(nextHit);\n            return policy.getStrongCaret(otherHit, nextHit, this);\n        }\n        else {\n            return null;\n        }\n    }"}
{"Number":"406","API Relative Path":"java.awt.font.TextLayout.java-getNextRightHit(int-CaretPolicy)","Corresponding Source":"/**\n     * Returns the hit for the next caret to the right (bottom); if no\n     * such hit, returns <code>null<\/code>.  The hit is to the right of\n     * the strong caret at the specified offset, as determined by the\n     * specified policy.\n     * The returned hit is the stronger of the two possible\n     * hits, as determined by the specified policy.\n     * @param offset an insertion offset in this <code>TextLayout<\/code>.\n     * Cannot be less than 0 or greater than this <code>TextLayout<\/code>\n     * object's character count.\n     * @param policy the policy used to select the strong caret\n     * @return a hit whose caret appears at the next position to the\n     * right (bottom) of the caret of the provided hit, or <code>null<\/code>.\n     */\n    public TextHitInfo getNextRightHit(int offset, CaretPolicy policy) {\n\n        if (offset < 0 || offset > characterCount) {\n            throw new IllegalArgumentException(\"Offset out of bounds in TextLayout.getNextRightHit()\");\n        }\n\n        if (policy == null) {\n            throw new IllegalArgumentException(\"Null CaretPolicy passed to TextLayout.getNextRightHit()\");\n        }\n\n        TextHitInfo hit1 = TextHitInfo.afterOffset(offset);\n        TextHitInfo hit2 = hit1.getOtherHit();\n\n        TextHitInfo nextHit = getNextRightHit(policy.getStrongCaret(hit1, hit2, this));\n\n        if (nextHit != null) {\n            TextHitInfo otherHit = getVisualOtherHit(nextHit);\n            return policy.getStrongCaret(otherHit, nextHit, this);\n        }\n        else {\n            return null;\n        }\n    }"}
{"Number":"407","API Relative Path":"java.awt.font.TextLayout.java-getNextRightHit(TextHitInfo)","Corresponding Source":"/**\n     * Returns the hit for the next caret to the right (bottom); if there\n     * is no such hit, returns <code>null<\/code>.\n     * If the hit character index is out of bounds, an\n     * {@link IllegalArgumentException} is thrown.\n     * @param hit a hit on a character in this layout\n     * @return a hit whose caret appears at the next position to the\n     * right (bottom) of the caret of the provided hit or <code>null<\/code>.\n     */\n    public TextHitInfo getNextRightHit(TextHitInfo hit) {\n        ensureCache();\n        checkTextHit(hit);\n\n        int caret = hitToCaret(hit);\n\n        if (caret == characterCount) {\n            return null;\n        }\n\n        do {\n            ++caret;\n        } while (!caretIsValid(caret));\n\n        return caretToHit(caret);\n    }"}
{"Number":"408","API Relative Path":"java.awt.font.TextLayout.java-getVisualHighlightShape(TextHitInfo-TextHitInfo-Rectangle2D)","Corresponding Source":"/**\n     * Returns a path enclosing the visual selection in the specified range,\n     * extended to <code>bounds<\/code>.\n     * <p>\n     * If the selection includes the leftmost (topmost) position, the selection\n     * is extended to the left (top) of <code>bounds<\/code>.  If the\n     * selection includes the rightmost (bottommost) position, the selection\n     * is extended to the right (bottom) of the bounds.  The height\n     * (width on vertical lines) of the selection is always extended to\n     * <code>bounds<\/code>.\n     * <p>\n     * Although the selection is always contiguous, the logically selected\n     * text can be discontiguous on lines with mixed-direction text.  The\n     * logical ranges of text selected can be retrieved using\n     * <code>getLogicalRangesForVisualSelection<\/code>.  For example,\n     * consider the text 'ABCdef' where capital letters indicate\n     * right-to-left text, rendered on a right-to-left line, with a visual\n     * selection from 0L (the leading edge of 'A') to 3T (the trailing edge\n     * of 'd').  The text appears as follows, with bold underlined areas\n     * representing the selection:\n     * <br><pre>\n     *    d<u><b>efCBA  <\/b><\/u>\n     * <\/pre>\n     * The logical selection ranges are 0-3, 4-6 (ABC, ef) because the\n     * visually contiguous text is logically discontiguous.  Also note that\n     * since the rightmost position on the layout (to the right of 'A') is\n     * selected, the selection is extended to the right of the bounds.\n     * @param firstEndpoint one end of the visual selection\n     * @param secondEndpoint the other end of the visual selection\n     * @param bounds the bounding rectangle to which to extend the selection.\n     *     This is in baseline-relative coordinates.\n     * @return a <code>Shape<\/code> enclosing the selection.  This is in\n     *     standard coordinates.\n     * @see #getLogicalRangesForVisualSelection(TextHitInfo, TextHitInfo)\n     * @see #getLogicalHighlightShape(int, int, Rectangle2D)\n     */\n    public Shape getVisualHighlightShape(TextHitInfo firstEndpoint,\n                                        TextHitInfo secondEndpoint,\n                                        Rectangle2D bounds)\n    {\n        ensureCache();\n\n        checkTextHit(firstEndpoint);\n        checkTextHit(secondEndpoint);\n\n        if(bounds == null) {\n                throw new IllegalArgumentException(\"Null Rectangle2D passed to TextLayout.getVisualHighlightShape()\");\n        }\n\n        GeneralPath result = new GeneralPath(GeneralPath.WIND_EVEN_ODD);\n\n        int firstCaret = hitToCaret(firstEndpoint);\n        int secondCaret = hitToCaret(secondEndpoint);\n\n        result.append(caretBoundingShape(firstCaret, secondCaret, bounds),\n                      false);\n\n        if (firstCaret == 0 || secondCaret == 0) {\n            GeneralPath ls = leftShape(bounds);\n            if (!ls.getBounds().isEmpty())\n                result.append(ls, false);\n        }\n\n        if (firstCaret == characterCount || secondCaret == characterCount) {\n            GeneralPath rs = rightShape(bounds);\n            if (!rs.getBounds().isEmpty()) {\n                result.append(rs, false);\n            }\n        }\n\n        LayoutPathImpl lp = textLine.getLayoutPath();\n        if (lp != null) {\n            result = (GeneralPath)lp.mapShape(result); // dlf cast safe?\n        }\n\n        return  result;\n    }"}
{"Number":"409","API Relative Path":"java.awt.font.TextLayout.java-getVisualHighlightShape(TextHitInfo-TextHitInfo-Rectangle2D)","Corresponding Source":"/**\n     * Returns a path enclosing the visual selection in the specified range,\n     * extended to <code>bounds<\/code>.\n     * <p>\n     * If the selection includes the leftmost (topmost) position, the selection\n     * is extended to the left (top) of <code>bounds<\/code>.  If the\n     * selection includes the rightmost (bottommost) position, the selection\n     * is extended to the right (bottom) of the bounds.  The height\n     * (width on vertical lines) of the selection is always extended to\n     * <code>bounds<\/code>.\n     * <p>\n     * Although the selection is always contiguous, the logically selected\n     * text can be discontiguous on lines with mixed-direction text.  The\n     * logical ranges of text selected can be retrieved using\n     * <code>getLogicalRangesForVisualSelection<\/code>.  For example,\n     * consider the text 'ABCdef' where capital letters indicate\n     * right-to-left text, rendered on a right-to-left line, with a visual\n     * selection from 0L (the leading edge of 'A') to 3T (the trailing edge\n     * of 'd').  The text appears as follows, with bold underlined areas\n     * representing the selection:\n     * <br><pre>\n     *    d<u><b>efCBA  <\/b><\/u>\n     * <\/pre>\n     * The logical selection ranges are 0-3, 4-6 (ABC, ef) because the\n     * visually contiguous text is logically discontiguous.  Also note that\n     * since the rightmost position on the layout (to the right of 'A') is\n     * selected, the selection is extended to the right of the bounds.\n     * @param firstEndpoint one end of the visual selection\n     * @param secondEndpoint the other end of the visual selection\n     * @param bounds the bounding rectangle to which to extend the selection.\n     *     This is in baseline-relative coordinates.\n     * @return a <code>Shape<\/code> enclosing the selection.  This is in\n     *     standard coordinates.\n     * @see #getLogicalRangesForVisualSelection(TextHitInfo, TextHitInfo)\n     * @see #getLogicalHighlightShape(int, int, Rectangle2D)\n     */\n    public Shape getVisualHighlightShape(TextHitInfo firstEndpoint,\n                                        TextHitInfo secondEndpoint,\n                                        Rectangle2D bounds)\n    {\n        ensureCache();\n\n        checkTextHit(firstEndpoint);\n        checkTextHit(secondEndpoint);\n\n        if(bounds == null) {\n                throw new IllegalArgumentException(\"Null Rectangle2D passed to TextLayout.getVisualHighlightShape()\");\n        }\n\n        GeneralPath result = new GeneralPath(GeneralPath.WIND_EVEN_ODD);\n\n        int firstCaret = hitToCaret(firstEndpoint);\n        int secondCaret = hitToCaret(secondEndpoint);\n\n        result.append(caretBoundingShape(firstCaret, secondCaret, bounds),\n                      false);\n\n        if (firstCaret == 0 || secondCaret == 0) {\n            GeneralPath ls = leftShape(bounds);\n            if (!ls.getBounds().isEmpty())\n                result.append(ls, false);\n        }\n\n        if (firstCaret == characterCount || secondCaret == characterCount) {\n            GeneralPath rs = rightShape(bounds);\n            if (!rs.getBounds().isEmpty()) {\n                result.append(rs, false);\n            }\n        }\n\n        LayoutPathImpl lp = textLine.getLayoutPath();\n        if (lp != null) {\n            result = (GeneralPath)lp.mapShape(result); // dlf cast safe?\n        }\n\n        return  result;\n    }"}
{"Number":"410","API Relative Path":"java.awt.font.TextLayout.java-getVisualOtherHit(TextHitInfo)","Corresponding Source":"/**\n     * Returns the hit on the opposite side of the specified hit's caret.\n     * @param hit the specified hit\n     * @return a hit that is on the opposite side of the specified hit's\n     *    caret.\n     */\n    public TextHitInfo getVisualOtherHit(TextHitInfo hit) {\n\n        ensureCache();\n        checkTextHit(hit);\n\n        int hitCharIndex = hit.getCharIndex();\n\n        int charIndex;\n        boolean leading;\n\n        if (hitCharIndex == -1 || hitCharIndex == characterCount) {\n\n            int visIndex;\n            if (textLine.isDirectionLTR() == (hitCharIndex == -1)) {\n                visIndex = 0;\n            }\n            else {\n                visIndex = characterCount-1;\n            }\n\n            charIndex = textLine.visualToLogical(visIndex);\n\n            if (textLine.isDirectionLTR() == (hitCharIndex == -1)) {\n                // at left end\n                leading = textLine.isCharLTR(charIndex);\n            }\n            else {\n                // at right end\n                leading = !textLine.isCharLTR(charIndex);\n            }\n        }\n        else {\n\n            int visIndex = textLine.logicalToVisual(hitCharIndex);\n\n            boolean movedToRight;\n            if (textLine.isCharLTR(hitCharIndex) == hit.isLeadingEdge()) {\n                --visIndex;\n                movedToRight = false;\n            }\n            else {\n                ++visIndex;\n                movedToRight = true;\n            }\n\n            if (visIndex > -1 && visIndex < characterCount) {\n                charIndex = textLine.visualToLogical(visIndex);\n                leading = movedToRight == textLine.isCharLTR(charIndex);\n            }\n            else {\n                charIndex =\n                    (movedToRight == textLine.isDirectionLTR())? characterCount : -1;\n                leading = charIndex == characterCount;\n            }\n        }\n\n        return leading? TextHitInfo.leading(charIndex) :\n                                TextHitInfo.trailing(charIndex);\n    }"}
{"Number":"411","API Relative Path":"java.awt.font.TextLayout.java-hitToPoint(TextHitInfo-Point2D)","Corresponding Source":"/**\n     * Convert a hit to a point in standard coordinates.  The point is\n     * on the baseline of the character at the leading or trailing\n     * edge of the character, as appropriate.  If the path is\n     * broken at the side of the character represented by the hit, the\n     * point will be adjacent to the character.\n     * @param hit the hit to check.  This must be a valid hit on\n     * the TextLayout.\n     * @param point the returned point. The point is in standard\n     *     coordinates.\n     * @throws IllegalArgumentException if the hit is not valid for the\n     * TextLayout.\n     * @throws NullPointerException if hit or point is null.\n     * @since 1.6\n     */\n    public void hitToPoint(TextHitInfo hit, Point2D point) {\n        if (hit == null || point == null) {\n            throw new NullPointerException((hit == null ? \"hit\" : \"point\") +\n                                           \" can't be null\");\n        }\n        ensureCache();\n        checkTextHit(hit);\n\n        float adv = 0;\n        float off = 0;\n\n        int ix = hit.getCharIndex();\n        boolean leading = hit.isLeadingEdge();\n        boolean ltr;\n        if (ix == -1 || ix == textLine.characterCount()) {\n            ltr = textLine.isDirectionLTR();\n            adv = (ltr == (ix == -1)) ? 0 : lineMetrics.advance;\n        } else {\n            ltr = textLine.isCharLTR(ix);\n            adv = textLine.getCharLinePosition(ix, leading);\n            off = textLine.getCharYPosition(ix);\n        }\n        point.setLocation(adv, off);\n        LayoutPath lp = textLine.getLayoutPath();\n        if (lp != null) {\n            lp.pathToPoint(point, ltr != leading, point);\n        }\n    }"}
{"Number":"412","API Relative Path":"java.awt.font.TextLayout.java-TextLayout(AttributedCharacterIterator-FontRenderContext)","Corresponding Source":"/**\n     * Constructs a <code>TextLayout<\/code> from an iterator over styled text.\n     * <p>\n     * The iterator must specify a single paragraph of text because an\n     * entire paragraph is required for the bidirectional\n     * algorithm.\n     * @param text the styled text to display\n     * @param frc contains information about a graphics device which is needed\n     *       to measure the text correctly.\n     *       Text measurements can vary slightly depending on the\n     *       device resolution, and attributes such as antialiasing.  This\n     *       parameter does not specify a translation between the\n     *       <code>TextLayout<\/code> and user space.\n     */\n    public TextLayout(AttributedCharacterIterator text, FontRenderContext frc) {\n\n        if (text == null) {\n            throw new IllegalArgumentException(\"Null iterator passed to TextLayout constructor.\");\n        }\n\n        int start = text.getBeginIndex();\n        int limit = text.getEndIndex();\n        if (start == limit) {\n            throw new IllegalArgumentException(\"Zero length iterator passed to TextLayout constructor.\");\n        }\n\n        int len = limit - start;\n        text.first();\n        char[] chars = new char[len];\n        int n = 0;\n        for (char c = text.first();\n             c != CharacterIterator.DONE;\n             c = text.next())\n        {\n            chars[n++] = c;\n        }\n\n        text.first();\n        if (text.getRunLimit() == limit) {\n\n            Map<? extends Attribute, ?> attributes = text.getAttributes();\n            Font font = singleFont(chars, 0, len, attributes);\n            if (font != null) {\n                fastInit(chars, font, attributes, frc);\n                return;\n            }\n        }\n\n        standardInit(text, chars, frc);\n    }"}
{"Number":"413","API Relative Path":"java.awt.font.TextLayout.java-TextLayout(String-Font-FontRenderContext)","Corresponding Source":"/**\n     * Constructs a <code>TextLayout<\/code> from a <code>String<\/code>\n     * and a {@link Font}.  All the text is styled using the specified\n     * <code>Font<\/code>.\n     * <p>\n     * The <code>String<\/code> must specify a single paragraph of text,\n     * because an entire paragraph is required for the bidirectional\n     * algorithm.\n     * @param string the text to display\n     * @param font a <code>Font<\/code> used to style the text\n     * @param frc contains information about a graphics device which is needed\n     *       to measure the text correctly.\n     *       Text measurements can vary slightly depending on the\n     *       device resolution, and attributes such as antialiasing.  This\n     *       parameter does not specify a translation between the\n     *       <code>TextLayout<\/code> and user space.\n     */\n    public TextLayout(String string, Font font, FontRenderContext frc) {\n\n        if (font == null) {\n            throw new IllegalArgumentException(\"Null font passed to TextLayout constructor.\");\n        }\n\n        if (string == null) {\n            throw new IllegalArgumentException(\"Null string passed to TextLayout constructor.\");\n        }\n\n        if (string.length() == 0) {\n            throw new IllegalArgumentException(\"Zero length string passed to TextLayout constructor.\");\n        }\n\n        Map<? extends Attribute, ?> attributes = null;\n        if (font.hasLayoutAttributes()) {\n            attributes = font.getAttributes();\n        }\n\n        char[] text = string.toCharArray();\n        if (sameBaselineUpTo(font, text, 0, text.length) == text.length) {\n            fastInit(text, font, attributes, frc);\n        } else {\n            AttributedString as = attributes == null\n                ? new AttributedString(string)\n                : new AttributedString(string, attributes);\n            as.addAttribute(TextAttribute.FONT, font);\n            standardInit(as.getIterator(), text, frc);\n        }\n    }"}
{"Number":"414","API Relative Path":"java.awt.font.TextLayout.java-TextLayout(String-Font-FontRenderContext)","Corresponding Source":"/**\n     * Constructs a <code>TextLayout<\/code> from a <code>String<\/code>\n     * and a {@link Font}.  All the text is styled using the specified\n     * <code>Font<\/code>.\n     * <p>\n     * The <code>String<\/code> must specify a single paragraph of text,\n     * because an entire paragraph is required for the bidirectional\n     * algorithm.\n     * @param string the text to display\n     * @param font a <code>Font<\/code> used to style the text\n     * @param frc contains information about a graphics device which is needed\n     *       to measure the text correctly.\n     *       Text measurements can vary slightly depending on the\n     *       device resolution, and attributes such as antialiasing.  This\n     *       parameter does not specify a translation between the\n     *       <code>TextLayout<\/code> and user space.\n     */\n    public TextLayout(String string, Font font, FontRenderContext frc) {\n\n        if (font == null) {\n            throw new IllegalArgumentException(\"Null font passed to TextLayout constructor.\");\n        }\n\n        if (string == null) {\n            throw new IllegalArgumentException(\"Null string passed to TextLayout constructor.\");\n        }\n\n        if (string.length() == 0) {\n            throw new IllegalArgumentException(\"Zero length string passed to TextLayout constructor.\");\n        }\n\n        Map<? extends Attribute, ?> attributes = null;\n        if (font.hasLayoutAttributes()) {\n            attributes = font.getAttributes();\n        }\n\n        char[] text = string.toCharArray();\n        if (sameBaselineUpTo(font, text, 0, text.length) == text.length) {\n            fastInit(text, font, attributes, frc);\n        } else {\n            AttributedString as = attributes == null\n                ? new AttributedString(string)\n                : new AttributedString(string, attributes);\n            as.addAttribute(TextAttribute.FONT, font);\n            standardInit(as.getIterator(), text, frc);\n        }\n    }"}
{"Number":"415","API Relative Path":"java.awt.font.TextLayout.java-TextLayout(String-Map-FontRenderContext)","Corresponding Source":"/**\n     * Constructs a <code>TextLayout<\/code> from a <code>String<\/code>\n     * and an attribute set.\n     * <p>\n     * All the text is styled using the provided attributes.\n     * <p>\n     * <code>string<\/code> must specify a single paragraph of text because an\n     * entire paragraph is required for the bidirectional algorithm.\n     * @param string the text to display\n     * @param attributes the attributes used to style the text\n     * @param frc contains information about a graphics device which is needed\n     *       to measure the text correctly.\n     *       Text measurements can vary slightly depending on the\n     *       device resolution, and attributes such as antialiasing.  This\n     *       parameter does not specify a translation between the\n     *       <code>TextLayout<\/code> and user space.\n     */\n    public TextLayout(String string, Map<? extends Attribute,?> attributes,\n                      FontRenderContext frc)\n    {\n        if (string == null) {\n            throw new IllegalArgumentException(\"Null string passed to TextLayout constructor.\");\n        }\n\n        if (attributes == null) {\n            throw new IllegalArgumentException(\"Null map passed to TextLayout constructor.\");\n        }\n\n        if (string.length() == 0) {\n            throw new IllegalArgumentException(\"Zero length string passed to TextLayout constructor.\");\n        }\n\n        char[] text = string.toCharArray();\n        Font font = singleFont(text, 0, text.length, attributes);\n        if (font != null) {\n            fastInit(text, font, attributes, frc);\n        } else {\n            AttributedString as = new AttributedString(string, attributes);\n            standardInit(as.getIterator(), text, frc);\n        }\n    }"}
{"Number":"416","API Relative Path":"java.awt.font.TextLayout.java-TextLayout(String-Map-FontRenderContext)","Corresponding Source":"/**\n     * Constructs a <code>TextLayout<\/code> from a <code>String<\/code>\n     * and an attribute set.\n     * <p>\n     * All the text is styled using the provided attributes.\n     * <p>\n     * <code>string<\/code> must specify a single paragraph of text because an\n     * entire paragraph is required for the bidirectional algorithm.\n     * @param string the text to display\n     * @param attributes the attributes used to style the text\n     * @param frc contains information about a graphics device which is needed\n     *       to measure the text correctly.\n     *       Text measurements can vary slightly depending on the\n     *       device resolution, and attributes such as antialiasing.  This\n     *       parameter does not specify a translation between the\n     *       <code>TextLayout<\/code> and user space.\n     */\n    public TextLayout(String string, Map<? extends Attribute,?> attributes,\n                      FontRenderContext frc)\n    {\n        if (string == null) {\n            throw new IllegalArgumentException(\"Null string passed to TextLayout constructor.\");\n        }\n\n        if (attributes == null) {\n            throw new IllegalArgumentException(\"Null map passed to TextLayout constructor.\");\n        }\n\n        if (string.length() == 0) {\n            throw new IllegalArgumentException(\"Zero length string passed to TextLayout constructor.\");\n        }\n\n        char[] text = string.toCharArray();\n        Font font = singleFont(text, 0, text.length, attributes);\n        if (font != null) {\n            fastInit(text, font, attributes, frc);\n        } else {\n            AttributedString as = new AttributedString(string, attributes);\n            standardInit(as.getIterator(), text, frc);\n        }\n    }"}
{"Number":"417","API Relative Path":"java.awt.font.TransformAttribute.java-TransformAttribute(AffineTransform)","Corresponding Source":"/**\n     * Wraps the specified transform.  The transform is cloned and a\n     * reference to the clone is kept.  The original transform is unchanged.\n     * If null is passed as the argument, this constructor behaves as though\n     * it were the identity transform.  (Note that it is preferable to use\n     * {@link #IDENTITY} in this case.)\n     * @param transform the specified {@link AffineTransform} to be wrapped,\n     * or null.\n     */\n    public TransformAttribute(AffineTransform transform) {\n        if (transform != null && !transform.isIdentity()) {\n            this.transform = new AffineTransform(transform);\n        }\n    }"}
{"Number":"418","API Relative Path":"java.awt.Font.java-createFont(int-File)","Corresponding Source":"/**\n     * Returns a new <code>Font<\/code> using the specified font type\n     * and the specified font file.  The new <code>Font<\/code> is\n     * created with a point size of 1 and style {@link #PLAIN PLAIN}.\n     * This base font can then be used with the <code>deriveFont<\/code>\n     * methods in this class to derive new <code>Font<\/code> objects with\n     * varying sizes, styles, transforms and font features.\n     * @param fontFormat the type of the <code>Font<\/code>, which is\n     * {@link #TRUETYPE_FONT TRUETYPE_FONT} if a TrueType resource is\n     * specified or {@link #TYPE1_FONT TYPE1_FONT} if a Type 1 resource is\n     * specified.\n     * So long as the returned font, or its derived fonts are referenced\n     * the implementation may continue to access <code>fontFile<\/code>\n     * to retrieve font data. Thus the results are undefined if the file\n     * is changed, or becomes inaccessible.\n     * <p>\n     * To make the <code>Font<\/code> available to Font constructors the\n     * returned <code>Font<\/code> must be registered in the\n     * <code>GraphicsEnviroment<\/code> by calling\n     * {@link GraphicsEnvironment#registerFont(Font) registerFont(Font)}.\n     * @param fontFile a <code>File<\/code> object representing the\n     * input data for the font.\n     * @return a new <code>Font<\/code> created with the specified font type.\n     * @throws IllegalArgumentException if <code>fontFormat<\/code> is not\n     *     <code>TRUETYPE_FONT<\/code>or<code>TYPE1_FONT<\/code>.\n     * @throws NullPointerException if <code>fontFile<\/code> is null.\n     * @throws IOException if the <code>fontFile<\/code> cannot be read.\n     * @throws FontFormatException if <code>fontFile<\/code> does\n     *     not contain the required font tables for the specified format.\n     * @throws SecurityException if the executing code does not have\n     * permission to read from the file.\n     * @see GraphicsEnvironment#registerFont(Font)\n     * @since 1.5\n     */\n    public static Font createFont(int fontFormat, File fontFile)\n        throws java.awt.FontFormatException, java.io.IOException {\n\n        fontFile = new File(fontFile.getPath());\n\n        if (fontFormat != Font.TRUETYPE_FONT &&\n            fontFormat != Font.TYPE1_FONT) {\n            throw new IllegalArgumentException (\"font format not recognized\");\n        }\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            FilePermission filePermission =\n                new FilePermission(fontFile.getPath(), \"read\");\n            sm.checkPermission(filePermission);\n        }\n        if (!fontFile.canRead()) {\n            throw new IOException(\"Can't read \" + fontFile);\n        }\n        return new Font(fontFile, fontFormat, false, null);\n    }"}
{"Number":"419","API Relative Path":"java.awt.Font.java-createFont(int-InputStream)","Corresponding Source":"/**\n     * Returns a new <code>Font<\/code> using the specified font type\n     * and input data.  The new <code>Font<\/code> is\n     * created with a point size of 1 and style {@link #PLAIN PLAIN}.\n     * This base font can then be used with the <code>deriveFont<\/code>\n     * methods in this class to derive new <code>Font<\/code> objects with\n     * varying sizes, styles, transforms and font features.  This\n     * method does not close the {@link InputStream}.\n     * <p>\n     * To make the <code>Font<\/code> available to Font constructors the\n     * returned <code>Font<\/code> must be registered in the\n     * <code>GraphicsEnviroment<\/code> by calling\n     * {@link GraphicsEnvironment#registerFont(Font) registerFont(Font)}.\n     * @param fontFormat the type of the <code>Font<\/code>, which is\n     * {@link #TRUETYPE_FONT TRUETYPE_FONT} if a TrueType resource is specified.\n     * or {@link #TYPE1_FONT TYPE1_FONT} if a Type 1 resource is specified.\n     * @param fontStream an <code>InputStream<\/code> object representing the\n     * input data for the font.\n     * @return a new <code>Font<\/code> created with the specified font type.\n     * @throws IllegalArgumentException if <code>fontFormat<\/code> is not\n     *     <code>TRUETYPE_FONT<\/code>or<code>TYPE1_FONT<\/code>.\n     * @throws FontFormatException if the <code>fontStream<\/code> data does\n     *     not contain the required font tables for the specified format.\n     * @throws IOException if the <code>fontStream<\/code>\n     *     cannot be completely read.\n     * @see GraphicsEnvironment#registerFont(Font)\n     * @since 1.3\n     */\n    public static Font createFont(int fontFormat, InputStream fontStream)\n        throws java.awt.FontFormatException, java.io.IOException {\n\n        if (hasTempPermission()) {\n            return createFont0(fontFormat, fontStream, null);\n        }\n\n        // Otherwise, be extra conscious of pending temp file creation and\n        // resourcefully handle the temp file resources, among other things.\n        CreatedFontTracker tracker = CreatedFontTracker.getTracker();\n        boolean acquired = false;\n        try {\n            acquired = tracker.acquirePermit();\n            if (!acquired) {\n                throw new IOException(\"Timed out waiting for resources.\");\n            }\n            return createFont0(fontFormat, fontStream, tracker);\n        } catch (InterruptedException e) {\n            throw new IOException(\"Problem reading font data.\");\n        } finally {\n            if (acquired) {\n                tracker.releasePermit();\n            }\n        }\n    }"}
{"Number":"420","API Relative Path":"java.awt.Font.java-getFamily(Locale)","Corresponding Source":"/**\n     * Returns the family name of this <code>Font<\/code>, localized for\n     * the specified locale.\n     *\n     * <p>The family name of a font is font specific. Two fonts such as\n     * Helvetica Italic and Helvetica Bold have the same family name,\n     * <i>Helvetica<\/i>, whereas their font face names are\n     * <i>Helvetica Bold<\/i> and <i>Helvetica Italic<\/i>. The list of\n     * available family names may be obtained by using the\n     * {@link GraphicsEnvironment#getAvailableFontFamilyNames()} method.\n     *\n     * <p>Use <code>getFontName<\/code> to get the font face name of the font.\n     * @param l locale for which to get the family name\n     * @return a <code>String<\/code> representing the family name of the\n     *          font, localized for the specified locale.\n     * @see #getFontName\n     * @see java.util.Locale\n     * @since 1.2\n     */\n    public String getFamily(Locale l) {\n        if (l == null) {\n            throw new NullPointerException(\"null locale doesn't mean default\");\n        }\n        return getFont2D().getFamilyName(l);\n    }"}
{"Number":"421","API Relative Path":"java.awt.Font.java-getFontName(Locale)","Corresponding Source":"/**\n     * Returns the font face name of the <code>Font<\/code>, localized\n     * for the specified locale. For example, Helvetica Fett could be\n     * returned as the font face name.\n     * Use <code>getFamily<\/code> to get the family name of the font.\n     * @param l a locale for which to get the font face name\n     * @return a <code>String<\/code> representing the font face name,\n     *          localized for the specified locale.\n     * @see #getFamily\n     * @see java.util.Locale\n     */\n    public String getFontName(Locale l) {\n        if (l == null) {\n            throw new NullPointerException(\"null locale doesn't mean default\");\n        }\n        return getFont2D().getFontName(l);\n    }"}
{"Number":"422","API Relative Path":"java.awt.Font.java-getStringBounds(CharacterIterator-int-int-FontRenderContext)","Corresponding Source":"/**\n     * Returns the logical bounds of the characters indexed in the\n     * specified {@link CharacterIterator} in the\n     * specified <code>FontRenderContext<\/code>.  The logical bounds\n     * contains the origin, ascent, advance, and height, which includes\n     * the leading.  The logical bounds does not always enclose all the\n     * text.  For example, in some languages and in some fonts, accent\n     * marks can be positioned above the ascent or below the descent.\n     * To obtain a visual bounding box, which encloses all the text,\n     * use the {@link TextLayout#getBounds() getBounds} method of\n     * <code>TextLayout<\/code>.\n     * <p>Note: The returned bounds is in baseline-relative coordinates\n     * (see {@link java.awt.Font class notes}).\n     * @param ci the specified <code>CharacterIterator<\/code>\n     * @param beginIndex the initial offset in <code>ci<\/code>\n     * @param limit the end offset in <code>ci<\/code>\n     * @param frc the specified <code>FontRenderContext<\/code>\n     * @return a <code>Rectangle2D<\/code> that is the bounding box of the\n     * characters indexed in the specified <code>CharacterIterator<\/code>\n     * in the specified <code>FontRenderContext<\/code>.\n     * @see FontRenderContext\n     * @see Font#createGlyphVector\n     * @since 1.2\n     * @throws IndexOutOfBoundsException if <code>beginIndex<\/code> is\n     *         less than the start index of <code>ci<\/code>, or\n     *         <code>limit<\/code> is greater than the end index of\n     *         <code>ci<\/code>, or <code>beginIndex<\/code> is greater\n     *         than <code>limit<\/code>\n     */\n    public Rectangle2D getStringBounds(CharacterIterator ci,\n                                    int beginIndex, int limit,\n                                       FontRenderContext frc) {\n        int start = ci.getBeginIndex();\n        int end = ci.getEndIndex();\n\n        if (beginIndex < start) {\n            throw new IndexOutOfBoundsException(\"beginIndex: \" + beginIndex);\n        }\n        if (limit > end) {\n            throw new IndexOutOfBoundsException(\"limit: \" + limit);\n        }\n        if (beginIndex > limit) {\n            throw new IndexOutOfBoundsException(\"range length: \" +\n                                                (limit - beginIndex));\n        }\n\n        char[]  arr = new char[limit - beginIndex];\n\n        ci.setIndex(beginIndex);\n        for(int idx = 0; idx < arr.length; idx++) {\n            arr[idx] = ci.current();\n            ci.next();\n        }\n\n        return getStringBounds(arr,0,arr.length,frc);\n    }"}
{"Number":"423","API Relative Path":"java.awt.Font.java-getStringBounds(CharacterIterator-int-int-FontRenderContext)","Corresponding Source":"/**\n     * Returns the logical bounds of the characters indexed in the\n     * specified {@link CharacterIterator} in the\n     * specified <code>FontRenderContext<\/code>.  The logical bounds\n     * contains the origin, ascent, advance, and height, which includes\n     * the leading.  The logical bounds does not always enclose all the\n     * text.  For example, in some languages and in some fonts, accent\n     * marks can be positioned above the ascent or below the descent.\n     * To obtain a visual bounding box, which encloses all the text,\n     * use the {@link TextLayout#getBounds() getBounds} method of\n     * <code>TextLayout<\/code>.\n     * <p>Note: The returned bounds is in baseline-relative coordinates\n     * (see {@link java.awt.Font class notes}).\n     * @param ci the specified <code>CharacterIterator<\/code>\n     * @param beginIndex the initial offset in <code>ci<\/code>\n     * @param limit the end offset in <code>ci<\/code>\n     * @param frc the specified <code>FontRenderContext<\/code>\n     * @return a <code>Rectangle2D<\/code> that is the bounding box of the\n     * characters indexed in the specified <code>CharacterIterator<\/code>\n     * in the specified <code>FontRenderContext<\/code>.\n     * @see FontRenderContext\n     * @see Font#createGlyphVector\n     * @since 1.2\n     * @throws IndexOutOfBoundsException if <code>beginIndex<\/code> is\n     *         less than the start index of <code>ci<\/code>, or\n     *         <code>limit<\/code> is greater than the end index of\n     *         <code>ci<\/code>, or <code>beginIndex<\/code> is greater\n     *         than <code>limit<\/code>\n     */\n    public Rectangle2D getStringBounds(CharacterIterator ci,\n                                    int beginIndex, int limit,\n                                       FontRenderContext frc) {\n        int start = ci.getBeginIndex();\n        int end = ci.getEndIndex();\n\n        if (beginIndex < start) {\n            throw new IndexOutOfBoundsException(\"beginIndex: \" + beginIndex);\n        }\n        if (limit > end) {\n            throw new IndexOutOfBoundsException(\"limit: \" + limit);\n        }\n        if (beginIndex > limit) {\n            throw new IndexOutOfBoundsException(\"range length: \" +\n                                                (limit - beginIndex));\n        }\n\n        char[]  arr = new char[limit - beginIndex];\n\n        ci.setIndex(beginIndex);\n        for(int idx = 0; idx < arr.length; idx++) {\n            arr[idx] = ci.current();\n            ci.next();\n        }\n\n        return getStringBounds(arr,0,arr.length,frc);\n    }"}
{"Number":"424","API Relative Path":"java.awt.Font.java-getStringBounds(CharacterIterator-int-int-FontRenderContext)","Corresponding Source":"/**\n     * Returns the logical bounds of the characters indexed in the\n     * specified {@link CharacterIterator} in the\n     * specified <code>FontRenderContext<\/code>.  The logical bounds\n     * contains the origin, ascent, advance, and height, which includes\n     * the leading.  The logical bounds does not always enclose all the\n     * text.  For example, in some languages and in some fonts, accent\n     * marks can be positioned above the ascent or below the descent.\n     * To obtain a visual bounding box, which encloses all the text,\n     * use the {@link TextLayout#getBounds() getBounds} method of\n     * <code>TextLayout<\/code>.\n     * <p>Note: The returned bounds is in baseline-relative coordinates\n     * (see {@link java.awt.Font class notes}).\n     * @param ci the specified <code>CharacterIterator<\/code>\n     * @param beginIndex the initial offset in <code>ci<\/code>\n     * @param limit the end offset in <code>ci<\/code>\n     * @param frc the specified <code>FontRenderContext<\/code>\n     * @return a <code>Rectangle2D<\/code> that is the bounding box of the\n     * characters indexed in the specified <code>CharacterIterator<\/code>\n     * in the specified <code>FontRenderContext<\/code>.\n     * @see FontRenderContext\n     * @see Font#createGlyphVector\n     * @since 1.2\n     * @throws IndexOutOfBoundsException if <code>beginIndex<\/code> is\n     *         less than the start index of <code>ci<\/code>, or\n     *         <code>limit<\/code> is greater than the end index of\n     *         <code>ci<\/code>, or <code>beginIndex<\/code> is greater\n     *         than <code>limit<\/code>\n     */\n    public Rectangle2D getStringBounds(CharacterIterator ci,\n                                    int beginIndex, int limit,\n                                       FontRenderContext frc) {\n        int start = ci.getBeginIndex();\n        int end = ci.getEndIndex();\n\n        if (beginIndex < start) {\n            throw new IndexOutOfBoundsException(\"beginIndex: \" + beginIndex);\n        }\n        if (limit > end) {\n            throw new IndexOutOfBoundsException(\"limit: \" + limit);\n        }\n        if (beginIndex > limit) {\n            throw new IndexOutOfBoundsException(\"range length: \" +\n                                                (limit - beginIndex));\n        }\n\n        char[]  arr = new char[limit - beginIndex];\n\n        ci.setIndex(beginIndex);\n        for(int idx = 0; idx < arr.length; idx++) {\n            arr[idx] = ci.current();\n            ci.next();\n        }\n\n        return getStringBounds(arr,0,arr.length,frc);\n    }"}
{"Number":"425","API Relative Path":"java.awt.Font.java-getStringBounds(char[]-int-int-FontRenderContext)","Corresponding Source":"/**\n     * Returns the logical bounds of the characters indexed in the\n     * specified {@link CharacterIterator} in the\n     * specified <code>FontRenderContext<\/code>.  The logical bounds\n     * contains the origin, ascent, advance, and height, which includes\n     * the leading.  The logical bounds does not always enclose all the\n     * text.  For example, in some languages and in some fonts, accent\n     * marks can be positioned above the ascent or below the descent.\n     * To obtain a visual bounding box, which encloses all the text,\n     * use the {@link TextLayout#getBounds() getBounds} method of\n     * <code>TextLayout<\/code>.\n     * <p>Note: The returned bounds is in baseline-relative coordinates\n     * (see {@link java.awt.Font class notes}).\n     * @param ci the specified <code>CharacterIterator<\/code>\n     * @param beginIndex the initial offset in <code>ci<\/code>\n     * @param limit the end offset in <code>ci<\/code>\n     * @param frc the specified <code>FontRenderContext<\/code>\n     * @return a <code>Rectangle2D<\/code> that is the bounding box of the\n     * characters indexed in the specified <code>CharacterIterator<\/code>\n     * in the specified <code>FontRenderContext<\/code>.\n     * @see FontRenderContext\n     * @see Font#createGlyphVector\n     * @since 1.2\n     * @throws IndexOutOfBoundsException if <code>beginIndex<\/code> is\n     *         less than the start index of <code>ci<\/code>, or\n     *         <code>limit<\/code> is greater than the end index of\n     *         <code>ci<\/code>, or <code>beginIndex<\/code> is greater\n     *         than <code>limit<\/code>\n     */\n    public Rectangle2D getStringBounds(CharacterIterator ci,\n                                    int beginIndex, int limit,\n                                       FontRenderContext frc) {\n        int start = ci.getBeginIndex();\n        int end = ci.getEndIndex();\n\n        if (beginIndex < start) {\n            throw new IndexOutOfBoundsException(\"beginIndex: \" + beginIndex);\n        }\n        if (limit > end) {\n            throw new IndexOutOfBoundsException(\"limit: \" + limit);\n        }\n        if (beginIndex > limit) {\n            throw new IndexOutOfBoundsException(\"range length: \" +\n                                                (limit - beginIndex));\n        }\n\n        char[]  arr = new char[limit - beginIndex];\n\n        ci.setIndex(beginIndex);\n        for(int idx = 0; idx < arr.length; idx++) {\n            arr[idx] = ci.current();\n            ci.next();\n        }\n\n        return getStringBounds(arr,0,arr.length,frc);\n    }"}
{"Number":"426","API Relative Path":"java.awt.Frame.java-setBackground(Color)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setBackground(Color bgColor) {\n        synchronized (getTreeLock()) {\n            if ((bgColor != null) && (bgColor.getAlpha() < 255) && !isUndecorated()) {\n                throw new IllegalComponentStateException(\"The frame is decorated\");\n            }\n            super.setBackground(bgColor);\n        }\n    }"}
{"Number":"427","API Relative Path":"java.awt.Frame.java-setCursor(int)","Corresponding Source":"/**\n     * @deprecated As of JDK version 1.1,\n     * replaced by <code>Component.setCursor(Cursor)<\/code>.\n     */\n    @Deprecated\n    public void setCursor(int cursorType) {\n        if (cursorType < DEFAULT_CURSOR || cursorType > MOVE_CURSOR) {\n            throw new IllegalArgumentException(\"illegal cursor type\");\n        }\n        setCursor(Cursor.getPredefinedCursor(cursorType));\n    }"}
{"Number":"428","API Relative Path":"java.awt.Frame.java-setCursor(int)","Corresponding Source":"/**\n     * @deprecated As of JDK version 1.1,\n     * replaced by <code>Component.setCursor(Cursor)<\/code>.\n     */\n    @Deprecated\n    public void setCursor(int cursorType) {\n        if (cursorType < DEFAULT_CURSOR || cursorType > MOVE_CURSOR) {\n            throw new IllegalArgumentException(\"illegal cursor type\");\n        }\n        setCursor(Cursor.getPredefinedCursor(cursorType));\n    }"}
{"Number":"429","API Relative Path":"java.awt.Frame.java-setCursor(int)","Corresponding Source":"/**\n     * @deprecated As of JDK version 1.1,\n     * replaced by <code>Component.setCursor(Cursor)<\/code>.\n     */\n    @Deprecated\n    public void setCursor(int cursorType) {\n        if (cursorType < DEFAULT_CURSOR || cursorType > MOVE_CURSOR) {\n            throw new IllegalArgumentException(\"illegal cursor type\");\n        }\n        setCursor(Cursor.getPredefinedCursor(cursorType));\n    }"}
{"Number":"430","API Relative Path":"java.awt.Frame.java-setMenuBar(MenuBar)","Corresponding Source":"/**\n     * Sets the menu bar for this frame to the specified menu bar.\n     * @param     mb the menu bar being set.\n     *            If this parameter is <code>null<\/code> then any\n     *            existing menu bar on this frame is removed.\n     * @see       #getMenuBar\n     */\n    public void setMenuBar(MenuBar mb) {\n        synchronized (getTreeLock()) {\n            if (menuBar == mb) {\n                return;\n            }\n            if ((mb != null) && (mb.parent != null)) {\n                mb.parent.remove(mb);\n            }\n            if (menuBar != null) {\n                remove(menuBar);\n            }\n            menuBar = mb;\n            if (menuBar != null) {\n                menuBar.parent = this;\n\n                FramePeer peer = (FramePeer)this.peer;\n                if (peer != null) {\n                    mbManagement = true;\n                    menuBar.addNotify();\n                    invalidateIfValid();\n                    peer.setMenuBar(menuBar);\n                }\n            }\n        }\n    }"}
{"Number":"431","API Relative Path":"java.awt.Frame.java-setOpacity(float)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setOpacity(float opacity) {\n        synchronized (getTreeLock()) {\n            if ((opacity < 1.0f) && !isUndecorated()) {\n                throw new IllegalComponentStateException(\"The frame is decorated\");\n            }\n            super.setOpacity(opacity);\n        }\n    }"}
{"Number":"432","API Relative Path":"java.awt.Frame.java-setShape(Shape)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setShape(Shape shape) {\n        synchronized (getTreeLock()) {\n            if ((shape != null) && !isUndecorated()) {\n                throw new IllegalComponentStateException(\"The frame is decorated\");\n            }\n            super.setShape(shape);\n        }\n    }"}
{"Number":"433","API Relative Path":"java.awt.Frame.java-setUndecorated(boolean)","Corresponding Source":"/**\n     * Disables or enables decorations for this frame.\n     * <p>\n     * This method can only be called while the frame is not displayable. To\n     * make this frame decorated, it must be opaque and have the default shape,\n     * otherwise the {@code IllegalComponentStateException} will be thrown.\n     * Refer to {@link Window#setShape}, {@link Window#setOpacity} and {@link\n     * Window#setBackground} for details\n     *\n     * @param  undecorated {@code true} if no frame decorations are to be\n     *         enabled; {@code false} if frame decorations are to be enabled\n     *\n     * @throws IllegalComponentStateException if the frame is displayable\n     * @throws IllegalComponentStateException if {@code undecorated} is\n     *      {@code false}, and this frame does not have the default shape\n     * @throws IllegalComponentStateException if {@code undecorated} is\n     *      {@code false}, and this frame opacity is less than {@code 1.0f}\n     * @throws IllegalComponentStateException if {@code undecorated} is\n     *      {@code false}, and the alpha value of this frame background\n     *      color is less than {@code 1.0f}\n     *\n     * @see    #isUndecorated\n     * @see    Component#isDisplayable\n     * @see    Window#getShape\n     * @see    Window#getOpacity\n     * @see    Window#getBackground\n     * @see    javax.swing.JFrame#setDefaultLookAndFeelDecorated(boolean)\n     *\n     * @since 1.4\n     */\n    public void setUndecorated(boolean undecorated) {\n        /* Make sure we don't run in the middle of peer creation.*/\n        synchronized (getTreeLock()) {\n            if (isDisplayable()) {\n                throw new IllegalComponentStateException(\"The frame is displayable.\");\n            }\n            if (!undecorated) {\n                if (getOpacity() < 1.0f) {\n                    throw new IllegalComponentStateException(\"The frame is not opaque\");\n                }\n                if (getShape() != null) {\n                    throw new IllegalComponentStateException(\"The frame does not have a default shape\");\n                }\n                Color bg = getBackground();\n                if ((bg != null) && (bg.getAlpha() < 255)) {\n                    throw new IllegalComponentStateException(\"The frame background color is not opaque\");\n                }\n            }\n            this.undecorated = undecorated;\n        }\n    }"}
{"Number":"434","API Relative Path":"java.awt.Frame.java-setUndecorated(boolean)","Corresponding Source":"/**\n     * Disables or enables decorations for this frame.\n     * <p>\n     * This method can only be called while the frame is not displayable. To\n     * make this frame decorated, it must be opaque and have the default shape,\n     * otherwise the {@code IllegalComponentStateException} will be thrown.\n     * Refer to {@link Window#setShape}, {@link Window#setOpacity} and {@link\n     * Window#setBackground} for details\n     *\n     * @param  undecorated {@code true} if no frame decorations are to be\n     *         enabled; {@code false} if frame decorations are to be enabled\n     *\n     * @throws IllegalComponentStateException if the frame is displayable\n     * @throws IllegalComponentStateException if {@code undecorated} is\n     *      {@code false}, and this frame does not have the default shape\n     * @throws IllegalComponentStateException if {@code undecorated} is\n     *      {@code false}, and this frame opacity is less than {@code 1.0f}\n     * @throws IllegalComponentStateException if {@code undecorated} is\n     *      {@code false}, and the alpha value of this frame background\n     *      color is less than {@code 1.0f}\n     *\n     * @see    #isUndecorated\n     * @see    Component#isDisplayable\n     * @see    Window#getShape\n     * @see    Window#getOpacity\n     * @see    Window#getBackground\n     * @see    javax.swing.JFrame#setDefaultLookAndFeelDecorated(boolean)\n     *\n     * @since 1.4\n     */\n    public void setUndecorated(boolean undecorated) {\n        /* Make sure we don't run in the middle of peer creation.*/\n        synchronized (getTreeLock()) {\n            if (isDisplayable()) {\n                throw new IllegalComponentStateException(\"The frame is displayable.\");\n            }\n            if (!undecorated) {\n                if (getOpacity() < 1.0f) {\n                    throw new IllegalComponentStateException(\"The frame is not opaque\");\n                }\n                if (getShape() != null) {\n                    throw new IllegalComponentStateException(\"The frame does not have a default shape\");\n                }\n                Color bg = getBackground();\n                if ((bg != null) && (bg.getAlpha() < 255)) {\n                    throw new IllegalComponentStateException(\"The frame background color is not opaque\");\n                }\n            }\n            this.undecorated = undecorated;\n        }\n    }"}
{"Number":"435","API Relative Path":"java.awt.Frame.java-setUndecorated(boolean)","Corresponding Source":"/**\n     * Disables or enables decorations for this frame.\n     * <p>\n     * This method can only be called while the frame is not displayable. To\n     * make this frame decorated, it must be opaque and have the default shape,\n     * otherwise the {@code IllegalComponentStateException} will be thrown.\n     * Refer to {@link Window#setShape}, {@link Window#setOpacity} and {@link\n     * Window#setBackground} for details\n     *\n     * @param  undecorated {@code true} if no frame decorations are to be\n     *         enabled; {@code false} if frame decorations are to be enabled\n     *\n     * @throws IllegalComponentStateException if the frame is displayable\n     * @throws IllegalComponentStateException if {@code undecorated} is\n     *      {@code false}, and this frame does not have the default shape\n     * @throws IllegalComponentStateException if {@code undecorated} is\n     *      {@code false}, and this frame opacity is less than {@code 1.0f}\n     * @throws IllegalComponentStateException if {@code undecorated} is\n     *      {@code false}, and the alpha value of this frame background\n     *      color is less than {@code 1.0f}\n     *\n     * @see    #isUndecorated\n     * @see    Component#isDisplayable\n     * @see    Window#getShape\n     * @see    Window#getOpacity\n     * @see    Window#getBackground\n     * @see    javax.swing.JFrame#setDefaultLookAndFeelDecorated(boolean)\n     *\n     * @since 1.4\n     */\n    public void setUndecorated(boolean undecorated) {\n        /* Make sure we don't run in the middle of peer creation.*/\n        synchronized (getTreeLock()) {\n            if (isDisplayable()) {\n                throw new IllegalComponentStateException(\"The frame is displayable.\");\n            }\n            if (!undecorated) {\n                if (getOpacity() < 1.0f) {\n                    throw new IllegalComponentStateException(\"The frame is not opaque\");\n                }\n                if (getShape() != null) {\n                    throw new IllegalComponentStateException(\"The frame does not have a default shape\");\n                }\n                Color bg = getBackground();\n                if ((bg != null) && (bg.getAlpha() < 255)) {\n                    throw new IllegalComponentStateException(\"The frame background color is not opaque\");\n                }\n            }\n            this.undecorated = undecorated;\n        }\n    }"}
{"Number":"436","API Relative Path":"java.awt.geom.AffineTransform.java-createTransformedShape(Shape)","Corresponding Source":"/**\n     * Returns a new {@link Shape} object defined by the geometry of the\n     * specified <code>Shape<\/code> after it has been transformed by\n     * this transform.\n     * @param pSrc the specified <code>Shape<\/code> object to be\n     * transformed by this transform.\n     * @return a new <code>Shape<\/code> object that defines the geometry\n     * of the transformed <code>Shape<\/code>, or null if {@code pSrc} is null.\n     * @since 1.2\n     */\n    public Shape createTransformedShape(Shape pSrc) {\n        if (pSrc == null) {\n            return null;\n        }\n        return new Path2D.Double(pSrc, this);\n    }"}
{"Number":"437","API Relative Path":"java.awt.geom.Arc2D.java-Arc2D(int)","Corresponding Source":"/**\n     * This is an abstract class that cannot be instantiated directly.\n     * Type-specific implementation subclasses are available for\n     * instantiation and provide a number of formats for storing\n     * the information necessary to satisfy the various accessor\n     * methods below.\n     *\n     * @param type The closure type of this arc:\n     * {@link #OPEN}, {@link #CHORD}, or {@link #PIE}.\n     * @see java.awt.geom.Arc2D.Float\n     * @see java.awt.geom.Arc2D.Double\n     * @since 1.2\n     */\n    protected Arc2D(int type) {\n        setArcType(type);\n    }"}
{"Number":"438","API Relative Path":"java.awt.geom.Arc2D.java-setArcType(int)","Corresponding Source":"/**\n     * Sets the closure type of this arc to the specified value:\n     * <CODE>OPEN<\/CODE>, <CODE>CHORD<\/CODE>, or <CODE>PIE<\/CODE>.\n     *\n     * @param type The integer constant that represents the closure\n     * type of this arc: {@link #OPEN}, {@link #CHORD}, or\n     * {@link #PIE}.\n     *\n     * @throws IllegalArgumentException if <code>type<\/code> is not\n     * 0, 1, or 2.+\n     * @see #getArcType\n     * @since 1.2\n     */\n    public void setArcType(int type) {\n        if (type < OPEN || type > PIE) {\n            throw new IllegalArgumentException(\"invalid type for Arc: \"+type);\n        }\n        this.type = type;\n    }"}
{"Number":"439","API Relative Path":"java.awt.geom.FlatteningPathIterator.java-FlatteningPathIterator(PathIterator-double-int)","Corresponding Source":"/**\n     * Constructs a new <code>FlatteningPathIterator<\/code> object\n     * that flattens a path as it iterates over it.\n     * The <code>limit<\/code> parameter allows you to control the\n     * maximum number of recursive subdivisions that the iterator\n     * can make before it assumes that the curve is flat enough\n     * without measuring against the <code>flatness<\/code> parameter.\n     * The flattened iteration therefore never generates more than\n     * a maximum of <code>(2^limit)<\/code> line segments per curve.\n     * @param src the original unflattened path being iterated over\n     * @param flatness the maximum allowable distance between the\n     * control points and the flattened curve\n     * @param limit the maximum number of recursive subdivisions\n     * allowed for any curved segment\n     * @exception IllegalArgumentException if\n     *          <code>flatness<\/code> or <code>limit<\/code>\n     *          is less than zero\n     */\n    public FlatteningPathIterator(PathIterator src, double flatness,\n                                  int limit) {\n        if (flatness < 0.0) {\n            throw new IllegalArgumentException(\"flatness must be >= 0\");\n        }\n        if (limit < 0) {\n            throw new IllegalArgumentException(\"limit must be >= 0\");\n        }\n        this.src = src;\n        this.squareflat = flatness * flatness;\n        this.limit = limit;\n        this.levels = new int[limit + 1];\n        // prime the first path segment\n        next(false);\n    }"}
{"Number":"440","API Relative Path":"java.awt.geom.Path2D.java-Path2D(int-int)","Corresponding Source":"/**\n     * Constructs a new {@code Path2D} object from the given\n     * specified initial values.\n     * This method is only intended for internal use and should\n     * not be made public if the other constructors for this class\n     * are ever exposed.\n     *\n     * @param rule the winding rule\n     * @param initialTypes the size to make the initial array to\n     *                     store the path segment types\n     * @since 1.6\n     */\n    /* private protected */\n    Path2D(int rule, int initialTypes) {\n        setWindingRule(rule);\n        this.pointTypes = new byte[initialTypes];\n    }"}
{"Number":"441","API Relative Path":"java.awt.geom.Path2D.java-setWindingRule(int)","Corresponding Source":"/**\n     * Sets the winding rule for this path to the specified value.\n     *\n     * @param rule an integer representing the specified\n     *             winding rule\n     * @exception IllegalArgumentException if\n     *          {@code rule} is not either\n     *          {@link #WIND_EVEN_ODD} or\n     *          {@link #WIND_NON_ZERO}\n     * @see #getWindingRule\n     * @since 1.6\n     */\n    public final void setWindingRule(int rule) {\n        if (rule != WIND_EVEN_ODD && rule != WIND_NON_ZERO) {\n            throw new IllegalArgumentException(\"winding rule must be \"+\n                                               \"WIND_EVEN_ODD or \"+\n                                               \"WIND_NON_ZERO\");\n        }\n        windingRule = rule;\n    }"}
{"Number":"442","API Relative Path":"java.awt.GradientPaint.java-GradientPaint(float-float-Color-float-float-Color)","Corresponding Source":"/**\n     * Constructs a simple acyclic <code>GradientPaint<\/code> object.\n     * @param x1 x coordinate of the first specified\n     * <code>Point<\/code> in user space\n     * @param y1 y coordinate of the first specified\n     * <code>Point<\/code> in user space\n     * @param color1 <code>Color<\/code> at the first specified\n     * <code>Point<\/code>\n     * @param x2 x coordinate of the second specified\n     * <code>Point<\/code> in user space\n     * @param y2 y coordinate of the second specified\n     * <code>Point<\/code> in user space\n     * @param color2 <code>Color<\/code> at the second specified\n     * <code>Point<\/code>\n     * @throws NullPointerException if either one of colors is null\n     */\n    public GradientPaint(float x1,\n                         float y1,\n                         Color color1,\n                         float x2,\n                         float y2,\n                         Color color2) {\n        if ((color1 == null) || (color2 == null)) {\n            throw new NullPointerException(\"Colors cannot be null\");\n        }\n\n        p1 = new Point2D.Float(x1, y1);\n        p2 = new Point2D.Float(x2, y2);\n        this.color1 = color1;\n        this.color2 = color2;\n    }"}
{"Number":"443","API Relative Path":"java.awt.GradientPaint.java-GradientPaint(Point2D-Color-Point2D-Color)","Corresponding Source":"/**\n     * Constructs a simple acyclic <code>GradientPaint<\/code> object.\n     * @param pt1 the first specified <code>Point<\/code> in user space\n     * @param color1 <code>Color<\/code> at the first specified\n     * <code>Point<\/code>\n     * @param pt2 the second specified <code>Point<\/code> in user space\n     * @param color2 <code>Color<\/code> at the second specified\n     * <code>Point<\/code>\n     * @throws NullPointerException if either one of colors or points\n     * is null\n     */\n    public GradientPaint(Point2D pt1,\n                         Color color1,\n                         Point2D pt2,\n                         Color color2) {\n        if ((color1 == null) || (color2 == null) ||\n            (pt1 == null) || (pt2 == null)) {\n            throw new NullPointerException(\"Colors and points should be non-null\");\n        }\n\n        p1 = new Point2D.Float((float)pt1.getX(), (float)pt1.getY());\n        p2 = new Point2D.Float((float)pt2.getX(), (float)pt2.getY());\n        this.color1 = color1;\n        this.color2 = color2;\n    }"}
{"Number":"444","API Relative Path":"java.awt.Graphics.java-getClipBounds(Rectangle)","Corresponding Source":"/**\n     * Returns the bounding rectangle of the current clipping area.\n     * The coordinates in the rectangle are relative to the coordinate\n     * system origin of this graphics context.  This method differs\n     * from {@link #getClipBounds() getClipBounds} in that an existing\n     * rectangle is used instead of allocating a new one.\n     * This method refers to the user clip, which is independent of the\n     * clipping associated with device bounds and window visibility.\n     *  If no clip has previously been set, or if the clip has been\n     * cleared using <code>setClip(null)<\/code>, this method returns the\n     * specified <code>Rectangle<\/code>.\n     * @param  r    the rectangle where the current clipping area is\n     *              copied to.  Any current values in this rectangle are\n     *              overwritten.\n     * @return      the bounding rectangle of the current clipping area.\n     */\n    public Rectangle getClipBounds(Rectangle r) {\n        // Note, this implementation is not very efficient.\n        // Subclasses should override this method and avoid\n        // the allocation overhead of getClipBounds().\n        Rectangle clipRect = getClipBounds();\n        if (clipRect != null) {\n            r.x = clipRect.x;\n            r.y = clipRect.y;\n            r.width = clipRect.width;\n            r.height = clipRect.height;\n        } else if (r == null) {\n            throw new NullPointerException(\"null rectangle parameter\");\n        }\n        return r;\n    }"}
{"Number":"445","API Relative Path":"java.awt.GraphicsConfiguration.java-createCompatibleVolatileImage(int-int-ImageCapabilities-int)","Corresponding Source":"/**\n     * Returns a {@link VolatileImage} with a data layout and color model\n     * compatible with this <code>GraphicsConfiguration<\/code>, using\n     * the specified image capabilities and transparency value.\n     * If the <code>caps<\/code> parameter is null, it is effectively ignored\n     * and this method will create a VolatileImage without regard to\n     * <code>ImageCapabilities<\/code> constraints.\n     *\n     * The returned <code>VolatileImage<\/code> has\n     * a layout and color model that is closest to this native device\n     * configuration and can therefore be optimally blitted to this\n     * device.\n     * @param width the width of the returned <code>VolatileImage<\/code>\n     * @param height the height of the returned <code>VolatileImage<\/code>\n     * @param caps the image capabilities\n     * @param transparency the specified transparency mode\n     * @return a <code>VolatileImage<\/code> whose data layout and color\n     * model is compatible with this <code>GraphicsConfiguration<\/code>.\n     * @see Transparency#OPAQUE\n     * @see Transparency#BITMASK\n     * @see Transparency#TRANSLUCENT\n     * @throws IllegalArgumentException if the transparency is not a valid value\n     * @exception AWTException if the supplied image capabilities could not\n     * be met by this graphics configuration\n     * @see Component#createVolatileImage(int, int)\n     * @since 1.5\n     */\n    public VolatileImage createCompatibleVolatileImage(int width, int height,\n        ImageCapabilities caps, int transparency) throws AWTException\n    {\n        VolatileImage vi =\n            new SunVolatileImage(this, width, height, transparency, caps);\n        if (caps != null && caps.isAccelerated() &&\n            !vi.getCapabilities().isAccelerated())\n        {\n            throw new AWTException(\"Supplied image capabilities could not \" +\n                                   \"be met by this graphics configuration.\");\n        }\n        return vi;\n    }"}
{"Number":"446","API Relative Path":"java.awt.GridBagLayout.java-addLayoutComponent(Component-Object)","Corresponding Source":"/**\n     * Adds the specified component to the layout, using the specified\n     * <code>constraints<\/code> object.  Note that constraints\n     * are mutable and are, therefore, cloned when cached.\n     *\n     * @param      comp         the component to be added\n     * @param      constraints  an object that determines how\n     *                          the component is added to the layout\n     * @exception IllegalArgumentException if <code>constraints<\/code>\n     *            is not a <code>GridBagConstraint<\/code>\n     */\n    public void addLayoutComponent(Component comp, Object constraints) {\n        if (constraints instanceof GridBagConstraints) {\n            setConstraints(comp, (GridBagConstraints)constraints);\n        } else if (constraints != null) {\n            throw new IllegalArgumentException(\"cannot add to layout: constraints must be a GridBagConstraint\");\n        }\n    }"}
{"Number":"447","API Relative Path":"java.awt.im.InputMethodHighlight.java-InputMethodHighlight(boolean-int-int-Map)","Corresponding Source":"/**\n     * Constructs an input method highlight record.\n     * The style attributes map provided must be unmodifiable.\n     * @param selected whether the text range is selected\n     * @param state the conversion state for the text range - RAW_TEXT or CONVERTED_TEXT\n     * @param variation the variation for the text range\n     * @param style the rendering style attributes for the text range, or null\n     * @see InputMethodHighlight#RAW_TEXT\n     * @see InputMethodHighlight#CONVERTED_TEXT\n     * @exception IllegalArgumentException if a state other than RAW_TEXT or CONVERTED_TEXT is given\n     * @since 1.3\n     */\n    public InputMethodHighlight(boolean selected, int state, int variation,\n                                Map<TextAttribute,?> style)\n    {\n        this.selected = selected;\n        if (!(state == RAW_TEXT || state == CONVERTED_TEXT)) {\n            throw new IllegalArgumentException(\"unknown input method highlight state\");\n        }\n        this.state = state;\n        this.variation = variation;\n        this.style = style;\n    }"}
{"Number":"448","API Relative Path":"java.awt.image.AffineTransformOp.java-createCompatibleDestImage(BufferedImage-ColorModel)","Corresponding Source":"/**\n     * Creates a zeroed destination image with the correct size and number of\n     * bands.  A <CODE>RasterFormatException<\/CODE> may be thrown if the\n     * transformed width or height is equal to 0.\n     * <p>\n     * If <CODE>destCM<\/CODE> is null,\n     * an appropriate <CODE>ColorModel<\/CODE> is used; this\n     * <CODE>ColorModel<\/CODE> may have\n     * an alpha channel even if the source <CODE>ColorModel<\/CODE> is opaque.\n     *\n     * @param src  The <CODE>BufferedImage<\/CODE> to be transformed.\n     * @param destCM  <CODE>ColorModel<\/CODE> of the destination.  If null,\n     * an appropriate <CODE>ColorModel<\/CODE> is used.\n     *\n     * @return The zeroed destination image.\n     */\n    public BufferedImage createCompatibleDestImage (BufferedImage src,\n                                                    ColorModel destCM) {\n        BufferedImage image;\n        Rectangle r = getBounds2D(src).getBounds();\n\n        // If r.x (or r.y) is < 0, then we want to only create an image\n        // that is in the positive range.\n        // If r.x (or r.y) is > 0, then we need to create an image that\n        // includes the translation.\n        int w = r.x + r.width;\n        int h = r.y + r.height;\n        if (w <= 0) {\n            throw new RasterFormatException(\"Transformed width (\"+w+\n                                            \") is less than or equal to 0.\");\n        }\n        if (h <= 0) {\n            throw new RasterFormatException(\"Transformed height (\"+h+\n                                            \") is less than or equal to 0.\");\n        }\n\n        if (destCM == null) {\n            ColorModel cm = src.getColorModel();\n            if (interpolationType != TYPE_NEAREST_NEIGHBOR &&\n                (cm instanceof IndexColorModel ||\n                 cm.getTransparency() == Transparency.OPAQUE))\n            {\n                image = new BufferedImage(w, h,\n                                          BufferedImage.TYPE_INT_ARGB);\n            }\n            else {\n                image = new BufferedImage(cm,\n                          src.getRaster().createCompatibleWritableRaster(w,h),\n                          cm.isAlphaPremultiplied(), null);\n            }\n        }\n        else {\n            image = new BufferedImage(destCM,\n                                    destCM.createCompatibleWritableRaster(w,h),\n                                    destCM.isAlphaPremultiplied(), null);\n        }\n\n        return image;\n    }"}
{"Number":"449","API Relative Path":"java.awt.image.AffineTransformOp.java-filter(BufferedImage-BufferedImage)","Corresponding Source":"/**\n     * Transforms the source <CODE>BufferedImage<\/CODE> and stores the results\n     * in the destination <CODE>BufferedImage<\/CODE>.\n     * If the color models for the two images do not match, a color\n     * conversion into the destination color model is performed.\n     * If the destination image is null,\n     * a <CODE>BufferedImage<\/CODE> is created with the source\n     * <CODE>ColorModel<\/CODE>.\n     * <p>\n     * The coordinates of the rectangle returned by\n     * <code>getBounds2D(BufferedImage)<\/code>\n     * are not necessarily the same as the coordinates of the\n     * <code>BufferedImage<\/code> returned by this method.  If the\n     * upper-left corner coordinates of the rectangle are\n     * negative then this part of the rectangle is not drawn.  If the\n     * upper-left corner coordinates of the  rectangle are positive\n     * then the filtered image is drawn at that position in the\n     * destination <code>BufferedImage<\/code>.\n     * <p>\n     * An <CODE>IllegalArgumentException<\/CODE> is thrown if the source is\n     * the same as the destination.\n     *\n     * @param src The <CODE>BufferedImage<\/CODE> to transform.\n     * @param dst The <CODE>BufferedImage<\/CODE> in which to store the results\n     * of the transformation.\n     *\n     * @return The filtered <CODE>BufferedImage<\/CODE>.\n     * @throws IllegalArgumentException if <code>src<\/code> and\n     *         <code>dst<\/code> are the same\n     * @throws ImagingOpException if the image cannot be transformed\n     *         because of a data-processing error that might be\n     *         caused by an invalid image format, tile format, or\n     *         image-processing operation, or any other unsupported\n     *         operation.\n     */\n    public final BufferedImage filter(BufferedImage src, BufferedImage dst) {\n\n        if (src == null) {\n            throw new NullPointerException(\"src image is null\");\n        }\n        if (src == dst) {\n            throw new IllegalArgumentException(\"src image cannot be the \"+\n                                               \"same as the dst image\");\n        }\n\n        boolean needToConvert = false;\n        ColorModel srcCM = src.getColorModel();\n        ColorModel dstCM;\n        BufferedImage origDst = dst;\n\n        if (dst == null) {\n            dst = createCompatibleDestImage(src, null);\n            dstCM = srcCM;\n            origDst = dst;\n        }\n        else {\n            dstCM = dst.getColorModel();\n            if (srcCM.getColorSpace().getType() !=\n                dstCM.getColorSpace().getType())\n            {\n                int type = xform.getType();\n                boolean needTrans = ((type&\n                                      (xform.TYPE_MASK_ROTATION|\n                                       xform.TYPE_GENERAL_TRANSFORM))\n                                     != 0);\n                if (! needTrans && type != xform.TYPE_TRANSLATION && type != xform.TYPE_IDENTITY)\n                {\n                    double[] mtx = new double[4];\n                    xform.getMatrix(mtx);\n                    // Check out the matrix.  A non-integral scale will force ARGB\n                    // since the edge conditions can't be guaranteed.\n                    needTrans = (mtx[0] != (int)mtx[0] || mtx[3] != (int)mtx[3]);\n                }\n\n                if (needTrans &&\n                    srcCM.getTransparency() == Transparency.OPAQUE)\n                {\n                    // Need to convert first\n                    ColorConvertOp ccop = new ColorConvertOp(hints);\n                    BufferedImage tmpSrc = null;\n                    int sw = src.getWidth();\n                    int sh = src.getHeight();\n                    if (dstCM.getTransparency() == Transparency.OPAQUE) {\n                        tmpSrc = new BufferedImage(sw, sh,\n                                                  BufferedImage.TYPE_INT_ARGB);\n                    }\n                    else {\n                        WritableRaster r =\n                            dstCM.createCompatibleWritableRaster(sw, sh);\n                        tmpSrc = new BufferedImage(dstCM, r,\n                                                  dstCM.isAlphaPremultiplied(),\n                                                  null);\n                    }\n                    src = ccop.filter(src, tmpSrc);\n                }\n                else {\n                    needToConvert = true;\n                    dst = createCompatibleDestImage(src, null);\n                }\n            }\n\n        }\n\n        if (interpolationType != TYPE_NEAREST_NEIGHBOR &&\n            dst.getColorModel() instanceof IndexColorModel) {\n            dst = new BufferedImage(dst.getWidth(), dst.getHeight(),\n                                    BufferedImage.TYPE_INT_ARGB);\n        }\n        if (ImagingLib.filter(this, src, dst) == null) {\n            throw new ImagingOpException (\"Unable to transform src image\");\n        }\n\n        if (needToConvert) {\n            ColorConvertOp ccop = new ColorConvertOp(hints);\n            ccop.filter(dst, origDst);\n        }\n        else if (origDst != dst) {\n            java.awt.Graphics2D g = origDst.createGraphics();\n            try {\n                g.setComposite(AlphaComposite.Src);\n                g.drawImage(dst, 0, 0, null);\n            } finally {\n                g.dispose();\n            }\n        }\n\n        return origDst;\n    }"}
{"Number":"450","API Relative Path":"java.awt.image.AffineTransformOp.java-filter(BufferedImage-BufferedImage)","Corresponding Source":"/**\n     * Transforms the source <CODE>BufferedImage<\/CODE> and stores the results\n     * in the destination <CODE>BufferedImage<\/CODE>.\n     * If the color models for the two images do not match, a color\n     * conversion into the destination color model is performed.\n     * If the destination image is null,\n     * a <CODE>BufferedImage<\/CODE> is created with the source\n     * <CODE>ColorModel<\/CODE>.\n     * <p>\n     * The coordinates of the rectangle returned by\n     * <code>getBounds2D(BufferedImage)<\/code>\n     * are not necessarily the same as the coordinates of the\n     * <code>BufferedImage<\/code> returned by this method.  If the\n     * upper-left corner coordinates of the rectangle are\n     * negative then this part of the rectangle is not drawn.  If the\n     * upper-left corner coordinates of the  rectangle are positive\n     * then the filtered image is drawn at that position in the\n     * destination <code>BufferedImage<\/code>.\n     * <p>\n     * An <CODE>IllegalArgumentException<\/CODE> is thrown if the source is\n     * the same as the destination.\n     *\n     * @param src The <CODE>BufferedImage<\/CODE> to transform.\n     * @param dst The <CODE>BufferedImage<\/CODE> in which to store the results\n     * of the transformation.\n     *\n     * @return The filtered <CODE>BufferedImage<\/CODE>.\n     * @throws IllegalArgumentException if <code>src<\/code> and\n     *         <code>dst<\/code> are the same\n     * @throws ImagingOpException if the image cannot be transformed\n     *         because of a data-processing error that might be\n     *         caused by an invalid image format, tile format, or\n     *         image-processing operation, or any other unsupported\n     *         operation.\n     */\n    public final BufferedImage filter(BufferedImage src, BufferedImage dst) {\n\n        if (src == null) {\n            throw new NullPointerException(\"src image is null\");\n        }\n        if (src == dst) {\n            throw new IllegalArgumentException(\"src image cannot be the \"+\n                                               \"same as the dst image\");\n        }\n\n        boolean needToConvert = false;\n        ColorModel srcCM = src.getColorModel();\n        ColorModel dstCM;\n        BufferedImage origDst = dst;\n\n        if (dst == null) {\n            dst = createCompatibleDestImage(src, null);\n            dstCM = srcCM;\n            origDst = dst;\n        }\n        else {\n            dstCM = dst.getColorModel();\n            if (srcCM.getColorSpace().getType() !=\n                dstCM.getColorSpace().getType())\n            {\n                int type = xform.getType();\n                boolean needTrans = ((type&\n                                      (xform.TYPE_MASK_ROTATION|\n                                       xform.TYPE_GENERAL_TRANSFORM))\n                                     != 0);\n                if (! needTrans && type != xform.TYPE_TRANSLATION && type != xform.TYPE_IDENTITY)\n                {\n                    double[] mtx = new double[4];\n                    xform.getMatrix(mtx);\n                    // Check out the matrix.  A non-integral scale will force ARGB\n                    // since the edge conditions can't be guaranteed.\n                    needTrans = (mtx[0] != (int)mtx[0] || mtx[3] != (int)mtx[3]);\n                }\n\n                if (needTrans &&\n                    srcCM.getTransparency() == Transparency.OPAQUE)\n                {\n                    // Need to convert first\n                    ColorConvertOp ccop = new ColorConvertOp(hints);\n                    BufferedImage tmpSrc = null;\n                    int sw = src.getWidth();\n                    int sh = src.getHeight();\n                    if (dstCM.getTransparency() == Transparency.OPAQUE) {\n                        tmpSrc = new BufferedImage(sw, sh,\n                                                  BufferedImage.TYPE_INT_ARGB);\n                    }\n                    else {\n                        WritableRaster r =\n                            dstCM.createCompatibleWritableRaster(sw, sh);\n                        tmpSrc = new BufferedImage(dstCM, r,\n                                                  dstCM.isAlphaPremultiplied(),\n                                                  null);\n                    }\n                    src = ccop.filter(src, tmpSrc);\n                }\n                else {\n                    needToConvert = true;\n                    dst = createCompatibleDestImage(src, null);\n                }\n            }\n\n        }\n\n        if (interpolationType != TYPE_NEAREST_NEIGHBOR &&\n            dst.getColorModel() instanceof IndexColorModel) {\n            dst = new BufferedImage(dst.getWidth(), dst.getHeight(),\n                                    BufferedImage.TYPE_INT_ARGB);\n        }\n        if (ImagingLib.filter(this, src, dst) == null) {\n            throw new ImagingOpException (\"Unable to transform src image\");\n        }\n\n        if (needToConvert) {\n            ColorConvertOp ccop = new ColorConvertOp(hints);\n            ccop.filter(dst, origDst);\n        }\n        else if (origDst != dst) {\n            java.awt.Graphics2D g = origDst.createGraphics();\n            try {\n                g.setComposite(AlphaComposite.Src);\n                g.drawImage(dst, 0, 0, null);\n            } finally {\n                g.dispose();\n            }\n        }\n\n        return origDst;\n    }"}
{"Number":"451","API Relative Path":"java.awt.image.AffineTransformOp.java-filter(Raster-WritableRaster)","Corresponding Source":"/**\n     * Transforms the source <CODE>Raster<\/CODE> and stores the results in\n     * the destination <CODE>Raster<\/CODE>.  This operation performs the\n     * transform band by band.\n     * <p>\n     * If the destination <CODE>Raster<\/CODE> is null, a new\n     * <CODE>Raster<\/CODE> is created.\n     * An <CODE>IllegalArgumentException<\/CODE> may be thrown if the source is\n     * the same as the destination or if the number of bands in\n     * the source is not equal to the number of bands in the\n     * destination.\n     * <p>\n     * The coordinates of the rectangle returned by\n     * <code>getBounds2D(Raster)<\/code>\n     * are not necessarily the same as the coordinates of the\n     * <code>WritableRaster<\/code> returned by this method.  If the\n     * upper-left corner coordinates of rectangle are negative then\n     * this part of the rectangle is not drawn.  If the coordinates\n     * of the rectangle are positive then the filtered image is drawn at\n     * that position in the destination <code>Raster<\/code>.\n     * <p>\n     * @param src The <CODE>Raster<\/CODE> to transform.\n     * @param dst The <CODE>Raster<\/CODE> in which to store the results of the\n     * transformation.\n     *\n     * @return The transformed <CODE>Raster<\/CODE>.\n     *\n     * @throws ImagingOpException if the raster cannot be transformed\n     *         because of a data-processing error that might be\n     *         caused by an invalid image format, tile format, or\n     *         image-processing operation, or any other unsupported\n     *         operation.\n     */\n    public final WritableRaster filter(Raster src, WritableRaster dst) {\n        if (src == null) {\n            throw new NullPointerException(\"src image is null\");\n        }\n        if (dst == null) {\n            dst = createCompatibleDestRaster(src);\n        }\n        if (src == dst) {\n            throw new IllegalArgumentException(\"src image cannot be the \"+\n                                               \"same as the dst image\");\n        }\n        if (src.getNumBands() != dst.getNumBands()) {\n            throw new IllegalArgumentException(\"Number of src bands (\"+\n                                               src.getNumBands()+\n                                               \") does not match number of \"+\n                                               \" dst bands (\"+\n                                               dst.getNumBands()+\")\");\n        }\n\n        if (ImagingLib.filter(this, src, dst) == null) {\n            throw new ImagingOpException (\"Unable to transform src image\");\n        }\n        return dst;\n    }"}
{"Number":"452","API Relative Path":"java.awt.image.AffineTransformOp.java-filter(Raster-WritableRaster)","Corresponding Source":"/**\n     * Transforms the source <CODE>Raster<\/CODE> and stores the results in\n     * the destination <CODE>Raster<\/CODE>.  This operation performs the\n     * transform band by band.\n     * <p>\n     * If the destination <CODE>Raster<\/CODE> is null, a new\n     * <CODE>Raster<\/CODE> is created.\n     * An <CODE>IllegalArgumentException<\/CODE> may be thrown if the source is\n     * the same as the destination or if the number of bands in\n     * the source is not equal to the number of bands in the\n     * destination.\n     * <p>\n     * The coordinates of the rectangle returned by\n     * <code>getBounds2D(Raster)<\/code>\n     * are not necessarily the same as the coordinates of the\n     * <code>WritableRaster<\/code> returned by this method.  If the\n     * upper-left corner coordinates of rectangle are negative then\n     * this part of the rectangle is not drawn.  If the coordinates\n     * of the rectangle are positive then the filtered image is drawn at\n     * that position in the destination <code>Raster<\/code>.\n     * <p>\n     * @param src The <CODE>Raster<\/CODE> to transform.\n     * @param dst The <CODE>Raster<\/CODE> in which to store the results of the\n     * transformation.\n     *\n     * @return The transformed <CODE>Raster<\/CODE>.\n     *\n     * @throws ImagingOpException if the raster cannot be transformed\n     *         because of a data-processing error that might be\n     *         caused by an invalid image format, tile format, or\n     *         image-processing operation, or any other unsupported\n     *         operation.\n     */\n    public final WritableRaster filter(Raster src, WritableRaster dst) {\n        if (src == null) {\n            throw new NullPointerException(\"src image is null\");\n        }\n        if (dst == null) {\n            dst = createCompatibleDestRaster(src);\n        }\n        if (src == dst) {\n            throw new IllegalArgumentException(\"src image cannot be the \"+\n                                               \"same as the dst image\");\n        }\n        if (src.getNumBands() != dst.getNumBands()) {\n            throw new IllegalArgumentException(\"Number of src bands (\"+\n                                               src.getNumBands()+\n                                               \") does not match number of \"+\n                                               \" dst bands (\"+\n                                               dst.getNumBands()+\")\");\n        }\n\n        if (ImagingLib.filter(this, src, dst) == null) {\n            throw new ImagingOpException (\"Unable to transform src image\");\n        }\n        return dst;\n    }"}
{"Number":"453","API Relative Path":"java.awt.image.BandedSampleModel.java-createSubsetSampleModel(int)","Corresponding Source":"/**\n     * Creates a new BandedSampleModel with a subset of the bands of this\n     * BandedSampleModel.  The new BandedSampleModel can be\n     * used with any DataBuffer that the existing BandedSampleModel\n     * can be used with.  The new BandedSampleModel/DataBuffer\n     * combination will represent an image with a subset of the bands\n     * of the original BandedSampleModel/DataBuffer combination.\n     * @throws RasterFormatException if the number of bands is greater than\n     *                               the number of banks in this sample model.\n     * @throws IllegalArgumentException if <code>dataType<\/code> is not\n     *         one of the supported data types\n     */\n    public SampleModel createSubsetSampleModel(int bands[]) {\n        if (bands.length > bankIndices.length)\n            throw new RasterFormatException(\"There are only \" +\n                                            bankIndices.length +\n                                            \" bands\");\n        int newBankIndices[] = new int[bands.length];\n        int newBandOffsets[] = new int[bands.length];\n\n        for (int i=0; i<bands.length; i++) {\n            newBankIndices[i] = bankIndices[bands[i]];\n            newBandOffsets[i] = bandOffsets[bands[i]];\n        }\n\n        return new BandedSampleModel(this.dataType, width, height,\n                                     this.scanlineStride,\n                                     newBankIndices, newBandOffsets);\n    }"}
{"Number":"454","API Relative Path":"java.awt.image.BandedSampleModel.java-getDataElements(int-int-Object-DataBuffer)","Corresponding Source":"/**\n     * Returns data for a single pixel in a primitive array of type\n     * TransferType.  For a BandedSampleModel, this will be the same\n     * as the data type, and samples will be returned one per array\n     * element.  Generally, obj\n     * should be passed in as null, so that the Object will be created\n     * automatically and will be of the right primitive data type.\n     * <p>\n     * The following code illustrates transferring data for one pixel from\n     * DataBuffer <code>db1<\/code>, whose storage layout is described by\n     * BandedSampleModel <code>bsm1<\/code>, to DataBuffer <code>db2<\/code>,\n     * whose storage layout is described by\n     * BandedSampleModel <code>bsm2<\/code>.\n     * The transfer will generally be more efficient than using\n     * getPixel/setPixel.\n     * <pre>\n     *       BandedSampleModel bsm1, bsm2;\n     *       DataBufferInt db1, db2;\n     *       bsm2.setDataElements(x, y, bsm1.getDataElements(x, y, null, db1),\n     *                            db2);\n     * <\/pre>\n     * Using getDataElements/setDataElements to transfer between two\n     * DataBuffer/SampleModel pairs is legitimate if the SampleModels have\n     * the same number of bands, corresponding bands have the same number of\n     * bits per sample, and the TransferTypes are the same.\n     * <p>\n     * If obj is non-null, it should be a primitive array of type TransferType.\n     * Otherwise, a ClassCastException is thrown.  An\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds, or if obj is non-null and is not large enough to hold\n     * the pixel data.\n     * @param x         The X coordinate of the pixel location\n     * @param y         The Y coordinate of the pixel location\n     * @param obj       If non-null, a primitive array in which to return\n     *                  the pixel data.\n     * @param data      The DataBuffer containing the image data.\n     * @return the data for the specified pixel.\n     * @see #setDataElements(int, int, Object, DataBuffer)\n     */\n    public Object getDataElements(int x, int y, Object obj, DataBuffer data) {\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int type = getTransferType();\n        int numDataElems = getNumDataElements();\n        int pixelOffset = y*scanlineStride + x;\n\n        switch(type) {\n\n        case DataBuffer.TYPE_BYTE:\n\n            byte[] bdata;\n\n            if (obj == null) {\n                bdata = new byte[numDataElems];\n            } else {\n                bdata = (byte[])obj;\n            }\n\n            for (int i=0; i<numDataElems; i++) {\n                bdata[i] = (byte)data.getElem(bankIndices[i],\n                                              pixelOffset + bandOffsets[i]);\n            }\n\n            obj = (Object)bdata;\n            break;\n\n        case DataBuffer.TYPE_USHORT:\n        case DataBuffer.TYPE_SHORT:\n\n            short[] sdata;\n\n            if (obj == null) {\n                sdata = new short[numDataElems];\n            } else {\n                sdata = (short[])obj;\n            }\n\n            for (int i=0; i<numDataElems; i++) {\n                sdata[i] = (short)data.getElem(bankIndices[i],\n                                               pixelOffset + bandOffsets[i]);\n            }\n\n            obj = (Object)sdata;\n            break;\n\n        case DataBuffer.TYPE_INT:\n\n            int[] idata;\n\n            if (obj == null) {\n                idata = new int[numDataElems];\n            } else {\n                idata = (int[])obj;\n            }\n\n            for (int i=0; i<numDataElems; i++) {\n                idata[i] = data.getElem(bankIndices[i],\n                                        pixelOffset + bandOffsets[i]);\n            }\n\n            obj = (Object)idata;\n            break;\n\n        case DataBuffer.TYPE_FLOAT:\n\n            float[] fdata;\n\n            if (obj == null) {\n                fdata = new float[numDataElems];\n            } else {\n                fdata = (float[])obj;\n            }\n\n            for (int i=0; i<numDataElems; i++) {\n                fdata[i] = data.getElemFloat(bankIndices[i],\n                                             pixelOffset + bandOffsets[i]);\n            }\n\n            obj = (Object)fdata;\n            break;\n\n        case DataBuffer.TYPE_DOUBLE:\n\n            double[] ddata;\n\n            if (obj == null) {\n                ddata = new double[numDataElems];\n            } else {\n                ddata = (double[])obj;\n            }\n\n            for (int i=0; i<numDataElems; i++) {\n                ddata[i] = data.getElemDouble(bankIndices[i],\n                                              pixelOffset + bandOffsets[i]);\n            }\n\n            obj = (Object)ddata;\n            break;\n        }\n\n        return obj;\n    }"}
{"Number":"455","API Relative Path":"java.awt.image.BandedSampleModel.java-getPixel(int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Returns all samples for the specified pixel in an int array.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the pixel location\n     * @param y         The Y coordinate of the pixel location\n     * @param iArray    If non-null, returns the samples in this array\n     * @param data      The DataBuffer containing the image data\n     * @return the samples for the specified pixel.\n     * @see #setPixel(int, int, int[], DataBuffer)\n     */\n    public int[] getPixel(int x, int y, int iArray[], DataBuffer data) {\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n\n        int[] pixels;\n\n        if (iArray != null) {\n           pixels = iArray;\n        } else {\n           pixels = new int [numBands];\n        }\n\n        int pixelOffset = y*scanlineStride + x;\n        for (int i=0; i<numBands; i++) {\n            pixels[i] = data.getElem(bankIndices[i],\n                                     pixelOffset + bandOffsets[i]);\n        }\n        return pixels;\n    }"}
{"Number":"456","API Relative Path":"java.awt.image.BandedSampleModel.java-getPixels(int-int-int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Returns all samples for the specified rectangle of pixels in\n     * an int array, one sample per data array element.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the upper left pixel location\n     * @param y         The Y coordinate of the upper left pixel location\n     * @param w         The width of the pixel rectangle\n     * @param h         The height of the pixel rectangle\n     * @param iArray    If non-null, returns the samples in this array\n     * @param data      The DataBuffer containing the image data\n     * @return the samples for the pixels within the specified region.\n     * @see #setPixels(int, int, int, int, int[], DataBuffer)\n     */\n    public int[] getPixels(int x, int y, int w, int h,\n                           int iArray[], DataBuffer data) {\n        int x1 = x + w;\n        int y1 = y + h;\n\n        if (x < 0 || x >= width || w > width || x1 < 0 || x1 > width ||\n            y < 0 || y >= height || h > height || y1 < 0 || y1 >  height)\n        {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int[] pixels;\n\n        if (iArray != null) {\n           pixels = iArray;\n        } else {\n           pixels = new int[w*h*numBands];\n        }\n\n        for (int k = 0; k < numBands; k++) {\n            int lineOffset = y*scanlineStride + x + bandOffsets[k];\n            int srcOffset = k;\n            int bank = bankIndices[k];\n\n            for (int i = 0; i < h; i++) {\n                int pixelOffset = lineOffset;\n                for (int j = 0; j < w; j++) {\n                    pixels[srcOffset] = data.getElem(bank, pixelOffset++);\n                    srcOffset += numBands;\n                }\n                lineOffset += scanlineStride;\n            }\n        }\n        return pixels;\n    }"}
{"Number":"457","API Relative Path":"java.awt.image.BandedSampleModel.java-getSample(int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Returns as int the sample in a specified band for the pixel\n     * located at (x,y).\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the pixel location\n     * @param y         The Y coordinate of the pixel location\n     * @param b         The band to return\n     * @param data      The DataBuffer containing the image data\n     * @return the sample in the specified band for the specified pixel.\n     * @see #setSample(int, int, int, int, DataBuffer)\n     */\n    public int getSample(int x, int y, int b, DataBuffer data) {\n        // Bounds check for 'b' will be performed automatically\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int sample =\n            data.getElem(bankIndices[b],\n                         y*scanlineStride + x + bandOffsets[b]);\n        return sample;\n    }"}
{"Number":"458","API Relative Path":"java.awt.image.BandedSampleModel.java-getSampleDouble(int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Returns the sample in a specified band\n     * for a pixel located at (x,y) as a double.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the pixel location\n     * @param y         The Y coordinate of the pixel location\n     * @param b         The band to return\n     * @param data      The DataBuffer containing the image data\n     * @return a double value that represents the sample in the specified\n     * band for the specified pixel.\n     */\n    public double getSampleDouble(int x, int y, int b, DataBuffer data) {\n        // Bounds check for 'b' will be performed automatically\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n\n        double sample = data.getElemDouble(bankIndices[b],\n                                       y*scanlineStride + x + bandOffsets[b]);\n        return sample;\n    }"}
{"Number":"459","API Relative Path":"java.awt.image.BandedSampleModel.java-getSampleFloat(int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Returns the sample in a specified band\n     * for the pixel located at (x,y) as a float.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the pixel location\n     * @param y         The Y coordinate of the pixel location\n     * @param b         The band to return\n     * @param data      The DataBuffer containing the image data\n     * @return a float value that represents the sample in the specified\n     * band for the specified pixel.\n     */\n    public float getSampleFloat(int x, int y, int b, DataBuffer data) {\n        // Bounds check for 'b' will be performed automatically\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n\n        float sample = data.getElemFloat(bankIndices[b],\n                                    y*scanlineStride + x + bandOffsets[b]);\n        return sample;\n    }"}
{"Number":"460","API Relative Path":"java.awt.image.BandedSampleModel.java-getSamples(int-int-int-int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Returns the samples in a specified band for the specified rectangle\n     * of pixels in an int array, one sample per data array element.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the upper left pixel location\n     * @param y         The Y coordinate of the upper left pixel location\n     * @param w         The width of the pixel rectangle\n     * @param h         The height of the pixel rectangle\n     * @param b         The band to return\n     * @param iArray    If non-null, returns the samples in this array\n     * @param data      The DataBuffer containing the image data\n     * @return the samples in the specified band for the pixels within\n     * the specified region.\n     * @see #setSamples(int, int, int, int, int, int[], DataBuffer)\n     */\n    public int[] getSamples(int x, int y, int w, int h, int b,\n                            int iArray[], DataBuffer data) {\n        // Bounds check for 'b' will be performed automatically\n        if ((x < 0) || (y < 0) || (x + w > width) || (y + h > height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int samples[];\n        if (iArray != null) {\n           samples = iArray;\n        } else {\n           samples = new int [w*h];\n        }\n\n        int lineOffset = y*scanlineStride + x + bandOffsets[b];\n        int srcOffset = 0;\n        int bank = bankIndices[b];\n\n        for (int i = 0; i < h; i++) {\n           int sampleOffset = lineOffset;\n           for (int j = 0; j < w; j++) {\n               samples[srcOffset++] = data.getElem(bank, sampleOffset++);\n           }\n           lineOffset += scanlineStride;\n        }\n        return samples;\n    }"}
{"Number":"461","API Relative Path":"java.awt.image.BandedSampleModel.java-setDataElements(int-int-Object-DataBuffer)","Corresponding Source":"/**\n     * Sets the data for a single pixel in the specified DataBuffer from a\n     * primitive array of type TransferType.  For a BandedSampleModel,\n     * this will be the same as the data type, and samples are transferred\n     * one per array element.\n     * <p>\n     * The following code illustrates transferring data for one pixel from\n     * DataBuffer <code>db1<\/code>, whose storage layout is described by\n     * BandedSampleModel <code>bsm1<\/code>, to DataBuffer <code>db2<\/code>,\n     * whose storage layout is described by\n     * BandedSampleModel <code>bsm2<\/code>.\n     * The transfer will generally be more efficient than using\n     * getPixel/setPixel.\n     * <pre>\n     *       BandedSampleModel bsm1, bsm2;\n     *       DataBufferInt db1, db2;\n     *       bsm2.setDataElements(x, y, bsm1.getDataElements(x, y, null, db1),\n     *                            db2);\n     * <\/pre>\n     * Using getDataElements/setDataElements to transfer between two\n     * DataBuffer/SampleModel pairs is legitimate if the SampleModels have\n     * the same number of bands, corresponding bands have the same number of\n     * bits per sample, and the TransferTypes are the same.\n     * <p>\n     * obj must be a primitive array of type TransferType.  Otherwise,\n     * a ClassCastException is thrown.  An\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds, or if obj is not large enough to hold the pixel data.\n     * @param x         The X coordinate of the pixel location\n     * @param y         The Y coordinate of the pixel location\n     * @param obj       If non-null, returns the primitive array in this\n     *                  object\n     * @param data      The DataBuffer containing the image data\n     * @see #getDataElements(int, int, Object, DataBuffer)\n     */\n    public void setDataElements(int x, int y, Object obj, DataBuffer data) {\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int type = getTransferType();\n        int numDataElems = getNumDataElements();\n        int pixelOffset = y*scanlineStride + x;\n\n        switch(type) {\n\n        case DataBuffer.TYPE_BYTE:\n\n            byte[] barray = (byte[])obj;\n\n            for (int i=0; i<numDataElems; i++) {\n                data.setElem(bankIndices[i], pixelOffset + bandOffsets[i],\n                             barray[i] & 0xff);\n            }\n            break;\n\n        case DataBuffer.TYPE_USHORT:\n        case DataBuffer.TYPE_SHORT:\n\n            short[] sarray = (short[])obj;\n\n            for (int i=0; i<numDataElems; i++) {\n                data.setElem(bankIndices[i], pixelOffset + bandOffsets[i],\n                             sarray[i] & 0xffff);\n            }\n            break;\n\n        case DataBuffer.TYPE_INT:\n\n            int[] iarray = (int[])obj;\n\n            for (int i=0; i<numDataElems; i++) {\n                data.setElem(bankIndices[i], pixelOffset + bandOffsets[i],\n                             iarray[i]);\n            }\n            break;\n\n        case DataBuffer.TYPE_FLOAT:\n\n            float[] farray = (float[])obj;\n\n            for (int i=0; i<numDataElems; i++) {\n                data.setElemFloat(bankIndices[i], pixelOffset + bandOffsets[i],\n                                  farray[i]);\n            }\n            break;\n\n        case DataBuffer.TYPE_DOUBLE:\n\n            double[] darray = (double[])obj;\n\n            for (int i=0; i<numDataElems; i++) {\n                data.setElemDouble(bankIndices[i], pixelOffset + bandOffsets[i],\n                                   darray[i]);\n            }\n            break;\n\n        }\n    }"}
{"Number":"462","API Relative Path":"java.awt.image.BandedSampleModel.java-setPixel(int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Sets a pixel in the DataBuffer using an int array of samples for input.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the pixel location\n     * @param y         The Y coordinate of the pixel location\n     * @param iArray    The input samples in an int array\n     * @param data      The DataBuffer containing the image data\n     * @see #getPixel(int, int, int[], DataBuffer)\n     */\n    public void setPixel(int x, int y, int iArray[], DataBuffer data) {\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n       int pixelOffset = y*scanlineStride + x;\n       for (int i=0; i<numBands; i++) {\n           data.setElem(bankIndices[i], pixelOffset + bandOffsets[i],\n                        iArray[i]);\n       }\n    }"}
{"Number":"463","API Relative Path":"java.awt.image.BandedSampleModel.java-setPixels(int-int-int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Sets all samples for a rectangle of pixels from an int array containing\n     * one sample per array element.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the upper left pixel location\n     * @param y         The Y coordinate of the upper left pixel location\n     * @param w         The width of the pixel rectangle\n     * @param h         The height of the pixel rectangle\n     * @param iArray    The input samples in an int array\n     * @param data      The DataBuffer containing the image data\n     * @see #getPixels(int, int, int, int, int[], DataBuffer)\n     */\n    public void setPixels(int x, int y, int w, int h,\n                          int iArray[], DataBuffer data) {\n        int x1 = x + w;\n        int y1 = y + h;\n\n        if (x < 0 || x >= width || w > width || x1 < 0 || x1 > width ||\n            y < 0 || y >= height || h > height || y1 < 0 || y1 >  height)\n        {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n\n        for (int k = 0; k < numBands; k++) {\n            int lineOffset = y*scanlineStride + x + bandOffsets[k];\n            int srcOffset = k;\n            int bank = bankIndices[k];\n\n            for (int i = 0; i < h; i++) {\n                int pixelOffset = lineOffset;\n                for (int j = 0; j < w; j++) {\n                    data.setElem(bank, pixelOffset++, iArray[srcOffset]);\n                    srcOffset += numBands;\n                }\n                lineOffset += scanlineStride;\n           }\n        }\n    }"}
{"Number":"464","API Relative Path":"java.awt.image.BandedSampleModel.java-setSample(int-int-int-double-DataBuffer)","Corresponding Source":"/**\n     * Sets a sample in the specified band for the pixel located at (x,y)\n     * in the DataBuffer using a double for input.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the pixel location\n     * @param y         The Y coordinate of the pixel location\n     * @param b         The band to set\n     * @param s         The input sample as a double\n     * @param data      The DataBuffer containing the image data\n     * @see #getSample(int, int, int, DataBuffer)\n     */\n    public void setSample(int x, int y, int b,\n                          double s,\n                          DataBuffer data) {\n        // Bounds check for 'b' will be performed automatically\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        data.setElemDouble(bankIndices[b],\n                          y*scanlineStride + x + bandOffsets[b], s);\n    }"}
{"Number":"465","API Relative Path":"java.awt.image.BandedSampleModel.java-setSample(int-int-int-float-DataBuffer)","Corresponding Source":"/**\n     * Sets a sample in the specified band for the pixel located at (x,y)\n     * in the DataBuffer using a float for input.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the pixel location\n     * @param y         The Y coordinate of the pixel location\n     * @param b         The band to set\n     * @param s         The input sample as a float\n     * @param data      The DataBuffer containing the image data\n     * @see #getSample(int, int, int, DataBuffer)\n     */\n    public void setSample(int x, int y, int b,\n                          float s ,\n                          DataBuffer data) {\n        // Bounds check for 'b' will be performed automatically\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        data.setElemFloat(bankIndices[b],\n                          y*scanlineStride + x + bandOffsets[b], s);\n    }"}
{"Number":"466","API Relative Path":"java.awt.image.BandedSampleModel.java-setSample(int-int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Sets a sample in the specified band for the pixel located at (x,y)\n     * in the DataBuffer using an int for input.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the pixel location\n     * @param y         The Y coordinate of the pixel location\n     * @param b         The band to set\n     * @param s         The input sample as an int\n     * @param data      The DataBuffer containing the image data\n     * @see #getSample(int, int, int, DataBuffer)\n     */\n    public void setSample(int x, int y, int b, int s,\n                          DataBuffer data) {\n        // Bounds check for 'b' will be performed automatically\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        data.setElem(bankIndices[b],\n                     y*scanlineStride + x + bandOffsets[b], s);\n    }"}
{"Number":"467","API Relative Path":"java.awt.image.BandedSampleModel.java-setSamples(int-int-int-int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Sets the samples in the specified band for the specified rectangle\n     * of pixels from an int array containing one sample per data array element.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the upper left pixel location\n     * @param y         The Y coordinate of the upper left pixel location\n     * @param w         The width of the pixel rectangle\n     * @param h         The height of the pixel rectangle\n     * @param b         The band to set\n     * @param iArray    The input sample array\n     * @param data      The DataBuffer containing the image data\n     * @see #getSamples(int, int, int, int, int, int[], DataBuffer)\n     */\n    public void setSamples(int x, int y, int w, int h, int b,\n                           int iArray[], DataBuffer data) {\n        // Bounds check for 'b' will be performed automatically\n        if ((x < 0) || (y < 0) || (x + w > width) || (y + h > height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int lineOffset = y*scanlineStride + x + bandOffsets[b];\n        int srcOffset = 0;\n        int bank = bankIndices[b];\n\n        for (int i = 0; i < h; i++) {\n           int sampleOffset = lineOffset;\n           for (int j = 0; j < w; j++) {\n              data.setElem(bank, sampleOffset++, iArray[srcOffset++]);\n           }\n           lineOffset += scanlineStride;\n        }\n    }"}
{"Number":"468","API Relative Path":"java.awt.image.BufferedImage.java-BufferedImage(ColorModel-WritableRaster-boolean-Hashtable)","Corresponding Source":"/**\n     * Constructs a new <code>BufferedImage<\/code> with a specified\n     * <code>ColorModel<\/code> and <code>Raster<\/code>.  If the number and\n     * types of bands in the <code>SampleModel<\/code> of the\n     * <code>Raster<\/code> do not match the number and types required by\n     * the <code>ColorModel<\/code> to represent its color and alpha\n     * components, a {@link RasterFormatException} is thrown.  This\n     * method can multiply or divide the color <code>Raster<\/code> data by\n     * alpha to match the <code>alphaPremultiplied<\/code> state\n     * in the <code>ColorModel<\/code>.  Properties for this\n     * <code>BufferedImage<\/code> can be established by passing\n     * in a {@link Hashtable} of <code>String<\/code>/<code>Object<\/code>\n     * pairs.\n     * @param cm <code>ColorModel<\/code> for the new image\n     * @param raster     <code>Raster<\/code> for the image data\n     * @param isRasterPremultiplied   if <code>true<\/code>, the data in\n     *                  the raster has been premultiplied with alpha.\n     * @param properties <code>Hashtable<\/code> of\n     *                  <code>String<\/code>/<code>Object<\/code> pairs.\n     * @exception RasterFormatException if the number and\n     * types of bands in the <code>SampleModel<\/code> of the\n     * <code>Raster<\/code> do not match the number and types required by\n     * the <code>ColorModel<\/code> to represent its color and alpha\n     * components.\n     * @exception IllegalArgumentException if\n     *          <code>raster<\/code> is incompatible with <code>cm<\/code>\n     * @see ColorModel\n     * @see Raster\n     * @see WritableRaster\n     */\n\n\n/*\n *\n *  FOR NOW THE CODE WHICH DEFINES THE RASTER TYPE IS DUPLICATED BY DVF\n *  SEE THE METHOD DEFINERASTERTYPE @ RASTEROUTPUTMANAGER\n *\n */\n    public BufferedImage (ColorModel cm,\n                          WritableRaster raster,\n                          boolean isRasterPremultiplied,\n                          Hashtable<?,?> properties) {\n\n        if (!cm.isCompatibleRaster(raster)) {\n            throw new\n                IllegalArgumentException(\"Raster \"+raster+\n                                         \" is incompatible with ColorModel \"+\n                                         cm);\n        }\n\n        if ((raster.minX != 0) || (raster.minY != 0)) {\n            throw new\n                IllegalArgumentException(\"Raster \"+raster+\n                                         \" has minX or minY not equal to zero: \"\n                                         + raster.minX + \" \" + raster.minY);\n        }\n\n        colorModel = cm;\n        this.raster  = raster;\n        this.properties = properties;\n        int numBands = raster.getNumBands();\n        boolean isAlphaPre = cm.isAlphaPremultiplied();\n        final boolean isStandard = isStandard(cm, raster);\n        ColorSpace cs;\n\n        // Force the raster data alpha state to match the premultiplied\n        // state in the color model\n        coerceData(isRasterPremultiplied);\n\n        SampleModel sm = raster.getSampleModel();\n        cs = cm.getColorSpace();\n        int csType = cs.getType();\n        if (csType != ColorSpace.TYPE_RGB) {\n            if (csType == ColorSpace.TYPE_GRAY &&\n                isStandard &&\n                cm instanceof ComponentColorModel) {\n                // Check if this might be a child raster (fix for bug 4240596)\n                if (sm instanceof ComponentSampleModel &&\n                    ((ComponentSampleModel)sm).getPixelStride() != numBands) {\n                    imageType = TYPE_CUSTOM;\n                } else if (raster instanceof ByteComponentRaster &&\n                       raster.getNumBands() == 1 &&\n                       cm.getComponentSize(0) == 8 &&\n                       ((ByteComponentRaster)raster).getPixelStride() == 1) {\n                    imageType = TYPE_BYTE_GRAY;\n                } else if (raster instanceof ShortComponentRaster &&\n                       raster.getNumBands() == 1 &&\n                       cm.getComponentSize(0) == 16 &&\n                       ((ShortComponentRaster)raster).getPixelStride() == 1) {\n                    imageType = TYPE_USHORT_GRAY;\n                }\n            } else {\n                imageType = TYPE_CUSTOM;\n            }\n            return;\n        }\n\n        if ((raster instanceof IntegerComponentRaster) &&\n            (numBands == 3 || numBands == 4)) {\n            IntegerComponentRaster iraster =\n                (IntegerComponentRaster) raster;\n            // Check if the raster params and the color model\n            // are correct\n            int pixSize = cm.getPixelSize();\n            if (iraster.getPixelStride() == 1 &&\n                isStandard &&\n                cm instanceof DirectColorModel  &&\n                (pixSize == 32 || pixSize == 24))\n            {\n                // Now check on the DirectColorModel params\n                DirectColorModel dcm = (DirectColorModel) cm;\n                int rmask = dcm.getRedMask();\n                int gmask = dcm.getGreenMask();\n                int bmask = dcm.getBlueMask();\n                if (rmask == DCM_RED_MASK && gmask == DCM_GREEN_MASK &&\n                    bmask == DCM_BLUE_MASK)\n                {\n                    if (dcm.getAlphaMask() == DCM_ALPHA_MASK) {\n                        imageType = (isAlphaPre\n                                     ? TYPE_INT_ARGB_PRE\n                                     : TYPE_INT_ARGB);\n                    }\n                    else {\n                        // No Alpha\n                        if (!dcm.hasAlpha()) {\n                            imageType = TYPE_INT_RGB;\n                        }\n                    }\n                }   // if (dcm.getRedMask() == DCM_RED_MASK &&\n                else if (rmask == DCM_BGR_RED_MASK && gmask == DCM_BGR_GRN_MASK\n                         && bmask == DCM_BGR_BLU_MASK) {\n                    if (!dcm.hasAlpha()) {\n                        imageType = TYPE_INT_BGR;\n                    }\n                }  // if (rmask == DCM_BGR_RED_MASK &&\n            }   // if (iraster.getPixelStride() == 1\n        }   // ((raster instanceof IntegerComponentRaster) &&\n        else if ((cm instanceof IndexColorModel) && (numBands == 1) &&\n                 isStandard &&\n                 (!cm.hasAlpha() || !isAlphaPre))\n        {\n            IndexColorModel icm = (IndexColorModel) cm;\n            int pixSize = icm.getPixelSize();\n\n            if (raster instanceof BytePackedRaster) {\n                imageType = TYPE_BYTE_BINARY;\n            }   // if (raster instanceof BytePackedRaster)\n            else if (raster instanceof ByteComponentRaster) {\n                ByteComponentRaster braster = (ByteComponentRaster) raster;\n                if (braster.getPixelStride() == 1 && pixSize <= 8) {\n                    imageType = TYPE_BYTE_INDEXED;\n                }\n            }\n        }   // else if (cm instanceof IndexColorModel) && (numBands == 1))\n        else if ((raster instanceof ShortComponentRaster)\n                 && (cm instanceof DirectColorModel)\n                 && isStandard\n                 && (numBands == 3)\n                 && !cm.hasAlpha())\n        {\n            DirectColorModel dcm = (DirectColorModel) cm;\n            if (dcm.getRedMask() == DCM_565_RED_MASK) {\n                if (dcm.getGreenMask() == DCM_565_GRN_MASK &&\n                    dcm.getBlueMask()  == DCM_565_BLU_MASK) {\n                    imageType = TYPE_USHORT_565_RGB;\n                }\n            }\n            else if (dcm.getRedMask() == DCM_555_RED_MASK) {\n                if (dcm.getGreenMask() == DCM_555_GRN_MASK &&\n                    dcm.getBlueMask() == DCM_555_BLU_MASK) {\n                    imageType = TYPE_USHORT_555_RGB;\n                }\n            }\n        }   // else if ((cm instanceof IndexColorModel) && (numBands == 1))\n        else if ((raster instanceof ByteComponentRaster)\n                 && (cm instanceof ComponentColorModel)\n                 && isStandard\n                 && (raster.getSampleModel() instanceof PixelInterleavedSampleModel)\n                 && (numBands == 3 || numBands == 4))\n        {\n            ComponentColorModel ccm = (ComponentColorModel) cm;\n            PixelInterleavedSampleModel csm =\n                (PixelInterleavedSampleModel)raster.getSampleModel();\n            ByteComponentRaster braster = (ByteComponentRaster) raster;\n            int[] offs = csm.getBandOffsets();\n            if (ccm.getNumComponents() != numBands) {\n                throw new RasterFormatException(\"Number of components in \"+\n                                                \"ColorModel (\"+\n                                                ccm.getNumComponents()+\n                                                \") does not match # in \"+\n                                                \" Raster (\"+numBands+\")\");\n            }\n            int[] nBits = ccm.getComponentSize();\n            boolean is8bit = true;\n            for (int i=0; i < numBands; i++) {\n                if (nBits[i] != 8) {\n                    is8bit = false;\n                    break;\n                }\n            }\n            if (is8bit &&\n                braster.getPixelStride() == numBands &&\n                offs[0] == numBands-1 &&\n                offs[1] == numBands-2 &&\n                offs[2] == numBands-3)\n            {\n                if (numBands == 3 && !ccm.hasAlpha()) {\n                    imageType = TYPE_3BYTE_BGR;\n                }\n                else if (offs[3] == 0 && ccm.hasAlpha()) {\n                    imageType = (isAlphaPre\n                                 ? TYPE_4BYTE_ABGR_PRE\n                                 : TYPE_4BYTE_ABGR);\n                }\n            }\n        }   // else if ((raster instanceof ByteComponentRaster) &&\n    }"}
{"Number":"469","API Relative Path":"java.awt.image.BufferedImage.java-BufferedImage(ColorModel-WritableRaster-boolean-Hashtable)","Corresponding Source":"/**\n     * Constructs a new <code>BufferedImage<\/code> with a specified\n     * <code>ColorModel<\/code> and <code>Raster<\/code>.  If the number and\n     * types of bands in the <code>SampleModel<\/code> of the\n     * <code>Raster<\/code> do not match the number and types required by\n     * the <code>ColorModel<\/code> to represent its color and alpha\n     * components, a {@link RasterFormatException} is thrown.  This\n     * method can multiply or divide the color <code>Raster<\/code> data by\n     * alpha to match the <code>alphaPremultiplied<\/code> state\n     * in the <code>ColorModel<\/code>.  Properties for this\n     * <code>BufferedImage<\/code> can be established by passing\n     * in a {@link Hashtable} of <code>String<\/code>/<code>Object<\/code>\n     * pairs.\n     * @param cm <code>ColorModel<\/code> for the new image\n     * @param raster     <code>Raster<\/code> for the image data\n     * @param isRasterPremultiplied   if <code>true<\/code>, the data in\n     *                  the raster has been premultiplied with alpha.\n     * @param properties <code>Hashtable<\/code> of\n     *                  <code>String<\/code>/<code>Object<\/code> pairs.\n     * @exception RasterFormatException if the number and\n     * types of bands in the <code>SampleModel<\/code> of the\n     * <code>Raster<\/code> do not match the number and types required by\n     * the <code>ColorModel<\/code> to represent its color and alpha\n     * components.\n     * @exception IllegalArgumentException if\n     *          <code>raster<\/code> is incompatible with <code>cm<\/code>\n     * @see ColorModel\n     * @see Raster\n     * @see WritableRaster\n     */\n\n\n/*\n *\n *  FOR NOW THE CODE WHICH DEFINES THE RASTER TYPE IS DUPLICATED BY DVF\n *  SEE THE METHOD DEFINERASTERTYPE @ RASTEROUTPUTMANAGER\n *\n */\n    public BufferedImage (ColorModel cm,\n                          WritableRaster raster,\n                          boolean isRasterPremultiplied,\n                          Hashtable<?,?> properties) {\n\n        if (!cm.isCompatibleRaster(raster)) {\n            throw new\n                IllegalArgumentException(\"Raster \"+raster+\n                                         \" is incompatible with ColorModel \"+\n                                         cm);\n        }\n\n        if ((raster.minX != 0) || (raster.minY != 0)) {\n            throw new\n                IllegalArgumentException(\"Raster \"+raster+\n                                         \" has minX or minY not equal to zero: \"\n                                         + raster.minX + \" \" + raster.minY);\n        }\n\n        colorModel = cm;\n        this.raster  = raster;\n        this.properties = properties;\n        int numBands = raster.getNumBands();\n        boolean isAlphaPre = cm.isAlphaPremultiplied();\n        final boolean isStandard = isStandard(cm, raster);\n        ColorSpace cs;\n\n        // Force the raster data alpha state to match the premultiplied\n        // state in the color model\n        coerceData(isRasterPremultiplied);\n\n        SampleModel sm = raster.getSampleModel();\n        cs = cm.getColorSpace();\n        int csType = cs.getType();\n        if (csType != ColorSpace.TYPE_RGB) {\n            if (csType == ColorSpace.TYPE_GRAY &&\n                isStandard &&\n                cm instanceof ComponentColorModel) {\n                // Check if this might be a child raster (fix for bug 4240596)\n                if (sm instanceof ComponentSampleModel &&\n                    ((ComponentSampleModel)sm).getPixelStride() != numBands) {\n                    imageType = TYPE_CUSTOM;\n                } else if (raster instanceof ByteComponentRaster &&\n                       raster.getNumBands() == 1 &&\n                       cm.getComponentSize(0) == 8 &&\n                       ((ByteComponentRaster)raster).getPixelStride() == 1) {\n                    imageType = TYPE_BYTE_GRAY;\n                } else if (raster instanceof ShortComponentRaster &&\n                       raster.getNumBands() == 1 &&\n                       cm.getComponentSize(0) == 16 &&\n                       ((ShortComponentRaster)raster).getPixelStride() == 1) {\n                    imageType = TYPE_USHORT_GRAY;\n                }\n            } else {\n                imageType = TYPE_CUSTOM;\n            }\n            return;\n        }\n\n        if ((raster instanceof IntegerComponentRaster) &&\n            (numBands == 3 || numBands == 4)) {\n            IntegerComponentRaster iraster =\n                (IntegerComponentRaster) raster;\n            // Check if the raster params and the color model\n            // are correct\n            int pixSize = cm.getPixelSize();\n            if (iraster.getPixelStride() == 1 &&\n                isStandard &&\n                cm instanceof DirectColorModel  &&\n                (pixSize == 32 || pixSize == 24))\n            {\n                // Now check on the DirectColorModel params\n                DirectColorModel dcm = (DirectColorModel) cm;\n                int rmask = dcm.getRedMask();\n                int gmask = dcm.getGreenMask();\n                int bmask = dcm.getBlueMask();\n                if (rmask == DCM_RED_MASK && gmask == DCM_GREEN_MASK &&\n                    bmask == DCM_BLUE_MASK)\n                {\n                    if (dcm.getAlphaMask() == DCM_ALPHA_MASK) {\n                        imageType = (isAlphaPre\n                                     ? TYPE_INT_ARGB_PRE\n                                     : TYPE_INT_ARGB);\n                    }\n                    else {\n                        // No Alpha\n                        if (!dcm.hasAlpha()) {\n                            imageType = TYPE_INT_RGB;\n                        }\n                    }\n                }   // if (dcm.getRedMask() == DCM_RED_MASK &&\n                else if (rmask == DCM_BGR_RED_MASK && gmask == DCM_BGR_GRN_MASK\n                         && bmask == DCM_BGR_BLU_MASK) {\n                    if (!dcm.hasAlpha()) {\n                        imageType = TYPE_INT_BGR;\n                    }\n                }  // if (rmask == DCM_BGR_RED_MASK &&\n            }   // if (iraster.getPixelStride() == 1\n        }   // ((raster instanceof IntegerComponentRaster) &&\n        else if ((cm instanceof IndexColorModel) && (numBands == 1) &&\n                 isStandard &&\n                 (!cm.hasAlpha() || !isAlphaPre))\n        {\n            IndexColorModel icm = (IndexColorModel) cm;\n            int pixSize = icm.getPixelSize();\n\n            if (raster instanceof BytePackedRaster) {\n                imageType = TYPE_BYTE_BINARY;\n            }   // if (raster instanceof BytePackedRaster)\n            else if (raster instanceof ByteComponentRaster) {\n                ByteComponentRaster braster = (ByteComponentRaster) raster;\n                if (braster.getPixelStride() == 1 && pixSize <= 8) {\n                    imageType = TYPE_BYTE_INDEXED;\n                }\n            }\n        }   // else if (cm instanceof IndexColorModel) && (numBands == 1))\n        else if ((raster instanceof ShortComponentRaster)\n                 && (cm instanceof DirectColorModel)\n                 && isStandard\n                 && (numBands == 3)\n                 && !cm.hasAlpha())\n        {\n            DirectColorModel dcm = (DirectColorModel) cm;\n            if (dcm.getRedMask() == DCM_565_RED_MASK) {\n                if (dcm.getGreenMask() == DCM_565_GRN_MASK &&\n                    dcm.getBlueMask()  == DCM_565_BLU_MASK) {\n                    imageType = TYPE_USHORT_565_RGB;\n                }\n            }\n            else if (dcm.getRedMask() == DCM_555_RED_MASK) {\n                if (dcm.getGreenMask() == DCM_555_GRN_MASK &&\n                    dcm.getBlueMask() == DCM_555_BLU_MASK) {\n                    imageType = TYPE_USHORT_555_RGB;\n                }\n            }\n        }   // else if ((cm instanceof IndexColorModel) && (numBands == 1))\n        else if ((raster instanceof ByteComponentRaster)\n                 && (cm instanceof ComponentColorModel)\n                 && isStandard\n                 && (raster.getSampleModel() instanceof PixelInterleavedSampleModel)\n                 && (numBands == 3 || numBands == 4))\n        {\n            ComponentColorModel ccm = (ComponentColorModel) cm;\n            PixelInterleavedSampleModel csm =\n                (PixelInterleavedSampleModel)raster.getSampleModel();\n            ByteComponentRaster braster = (ByteComponentRaster) raster;\n            int[] offs = csm.getBandOffsets();\n            if (ccm.getNumComponents() != numBands) {\n                throw new RasterFormatException(\"Number of components in \"+\n                                                \"ColorModel (\"+\n                                                ccm.getNumComponents()+\n                                                \") does not match # in \"+\n                                                \" Raster (\"+numBands+\")\");\n            }\n            int[] nBits = ccm.getComponentSize();\n            boolean is8bit = true;\n            for (int i=0; i < numBands; i++) {\n                if (nBits[i] != 8) {\n                    is8bit = false;\n                    break;\n                }\n            }\n            if (is8bit &&\n                braster.getPixelStride() == numBands &&\n                offs[0] == numBands-1 &&\n                offs[1] == numBands-2 &&\n                offs[2] == numBands-3)\n            {\n                if (numBands == 3 && !ccm.hasAlpha()) {\n                    imageType = TYPE_3BYTE_BGR;\n                }\n                else if (offs[3] == 0 && ccm.hasAlpha()) {\n                    imageType = (isAlphaPre\n                                 ? TYPE_4BYTE_ABGR_PRE\n                                 : TYPE_4BYTE_ABGR);\n                }\n            }\n        }   // else if ((raster instanceof ByteComponentRaster) &&\n    }"}
{"Number":"470","API Relative Path":"java.awt.image.ColorModel.java-ColorModel(int)","Corresponding Source":"/**\n     * Constructs a <code>ColorModel<\/code> that translates pixels of the\n     * specified number of bits to color/alpha components.  The color\n     * space is the default RGB <code>ColorSpace<\/code>, which is sRGB.\n     * Pixel values are assumed to include alpha information.  If color\n     * and alpha information are represented in the pixel value as\n     * separate spatial bands, the color bands are assumed not to be\n     * premultiplied with the alpha value. The transparency type is\n     * java.awt.Transparency.TRANSLUCENT.  The transfer type will be the\n     * smallest of DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT,\n     * or DataBuffer.TYPE_INT that can hold a single pixel\n     * (or DataBuffer.TYPE_UNDEFINED if bits is greater\n     * than 32).  Since this constructor has no information about the\n     * number of bits per color and alpha component, any subclass calling\n     * this constructor should override any method that requires this\n     * information.\n     * @param bits the number of bits of a pixel\n     * @throws IllegalArgumentException if the number\n     *          of bits in <code>bits<\/code> is less than 1\n     */\n    public ColorModel(int bits) {\n        pixel_bits = bits;\n        if (bits < 1) {\n            throw new IllegalArgumentException(\"Number of bits must be > 0\");\n        }\n        numComponents = 4;\n        numColorComponents = 3;\n        maxBits = bits;\n        // REMIND: make sure transferType is set correctly\n        transferType = ColorModel.getDefaultTransferType(bits);\n    }"}
{"Number":"471","API Relative Path":"java.awt.image.ColorModel.java-ColorModel(int-int[]-ColorSpace-boolean-boolean-int-int)","Corresponding Source":"/**\n     * Constructs a <code>ColorModel<\/code> that translates pixel values\n     * to color/alpha components.  Color components will be in the\n     * specified <code>ColorSpace<\/code>. <code>pixel_bits<\/code> is the\n     * number of bits in the pixel values.  The bits array\n     * specifies the number of significant bits per color and alpha component.\n     * Its length should be the number of components in the\n     * <code>ColorSpace<\/code> if there is no alpha information in the\n     * pixel values, or one more than this number if there is alpha\n     * information.  <code>hasAlpha<\/code> indicates whether or not alpha\n     * information is present.  The <code>boolean<\/code>\n     * <code>isAlphaPremultiplied<\/code> specifies how to interpret pixel\n     * values in which color and alpha information are represented as\n     * separate spatial bands.  If the <code>boolean<\/code>\n     * is <code>true<\/code>, color samples are assumed to have been\n     * multiplied by the alpha sample.  The <code>transparency<\/code>\n     * specifies what alpha values can be represented by this color model.\n     * The transfer type is the type of primitive array used to represent\n     * pixel values.  Note that the bits array contains the number of\n     * significant bits per color/alpha component after the translation\n     * from pixel values.  For example, for an\n     * <code>IndexColorModel<\/code> with <code>pixel_bits<\/code> equal to\n     * 16, the bits array might have four elements with each element set\n     * to 8.\n     * @param pixel_bits the number of bits in the pixel values\n     * @param bits array that specifies the number of significant bits\n     *          per color and alpha component\n     * @param cspace the specified <code>ColorSpace<\/code>\n     * @param hasAlpha <code>true<\/code> if alpha information is present;\n     *          <code>false<\/code> otherwise\n     * @param isAlphaPremultiplied <code>true<\/code> if color samples are\n     *          assumed to be premultiplied by the alpha samples;\n     *          <code>false<\/code> otherwise\n     * @param transparency what alpha values can be represented by this\n     *          color model\n     * @param transferType the type of the array used to represent pixel\n     *          values\n     * @throws IllegalArgumentException if the length of\n     *          the bit array is less than the number of color or alpha\n     *          components in this <code>ColorModel<\/code>, or if the\n     *          transparency is not a valid value.\n     * @throws IllegalArgumentException if the sum of the number\n     *          of bits in <code>bits<\/code> is less than 1 or if\n     *          any of the elements in <code>bits<\/code> is less than 0.\n     * @see java.awt.Transparency\n     */\n    protected ColorModel(int pixel_bits, int[] bits, ColorSpace cspace,\n                         boolean hasAlpha,\n                         boolean isAlphaPremultiplied,\n                         int transparency,\n                         int transferType) {\n        colorSpace                = cspace;\n        colorSpaceType            = cspace.getType();\n        numColorComponents        = cspace.getNumComponents();\n        numComponents             = numColorComponents + (hasAlpha ? 1 : 0);\n        supportsAlpha             = hasAlpha;\n        if (bits.length < numComponents) {\n            throw new IllegalArgumentException(\"Number of color/alpha \"+\n                                               \"components should be \"+\n                                               numComponents+\n                                               \" but length of bits array is \"+\n                                               bits.length);\n        }\n\n        // 4186669\n        if (transparency < Transparency.OPAQUE ||\n            transparency > Transparency.TRANSLUCENT)\n        {\n            throw new IllegalArgumentException(\"Unknown transparency: \"+\n                                               transparency);\n        }\n\n        if (supportsAlpha == false) {\n            this.isAlphaPremultiplied = false;\n            this.transparency = Transparency.OPAQUE;\n        }\n        else {\n            this.isAlphaPremultiplied = isAlphaPremultiplied;\n            this.transparency         = transparency;\n        }\n\n        nBits = bits.clone();\n        this.pixel_bits = pixel_bits;\n        if (pixel_bits <= 0) {\n            throw new IllegalArgumentException(\"Number of pixel bits must \"+\n                                               \"be > 0\");\n        }\n        // Check for bits < 0\n        maxBits = 0;\n        for (int i=0; i < bits.length; i++) {\n            // bug 4304697\n            if (bits[i] < 0) {\n                throw new\n                    IllegalArgumentException(\"Number of bits must be >= 0\");\n            }\n            if (maxBits < bits[i]) {\n                maxBits = bits[i];\n            }\n        }\n\n        // Make sure that we don't have all 0-bit components\n        if (maxBits == 0) {\n            throw new IllegalArgumentException(\"There must be at least \"+\n                                               \"one component with > 0 \"+\n                                              \"pixel bits.\");\n        }\n\n        // Save this since we always need to check if it is the default CS\n        if (cspace != ColorSpace.getInstance(ColorSpace.CS_sRGB)) {\n            is_sRGB = false;\n        }\n\n        // Save the transfer type\n        this.transferType = transferType;\n    }"}
{"Number":"472","API Relative Path":"java.awt.image.ColorModel.java-ColorModel(int-int[]-ColorSpace-boolean-boolean-int-int)","Corresponding Source":"/**\n     * Constructs a <code>ColorModel<\/code> that translates pixel values\n     * to color/alpha components.  Color components will be in the\n     * specified <code>ColorSpace<\/code>. <code>pixel_bits<\/code> is the\n     * number of bits in the pixel values.  The bits array\n     * specifies the number of significant bits per color and alpha component.\n     * Its length should be the number of components in the\n     * <code>ColorSpace<\/code> if there is no alpha information in the\n     * pixel values, or one more than this number if there is alpha\n     * information.  <code>hasAlpha<\/code> indicates whether or not alpha\n     * information is present.  The <code>boolean<\/code>\n     * <code>isAlphaPremultiplied<\/code> specifies how to interpret pixel\n     * values in which color and alpha information are represented as\n     * separate spatial bands.  If the <code>boolean<\/code>\n     * is <code>true<\/code>, color samples are assumed to have been\n     * multiplied by the alpha sample.  The <code>transparency<\/code>\n     * specifies what alpha values can be represented by this color model.\n     * The transfer type is the type of primitive array used to represent\n     * pixel values.  Note that the bits array contains the number of\n     * significant bits per color/alpha component after the translation\n     * from pixel values.  For example, for an\n     * <code>IndexColorModel<\/code> with <code>pixel_bits<\/code> equal to\n     * 16, the bits array might have four elements with each element set\n     * to 8.\n     * @param pixel_bits the number of bits in the pixel values\n     * @param bits array that specifies the number of significant bits\n     *          per color and alpha component\n     * @param cspace the specified <code>ColorSpace<\/code>\n     * @param hasAlpha <code>true<\/code> if alpha information is present;\n     *          <code>false<\/code> otherwise\n     * @param isAlphaPremultiplied <code>true<\/code> if color samples are\n     *          assumed to be premultiplied by the alpha samples;\n     *          <code>false<\/code> otherwise\n     * @param transparency what alpha values can be represented by this\n     *          color model\n     * @param transferType the type of the array used to represent pixel\n     *          values\n     * @throws IllegalArgumentException if the length of\n     *          the bit array is less than the number of color or alpha\n     *          components in this <code>ColorModel<\/code>, or if the\n     *          transparency is not a valid value.\n     * @throws IllegalArgumentException if the sum of the number\n     *          of bits in <code>bits<\/code> is less than 1 or if\n     *          any of the elements in <code>bits<\/code> is less than 0.\n     * @see java.awt.Transparency\n     */\n    protected ColorModel(int pixel_bits, int[] bits, ColorSpace cspace,\n                         boolean hasAlpha,\n                         boolean isAlphaPremultiplied,\n                         int transparency,\n                         int transferType) {\n        colorSpace                = cspace;\n        colorSpaceType            = cspace.getType();\n        numColorComponents        = cspace.getNumComponents();\n        numComponents             = numColorComponents + (hasAlpha ? 1 : 0);\n        supportsAlpha             = hasAlpha;\n        if (bits.length < numComponents) {\n            throw new IllegalArgumentException(\"Number of color/alpha \"+\n                                               \"components should be \"+\n                                               numComponents+\n                                               \" but length of bits array is \"+\n                                               bits.length);\n        }\n\n        // 4186669\n        if (transparency < Transparency.OPAQUE ||\n            transparency > Transparency.TRANSLUCENT)\n        {\n            throw new IllegalArgumentException(\"Unknown transparency: \"+\n                                               transparency);\n        }\n\n        if (supportsAlpha == false) {\n            this.isAlphaPremultiplied = false;\n            this.transparency = Transparency.OPAQUE;\n        }\n        else {\n            this.isAlphaPremultiplied = isAlphaPremultiplied;\n            this.transparency         = transparency;\n        }\n\n        nBits = bits.clone();\n        this.pixel_bits = pixel_bits;\n        if (pixel_bits <= 0) {\n            throw new IllegalArgumentException(\"Number of pixel bits must \"+\n                                               \"be > 0\");\n        }\n        // Check for bits < 0\n        maxBits = 0;\n        for (int i=0; i < bits.length; i++) {\n            // bug 4304697\n            if (bits[i] < 0) {\n                throw new\n                    IllegalArgumentException(\"Number of bits must be >= 0\");\n            }\n            if (maxBits < bits[i]) {\n                maxBits = bits[i];\n            }\n        }\n\n        // Make sure that we don't have all 0-bit components\n        if (maxBits == 0) {\n            throw new IllegalArgumentException(\"There must be at least \"+\n                                               \"one component with > 0 \"+\n                                              \"pixel bits.\");\n        }\n\n        // Save this since we always need to check if it is the default CS\n        if (cspace != ColorSpace.getInstance(ColorSpace.CS_sRGB)) {\n            is_sRGB = false;\n        }\n\n        // Save the transfer type\n        this.transferType = transferType;\n    }"}
{"Number":"473","API Relative Path":"java.awt.image.ColorModel.java-ColorModel(int-int[]-ColorSpace-boolean-boolean-int-int)","Corresponding Source":"/**\n     * Constructs a <code>ColorModel<\/code> that translates pixel values\n     * to color/alpha components.  Color components will be in the\n     * specified <code>ColorSpace<\/code>. <code>pixel_bits<\/code> is the\n     * number of bits in the pixel values.  The bits array\n     * specifies the number of significant bits per color and alpha component.\n     * Its length should be the number of components in the\n     * <code>ColorSpace<\/code> if there is no alpha information in the\n     * pixel values, or one more than this number if there is alpha\n     * information.  <code>hasAlpha<\/code> indicates whether or not alpha\n     * information is present.  The <code>boolean<\/code>\n     * <code>isAlphaPremultiplied<\/code> specifies how to interpret pixel\n     * values in which color and alpha information are represented as\n     * separate spatial bands.  If the <code>boolean<\/code>\n     * is <code>true<\/code>, color samples are assumed to have been\n     * multiplied by the alpha sample.  The <code>transparency<\/code>\n     * specifies what alpha values can be represented by this color model.\n     * The transfer type is the type of primitive array used to represent\n     * pixel values.  Note that the bits array contains the number of\n     * significant bits per color/alpha component after the translation\n     * from pixel values.  For example, for an\n     * <code>IndexColorModel<\/code> with <code>pixel_bits<\/code> equal to\n     * 16, the bits array might have four elements with each element set\n     * to 8.\n     * @param pixel_bits the number of bits in the pixel values\n     * @param bits array that specifies the number of significant bits\n     *          per color and alpha component\n     * @param cspace the specified <code>ColorSpace<\/code>\n     * @param hasAlpha <code>true<\/code> if alpha information is present;\n     *          <code>false<\/code> otherwise\n     * @param isAlphaPremultiplied <code>true<\/code> if color samples are\n     *          assumed to be premultiplied by the alpha samples;\n     *          <code>false<\/code> otherwise\n     * @param transparency what alpha values can be represented by this\n     *          color model\n     * @param transferType the type of the array used to represent pixel\n     *          values\n     * @throws IllegalArgumentException if the length of\n     *          the bit array is less than the number of color or alpha\n     *          components in this <code>ColorModel<\/code>, or if the\n     *          transparency is not a valid value.\n     * @throws IllegalArgumentException if the sum of the number\n     *          of bits in <code>bits<\/code> is less than 1 or if\n     *          any of the elements in <code>bits<\/code> is less than 0.\n     * @see java.awt.Transparency\n     */\n    protected ColorModel(int pixel_bits, int[] bits, ColorSpace cspace,\n                         boolean hasAlpha,\n                         boolean isAlphaPremultiplied,\n                         int transparency,\n                         int transferType) {\n        colorSpace                = cspace;\n        colorSpaceType            = cspace.getType();\n        numColorComponents        = cspace.getNumComponents();\n        numComponents             = numColorComponents + (hasAlpha ? 1 : 0);\n        supportsAlpha             = hasAlpha;\n        if (bits.length < numComponents) {\n            throw new IllegalArgumentException(\"Number of color/alpha \"+\n                                               \"components should be \"+\n                                               numComponents+\n                                               \" but length of bits array is \"+\n                                               bits.length);\n        }\n\n        // 4186669\n        if (transparency < Transparency.OPAQUE ||\n            transparency > Transparency.TRANSLUCENT)\n        {\n            throw new IllegalArgumentException(\"Unknown transparency: \"+\n                                               transparency);\n        }\n\n        if (supportsAlpha == false) {\n            this.isAlphaPremultiplied = false;\n            this.transparency = Transparency.OPAQUE;\n        }\n        else {\n            this.isAlphaPremultiplied = isAlphaPremultiplied;\n            this.transparency         = transparency;\n        }\n\n        nBits = bits.clone();\n        this.pixel_bits = pixel_bits;\n        if (pixel_bits <= 0) {\n            throw new IllegalArgumentException(\"Number of pixel bits must \"+\n                                               \"be > 0\");\n        }\n        // Check for bits < 0\n        maxBits = 0;\n        for (int i=0; i < bits.length; i++) {\n            // bug 4304697\n            if (bits[i] < 0) {\n                throw new\n                    IllegalArgumentException(\"Number of bits must be >= 0\");\n            }\n            if (maxBits < bits[i]) {\n                maxBits = bits[i];\n            }\n        }\n\n        // Make sure that we don't have all 0-bit components\n        if (maxBits == 0) {\n            throw new IllegalArgumentException(\"There must be at least \"+\n                                               \"one component with > 0 \"+\n                                              \"pixel bits.\");\n        }\n\n        // Save this since we always need to check if it is the default CS\n        if (cspace != ColorSpace.getInstance(ColorSpace.CS_sRGB)) {\n            is_sRGB = false;\n        }\n\n        // Save the transfer type\n        this.transferType = transferType;\n    }"}
{"Number":"474","API Relative Path":"java.awt.image.ColorModel.java-getDataElement(float[]-int)","Corresponding Source":"/**\n     * Returns a pixel value represented as an <code>int<\/code> in this\n     * <code>ColorModel<\/code>, given an array of normalized color/alpha\n     * components.  This method will throw an\n     * <code>IllegalArgumentException<\/code> if pixel values for this\n     * <code>ColorModel<\/code> are not conveniently representable as a\n     * single <code>int<\/code>.  An\n     * <code>ArrayIndexOutOfBoundsException<\/code> is thrown if  the\n     * <code>normComponents<\/code> array is not large enough to hold all the\n     * color and alpha components (starting at <code>normOffset<\/code>).\n     * Since <code>ColorModel<\/code> is an abstract class,\n     * any instance is an instance of a subclass.  The default implementation\n     * of this method in this abstract class first converts from the\n     * normalized form to the unnormalized form and then calls\n     * <code>getDataElement(int[], int)<\/code>.  Subclasses which may\n     * have instances which do not support the unnormalized form must\n     * override this method.\n     * @param normComponents an array of normalized color and alpha\n     * components\n     * @param normOffset the index into <code>normComponents<\/code> at which to\n     * begin retrieving the color and alpha components\n     * @return an <code>int<\/code> pixel value in this\n     * <code>ColorModel<\/code> corresponding to the specified components.\n     * @throws IllegalArgumentException if\n     *  pixel values for this <code>ColorModel<\/code> are not\n     *  conveniently representable as a single <code>int<\/code>\n     * @throws ArrayIndexOutOfBoundsException if\n     *  the <code>normComponents<\/code> array is not large enough to\n     *  hold all of the color and alpha components starting at\n     *  <code>normOffset<\/code>\n     * @since 1.4\n     */\n    public int getDataElement(float[] normComponents, int normOffset) {\n        int components[] = getUnnormalizedComponents(normComponents,\n                                                     normOffset, null, 0);\n        return getDataElement(components, 0);\n    }"}
{"Number":"475","API Relative Path":"java.awt.image.ColorModel.java-getDataElements(float[]-int-Object)","Corresponding Source":"/**\n     * Returns a data element array representation of a pixel in this\n     * <code>ColorModel<\/code>, given an array of normalized color/alpha\n     * components.  This array can then be passed to the\n     * <code>setDataElements<\/code> method of a <code>WritableRaster<\/code>\n     * object.  An <code>ArrayIndexOutOfBoundsException<\/code> is thrown\n     * if the <code>normComponents<\/code> array is not large enough to hold\n     * all the color and alpha components (starting at\n     * <code>normOffset<\/code>).  If the <code>obj<\/code> variable is\n     * <code>null<\/code>, a new array will be allocated.  If\n     * <code>obj<\/code> is not <code>null<\/code>, it must be a primitive\n     * array of type transferType; otherwise, a\n     * <code>ClassCastException<\/code> is thrown.  An\n     * <code>ArrayIndexOutOfBoundsException<\/code> is thrown if\n     * <code>obj<\/code> is not large enough to hold a pixel value for this\n     * <code>ColorModel<\/code>.\n     * Since <code>ColorModel<\/code> is an abstract class,\n     * any instance is an instance of a subclass.  The default implementation\n     * of this method in this abstract class first converts from the\n     * normalized form to the unnormalized form and then calls\n     * <code>getDataElement(int[], int, Object)<\/code>.  Subclasses which may\n     * have instances which do not support the unnormalized form must\n     * override this method.\n     * @param normComponents an array of normalized color and alpha\n     * components\n     * @param normOffset the index into <code>normComponents<\/code> at which to\n     * begin retrieving color and alpha components\n     * @param obj a primitive data array to hold the returned pixel\n     * @return an <code>Object<\/code> which is a primitive data array\n     * representation of a pixel\n     * @throws ClassCastException if <code>obj<\/code>\n     *  is not a primitive array of type <code>transferType<\/code>\n     * @throws ArrayIndexOutOfBoundsException if\n     *  <code>obj<\/code> is not large enough to hold a pixel value\n     *  for this <code>ColorModel<\/code> or the <code>normComponents<\/code>\n     *  array is not large enough to hold all of the color and alpha\n     *  components starting at <code>normOffset<\/code>\n     * @see WritableRaster#setDataElements\n     * @see SampleModel#setDataElements\n     * @since 1.4\n     */\n    public Object getDataElements(float[] normComponents, int normOffset,\n                                  Object obj) {\n        int components[] = getUnnormalizedComponents(normComponents,\n                                                     normOffset, null, 0);\n        return getDataElements(components, 0, obj);\n    }"}
{"Number":"476","API Relative Path":"java.awt.image.ColorModel.java-getNormalizedComponents(int[]-int-float[]-int)","Corresponding Source":"/**\n     * Returns an array of all of the color/alpha components in normalized\n     * form, given an unnormalized component array.  Unnormalized components\n     * are unsigned integral values between 0 and 2<sup>n<\/sup> - 1, where\n     * n is the number of bits for a particular component.  Normalized\n     * components are float values between a per component minimum and\n     * maximum specified by the <code>ColorSpace<\/code> object for this\n     * <code>ColorModel<\/code>.  An <code>IllegalArgumentException<\/code>\n     * will be thrown if color component values for this\n     * <code>ColorModel<\/code> are not conveniently representable in the\n     * unnormalized form.  If the\n     * <code>normComponents<\/code> array is <code>null<\/code>, a new array\n     * will be allocated.  The <code>normComponents<\/code> array\n     * will be returned.  Color/alpha components are stored in the\n     * <code>normComponents<\/code> array starting at\n     * <code>normOffset<\/code> (even if the array is allocated by this\n     * method).  An <code>ArrayIndexOutOfBoundsException<\/code> is thrown\n     * if the <code>normComponents<\/code> array is not <code>null<\/code>\n     * and is not large enough to hold all the color and alpha components\n     * (starting at <code>normOffset<\/code>).  An\n     * <code>IllegalArgumentException<\/code> is thrown if the\n     * <code>components<\/code> array is not large enough to hold all the\n     * color and alpha components starting at <code>offset<\/code>.\n     * <p>\n     * Since <code>ColorModel<\/code> is an abstract class,\n     * any instance is an instance of a subclass.  The default implementation\n     * of this method in this abstract class assumes that component values\n     * for this class are conveniently representable in the unnormalized\n     * form.  Therefore, subclasses which may\n     * have instances which do not support the unnormalized form must\n     * override this method.\n     * @param components an array containing unnormalized components\n     * @param offset the offset into the <code>components<\/code> array at\n     * which to start retrieving unnormalized components\n     * @param normComponents an array that receives the normalized components\n     * @param normOffset the index into <code>normComponents<\/code> at\n     * which to begin storing normalized components\n     * @return an array containing normalized color and alpha\n     * components.\n     * @throws IllegalArgumentException If the component values for this\n     * <CODE>ColorModel<\/CODE> are not conveniently representable in the\n     * unnormalized form.\n     * @throws UnsupportedOperationException if the\n     *          constructor of this <code>ColorModel<\/code> called the\n     *          <code>super(bits)<\/code> constructor, but did not\n     *          override this method.  See the constructor,\n     *          {@link #ColorModel(int)}.\n     * @throws UnsupportedOperationException if this method is unable\n     *          to determine the number of bits per component\n     */\n    public float[] getNormalizedComponents(int[] components, int offset,\n                                           float[] normComponents,\n                                           int normOffset) {\n        // Make sure that someone isn't using a custom color model\n        // that called the super(bits) constructor.\n        if (colorSpace == null) {\n            throw new UnsupportedOperationException(\"This method is not supported by \"+\n                                        \"this color model.\");\n        }\n        if (nBits == null) {\n            throw new UnsupportedOperationException (\"This method is not supported.  \"+\n                                         \"Unable to determine #bits per \"+\n                                         \"component.\");\n        }\n\n        if ((components.length - offset) < numComponents) {\n            throw new\n                IllegalArgumentException(\n                        \"Incorrect number of components.  Expecting \"+\n                        numComponents);\n        }\n\n        if (normComponents == null) {\n            normComponents = new float[numComponents+normOffset];\n        }\n\n        if (supportsAlpha && isAlphaPremultiplied) {\n            // Normalized coordinates are non premultiplied\n            float normAlpha = (float)components[offset+numColorComponents];\n            normAlpha /= (float) ((1<<nBits[numColorComponents]) - 1);\n            if (normAlpha != 0.0f) {\n                for (int i=0; i < numColorComponents; i++) {\n                    normComponents[normOffset+i] =\n                        ((float) components[offset+i]) /\n                        (normAlpha * ((float) ((1<<nBits[i]) - 1)));\n                }\n            } else {\n                for (int i=0; i < numColorComponents; i++) {\n                    normComponents[normOffset+i] = 0.0f;\n                }\n            }\n            normComponents[normOffset+numColorComponents] = normAlpha;\n        }\n        else {\n            for (int i=0; i < numComponents; i++) {\n                normComponents[normOffset+i] = ((float) components[offset+i]) /\n                                               ((float) ((1<<nBits[i]) - 1));\n            }\n        }\n\n        return normComponents;\n    }"}
{"Number":"477","API Relative Path":"java.awt.image.ColorModel.java-getUnnormalizedComponents(float[]-int-int[]-int)","Corresponding Source":"/**\n     * Returns an array of all of the color/alpha components in unnormalized\n     * form, given a normalized component array.  Unnormalized components\n     * are unsigned integral values between 0 and 2<sup>n<\/sup> - 1, where\n     * n is the number of bits for a particular component.  Normalized\n     * components are float values between a per component minimum and\n     * maximum specified by the <code>ColorSpace<\/code> object for this\n     * <code>ColorModel<\/code>.  An <code>IllegalArgumentException<\/code>\n     * will be thrown if color component values for this\n     * <code>ColorModel<\/code> are not conveniently representable in the\n     * unnormalized form.  If the\n     * <code>components<\/code> array is <code>null<\/code>, a new array\n     * will be allocated.  The <code>components<\/code> array will\n     * be returned.  Color/alpha components are stored in the\n     * <code>components<\/code> array starting at <code>offset<\/code> (even\n     * if the array is allocated by this method). An\n     * <code>ArrayIndexOutOfBoundsException<\/code> is thrown if the\n     * <code>components<\/code> array is not <code>null<\/code> and is not\n     * large enough to hold all the color and alpha\n     * components (starting at <code>offset<\/code>).  An\n     * <code>IllegalArgumentException<\/code> is thrown if the\n     * <code>normComponents<\/code> array is not large enough to hold\n     * all the color and alpha components starting at\n     * <code>normOffset<\/code>.\n     * @param normComponents an array containing normalized components\n     * @param normOffset the offset into the <code>normComponents<\/code>\n     * array at which to start retrieving normalized components\n     * @param components an array that receives the components from\n     * <code>normComponents<\/code>\n     * @param offset the index into <code>components<\/code> at which to\n     * begin storing normalized components from\n     * <code>normComponents<\/code>\n     * @return an array containing unnormalized color and alpha\n     * components.\n     * @throws IllegalArgumentException If the component values for this\n     * <CODE>ColorModel<\/CODE> are not conveniently representable in the\n     * unnormalized form.\n     * @throws IllegalArgumentException if the length of\n     *          <code>normComponents<\/code> minus <code>normOffset<\/code>\n     *          is less than <code>numComponents<\/code>\n     * @throws UnsupportedOperationException if the\n     *          constructor of this <code>ColorModel<\/code> called the\n     *          <code>super(bits)<\/code> constructor, but did not\n     *          override this method.  See the constructor,\n     *          {@link #ColorModel(int)}.\n     */\n    public int[] getUnnormalizedComponents(float[] normComponents,\n                                           int normOffset,\n                                           int[] components, int offset) {\n        // Make sure that someone isn't using a custom color model\n        // that called the super(bits) constructor.\n        if (colorSpace == null) {\n            throw new UnsupportedOperationException(\"This method is not supported \"+\n                                        \"by this color model.\");\n        }\n\n        if (nBits == null) {\n            throw new UnsupportedOperationException (\"This method is not supported.  \"+\n                                         \"Unable to determine #bits per \"+\n                                         \"component.\");\n        }\n        if ((normComponents.length - normOffset) < numComponents) {\n            throw new\n                IllegalArgumentException(\n                        \"Incorrect number of components.  Expecting \"+\n                        numComponents);\n        }\n\n        if (components == null) {\n            components = new int[offset+numComponents];\n        }\n\n        if (supportsAlpha && isAlphaPremultiplied) {\n            float normAlpha = normComponents[normOffset+numColorComponents];\n            for (int i=0; i < numColorComponents; i++) {\n                components[offset+i] = (int) (normComponents[normOffset+i]\n                                              * ((1<<nBits[i]) - 1)\n                                              * normAlpha + 0.5f);\n            }\n            components[offset+numColorComponents] = (int)\n                (normAlpha * ((1<<nBits[numColorComponents]) - 1) + 0.5f);\n        }\n        else {\n            for (int i=0; i < numComponents; i++) {\n                components[offset+i] = (int) (normComponents[normOffset+i]\n                                              * ((1<<nBits[i]) - 1) + 0.5f);\n            }\n        }\n\n        return components;\n    }"}
{"Number":"478","API Relative Path":"java.awt.image.ComponentColorModel.java-ComponentColorModel(ColorSpace-int[]-boolean-boolean-int-int)","Corresponding Source":"/**\n     * Constructs a <CODE>ComponentColorModel<\/CODE> from the specified\n     * parameters. Color components will be in the specified\n     * <CODE>ColorSpace<\/CODE>.  The supported transfer types are\n     * <CODE>DataBuffer.TYPE_BYTE<\/CODE>, <CODE>DataBuffer.TYPE_USHORT<\/CODE>,\n     * <CODE>DataBuffer.TYPE_INT<\/CODE>,\n     * <CODE>DataBuffer.TYPE_SHORT<\/CODE>, <CODE>DataBuffer.TYPE_FLOAT<\/CODE>,\n     * and <CODE>DataBuffer.TYPE_DOUBLE<\/CODE>.\n     * If not null, the <CODE>bits<\/CODE> array specifies the\n     * number of significant bits per color and alpha component and its\n     * length should be at least the number of components in the\n     * <CODE>ColorSpace<\/CODE> if there is no alpha\n     * information in the pixel values, or one more than this number if\n     * there is alpha information.  When the <CODE>transferType<\/CODE> is\n     * <CODE>DataBuffer.TYPE_SHORT<\/CODE>, <CODE>DataBuffer.TYPE_FLOAT<\/CODE>,\n     * or <CODE>DataBuffer.TYPE_DOUBLE<\/CODE> the <CODE>bits<\/CODE> array\n     * argument is ignored.  <CODE>hasAlpha<\/CODE> indicates whether alpha\n     * information is present.  If <CODE>hasAlpha<\/CODE> is true, then\n     * the boolean <CODE>isAlphaPremultiplied<\/CODE>\n     * specifies how to interpret color and alpha samples in pixel values.\n     * If the boolean is true, color samples are assumed to have been\n     * multiplied by the alpha sample. The <CODE>transparency<\/CODE>\n     * specifies what alpha values can be represented by this color model.\n     * The acceptable <code>transparency<\/code> values are\n     * <CODE>OPAQUE<\/CODE>, <CODE>BITMASK<\/CODE> or <CODE>TRANSLUCENT<\/CODE>.\n     * The <CODE>transferType<\/CODE> is the type of primitive array used\n     * to represent pixel values.\n     *\n     * @param colorSpace       The <CODE>ColorSpace<\/CODE> associated\n     *                         with this color model.\n     * @param bits             The number of significant bits per component.\n     *                         May be null, in which case all bits of all\n     *                         component samples will be significant.\n     *                         Ignored if transferType is one of\n     *                         <CODE>DataBuffer.TYPE_SHORT<\/CODE>,\n     *                         <CODE>DataBuffer.TYPE_FLOAT<\/CODE>, or\n     *                         <CODE>DataBuffer.TYPE_DOUBLE<\/CODE>,\n     *                         in which case all bits of all component\n     *                         samples will be significant.\n     * @param hasAlpha         If true, this color model supports alpha.\n     * @param isAlphaPremultiplied If true, alpha is premultiplied.\n     * @param transparency     Specifies what alpha values can be represented\n     *                         by this color model.\n     * @param transferType     Specifies the type of primitive array used to\n     *                         represent pixel values.\n     *\n     * @throws IllegalArgumentException If the <CODE>bits<\/CODE> array\n     *         argument is not null, its length is less than the number of\n     *         color and alpha components, and transferType is one of\n     *         <CODE>DataBuffer.TYPE_BYTE<\/CODE>,\n     *         <CODE>DataBuffer.TYPE_USHORT<\/CODE>, or\n     *         <CODE>DataBuffer.TYPE_INT<\/CODE>.\n     * @throws IllegalArgumentException If transferType is not one of\n     *         <CODE>DataBuffer.TYPE_BYTE<\/CODE>,\n     *         <CODE>DataBuffer.TYPE_USHORT<\/CODE>,\n     *         <CODE>DataBuffer.TYPE_INT<\/CODE>,\n     *         <CODE>DataBuffer.TYPE_SHORT<\/CODE>,\n     *         <CODE>DataBuffer.TYPE_FLOAT<\/CODE>, or\n     *         <CODE>DataBuffer.TYPE_DOUBLE<\/CODE>.\n     *\n     * @see ColorSpace\n     * @see java.awt.Transparency\n     */\n    public ComponentColorModel (ColorSpace colorSpace,\n                                int[] bits,\n                                boolean hasAlpha,\n                                boolean isAlphaPremultiplied,\n                                int transparency,\n                                int transferType) {\n        super (bitsHelper(transferType, colorSpace, hasAlpha),\n               bitsArrayHelper(bits, transferType, colorSpace, hasAlpha),\n               colorSpace, hasAlpha, isAlphaPremultiplied, transparency,\n               transferType);\n        switch(transferType) {\n            case DataBuffer.TYPE_BYTE:\n            case DataBuffer.TYPE_USHORT:\n            case DataBuffer.TYPE_INT:\n                signed = false;\n                needScaleInit = true;\n                break;\n            case DataBuffer.TYPE_SHORT:\n                signed = true;\n                needScaleInit = true;\n                break;\n            case DataBuffer.TYPE_FLOAT:\n            case DataBuffer.TYPE_DOUBLE:\n                signed = true;\n                needScaleInit = false;\n                noUnnorm = true;\n                nonStdScale = false;\n                break;\n            default:\n                throw new IllegalArgumentException(\"This constructor is not \"+\n                         \"compatible with transferType \" + transferType);\n        }\n        setupLUTs();\n    }"}
{"Number":"479","API Relative Path":"java.awt.image.ComponentColorModel.java-ComponentColorModel(ColorSpace-int[]-boolean-boolean-int-int)","Corresponding Source":"/**\n     * Constructs a <CODE>ComponentColorModel<\/CODE> from the specified\n     * parameters. Color components will be in the specified\n     * <CODE>ColorSpace<\/CODE>.  The supported transfer types are\n     * <CODE>DataBuffer.TYPE_BYTE<\/CODE>, <CODE>DataBuffer.TYPE_USHORT<\/CODE>,\n     * <CODE>DataBuffer.TYPE_INT<\/CODE>,\n     * <CODE>DataBuffer.TYPE_SHORT<\/CODE>, <CODE>DataBuffer.TYPE_FLOAT<\/CODE>,\n     * and <CODE>DataBuffer.TYPE_DOUBLE<\/CODE>.\n     * If not null, the <CODE>bits<\/CODE> array specifies the\n     * number of significant bits per color and alpha component and its\n     * length should be at least the number of components in the\n     * <CODE>ColorSpace<\/CODE> if there is no alpha\n     * information in the pixel values, or one more than this number if\n     * there is alpha information.  When the <CODE>transferType<\/CODE> is\n     * <CODE>DataBuffer.TYPE_SHORT<\/CODE>, <CODE>DataBuffer.TYPE_FLOAT<\/CODE>,\n     * or <CODE>DataBuffer.TYPE_DOUBLE<\/CODE> the <CODE>bits<\/CODE> array\n     * argument is ignored.  <CODE>hasAlpha<\/CODE> indicates whether alpha\n     * information is present.  If <CODE>hasAlpha<\/CODE> is true, then\n     * the boolean <CODE>isAlphaPremultiplied<\/CODE>\n     * specifies how to interpret color and alpha samples in pixel values.\n     * If the boolean is true, color samples are assumed to have been\n     * multiplied by the alpha sample. The <CODE>transparency<\/CODE>\n     * specifies what alpha values can be represented by this color model.\n     * The acceptable <code>transparency<\/code> values are\n     * <CODE>OPAQUE<\/CODE>, <CODE>BITMASK<\/CODE> or <CODE>TRANSLUCENT<\/CODE>.\n     * The <CODE>transferType<\/CODE> is the type of primitive array used\n     * to represent pixel values.\n     *\n     * @param colorSpace       The <CODE>ColorSpace<\/CODE> associated\n     *                         with this color model.\n     * @param bits             The number of significant bits per component.\n     *                         May be null, in which case all bits of all\n     *                         component samples will be significant.\n     *                         Ignored if transferType is one of\n     *                         <CODE>DataBuffer.TYPE_SHORT<\/CODE>,\n     *                         <CODE>DataBuffer.TYPE_FLOAT<\/CODE>, or\n     *                         <CODE>DataBuffer.TYPE_DOUBLE<\/CODE>,\n     *                         in which case all bits of all component\n     *                         samples will be significant.\n     * @param hasAlpha         If true, this color model supports alpha.\n     * @param isAlphaPremultiplied If true, alpha is premultiplied.\n     * @param transparency     Specifies what alpha values can be represented\n     *                         by this color model.\n     * @param transferType     Specifies the type of primitive array used to\n     *                         represent pixel values.\n     *\n     * @throws IllegalArgumentException If the <CODE>bits<\/CODE> array\n     *         argument is not null, its length is less than the number of\n     *         color and alpha components, and transferType is one of\n     *         <CODE>DataBuffer.TYPE_BYTE<\/CODE>,\n     *         <CODE>DataBuffer.TYPE_USHORT<\/CODE>, or\n     *         <CODE>DataBuffer.TYPE_INT<\/CODE>.\n     * @throws IllegalArgumentException If transferType is not one of\n     *         <CODE>DataBuffer.TYPE_BYTE<\/CODE>,\n     *         <CODE>DataBuffer.TYPE_USHORT<\/CODE>,\n     *         <CODE>DataBuffer.TYPE_INT<\/CODE>,\n     *         <CODE>DataBuffer.TYPE_SHORT<\/CODE>,\n     *         <CODE>DataBuffer.TYPE_FLOAT<\/CODE>, or\n     *         <CODE>DataBuffer.TYPE_DOUBLE<\/CODE>.\n     *\n     * @see ColorSpace\n     * @see java.awt.Transparency\n     */\n    public ComponentColorModel (ColorSpace colorSpace,\n                                int[] bits,\n                                boolean hasAlpha,\n                                boolean isAlphaPremultiplied,\n                                int transparency,\n                                int transferType) {\n        super (bitsHelper(transferType, colorSpace, hasAlpha),\n               bitsArrayHelper(bits, transferType, colorSpace, hasAlpha),\n               colorSpace, hasAlpha, isAlphaPremultiplied, transparency,\n               transferType);\n        switch(transferType) {\n            case DataBuffer.TYPE_BYTE:\n            case DataBuffer.TYPE_USHORT:\n            case DataBuffer.TYPE_INT:\n                signed = false;\n                needScaleInit = true;\n                break;\n            case DataBuffer.TYPE_SHORT:\n                signed = true;\n                needScaleInit = true;\n                break;\n            case DataBuffer.TYPE_FLOAT:\n            case DataBuffer.TYPE_DOUBLE:\n                signed = true;\n                needScaleInit = false;\n                noUnnorm = true;\n                nonStdScale = false;\n                break;\n            default:\n                throw new IllegalArgumentException(\"This constructor is not \"+\n                         \"compatible with transferType \" + transferType);\n        }\n        setupLUTs();\n    }"}
{"Number":"480","API Relative Path":"java.awt.image.ComponentColorModel.java-getComponents(Object-int[]-int)","Corresponding Source":"/**\n     * Returns an array of unnormalized color/alpha components given a pixel\n     * in this <CODE>ColorModel<\/CODE>.  The pixel value is specified by an\n     * array of data elements of type <CODE>transferType<\/CODE> passed in as\n     * an object reference.\n     * An IllegalArgumentException is thrown if the component values for this\n     * <CODE>ColorModel<\/CODE> are not conveniently representable in the\n     * unnormalized form.\n     * Color/alpha components are stored in the <CODE>components<\/CODE> array\n     * starting at  <CODE>offset<\/CODE> (even if the array is allocated by\n     * this method).  Since <code>ComponentColorModel<\/code> can be\n     * subclassed, subclasses inherit the\n     * implementation of this method and if they don't override it then\n     * this method might throw an exception if they use an unsupported\n     * <code>transferType<\/code>.\n     *\n     * @param pixel A pixel value specified by an array of data elements of\n     * type <CODE>transferType<\/CODE>.\n     * @param components An integer array in which to store the unnormalized\n     * color/alpha components. If the <CODE>components<\/CODE> array is null,\n     * a new array is allocated.\n     * @param offset An offset into the <CODE>components<\/CODE> array.\n     *\n     * @return The <CODE>components<\/CODE> array.\n     *\n     * @throws IllegalArgumentException If this\n     * <CODE>ComponentColorModel<\/CODE> does not support the unnormalized form\n     * @throws UnsupportedOperationException in some cases iff the\n     * transfer type of this <CODE>ComponentColorModel<\/CODE>\n     * is not one of the following transfer types:\n     * <CODE>DataBuffer.TYPE_BYTE<\/CODE>, <CODE>DataBuffer.TYPE_USHORT<\/CODE>,\n     * or <CODE>DataBuffer.TYPE_INT<\/CODE>.\n     * @throws ClassCastException If <CODE>pixel<\/CODE> is not a primitive\n     * array of type <CODE>transferType<\/CODE>.\n     * @throws IllegalArgumentException If the <CODE>components<\/CODE> array is\n     * not null and is not large enough to hold all the color and alpha\n     * components (starting at offset), or if <CODE>pixel<\/CODE> is not large\n     * enough to hold a pixel value for this ColorModel.\n     */\n    public int[] getComponents(Object pixel, int[] components, int offset) {\n        int intpixel[];\n        if (needScaleInit) {\n            initScale();\n        }\n        if (noUnnorm) {\n            throw new\n                IllegalArgumentException(\n                    \"This ColorModel does not support the unnormalized form\");\n        }\n        if (pixel instanceof int[]) {\n            intpixel = (int[])pixel;\n        } else {\n            intpixel = DataBuffer.toIntArray(pixel);\n            if (intpixel == null) {\n               throw new UnsupportedOperationException(\"This method has not been \"+\n                   \"implemented for transferType \" + transferType);\n            }\n        }\n        if (intpixel.length < numComponents) {\n            throw new IllegalArgumentException\n                (\"Length of pixel array < number of components in model\");\n        }\n        if (components == null) {\n            components = new int[offset+numComponents];\n        }\n        else if ((components.length-offset) < numComponents) {\n            throw new IllegalArgumentException\n                (\"Length of components array < number of components in model\");\n        }\n        System.arraycopy(intpixel, 0, components, offset, numComponents);\n\n        return components;\n    }"}
{"Number":"481","API Relative Path":"java.awt.image.ComponentColorModel.java-getComponents(Object-int[]-int)","Corresponding Source":"/**\n     * Returns an array of unnormalized color/alpha components given a pixel\n     * in this <CODE>ColorModel<\/CODE>.  The pixel value is specified by an\n     * array of data elements of type <CODE>transferType<\/CODE> passed in as\n     * an object reference.\n     * An IllegalArgumentException is thrown if the component values for this\n     * <CODE>ColorModel<\/CODE> are not conveniently representable in the\n     * unnormalized form.\n     * Color/alpha components are stored in the <CODE>components<\/CODE> array\n     * starting at  <CODE>offset<\/CODE> (even if the array is allocated by\n     * this method).  Since <code>ComponentColorModel<\/code> can be\n     * subclassed, subclasses inherit the\n     * implementation of this method and if they don't override it then\n     * this method might throw an exception if they use an unsupported\n     * <code>transferType<\/code>.\n     *\n     * @param pixel A pixel value specified by an array of data elements of\n     * type <CODE>transferType<\/CODE>.\n     * @param components An integer array in which to store the unnormalized\n     * color/alpha components. If the <CODE>components<\/CODE> array is null,\n     * a new array is allocated.\n     * @param offset An offset into the <CODE>components<\/CODE> array.\n     *\n     * @return The <CODE>components<\/CODE> array.\n     *\n     * @throws IllegalArgumentException If this\n     * <CODE>ComponentColorModel<\/CODE> does not support the unnormalized form\n     * @throws UnsupportedOperationException in some cases iff the\n     * transfer type of this <CODE>ComponentColorModel<\/CODE>\n     * is not one of the following transfer types:\n     * <CODE>DataBuffer.TYPE_BYTE<\/CODE>, <CODE>DataBuffer.TYPE_USHORT<\/CODE>,\n     * or <CODE>DataBuffer.TYPE_INT<\/CODE>.\n     * @throws ClassCastException If <CODE>pixel<\/CODE> is not a primitive\n     * array of type <CODE>transferType<\/CODE>.\n     * @throws IllegalArgumentException If the <CODE>components<\/CODE> array is\n     * not null and is not large enough to hold all the color and alpha\n     * components (starting at offset), or if <CODE>pixel<\/CODE> is not large\n     * enough to hold a pixel value for this ColorModel.\n     */\n    public int[] getComponents(Object pixel, int[] components, int offset) {\n        int intpixel[];\n        if (needScaleInit) {\n            initScale();\n        }\n        if (noUnnorm) {\n            throw new\n                IllegalArgumentException(\n                    \"This ColorModel does not support the unnormalized form\");\n        }\n        if (pixel instanceof int[]) {\n            intpixel = (int[])pixel;\n        } else {\n            intpixel = DataBuffer.toIntArray(pixel);\n            if (intpixel == null) {\n               throw new UnsupportedOperationException(\"This method has not been \"+\n                   \"implemented for transferType \" + transferType);\n            }\n        }\n        if (intpixel.length < numComponents) {\n            throw new IllegalArgumentException\n                (\"Length of pixel array < number of components in model\");\n        }\n        if (components == null) {\n            components = new int[offset+numComponents];\n        }\n        else if ((components.length-offset) < numComponents) {\n            throw new IllegalArgumentException\n                (\"Length of components array < number of components in model\");\n        }\n        System.arraycopy(intpixel, 0, components, offset, numComponents);\n\n        return components;\n    }"}
{"Number":"482","API Relative Path":"java.awt.image.ComponentColorModel.java-getDataElements(int[]-int-Object)","Corresponding Source":"/**\n     * Returns a data element array representation of a pixel in this\n     * <CODE>ColorModel<\/CODE>, given an array of unnormalized color/alpha\n     * components. This array can then be passed to the <CODE>setDataElements<\/CODE>\n     * method of a <CODE>WritableRaster<\/CODE> object.\n     *\n     * @param components An array of unnormalized color/alpha components.\n     * @param offset The integer offset into the <CODE>components<\/CODE> array.\n     * @param obj The object in which to store the data element array\n     * representation of the pixel. If <CODE>obj<\/CODE> variable is null,\n     * a new array is allocated.  If <CODE>obj<\/CODE> is not null, it must\n     * be a primitive array of type <CODE>transferType<\/CODE>. An\n     * <CODE>ArrayIndexOutOfBoundsException<\/CODE> is thrown if\n     * <CODE>obj<\/CODE> is not large enough to hold a pixel value\n     * for this <CODE>ColorModel<\/CODE>.  Since\n     * <code>ComponentColorModel<\/code> can be subclassed, subclasses\n     * inherit the implementation of this method and if they don't\n     * override it then they throw an exception if they use an\n     * unsupported <code>transferType<\/code>.\n     *\n     * @return The data element array representation of a pixel\n     * in this <CODE>ColorModel<\/CODE>.\n     *\n     * @throws IllegalArgumentException If the components array\n     * is not large enough to hold all the color and alpha components\n     * (starting at offset).\n     * @throws ClassCastException If <CODE>obj<\/CODE> is not null and is not a\n     * primitive  array of type <CODE>transferType<\/CODE>.\n     * @throws ArrayIndexOutOfBoundsException If <CODE>obj<\/CODE> is not large\n     * enough to hold a pixel value for this <CODE>ColorModel<\/CODE>.\n     * @throws IllegalArgumentException If this\n     * <CODE>ComponentColorModel<\/CODE> does not support the unnormalized form\n     * @throws UnsupportedOperationException If the transfer type of\n     * this <CODE>ComponentColorModel<\/CODE>\n     * is not one of the following transfer types:\n     * <CODE>DataBuffer.TYPE_BYTE<\/CODE>, <CODE>DataBuffer.TYPE_USHORT<\/CODE>,\n     * or <CODE>DataBuffer.TYPE_INT<\/CODE>.\n     *\n     * @see WritableRaster#setDataElements\n     * @see SampleModel#setDataElements\n     */\n    public Object getDataElements(int[] components, int offset, Object obj) {\n        if (needScaleInit) {\n            initScale();\n        }\n        if (noUnnorm) {\n            throw new\n                IllegalArgumentException(\n                    \"This ColorModel does not support the unnormalized form\");\n        }\n        if ((components.length-offset) < numComponents) {\n            throw new IllegalArgumentException(\"Component array too small\"+\n                                               \" (should be \"+numComponents);\n        }\n        switch(transferType) {\n        case DataBuffer.TYPE_INT:\n            {\n                int[] pixel;\n                if (obj == null) {\n                    pixel = new int[numComponents];\n                }\n                else {\n                    pixel = (int[]) obj;\n                }\n                System.arraycopy(components, offset, pixel, 0,\n                                 numComponents);\n                return pixel;\n            }\n\n        case DataBuffer.TYPE_BYTE:\n            {\n                byte[] pixel;\n                if (obj == null) {\n                    pixel = new byte[numComponents];\n                }\n                else {\n                    pixel = (byte[]) obj;\n                }\n                for (int i=0; i < numComponents; i++) {\n                    pixel[i] = (byte) (components[offset+i]&0xff);\n                }\n                return pixel;\n            }\n\n        case DataBuffer.TYPE_USHORT:\n            {\n                short[] pixel;\n                if (obj == null) {\n                    pixel = new short[numComponents];\n                }\n                else {\n                    pixel = (short[]) obj;\n                }\n                for (int i=0; i < numComponents; i++) {\n                    pixel[i] = (short) (components[offset+i]&0xffff);\n                }\n                return pixel;\n            }\n\n        default:\n            throw new UnsupportedOperationException(\"This method has not been \"+\n                                        \"implemented for transferType \" +\n                                        transferType);\n        }\n    }"}
{"Number":"483","API Relative Path":"java.awt.image.ComponentSampleModel.java-ComponentSampleModel(int-int-int-int-int-int)","Corresponding Source":"/**\n     * Constructs a ComponentSampleModel with the specified parameters.\n     * The number of bands will be given by the length of the bandOffsets array.\n     * All bands will be stored in the first bank of the DataBuffer.\n     * @param dataType  the data type for storing samples\n     * @param w         the width (in pixels) of the region of\n     *     image data described\n     * @param h         the height (in pixels) of the region of\n     *     image data described\n     * @param pixelStride the pixel stride of the region of image\n     *     data described\n     * @param scanlineStride the line stride of the region of image\n     *     data described\n     * @param bandOffsets the offsets of all bands\n     * @throws IllegalArgumentException if <code>w<\/code> or\n     *         <code>h<\/code> is not greater than 0\n     * @throws IllegalArgumentException if <code>pixelStride<\/code>\n     *         is less than 0\n     * @throws IllegalArgumentException if <code>scanlineStride<\/code>\n     *         is less than 0\n     * @throws IllegalArgumentException if <code>numBands<\/code>\n     *         is less than 1\n     * @throws IllegalArgumentException if the product of <code>w<\/code>\n     *         and <code>h<\/code> is greater than\n     *         <code>Integer.MAX_VALUE<\/code>\n     * @throws IllegalArgumentException if <code>dataType<\/code> is not\n     *         one of the supported data types\n     */\n    public ComponentSampleModel(int dataType,\n                                int w, int h,\n                                int pixelStride,\n                                int scanlineStride,\n                                int bandOffsets[]) {\n        super(dataType, w, h, bandOffsets.length);\n        this.dataType = dataType;\n        this.pixelStride = pixelStride;\n        this.scanlineStride  = scanlineStride;\n        this.bandOffsets = (int[])bandOffsets.clone();\n        numBands = this.bandOffsets.length;\n        if (pixelStride < 0) {\n            throw new IllegalArgumentException(\"Pixel stride must be >= 0\");\n        }\n        // TODO - bug 4296691 - remove this check\n        if (scanlineStride < 0) {\n            throw new IllegalArgumentException(\"Scanline stride must be >= 0\");\n        }\n        if (numBands < 1) {\n            throw new IllegalArgumentException(\"Must have at least one band.\");\n        }\n        if ((dataType < DataBuffer.TYPE_BYTE) ||\n            (dataType > DataBuffer.TYPE_DOUBLE)) {\n            throw new IllegalArgumentException(\"Unsupported dataType.\");\n        }\n        bankIndices = new int[numBands];\n        for (int i=0; i<numBands; i++) {\n            bankIndices[i] = 0;\n        }\n        verify();\n    }"}
{"Number":"484","API Relative Path":"java.awt.image.ComponentSampleModel.java-ComponentSampleModel(int-int-int-int-int-int-int)","Corresponding Source":"/**\n     * Constructs a ComponentSampleModel with the specified parameters.\n     * The number of bands will be given by the length of the bandOffsets array.\n     * Different bands may be stored in different banks of the DataBuffer.\n     *\n     * @param dataType  the data type for storing samples\n     * @param w         the width (in pixels) of the region of\n     *     image data described\n     * @param h         the height (in pixels) of the region of\n     *     image data described\n     * @param pixelStride the pixel stride of the region of image\n     *     data described\n     * @param scanlineStride The line stride of the region of image\n     *     data described\n     * @param bankIndices the bank indices of all bands\n     * @param bandOffsets the band offsets of all bands\n     * @throws IllegalArgumentException if <code>w<\/code> or\n     *         <code>h<\/code> is not greater than 0\n     * @throws IllegalArgumentException if <code>pixelStride<\/code>\n     *         is less than 0\n     * @throws IllegalArgumentException if <code>scanlineStride<\/code>\n     *         is less than 0\n     * @throws IllegalArgumentException if the length of\n     *         <code>bankIndices<\/code> does not equal the length of\n     *         <code>bankOffsets<\/code>\n     * @throws IllegalArgumentException if any of the bank indices\n     *         of <code>bandIndices<\/code> is less than 0\n     * @throws IllegalArgumentException if <code>dataType<\/code> is not\n     *         one of the supported data types\n     */\n    public ComponentSampleModel(int dataType,\n                                int w, int h,\n                                int pixelStride,\n                                int scanlineStride,\n                                int bankIndices[],\n                                int bandOffsets[]) {\n        super(dataType, w, h, bandOffsets.length);\n        this.dataType = dataType;\n        this.pixelStride = pixelStride;\n        this.scanlineStride  = scanlineStride;\n        this.bandOffsets = (int[])bandOffsets.clone();\n        this.bankIndices = (int[]) bankIndices.clone();\n        if (pixelStride < 0) {\n            throw new IllegalArgumentException(\"Pixel stride must be >= 0\");\n        }\n        // TODO - bug 4296691 - remove this check\n        if (scanlineStride < 0) {\n            throw new IllegalArgumentException(\"Scanline stride must be >= 0\");\n        }\n        if ((dataType < DataBuffer.TYPE_BYTE) ||\n            (dataType > DataBuffer.TYPE_DOUBLE)) {\n            throw new IllegalArgumentException(\"Unsupported dataType.\");\n        }\n        int maxBank = this.bankIndices[0];\n        if (maxBank < 0) {\n            throw new IllegalArgumentException(\"Index of bank 0 is less than \"+\n                                               \"0 (\"+maxBank+\")\");\n        }\n        for (int i=1; i < this.bankIndices.length; i++) {\n            if (this.bankIndices[i] > maxBank) {\n                maxBank = this.bankIndices[i];\n            }\n            else if (this.bankIndices[i] < 0) {\n                throw new IllegalArgumentException(\"Index of bank \"+i+\n                                                   \" is less than 0 (\"+\n                                                   maxBank+\")\");\n            }\n        }\n        numBanks         = maxBank+1;\n        numBands         = this.bandOffsets.length;\n        if (this.bandOffsets.length != this.bankIndices.length) {\n            throw new IllegalArgumentException(\"Length of bandOffsets must \"+\n                                               \"equal length of bankIndices.\");\n        }\n        verify();\n    }"}
{"Number":"485","API Relative Path":"java.awt.image.ComponentSampleModel.java-ComponentSampleModel(int-int-int-int-int-int-int)","Corresponding Source":"/**\n     * Constructs a ComponentSampleModel with the specified parameters.\n     * The number of bands will be given by the length of the bandOffsets array.\n     * Different bands may be stored in different banks of the DataBuffer.\n     *\n     * @param dataType  the data type for storing samples\n     * @param w         the width (in pixels) of the region of\n     *     image data described\n     * @param h         the height (in pixels) of the region of\n     *     image data described\n     * @param pixelStride the pixel stride of the region of image\n     *     data described\n     * @param scanlineStride The line stride of the region of image\n     *     data described\n     * @param bankIndices the bank indices of all bands\n     * @param bandOffsets the band offsets of all bands\n     * @throws IllegalArgumentException if <code>w<\/code> or\n     *         <code>h<\/code> is not greater than 0\n     * @throws IllegalArgumentException if <code>pixelStride<\/code>\n     *         is less than 0\n     * @throws IllegalArgumentException if <code>scanlineStride<\/code>\n     *         is less than 0\n     * @throws IllegalArgumentException if the length of\n     *         <code>bankIndices<\/code> does not equal the length of\n     *         <code>bankOffsets<\/code>\n     * @throws IllegalArgumentException if any of the bank indices\n     *         of <code>bandIndices<\/code> is less than 0\n     * @throws IllegalArgumentException if <code>dataType<\/code> is not\n     *         one of the supported data types\n     */\n    public ComponentSampleModel(int dataType,\n                                int w, int h,\n                                int pixelStride,\n                                int scanlineStride,\n                                int bankIndices[],\n                                int bandOffsets[]) {\n        super(dataType, w, h, bandOffsets.length);\n        this.dataType = dataType;\n        this.pixelStride = pixelStride;\n        this.scanlineStride  = scanlineStride;\n        this.bandOffsets = (int[])bandOffsets.clone();\n        this.bankIndices = (int[]) bankIndices.clone();\n        if (pixelStride < 0) {\n            throw new IllegalArgumentException(\"Pixel stride must be >= 0\");\n        }\n        // TODO - bug 4296691 - remove this check\n        if (scanlineStride < 0) {\n            throw new IllegalArgumentException(\"Scanline stride must be >= 0\");\n        }\n        if ((dataType < DataBuffer.TYPE_BYTE) ||\n            (dataType > DataBuffer.TYPE_DOUBLE)) {\n            throw new IllegalArgumentException(\"Unsupported dataType.\");\n        }\n        int maxBank = this.bankIndices[0];\n        if (maxBank < 0) {\n            throw new IllegalArgumentException(\"Index of bank 0 is less than \"+\n                                               \"0 (\"+maxBank+\")\");\n        }\n        for (int i=1; i < this.bankIndices.length; i++) {\n            if (this.bankIndices[i] > maxBank) {\n                maxBank = this.bankIndices[i];\n            }\n            else if (this.bankIndices[i] < 0) {\n                throw new IllegalArgumentException(\"Index of bank \"+i+\n                                                   \" is less than 0 (\"+\n                                                   maxBank+\")\");\n            }\n        }\n        numBanks         = maxBank+1;\n        numBands         = this.bandOffsets.length;\n        if (this.bandOffsets.length != this.bankIndices.length) {\n            throw new IllegalArgumentException(\"Length of bandOffsets must \"+\n                                               \"equal length of bankIndices.\");\n        }\n        verify();\n    }"}
{"Number":"486","API Relative Path":"java.awt.image.ComponentSampleModel.java-createSubsetSampleModel(int)","Corresponding Source":"/**\n     * Creates a new ComponentSampleModel with a subset of the bands\n     * of this ComponentSampleModel.  The new ComponentSampleModel can be\n     * used with any DataBuffer that the existing ComponentSampleModel\n     * can be used with.  The new ComponentSampleModel/DataBuffer\n     * combination will represent an image with a subset of the bands\n     * of the original ComponentSampleModel/DataBuffer combination.\n     * @param bands a subset of bands from this\n     *              <code>ComponentSampleModel<\/code>\n     * @return a <code>ComponentSampleModel<\/code> created with a subset\n     *          of bands from this <code>ComponentSampleModel<\/code>.\n     */\n    public SampleModel createSubsetSampleModel(int bands[]) {\n       if (bands.length > bankIndices.length)\n            throw new RasterFormatException(\"There are only \" +\n                                            bankIndices.length +\n                                            \" bands\");\n        int newBankIndices[] = new int[bands.length];\n        int newBandOffsets[] = new int[bands.length];\n\n        for (int i=0; i<bands.length; i++) {\n            newBankIndices[i] = bankIndices[bands[i]];\n            newBandOffsets[i] = bandOffsets[bands[i]];\n        }\n\n        return new ComponentSampleModel(this.dataType, width, height,\n                                        this.pixelStride,\n                                        this.scanlineStride,\n                                        newBankIndices, newBandOffsets);\n    }"}
{"Number":"487","API Relative Path":"java.awt.image.ComponentSampleModel.java-getDataElements(int-int-Object-DataBuffer)","Corresponding Source":"/**\n     * Returns data for a single pixel in a primitive array of type\n     * <code>TransferType<\/code>.  For a <code>ComponentSampleModel<\/code>,\n     * this is the same as the data type, and samples are returned\n     * one per array element.  Generally, <code>obj<\/code> should\n     * be passed in as <code>null<\/code>, so that the <code>Object<\/code>\n     * is created automatically and is the right primitive data type.\n     * <p>\n     * The following code illustrates transferring data for one pixel from\n     * <code>DataBuffer<\/code> <code>db1<\/code>, whose storage layout is\n     * described by <code>ComponentSampleModel<\/code> <code>csm1<\/code>,\n     * to <code>DataBuffer<\/code> <code>db2<\/code>, whose storage layout\n     * is described by <code>ComponentSampleModel<\/code> <code>csm2<\/code>.\n     * The transfer is usually more efficient than using\n     * <code>getPixel<\/code> and <code>setPixel<\/code>.\n     * <pre>\n     *       ComponentSampleModel csm1, csm2;\n     *       DataBufferInt db1, db2;\n     *       csm2.setDataElements(x, y,\n     *                            csm1.getDataElements(x, y, null, db1), db2);\n     * <\/pre>\n     *\n     * Using <code>getDataElements<\/code> and <code>setDataElements<\/code>\n     * to transfer between two <code>DataBuffer/SampleModel<\/code>\n     * pairs is legitimate if the <code>SampleModel<\/code> objects have\n     * the same number of bands, corresponding bands have the same number of\n     * bits per sample, and the <code>TransferType<\/code>s are the same.\n     * <p>\n     * If <code>obj<\/code> is not <code>null<\/code>, it should be a\n     * primitive array of type <code>TransferType<\/code>.\n     * Otherwise, a <code>ClassCastException<\/code> is thrown.  An\n     * <code>ArrayIndexOutOfBoundsException<\/code> might be thrown if the\n     * coordinates are not in bounds, or if <code>obj<\/code> is not\n     * <code>null<\/code> and is not large enough to hold\n     * the pixel data.\n     *\n     * @param x         the X coordinate of the pixel location\n     * @param y         the Y coordinate of the pixel location\n     * @param obj       if non-<code>null<\/code>, a primitive array\n     *                  in which to return the pixel data\n     * @param data      the <code>DataBuffer<\/code> containing the image data\n     * @return the data of the specified pixel\n     * @see #setDataElements(int, int, Object, DataBuffer)\n     *\n     * @throws NullPointerException if data is null.\n     * @throws ArrayIndexOutOfBoundsException if the coordinates are\n     * not in bounds, or if obj is too small to hold the output.\n     */\n    public Object getDataElements(int x, int y, Object obj, DataBuffer data) {\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n\n        int type = getTransferType();\n        int numDataElems = getNumDataElements();\n        int pixelOffset = y*scanlineStride + x*pixelStride;\n\n        switch(type) {\n\n        case DataBuffer.TYPE_BYTE:\n\n            byte[] bdata;\n\n            if (obj == null)\n                bdata = new byte[numDataElems];\n            else\n                bdata = (byte[])obj;\n\n            for (int i=0; i<numDataElems; i++) {\n                bdata[i] = (byte)data.getElem(bankIndices[i],\n                                              pixelOffset + bandOffsets[i]);\n            }\n\n            obj = (Object)bdata;\n            break;\n\n        case DataBuffer.TYPE_USHORT:\n        case DataBuffer.TYPE_SHORT:\n\n            short[] sdata;\n\n            if (obj == null)\n                sdata = new short[numDataElems];\n            else\n                sdata = (short[])obj;\n\n            for (int i=0; i<numDataElems; i++) {\n                sdata[i] = (short)data.getElem(bankIndices[i],\n                                               pixelOffset + bandOffsets[i]);\n            }\n\n            obj = (Object)sdata;\n            break;\n\n        case DataBuffer.TYPE_INT:\n\n            int[] idata;\n\n            if (obj == null)\n                idata = new int[numDataElems];\n            else\n                idata = (int[])obj;\n\n            for (int i=0; i<numDataElems; i++) {\n                idata[i] = data.getElem(bankIndices[i],\n                                        pixelOffset + bandOffsets[i]);\n            }\n\n            obj = (Object)idata;\n            break;\n\n        case DataBuffer.TYPE_FLOAT:\n\n            float[] fdata;\n\n            if (obj == null)\n                fdata = new float[numDataElems];\n            else\n                fdata = (float[])obj;\n\n            for (int i=0; i<numDataElems; i++) {\n                fdata[i] = data.getElemFloat(bankIndices[i],\n                                             pixelOffset + bandOffsets[i]);\n            }\n\n            obj = (Object)fdata;\n            break;\n\n        case DataBuffer.TYPE_DOUBLE:\n\n            double[] ddata;\n\n            if (obj == null)\n                ddata = new double[numDataElems];\n            else\n                ddata = (double[])obj;\n\n            for (int i=0; i<numDataElems; i++) {\n                ddata[i] = data.getElemDouble(bankIndices[i],\n                                              pixelOffset + bandOffsets[i]);\n            }\n\n            obj = (Object)ddata;\n            break;\n        }\n\n        return obj;\n    }"}
{"Number":"488","API Relative Path":"java.awt.image.ComponentSampleModel.java-getPixel(int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Returns all samples for the specified pixel in an int array,\n     * one sample per array element.\n     * An <code>ArrayIndexOutOfBoundsException<\/code> might be thrown if\n     * the coordinates are not in bounds.\n     * @param x         the X coordinate of the pixel location\n     * @param y         the Y coordinate of the pixel location\n     * @param iArray    If non-null, returns the samples in this array\n     * @param data      The DataBuffer containing the image data\n     * @return the samples of the specified pixel.\n     * @see #setPixel(int, int, int[], DataBuffer)\n     *\n     * @throws NullPointerException if data is null.\n     * @throws ArrayIndexOutOfBoundsException if the coordinates are\n     * not in bounds, or if iArray is too small to hold the output.\n     */\n    public int[] getPixel(int x, int y, int iArray[], DataBuffer data) {\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int pixels[];\n        if (iArray != null) {\n           pixels = iArray;\n        } else {\n           pixels = new int [numBands];\n        }\n        int pixelOffset = y*scanlineStride + x*pixelStride;\n        for (int i=0; i<numBands; i++) {\n            pixels[i] = data.getElem(bankIndices[i],\n                                     pixelOffset + bandOffsets[i]);\n        }\n        return pixels;\n    }"}
{"Number":"489","API Relative Path":"java.awt.image.ComponentSampleModel.java-getPixels(int-int-int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Returns all samples for the specified rectangle of pixels in\n     * an int array, one sample per array element.\n     * An <code>ArrayIndexOutOfBoundsException<\/code> might be thrown if\n     * the coordinates are not in bounds.\n     * @param x         The X coordinate of the upper left pixel location\n     * @param y         The Y coordinate of the upper left pixel location\n     * @param w         The width of the pixel rectangle\n     * @param h         The height of the pixel rectangle\n     * @param iArray    If non-null, returns the samples in this array\n     * @param data      The DataBuffer containing the image data\n     * @return the samples of the pixels within the specified region.\n     * @see #setPixels(int, int, int, int, int[], DataBuffer)\n     */\n    public int[] getPixels(int x, int y, int w, int h,\n                           int iArray[], DataBuffer data) {\n        int x1 = x + w;\n        int y1 = y + h;\n\n        if (x < 0 || x >= width || w > width || x1 < 0 || x1 > width ||\n            y < 0 || y >= height || y > height || y1 < 0 || y1 >  height)\n        {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int pixels[];\n        if (iArray != null) {\n           pixels = iArray;\n        } else {\n           pixels = new int [w*h*numBands];\n        }\n        int lineOffset = y*scanlineStride + x*pixelStride;\n        int srcOffset = 0;\n\n        for (int i = 0; i < h; i++) {\n           int pixelOffset = lineOffset;\n           for (int j = 0; j < w; j++) {\n              for (int k=0; k < numBands; k++) {\n                 pixels[srcOffset++] =\n                    data.getElem(bankIndices[k], pixelOffset + bandOffsets[k]);\n              }\n              pixelOffset += pixelStride;\n           }\n           lineOffset += scanlineStride;\n        }\n        return pixels;\n    }"}
{"Number":"490","API Relative Path":"java.awt.image.ComponentSampleModel.java-getSample(int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Returns as int the sample in a specified band for the pixel\n     * located at (x,y).\n     * An <code>ArrayIndexOutOfBoundsException<\/code> might be thrown if\n     * the coordinates are not in bounds.\n     * @param x         the X coordinate of the pixel location\n     * @param y         the Y coordinate of the pixel location\n     * @param b         the band to return\n     * @param data      the <code>DataBuffer<\/code> containing the image data\n     * @return the sample in a specified band for the specified pixel\n     * @see #setSample(int, int, int, int, DataBuffer)\n     */\n    public int getSample(int x, int y, int b, DataBuffer data) {\n        // Bounds check for 'b' will be performed automatically\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int sample = data.getElem(bankIndices[b],\n                                  y*scanlineStride + x*pixelStride +\n                                  bandOffsets[b]);\n        return sample;\n    }"}
{"Number":"491","API Relative Path":"java.awt.image.ComponentSampleModel.java-getSampleDouble(int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Returns the sample in a specified band\n     * for a pixel located at (x,y) as a double.\n     * An <code>ArrayIndexOutOfBoundsException<\/code> might be\n     * thrown if the coordinates are not in bounds.\n     * @param x         The X coordinate of the pixel location\n     * @param y         The Y coordinate of the pixel location\n     * @param b         The band to return\n     * @param data      The DataBuffer containing the image data\n     * @return a double value representing the sample in the specified\n     * band for the specified pixel.\n     */\n    public double getSampleDouble(int x, int y, int b, DataBuffer data) {\n        // Bounds check for 'b' will be performed automatically\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n\n        double sample = data.getElemDouble(bankIndices[b],\n                                           y*scanlineStride + x*pixelStride +\n                                           bandOffsets[b]);\n        return sample;\n    }"}
{"Number":"492","API Relative Path":"java.awt.image.ComponentSampleModel.java-getSampleFloat(int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Returns the sample in a specified band\n     * for the pixel located at (x,y) as a float.\n     * An <code>ArrayIndexOutOfBoundsException<\/code> might be\n     * thrown if the coordinates are not in bounds.\n     * @param x         The X coordinate of the pixel location\n     * @param y         The Y coordinate of the pixel location\n     * @param b         The band to return\n     * @param data      The DataBuffer containing the image data\n     * @return a float value representing the sample in the specified\n     * band for the specified pixel.\n     */\n    public float getSampleFloat(int x, int y, int b, DataBuffer data) {\n        // Bounds check for 'b' will be performed automatically\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n\n        float sample = data.getElemFloat(bankIndices[b],\n                                         y*scanlineStride + x*pixelStride +\n                                         bandOffsets[b]);\n        return sample;\n    }"}
{"Number":"493","API Relative Path":"java.awt.image.ComponentSampleModel.java-getSamples(int-int-int-int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Returns the samples in a specified band for the specified rectangle\n     * of pixels in an int array, one sample per data array element.\n     * An <code>ArrayIndexOutOfBoundsException<\/code> might be thrown if\n     * the coordinates are not in bounds.\n     * @param x         The X coordinate of the upper left pixel location\n     * @param y         The Y coordinate of the upper left pixel location\n     * @param w         the width of the pixel rectangle\n     * @param h         the height of the pixel rectangle\n     * @param b         the band to return\n     * @param iArray    if non-<code>null<\/code>, returns the samples\n     *                  in this array\n     * @param data      the <code>DataBuffer<\/code> containing the image data\n     * @return the samples in the specified band of the specified pixel\n     * @see #setSamples(int, int, int, int, int, int[], DataBuffer)\n     */\n    public int[] getSamples(int x, int y, int w, int h, int b,\n                            int iArray[], DataBuffer data) {\n        // Bounds check for 'b' will be performed automatically\n        if ((x < 0) || (y < 0) || (x + w > width) || (y + h > height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int samples[];\n        if (iArray != null) {\n           samples = iArray;\n        } else {\n           samples = new int [w*h];\n        }\n        int lineOffset = y*scanlineStride + x*pixelStride +  bandOffsets[b];\n        int srcOffset = 0;\n\n        for (int i = 0; i < h; i++) {\n           int sampleOffset = lineOffset;\n           for (int j = 0; j < w; j++) {\n              samples[srcOffset++] = data.getElem(bankIndices[b],\n                                                  sampleOffset);\n              sampleOffset += pixelStride;\n           }\n           lineOffset += scanlineStride;\n        }\n        return samples;\n    }"}
{"Number":"494","API Relative Path":"java.awt.image.ComponentSampleModel.java-setDataElements(int-int-Object-DataBuffer)","Corresponding Source":"/**\n     * Sets the data for a single pixel in the specified\n     * <code>DataBuffer<\/code> from a primitive array of type\n     * <code>TransferType<\/code>.  For a <code>ComponentSampleModel<\/code>,\n     * this is the same as the data type, and samples are transferred\n     * one per array element.\n     * <p>\n     * The following code illustrates transferring data for one pixel from\n     * <code>DataBuffer<\/code> <code>db1<\/code>, whose storage layout is\n     * described by <code>ComponentSampleModel<\/code> <code>csm1<\/code>,\n     * to <code>DataBuffer<\/code> <code>db2<\/code>, whose storage layout\n     * is described by <code>ComponentSampleModel<\/code> <code>csm2<\/code>.\n     * The transfer is usually more efficient than using\n     * <code>getPixel<\/code> and <code>setPixel<\/code>.\n     * <pre>\n     *       ComponentSampleModel csm1, csm2;\n     *       DataBufferInt db1, db2;\n     *       csm2.setDataElements(x, y, csm1.getDataElements(x, y, null, db1),\n     *                            db2);\n     * <\/pre>\n     * Using <code>getDataElements<\/code> and <code>setDataElements<\/code>\n     * to transfer between two <code>DataBuffer/SampleModel<\/code> pairs\n     * is legitimate if the <code>SampleModel<\/code> objects have\n     * the same number of bands, corresponding bands have the same number of\n     * bits per sample, and the <code>TransferType<\/code>s are the same.\n     * <p>\n     * A <code>ClassCastException<\/code> is thrown if <code>obj<\/code> is not\n     * a primitive array of type <code>TransferType<\/code>.\n     * An <code>ArrayIndexOutOfBoundsException<\/code> might be thrown if\n     * the coordinates are not in bounds, or if <code>obj<\/code> is not large\n     * enough to hold the pixel data.\n     * @param x         the X coordinate of the pixel location\n     * @param y         the Y coordinate of the pixel location\n     * @param obj       a primitive array containing pixel data\n     * @param data      the DataBuffer containing the image data\n     * @see #getDataElements(int, int, Object, DataBuffer)\n     */\n    public void setDataElements(int x, int y, Object obj, DataBuffer data) {\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n\n        int type = getTransferType();\n        int numDataElems = getNumDataElements();\n        int pixelOffset = y*scanlineStride + x*pixelStride;\n\n        switch(type) {\n\n        case DataBuffer.TYPE_BYTE:\n\n            byte[] barray = (byte[])obj;\n\n            for (int i=0; i<numDataElems; i++) {\n                data.setElem(bankIndices[i], pixelOffset + bandOffsets[i],\n                           ((int)barray[i])&0xff);\n            }\n            break;\n\n        case DataBuffer.TYPE_USHORT:\n        case DataBuffer.TYPE_SHORT:\n\n            short[] sarray = (short[])obj;\n\n            for (int i=0; i<numDataElems; i++) {\n                data.setElem(bankIndices[i], pixelOffset + bandOffsets[i],\n                           ((int)sarray[i])&0xffff);\n            }\n            break;\n\n        case DataBuffer.TYPE_INT:\n\n            int[] iarray = (int[])obj;\n\n            for (int i=0; i<numDataElems; i++) {\n                data.setElem(bankIndices[i],\n                             pixelOffset + bandOffsets[i], iarray[i]);\n            }\n            break;\n\n        case DataBuffer.TYPE_FLOAT:\n\n            float[] farray = (float[])obj;\n\n            for (int i=0; i<numDataElems; i++) {\n                data.setElemFloat(bankIndices[i],\n                             pixelOffset + bandOffsets[i], farray[i]);\n            }\n            break;\n\n        case DataBuffer.TYPE_DOUBLE:\n\n            double[] darray = (double[])obj;\n\n            for (int i=0; i<numDataElems; i++) {\n                data.setElemDouble(bankIndices[i],\n                             pixelOffset + bandOffsets[i], darray[i]);\n            }\n            break;\n\n        }\n    }"}
{"Number":"495","API Relative Path":"java.awt.image.ComponentSampleModel.java-setPixel(int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Sets a pixel in the <code>DataBuffer<\/code> using an int array of\n     * samples for input.  An <code>ArrayIndexOutOfBoundsException<\/code>\n     * might be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the pixel location\n     * @param y         The Y coordinate of the pixel location\n     * @param iArray    The input samples in an int array\n     * @param data      The DataBuffer containing the image data\n     * @see #getPixel(int, int, int[], DataBuffer)\n     */\n    public void setPixel(int x, int y, int iArray[], DataBuffer data) {\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n       int pixelOffset = y*scanlineStride + x*pixelStride;\n       for (int i=0; i<numBands; i++) {\n           data.setElem(bankIndices[i],\n                        pixelOffset + bandOffsets[i],iArray[i]);\n       }\n    }"}
{"Number":"496","API Relative Path":"java.awt.image.ComponentSampleModel.java-setPixels(int-int-int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Sets all samples for a rectangle of pixels from an int array containing\n     * one sample per array element.\n     * An <code>ArrayIndexOutOfBoundsException<\/code> might be thrown if the\n     * coordinates are not in bounds.\n     * @param x         The X coordinate of the upper left pixel location\n     * @param y         The Y coordinate of the upper left pixel location\n     * @param w         The width of the pixel rectangle\n     * @param h         The height of the pixel rectangle\n     * @param iArray    The input samples in an int array\n     * @param data      The DataBuffer containing the image data\n     * @see #getPixels(int, int, int, int, int[], DataBuffer)\n     */\n    public void setPixels(int x, int y, int w, int h,\n                          int iArray[], DataBuffer data) {\n        int x1 = x + w;\n        int y1 = y + h;\n\n        if (x < 0 || x >= width || w > width || x1 < 0 || x1 > width ||\n            y < 0 || y >= height || h > height || y1 < 0 || y1 >  height)\n        {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n\n        int lineOffset = y*scanlineStride + x*pixelStride;\n        int srcOffset = 0;\n\n        for (int i = 0; i < h; i++) {\n           int pixelOffset = lineOffset;\n           for (int j = 0; j < w; j++) {\n              for (int k=0; k < numBands; k++) {\n                 data.setElem(bankIndices[k], pixelOffset + bandOffsets[k],\n                              iArray[srcOffset++]);\n              }\n              pixelOffset += pixelStride;\n           }\n           lineOffset += scanlineStride;\n        }\n    }"}
{"Number":"497","API Relative Path":"java.awt.image.ComponentSampleModel.java-setSample(int-int-int-double-DataBuffer)","Corresponding Source":"/**\n     * Sets a sample in the specified band for the pixel located at (x,y)\n     * in the <code>DataBuffer<\/code> using a double for input.\n     * An <code>ArrayIndexOutOfBoundsException<\/code> might be thrown if\n     * the coordinates are not in bounds.\n     * @param x         The X coordinate of the pixel location\n     * @param y         The Y coordinate of the pixel location\n     * @param b         The band to set\n     * @param s         The input sample as a double\n     * @param data      The DataBuffer containing the image data\n     * @see #getSample(int, int, int, DataBuffer)\n     */\n    public void setSample(int x, int y, int b,\n                          double s,\n                          DataBuffer data) {\n        // Bounds check for 'b' will be performed automatically\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        data.setElemDouble(bankIndices[b],\n                          y*scanlineStride + x*pixelStride + bandOffsets[b],\n                          s);\n    }"}
{"Number":"498","API Relative Path":"java.awt.image.ComponentSampleModel.java-setSample(int-int-int-float-DataBuffer)","Corresponding Source":"/**\n     * Sets a sample in the specified band for the pixel located at (x,y)\n     * in the <code>DataBuffer<\/code> using a float for input.\n     * An <code>ArrayIndexOutOfBoundsException<\/code> might be thrown if\n     * the coordinates are not in bounds.\n     * @param x         The X coordinate of the pixel location\n     * @param y         The Y coordinate of the pixel location\n     * @param b         The band to set\n     * @param s         The input sample as a float\n     * @param data      The DataBuffer containing the image data\n     * @see #getSample(int, int, int, DataBuffer)\n     */\n    public void setSample(int x, int y, int b,\n                          float s ,\n                          DataBuffer data) {\n        // Bounds check for 'b' will be performed automatically\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        data.setElemFloat(bankIndices[b],\n                          y*scanlineStride + x*pixelStride + bandOffsets[b],\n                          s);\n    }"}
{"Number":"499","API Relative Path":"java.awt.image.ComponentSampleModel.java-setSample(int-int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Sets a sample in the specified band for the pixel located at (x,y)\n     * in the <code>DataBuffer<\/code> using an int for input.\n     * An <code>ArrayIndexOutOfBoundsException<\/code> might be thrown if the\n     * coordinates are not in bounds.\n     * @param x         The X coordinate of the pixel location\n     * @param y         The Y coordinate of the pixel location\n     * @param b         the band to set\n     * @param s         the input sample as an int\n     * @param data      the DataBuffer containing the image data\n     * @see #getSample(int, int, int, DataBuffer)\n     */\n    public void setSample(int x, int y, int b, int s,\n                          DataBuffer data) {\n        // Bounds check for 'b' will be performed automatically\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        data.setElem(bankIndices[b],\n                     y*scanlineStride + x*pixelStride + bandOffsets[b], s);\n    }"}
{"Number":"500","API Relative Path":"java.awt.image.ComponentSampleModel.java-setSamples(int-int-int-int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Sets the samples in the specified band for the specified rectangle\n     * of pixels from an int array containing one sample per data array element.\n     * An <code>ArrayIndexOutOfBoundsException<\/code> might be thrown if the\n     * coordinates are not in bounds.\n     * @param x         The X coordinate of the upper left pixel location\n     * @param y         The Y coordinate of the upper left pixel location\n     * @param w         The width of the pixel rectangle\n     * @param h         The height of the pixel rectangle\n     * @param b         The band to set\n     * @param iArray    The input samples in an int array\n     * @param data      The DataBuffer containing the image data\n     * @see #getSamples(int, int, int, int, int, int[], DataBuffer)\n     */\n    public void setSamples(int x, int y, int w, int h, int b,\n                           int iArray[], DataBuffer data) {\n        // Bounds check for 'b' will be performed automatically\n        if ((x < 0) || (y < 0) || (x + w > width) || (y + h > height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int lineOffset = y*scanlineStride + x*pixelStride + bandOffsets[b];\n        int srcOffset = 0;\n\n        for (int i = 0; i < h; i++) {\n           int sampleOffset = lineOffset;\n           for (int j = 0; j < w; j++) {\n              data.setElem(bankIndices[b], sampleOffset, iArray[srcOffset++]);\n              sampleOffset += pixelStride;\n           }\n           lineOffset += scanlineStride;\n        }\n    }"}
{"Number":"501","API Relative Path":"java.awt.image.ConvolveOp.java-createCompatibleDestImage(BufferedImage-ColorModel)","Corresponding Source":"/**\n     * Creates a zeroed destination image with the correct size and number\n     * of bands.  If destCM is null, an appropriate ColorModel will be used.\n     * @param src       Source image for the filter operation.\n     * @param destCM    ColorModel of the destination.  Can be null.\n     * @return a destination <code>BufferedImage<\/code> with the correct\n     *         size and number of bands.\n     */\n    public BufferedImage createCompatibleDestImage(BufferedImage src,\n                                                   ColorModel destCM) {\n        BufferedImage image;\n\n        int w = src.getWidth();\n        int h = src.getHeight();\n\n        WritableRaster wr = null;\n\n        if (destCM == null) {\n            destCM = src.getColorModel();\n            // Not much support for ICM\n            if (destCM instanceof IndexColorModel) {\n                destCM = ColorModel.getRGBdefault();\n            } else {\n                /* Create destination image as similar to the source\n                 *  as it possible...\n                 */\n                wr = src.getData().createCompatibleWritableRaster(w, h);\n            }\n        }\n\n        if (wr == null) {\n            /* This is the case when destination color model\n             * was explicitly specified (and it may be not compatible\n             * with source raster structure) or source is indexed image.\n             * We should use destination color model to create compatible\n             * destination raster here.\n             */\n            wr = destCM.createCompatibleWritableRaster(w, h);\n        }\n\n        image = new BufferedImage (destCM, wr,\n                                   destCM.isAlphaPremultiplied(), null);\n\n        return image;\n    }"}
{"Number":"502","API Relative Path":"java.awt.image.DataBuffer.java-DataBuffer(State-int-int-int-int)","Corresponding Source":"/**\n     *  Constructs a DataBuffer which contains the specified number\n     *  of banks with the indicated initial {@link State State}.\n     *  Each bank has the specified datatype and size.  The\n     *  offset for each bank is specified by its respective entry in\n     *  the offsets array.\n     *\n     *  @param initialState the initial {@link State State} state of the data\n     *  @param dataType the data type of this <code>DataBuffer<\/code>\n     *  @param size the size of the banks\n     *  @param numBanks the number of banks in this\n     *         <code>DataBuffer<\/code>\n     *  @param offsets an array containing an offset for each bank.\n     *  @throws ArrayIndexOutOfBoundsException if <code>numBanks<\/code>\n     *          does not equal the length of <code>offsets<\/code>\n     *  @since 1.7\n     */\n    DataBuffer(State initialState,\n               int dataType, int size, int numBanks, int offsets[])\n    {\n        if (numBanks != offsets.length) {\n            throw new ArrayIndexOutOfBoundsException(\"Number of banks\" +\n                 \" does not match number of bank offsets\");\n        }\n        this.theTrackable = StateTrackableDelegate.createInstance(initialState);\n        this.dataType = dataType;\n        this.banks = numBanks;\n        this.size = size;\n        this.offset = offsets[0];\n        this.offsets = (int[])offsets.clone();\n    }"}
{"Number":"503","API Relative Path":"java.awt.image.DataBuffer.java-getDataTypeSize(int)","Corresponding Source":"/** Returns the size (in bits) of the data type, given a datatype tag.\n      * @param type the value of one of the defined datatype tags\n      * @return the size of the data type\n      * @throws IllegalArgumentException if <code>type<\/code> is less than\n      *         zero or greater than {@link #TYPE_DOUBLE}\n      */\n    public static int getDataTypeSize(int type) {\n        if (type < TYPE_BYTE || type > TYPE_DOUBLE) {\n            throw new IllegalArgumentException(\"Unknown data type \"+type);\n        }\n        return dataTypeSize[type];\n    }"}
{"Number":"504","API Relative Path":"java.awt.image.DataBufferUShort.java-DataBufferUShort(short-int)","Corresponding Source":"/**\n     * Constructs an unsigned-short based <CODE>DataBuffer<\/CODE> with the specified arrays.\n     * The number of banks will be equal to <CODE>dataArray.length<\/CODE>.\n     * Only the first <CODE>size<\/CODE> elements of each array should be used by\n     * accessors of this <CODE>DataBuffer<\/CODE>.\n     * <p>\n     * Note that {@code DataBuffer} objects created by this constructor\n     * may be incompatible with <a href=\"#optimizations\">performance\n     * optimizations<\/a> used by some implementations (such as caching\n     * an associated image in video memory).\n     *\n     * @param dataArray The unsigned-short arrays for the <CODE>DataBuffer<\/CODE>.\n     * @param size The size of the banks in the <CODE>DataBuffer<\/CODE>.\n     */\n    public DataBufferUShort(short dataArray[][], int size) {\n        super(UNTRACKABLE, TYPE_USHORT, size, dataArray.length);\n        if (dataArray == null) {\n            throw new NullPointerException(\"dataArray is null\");\n        }\n        for (int i=0; i < dataArray.length; i++) {\n            if (dataArray[i] == null) {\n                throw new NullPointerException(\"dataArray[\"+i+\"] is null\");\n            }\n        }\n\n        bankdata = (short[][]) dataArray.clone();\n        data = bankdata[0];\n    }"}
{"Number":"505","API Relative Path":"java.awt.image.DataBufferUShort.java-DataBufferUShort(short-int-int)","Corresponding Source":"/**\n     * Constructs an unsigned-short based <CODE>DataBuffer<\/CODE> with specified arrays,\n     * size, and offsets.\n     * The number of banks is equal to <CODE>dataArray.length<\/CODE>.  Each array must\n     * be at least as large as <CODE>size<\/CODE> + the corresponding offset.   There must\n     * be an entry in the offset array for each <CODE>dataArray<\/CODE> entry.  For each\n     * bank, only elements <CODE>offset<\/CODE> through\n     * <CODE>offset<\/CODE> + <CODE>size<\/CODE> - 1 should be\n     * used by accessors of this <CODE>DataBuffer<\/CODE>.\n     * <p>\n     * Note that {@code DataBuffer} objects created by this constructor\n     * may be incompatible with <a href=\"#optimizations\">performance\n     * optimizations<\/a> used by some implementations (such as caching\n     * an associated image in video memory).\n     *\n     * @param dataArray The unsigned-short arrays for the <CODE>DataBuffer<\/CODE>.\n     * @param size The size of the banks in the <CODE>DataBuffer<\/CODE>.\n     * @param offsets The offsets into each array.\n     */\n    public DataBufferUShort(short dataArray[][], int size, int offsets[]) {\n        super(UNTRACKABLE, TYPE_USHORT, size, dataArray.length, offsets);\n        if (dataArray == null) {\n            throw new NullPointerException(\"dataArray is null\");\n        }\n        for (int i=0; i < dataArray.length; i++) {\n            if (dataArray[i] == null) {\n                throw new NullPointerException(\"dataArray[\"+i+\"] is null\");\n            }\n            if ((size+offsets[i]) > dataArray[i].length) {\n                throw new IllegalArgumentException(\"Length of dataArray[\"+i+\n                                                   \"] is less than size+\"+\n                                                   \"offsets[\"+i+\"].\");\n            }\n\n        }\n        bankdata = (short[][]) dataArray.clone();\n        data = bankdata[0];\n    }"}
{"Number":"506","API Relative Path":"java.awt.image.DataBufferUShort.java-DataBufferUShort(short-int-int)","Corresponding Source":"/**\n     * Constructs an unsigned-short based <CODE>DataBuffer<\/CODE> with specified arrays,\n     * size, and offsets.\n     * The number of banks is equal to <CODE>dataArray.length<\/CODE>.  Each array must\n     * be at least as large as <CODE>size<\/CODE> + the corresponding offset.   There must\n     * be an entry in the offset array for each <CODE>dataArray<\/CODE> entry.  For each\n     * bank, only elements <CODE>offset<\/CODE> through\n     * <CODE>offset<\/CODE> + <CODE>size<\/CODE> - 1 should be\n     * used by accessors of this <CODE>DataBuffer<\/CODE>.\n     * <p>\n     * Note that {@code DataBuffer} objects created by this constructor\n     * may be incompatible with <a href=\"#optimizations\">performance\n     * optimizations<\/a> used by some implementations (such as caching\n     * an associated image in video memory).\n     *\n     * @param dataArray The unsigned-short arrays for the <CODE>DataBuffer<\/CODE>.\n     * @param size The size of the banks in the <CODE>DataBuffer<\/CODE>.\n     * @param offsets The offsets into each array.\n     */\n    public DataBufferUShort(short dataArray[][], int size, int offsets[]) {\n        super(UNTRACKABLE, TYPE_USHORT, size, dataArray.length, offsets);\n        if (dataArray == null) {\n            throw new NullPointerException(\"dataArray is null\");\n        }\n        for (int i=0; i < dataArray.length; i++) {\n            if (dataArray[i] == null) {\n                throw new NullPointerException(\"dataArray[\"+i+\"] is null\");\n            }\n            if ((size+offsets[i]) > dataArray[i].length) {\n                throw new IllegalArgumentException(\"Length of dataArray[\"+i+\n                                                   \"] is less than size+\"+\n                                                   \"offsets[\"+i+\"].\");\n            }\n\n        }\n        bankdata = (short[][]) dataArray.clone();\n        data = bankdata[0];\n    }"}
{"Number":"507","API Relative Path":"java.awt.image.DirectColorModel.java-createCompatibleWritableRaster(int-int)","Corresponding Source":"/**\n     * Creates a <code>WritableRaster<\/code> with the specified width and\n     * height that has a data layout (<code>SampleModel<\/code>) compatible\n     * with this <code>ColorModel<\/code>.\n     * @param w the width to apply to the new <code>WritableRaster<\/code>\n     * @param h the height to apply to the new <code>WritableRaster<\/code>\n     * @return a <code>WritableRaster<\/code> object with the specified\n     * width and height.\n     * @throws IllegalArgumentException if <code>w<\/code> or <code>h<\/code>\n     *         is less than or equal to zero\n     * @see WritableRaster\n     * @see SampleModel\n     */\n    final public WritableRaster createCompatibleWritableRaster (int w,\n                                                                int h) {\n        if ((w <= 0) || (h <= 0)) {\n            throw new IllegalArgumentException(\"Width (\" + w + \") and height (\" + h +\n                                               \") cannot be <= 0\");\n        }\n        int[] bandmasks;\n        if (supportsAlpha) {\n            bandmasks = new int[4];\n            bandmasks[3] = alpha_mask;\n        }\n        else {\n            bandmasks = new int[3];\n        }\n        bandmasks[0] = red_mask;\n        bandmasks[1] = green_mask;\n        bandmasks[2] = blue_mask;\n\n        if (pixel_bits > 16) {\n            return Raster.createPackedRaster(DataBuffer.TYPE_INT,\n                                             w,h,bandmasks,null);\n        }\n        else if (pixel_bits > 8) {\n            return Raster.createPackedRaster(DataBuffer.TYPE_USHORT,\n                                             w,h,bandmasks,null);\n        }\n        else {\n            return Raster.createPackedRaster(DataBuffer.TYPE_BYTE,\n                                             w,h,bandmasks,null);\n        }\n    }"}
{"Number":"508","API Relative Path":"java.awt.image.Kernel.java-getKernelData(float[])","Corresponding Source":"/**\n     * Returns the kernel data in row major order.\n     * The <code>data<\/code> array is returned.  If <code>data<\/code>\n     * is <code>null<\/code>, a new array is allocated.\n     * @param data  if non-null, contains the returned kernel data\n     * @return the <code>data<\/code> array containing the kernel data\n     *         in row major order or, if <code>data<\/code> is\n     *         <code>null<\/code>, a newly allocated array containing\n     *         the kernel data in row major order\n     * @throws IllegalArgumentException if <code>data<\/code> is less\n     *         than the size of this <code>Kernel<\/code>\n     */\n    final public float[] getKernelData(float[] data) {\n        if (data == null) {\n            data = new float[this.data.length];\n        }\n        else if (data.length < this.data.length) {\n            throw new IllegalArgumentException(\"Data array too small \"+\n                                               \"(should be \"+this.data.length+\n                                               \" but is \"+\n                                               data.length+\" )\");\n        }\n        System.arraycopy(this.data, 0, data, 0, this.data.length);\n\n        return data;\n    }"}
{"Number":"509","API Relative Path":"java.awt.image.Kernel.java-Kernel(int-int-float)","Corresponding Source":"/**\n     * Constructs a <code>Kernel<\/code> object from an array of floats.\n     * The first <code>width<\/code>*<code>height<\/code> elements of\n     * the <code>data<\/code> array are copied.\n     * If the length of the <code>data<\/code> array is less\n     * than width*height, an <code>IllegalArgumentException<\/code> is thrown.\n     * The X origin is (width-1)/2 and the Y origin is (height-1)/2.\n     * @param width         width of the kernel\n     * @param height        height of the kernel\n     * @param data          kernel data in row major order\n     * @throws IllegalArgumentException if the length of <code>data<\/code>\n     *         is less than the product of <code>width<\/code> and\n     *         <code>height<\/code>\n     */\n    public Kernel(int width, int height, float data[]) {\n        this.width  = width;\n        this.height = height;\n        this.xOrigin  = (width-1)>>1;\n        this.yOrigin  = (height-1)>>1;\n        int len = width*height;\n        if (data.length < len) {\n            throw new IllegalArgumentException(\"Data array too small \"+\n                                               \"(is \"+data.length+\n                                               \" and should be \"+len);\n        }\n        this.data = new float[len];\n        System.arraycopy(data, 0, this.data, 0, len);\n\n    }"}
{"Number":"510","API Relative Path":"java.awt.image.LookupOp.java-createCompatibleDestImage(BufferedImage-ColorModel)","Corresponding Source":"/**\n     * Creates a zeroed destination image with the correct size and number of\n     * bands.  If destCM is <code>null<\/code>, an appropriate\n     * <code>ColorModel<\/code> will be used.\n     * @param src       Source image for the filter operation.\n     * @param destCM    the destination's <code>ColorModel<\/code>, which\n     *                  can be <code>null<\/code>.\n     * @return a filtered destination <code>BufferedImage<\/code>.\n     */\n    public BufferedImage createCompatibleDestImage (BufferedImage src,\n                                                    ColorModel destCM) {\n        BufferedImage image;\n        int w = src.getWidth();\n        int h = src.getHeight();\n        int transferType = DataBuffer.TYPE_BYTE;\n        if (destCM == null) {\n            ColorModel cm = src.getColorModel();\n            Raster raster = src.getRaster();\n            if (cm instanceof ComponentColorModel) {\n                DataBuffer db = raster.getDataBuffer();\n                boolean hasAlpha = cm.hasAlpha();\n                boolean isPre    = cm.isAlphaPremultiplied();\n                int trans        = cm.getTransparency();\n                int[] nbits = null;\n                if (ltable instanceof ByteLookupTable) {\n                    if (db.getDataType() == db.TYPE_USHORT) {\n                        // Dst raster should be of type byte\n                        if (hasAlpha) {\n                            nbits = new int[2];\n                            if (trans == cm.BITMASK) {\n                                nbits[1] = 1;\n                            }\n                            else {\n                                nbits[1] = 8;\n                            }\n                        }\n                        else {\n                            nbits = new int[1];\n                        }\n                        nbits[0] = 8;\n                    }\n                    // For byte, no need to change the cm\n                }\n                else if (ltable instanceof ShortLookupTable) {\n                    transferType = DataBuffer.TYPE_USHORT;\n                    if (db.getDataType() == db.TYPE_BYTE) {\n                        if (hasAlpha) {\n                            nbits = new int[2];\n                            if (trans == cm.BITMASK) {\n                                nbits[1] = 1;\n                            }\n                            else {\n                                nbits[1] = 16;\n                            }\n                        }\n                        else {\n                            nbits = new int[1];\n                        }\n                        nbits[0] = 16;\n                    }\n                }\n                if (nbits != null) {\n                    cm = new ComponentColorModel(cm.getColorSpace(),\n                                                 nbits, hasAlpha, isPre,\n                                                 trans, transferType);\n                }\n            }\n            image = new BufferedImage(cm,\n                                      cm.createCompatibleWritableRaster(w, h),\n                                      cm.isAlphaPremultiplied(),\n                                      null);\n        }\n        else {\n            image = new BufferedImage(destCM,\n                                      destCM.createCompatibleWritableRaster(w,\n                                                                            h),\n                                      destCM.isAlphaPremultiplied(),\n                                      null);\n        }\n\n        return image;\n    }"}
{"Number":"511","API Relative Path":"java.awt.image.LookupOp.java-filter(Raster-WritableRaster)","Corresponding Source":"/**\n     * Performs a lookup operation on a <code>Raster<\/code>.\n     * If the destination <code>Raster<\/code> is <code>null<\/code>,\n     * a new <code>Raster<\/code> will be created.\n     * The <code>IllegalArgumentException<\/code> might be thrown\n     * if the source <code>Raster<\/code> and the destination\n     * <code>Raster<\/code> do not have the same\n     * number of bands or if the number of arrays in the\n     * <code>LookupTable<\/code> does not meet the\n     * restrictions stated in the class comment above.\n     * @param src the source <code>Raster<\/code> to filter\n     * @param dst the destination <code>WritableRaster<\/code> for the\n     *            filtered <code>src<\/code>\n     * @return the filtered <code>WritableRaster<\/code>.\n     * @throws IllegalArgumentException if the source and destinations\n     *         rasters do not have the same number of bands, or the\n     *         number of arrays in the <code>LookupTable<\/code> does\n     *         not meet the restrictions described in the class comments.\n     *\n     */\n    public final WritableRaster filter (Raster src, WritableRaster dst) {\n        int numBands  = src.getNumBands();\n        int dstLength = dst.getNumBands();\n        int height    = src.getHeight();\n        int width     = src.getWidth();\n        int srcPix[]  = new int[numBands];\n\n        // Create a new destination Raster, if needed\n\n        if (dst == null) {\n            dst = createCompatibleDestRaster(src);\n        }\n        else if (height != dst.getHeight() || width != dst.getWidth()) {\n            throw new\n                IllegalArgumentException (\"Width or height of Rasters do not \"+\n                                          \"match\");\n        }\n        dstLength = dst.getNumBands();\n\n        if (numBands != dstLength) {\n            throw new\n                IllegalArgumentException (\"Number of channels in the src (\"\n                                          + numBands +\n                                          \") does not match number of channels\"\n                                          + \" in the destination (\"\n                                          + dstLength + \")\");\n        }\n        int numComponents = ltable.getNumComponents();\n        if (numComponents != 1 && numComponents != src.getNumBands()) {\n            throw new IllegalArgumentException(\"Number of arrays in the \"+\n                                               \" lookup table (\"+\n                                               numComponents+\n                                               \" is not compatible with the \"+\n                                               \" src Raster: \"+src);\n        }\n\n\n        if (ImagingLib.filter(this, src, dst) != null) {\n            return dst;\n        }\n\n        // Optimize for cases we know about\n        if (ltable instanceof ByteLookupTable) {\n            byteFilter ((ByteLookupTable) ltable, src, dst,\n                        width, height, numBands);\n        }\n        else if (ltable instanceof ShortLookupTable) {\n            shortFilter ((ShortLookupTable) ltable, src, dst, width,\n                         height, numBands);\n        }\n        else {\n            // Not one we recognize so do it slowly\n            int sminX = src.getMinX();\n            int sY = src.getMinY();\n            int dminX = dst.getMinX();\n            int dY = dst.getMinY();\n            for (int y=0; y < height; y++, sY++, dY++) {\n                int sX = sminX;\n                int dX = dminX;\n                for (int x=0; x < width; x++, sX++, dX++) {\n                    // Find data for all bands at this x,y position\n                    src.getPixel(sX, sY, srcPix);\n\n                    // Lookup the data for all bands at this x,y position\n                    ltable.lookupPixel(srcPix, srcPix);\n\n                    // Put it back for all bands\n                    dst.setPixel(dX, dY, srcPix);\n                }\n            }\n        }\n\n        return dst;\n    }"}
{"Number":"512","API Relative Path":"java.awt.image.MultiPixelPackedSampleModel.java-createSubsetSampleModel(int)","Corresponding Source":"/**\n     * Creates a new <code>MultiPixelPackedSampleModel<\/code> with a\n     * subset of the bands of this\n     * <code>MultiPixelPackedSampleModel<\/code>.  Since a\n     * <code>MultiPixelPackedSampleModel<\/code> only has one band, the\n     * bands argument must have a length of one and indicate the zeroth\n     * band.\n     * @param bands the specified bands\n     * @return a new <code>SampleModel<\/code> with a subset of bands of\n     * this <code>MultiPixelPackedSampleModel<\/code>.\n     * @exception RasterFormatException if the number of bands requested\n     * is not one.\n     * @throws IllegalArgumentException if <code>w<\/code> or\n     *         <code>h<\/code> is not greater than 0\n     */\n    public SampleModel createSubsetSampleModel(int bands[]) {\n        if (bands != null) {\n           if (bands.length != 1)\n            throw new RasterFormatException(\"MultiPixelPackedSampleModel has \"\n                                            + \"only one band.\");\n        }\n        SampleModel sm = createCompatibleSampleModel(width, height);\n        return sm;\n    }"}
{"Number":"513","API Relative Path":"java.awt.image.MultiPixelPackedSampleModel.java-getDataElements(int-int-Object-DataBuffer)","Corresponding Source":"/**\n     * Returns data for a single pixel in a primitive array of type\n     * TransferType.  For a <code>MultiPixelPackedSampleModel<\/code>,\n     * the array has one element, and the type is the smallest of\n     * DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT, or DataBuffer.TYPE_INT\n     * that can hold a single pixel.  Generally, <code>obj<\/code>\n     * should be passed in as <code>null<\/code>, so that the\n     * <code>Object<\/code> is created automatically and is the\n     * correct primitive data type.\n     * <p>\n     * The following code illustrates transferring data for one pixel from\n     * <code>DataBuffer<\/code> <code>db1<\/code>, whose storage layout is\n     * described by <code>MultiPixelPackedSampleModel<\/code>\n     * <code>mppsm1<\/code>, to <code>DataBuffer<\/code> <code>db2<\/code>,\n     * whose storage layout is described by\n     * <code>MultiPixelPackedSampleModel<\/code> <code>mppsm2<\/code>.\n     * The transfer is generally more efficient than using\n     * <code>getPixel<\/code> or <code>setPixel<\/code>.\n     * <pre>\n     *       MultiPixelPackedSampleModel mppsm1, mppsm2;\n     *       DataBufferInt db1, db2;\n     *       mppsm2.setDataElements(x, y, mppsm1.getDataElements(x, y, null,\n     *                              db1), db2);\n     * <\/pre>\n     * Using <code>getDataElements<\/code> or <code>setDataElements<\/code>\n     * to transfer between two <code>DataBuffer/SampleModel<\/code> pairs\n     * is legitimate if the <code>SampleModels<\/code> have the same number\n     * of bands, corresponding bands have the same number of\n     * bits per sample, and the TransferTypes are the same.\n     * <p>\n     * If <code>obj<\/code> is not <code>null<\/code>, it should be a\n     * primitive array of type TransferType.  Otherwise, a\n     * <code>ClassCastException<\/code> is thrown.  An\n     * <code>ArrayIndexOutOfBoundsException<\/code> is thrown if the\n     * coordinates are not in bounds, or if <code>obj<\/code> is not\n     * <code>null<\/code> and is not large enough to hold the pixel data.\n     * @param x the X coordinate of the specified pixel\n     * @param y the Y coordinate of the specified pixel\n     * @param obj a primitive array in which to return the pixel data or\n     *          <code>null<\/code>.\n     * @param data the <code>DataBuffer<\/code> containing the image data.\n     * @return an <code>Object<\/code> containing data for the specified\n     *  pixel.\n     * @exception ClassCastException if <code>obj<\/code> is not a\n     *  primitive array of type TransferType or is not <code>null<\/code>\n     * @exception ArrayIndexOutOfBoundsException if the coordinates are\n     * not in bounds, or if <code>obj<\/code> is not <code>null<\/code> or\n     * not large enough to hold the pixel data\n     * @see #setDataElements(int, int, Object, DataBuffer)\n     */\n    public Object getDataElements(int x, int y, Object obj, DataBuffer data) {\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n\n        int type = getTransferType();\n        int bitnum = dataBitOffset + x*pixelBitStride;\n        int shift = dataElementSize - (bitnum & (dataElementSize-1))\n                    - pixelBitStride;\n        int element = 0;\n\n        switch(type) {\n\n        case DataBuffer.TYPE_BYTE:\n\n            byte[] bdata;\n\n            if (obj == null)\n                bdata = new byte[1];\n            else\n                bdata = (byte[])obj;\n\n            element = data.getElem(y*scanlineStride +\n                                    bitnum/dataElementSize);\n            bdata[0] = (byte)((element >> shift) & bitMask);\n\n            obj = (Object)bdata;\n            break;\n\n        case DataBuffer.TYPE_USHORT:\n\n            short[] sdata;\n\n            if (obj == null)\n                sdata = new short[1];\n            else\n                sdata = (short[])obj;\n\n            element = data.getElem(y*scanlineStride +\n                                   bitnum/dataElementSize);\n            sdata[0] = (short)((element >> shift) & bitMask);\n\n            obj = (Object)sdata;\n            break;\n\n        case DataBuffer.TYPE_INT:\n\n            int[] idata;\n\n            if (obj == null)\n                idata = new int[1];\n            else\n                idata = (int[])obj;\n\n            element = data.getElem(y*scanlineStride +\n                                   bitnum/dataElementSize);\n            idata[0] = (element >> shift) & bitMask;\n\n            obj = (Object)idata;\n            break;\n        }\n\n        return obj;\n    }"}
{"Number":"514","API Relative Path":"java.awt.image.MultiPixelPackedSampleModel.java-getPixel(int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Returns the specified single band pixel in the first element\n     * of an <code>int<\/code> array.\n     * <code>ArrayIndexOutOfBoundsException<\/code> is thrown if the\n     * coordinates are not in bounds.\n     * @param x the X coordinate of the specified pixel\n     * @param y the Y coordinate of the specified pixel\n     * @param iArray the array containing the pixel to be returned or\n     *  <code>null<\/code>\n     * @param data the <code>DataBuffer<\/code> where image data is stored\n     * @return an array containing the specified pixel.\n     * @exception ArrayIndexOutOfBoundsException if the coordinates\n     *  are not in bounds\n     * @see #setPixel(int, int, int[], DataBuffer)\n     */\n    public int[] getPixel(int x, int y, int iArray[], DataBuffer data) {\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int pixels[];\n        if (iArray != null) {\n           pixels = iArray;\n        } else {\n           pixels = new int [numBands];\n        }\n        int bitnum = dataBitOffset + x*pixelBitStride;\n        int element = data.getElem(y*scanlineStride + bitnum/dataElementSize);\n        int shift = dataElementSize - (bitnum & (dataElementSize-1))\n                    - pixelBitStride;\n        pixels[0] = (element >> shift) & bitMask;\n        return pixels;\n    }"}
{"Number":"515","API Relative Path":"java.awt.image.MultiPixelPackedSampleModel.java-getSample(int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Returns as <code>int<\/code> the sample in a specified band for the\n     * pixel located at (x,&nbsp;y).  An\n     * <code>ArrayIndexOutOfBoundsException<\/code> is thrown if the\n     * coordinates are not in bounds.\n     * @param x         the X coordinate of the specified pixel\n     * @param y         the Y coordinate of the specified pixel\n     * @param b         the band to return, which is assumed to be 0\n     * @param data      the <code>DataBuffer<\/code> containing the image\n     *                  data\n     * @return the specified band containing the sample of the specified\n     * pixel.\n     * @exception ArrayIndexOutOfBoundsException if the specified\n     *          coordinates are not in bounds.\n     * @see #setSample(int, int, int, int, DataBuffer)\n     */\n    public int getSample(int x, int y, int b, DataBuffer data) {\n        // 'b' must be 0\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height) ||\n            (b != 0)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int bitnum = dataBitOffset + x*pixelBitStride;\n        int element = data.getElem(y*scanlineStride + bitnum/dataElementSize);\n        int shift = dataElementSize - (bitnum & (dataElementSize-1))\n                    - pixelBitStride;\n        return (element >> shift) & bitMask;\n    }"}
{"Number":"516","API Relative Path":"java.awt.image.MultiPixelPackedSampleModel.java-MultiPixelPackedSampleModel(int-int-int-int)","Corresponding Source":"/**\n     * Constructs a <code>MultiPixelPackedSampleModel<\/code> with the\n     * specified data type, width, height and number of bits per pixel.\n     * @param dataType  the data type for storing samples\n     * @param w         the width, in pixels, of the region of\n     *                  image data described\n     * @param h         the height, in pixels, of the region of\n     *                  image data described\n     * @param numberOfBits the number of bits per pixel\n     * @throws IllegalArgumentException if <code>dataType<\/code> is not\n     *         either <code>DataBuffer.TYPE_BYTE<\/code>,\n     *         <code>DataBuffer.TYPE_USHORT<\/code>, or\n     *         <code>DataBuffer.TYPE_INT<\/code>\n     */\n    public MultiPixelPackedSampleModel(int dataType,\n                                       int w,\n                                       int h,\n                                       int numberOfBits) {\n        this(dataType,w,h,\n             numberOfBits,\n            (w*numberOfBits+DataBuffer.getDataTypeSize(dataType)-1)/\n                DataBuffer.getDataTypeSize(dataType),\n             0);\n        if (dataType != DataBuffer.TYPE_BYTE &&\n            dataType != DataBuffer.TYPE_USHORT &&\n            dataType != DataBuffer.TYPE_INT) {\n            throw new IllegalArgumentException(\"Unsupported data type \"+\n                                               dataType);\n        }\n    }"}
{"Number":"517","API Relative Path":"java.awt.image.MultiPixelPackedSampleModel.java-MultiPixelPackedSampleModel(int-int-int-int-int-int)","Corresponding Source":"/**\n     * Constructs a <code>MultiPixelPackedSampleModel<\/code> with\n     * specified data type, width, height, number of bits per pixel,\n     * scanline stride and data bit offset.\n     * @param dataType  the data type for storing samples\n     * @param w         the width, in pixels, of the region of\n     *                  image data described\n     * @param h         the height, in pixels, of the region of\n     *                  image data described\n     * @param numberOfBits the number of bits per pixel\n     * @param scanlineStride the line stride of the image data\n     * @param dataBitOffset the data bit offset for the region of image\n     *                  data described\n     * @exception RasterFormatException if the number of bits per pixel\n     *                  is not a power of 2 or if a power of 2 number of\n     *                  pixels do not fit in one data element.\n     * @throws IllegalArgumentException if <code>w<\/code> or\n     *         <code>h<\/code> is not greater than 0\n     * @throws IllegalArgumentException if <code>dataType<\/code> is not\n     *         either <code>DataBuffer.TYPE_BYTE<\/code>,\n     *         <code>DataBuffer.TYPE_USHORT<\/code>, or\n     *         <code>DataBuffer.TYPE_INT<\/code>\n     */\n    public MultiPixelPackedSampleModel(int dataType, int w, int h,\n                                       int numberOfBits,\n                                       int scanlineStride,\n                                       int dataBitOffset) {\n        super(dataType, w, h, 1);\n        if (dataType != DataBuffer.TYPE_BYTE &&\n            dataType != DataBuffer.TYPE_USHORT &&\n            dataType != DataBuffer.TYPE_INT) {\n            throw new IllegalArgumentException(\"Unsupported data type \"+\n                                               dataType);\n        }\n        this.dataType = dataType;\n        this.pixelBitStride = numberOfBits;\n        this.scanlineStride = scanlineStride;\n        this.dataBitOffset = dataBitOffset;\n        this.dataElementSize = DataBuffer.getDataTypeSize(dataType);\n        this.pixelsPerDataElement = dataElementSize/numberOfBits;\n        if (pixelsPerDataElement*numberOfBits != dataElementSize) {\n           throw new RasterFormatException(\"MultiPixelPackedSampleModel \" +\n                                             \"does not allow pixels to \" +\n                                             \"span data element boundaries\");\n        }\n        this.bitMask = (1 << numberOfBits) - 1;\n    }"}
{"Number":"518","API Relative Path":"java.awt.image.MultiPixelPackedSampleModel.java-MultiPixelPackedSampleModel(int-int-int-int-int-int)","Corresponding Source":"/**\n     * Constructs a <code>MultiPixelPackedSampleModel<\/code> with\n     * specified data type, width, height, number of bits per pixel,\n     * scanline stride and data bit offset.\n     * @param dataType  the data type for storing samples\n     * @param w         the width, in pixels, of the region of\n     *                  image data described\n     * @param h         the height, in pixels, of the region of\n     *                  image data described\n     * @param numberOfBits the number of bits per pixel\n     * @param scanlineStride the line stride of the image data\n     * @param dataBitOffset the data bit offset for the region of image\n     *                  data described\n     * @exception RasterFormatException if the number of bits per pixel\n     *                  is not a power of 2 or if a power of 2 number of\n     *                  pixels do not fit in one data element.\n     * @throws IllegalArgumentException if <code>w<\/code> or\n     *         <code>h<\/code> is not greater than 0\n     * @throws IllegalArgumentException if <code>dataType<\/code> is not\n     *         either <code>DataBuffer.TYPE_BYTE<\/code>,\n     *         <code>DataBuffer.TYPE_USHORT<\/code>, or\n     *         <code>DataBuffer.TYPE_INT<\/code>\n     */\n    public MultiPixelPackedSampleModel(int dataType, int w, int h,\n                                       int numberOfBits,\n                                       int scanlineStride,\n                                       int dataBitOffset) {\n        super(dataType, w, h, 1);\n        if (dataType != DataBuffer.TYPE_BYTE &&\n            dataType != DataBuffer.TYPE_USHORT &&\n            dataType != DataBuffer.TYPE_INT) {\n            throw new IllegalArgumentException(\"Unsupported data type \"+\n                                               dataType);\n        }\n        this.dataType = dataType;\n        this.pixelBitStride = numberOfBits;\n        this.scanlineStride = scanlineStride;\n        this.dataBitOffset = dataBitOffset;\n        this.dataElementSize = DataBuffer.getDataTypeSize(dataType);\n        this.pixelsPerDataElement = dataElementSize/numberOfBits;\n        if (pixelsPerDataElement*numberOfBits != dataElementSize) {\n           throw new RasterFormatException(\"MultiPixelPackedSampleModel \" +\n                                             \"does not allow pixels to \" +\n                                             \"span data element boundaries\");\n        }\n        this.bitMask = (1 << numberOfBits) - 1;\n    }"}
{"Number":"519","API Relative Path":"java.awt.image.MultiPixelPackedSampleModel.java-setDataElements(int-int-Object-DataBuffer)","Corresponding Source":"/**\n     * Sets the data for a single pixel in the specified\n     * <code>DataBuffer<\/code> from a primitive array of type\n     * TransferType.  For a <code>MultiPixelPackedSampleModel<\/code>,\n     * only the first element of the array holds valid data,\n     * and the type must be the smallest of\n     * DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT, or DataBuffer.TYPE_INT\n     * that can hold a single pixel.\n     * <p>\n     * The following code illustrates transferring data for one pixel from\n     * <code>DataBuffer<\/code> <code>db1<\/code>, whose storage layout is\n     * described by <code>MultiPixelPackedSampleModel<\/code>\n     * <code>mppsm1<\/code>, to <code>DataBuffer<\/code> <code>db2<\/code>,\n     * whose storage layout is described by\n     * <code>MultiPixelPackedSampleModel<\/code> <code>mppsm2<\/code>.\n     * The transfer is generally more efficient than using\n     * <code>getPixel<\/code> or <code>setPixel<\/code>.\n     * <pre>\n     *       MultiPixelPackedSampleModel mppsm1, mppsm2;\n     *       DataBufferInt db1, db2;\n     *       mppsm2.setDataElements(x, y, mppsm1.getDataElements(x, y, null,\n     *                              db1), db2);\n     * <\/pre>\n     * Using <code>getDataElements<\/code> or <code>setDataElements<\/code> to\n     * transfer between two <code>DataBuffer/SampleModel<\/code> pairs is\n     * legitimate if the <code>SampleModel<\/code> objects have\n     * the same number of bands, corresponding bands have the same number of\n     * bits per sample, and the TransferTypes are the same.\n     * <p>\n     * <code>obj<\/code> must be a primitive array of type TransferType.\n     * Otherwise, a <code>ClassCastException<\/code> is thrown.  An\n     * <code>ArrayIndexOutOfBoundsException<\/code> is thrown if the\n     * coordinates are not in bounds, or if <code>obj<\/code> is not large\n     * enough to hold the pixel data.\n     * @param x the X coordinate of the pixel location\n     * @param y the Y coordinate of the pixel location\n     * @param obj a primitive array containing pixel data\n     * @param data the <code>DataBuffer<\/code> containing the image data\n     * @see #getDataElements(int, int, Object, DataBuffer)\n     */\n    public void setDataElements(int x, int y, Object obj, DataBuffer data) {\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n\n        int type = getTransferType();\n        int bitnum = dataBitOffset + x * pixelBitStride;\n        int index = y * scanlineStride + (bitnum / dataElementSize);\n        int shift = dataElementSize - (bitnum & (dataElementSize-1))\n                    - pixelBitStride;\n        int element = data.getElem(index);\n        element &= ~(bitMask << shift);\n\n        switch(type) {\n\n        case DataBuffer.TYPE_BYTE:\n\n            byte[] barray = (byte[])obj;\n            element |= ( ((int)(barray[0])&0xff) & bitMask) << shift;\n            data.setElem(index, element);\n            break;\n\n        case DataBuffer.TYPE_USHORT:\n\n            short[] sarray = (short[])obj;\n            element |= ( ((int)(sarray[0])&0xffff) & bitMask) << shift;\n            data.setElem(index, element);\n            break;\n\n        case DataBuffer.TYPE_INT:\n\n            int[] iarray = (int[])obj;\n            element |= (iarray[0] & bitMask) << shift;\n            data.setElem(index, element);\n            break;\n        }\n    }"}
{"Number":"520","API Relative Path":"java.awt.image.MultiPixelPackedSampleModel.java-setPixel(int-int-int[]-DataBuffer)","Corresponding Source":"/**\n     * Sets a pixel in the <code>DataBuffer<\/code> using an\n     * <code>int<\/code> array for input.\n     * <code>ArrayIndexOutOfBoundsException<\/code> is thrown if\n     * the coordinates are not in bounds.\n     * @param x the X coordinate of the pixel location\n     * @param y the Y coordinate of the pixel location\n     * @param iArray the input pixel in an <code>int<\/code> array\n     * @param data the <code>DataBuffer<\/code> containing the image data\n     * @see #getPixel(int, int, int[], DataBuffer)\n     */\n    public void setPixel(int x, int y, int[] iArray, DataBuffer data) {\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int bitnum = dataBitOffset + x * pixelBitStride;\n        int index = y * scanlineStride + (bitnum / dataElementSize);\n        int shift = dataElementSize - (bitnum & (dataElementSize-1))\n                    - pixelBitStride;\n        int element = data.getElem(index);\n        element &= ~(bitMask << shift);\n        element |= (iArray[0] & bitMask) << shift;\n        data.setElem(index,element);\n    }"}
{"Number":"521","API Relative Path":"java.awt.image.MultiPixelPackedSampleModel.java-setSample(int-int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Sets a sample in the specified band for the pixel located at\n     * (x,&nbsp;y) in the <code>DataBuffer<\/code> using an\n     * <code>int<\/code> for input.\n     * An <code>ArrayIndexOutOfBoundsException<\/code> is thrown if the\n     * coordinates are not in bounds.\n     * @param x the X coordinate of the specified pixel\n     * @param y the Y coordinate of the specified pixel\n     * @param b the band to return, which is assumed to be 0\n     * @param s the input sample as an <code>int<\/code>\n     * @param data the <code>DataBuffer<\/code> where image data is stored\n     * @exception ArrayIndexOutOfBoundsException if the coordinates are\n     * not in bounds.\n     * @see #getSample(int, int, int, DataBuffer)\n     */\n    public void setSample(int x, int y, int b, int s,\n                          DataBuffer data) {\n        // 'b' must be 0\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height) ||\n            (b != 0)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int bitnum = dataBitOffset + x * pixelBitStride;\n        int index = y * scanlineStride + (bitnum / dataElementSize);\n        int shift = dataElementSize - (bitnum & (dataElementSize-1))\n                    - pixelBitStride;\n        int element = data.getElem(index);\n        element &= ~(bitMask << shift);\n        element |= (s & bitMask) << shift;\n        data.setElem(index,element);\n    }"}
{"Number":"522","API Relative Path":"java.awt.image.PackedColorModel.java-PackedColorModel(ColorSpace-int-int-int-int-int-boolean-int-int)","Corresponding Source":"/**\n     * Constructs a <code>PackedColorModel<\/code> from the specified\n     * masks which indicate which bits in an <code>int<\/code> pixel\n     * representation contain the alpha, red, green and blue color samples.\n     * Color components are in the specified <code>ColorSpace<\/code>, which\n     * must be of type ColorSpace.TYPE_RGB.  All of the bits in each\n     * mask must be contiguous and fit in the specified number of\n     * least significant bits of an <code>int<\/code> pixel representation.  If\n     * <code>amask<\/code> is 0, there is no alpha.  If there is alpha,\n     * the <code>boolean<\/code> <code>isAlphaPremultiplied<\/code>\n     * specifies how to interpret color and alpha samples\n     * in pixel values.  If the <code>boolean<\/code> is <code>true<\/code>,\n     * color samples are assumed to have been multiplied by the alpha sample.\n     * The transparency, <code>trans<\/code>, specifies what alpha values\n     * can be represented by this color model.\n     * The transfer type is the type of primitive array used to represent\n     * pixel values.\n     * @param space the specified <code>ColorSpace<\/code>\n     * @param bits the number of bits in the pixel values\n     * @param rmask specifies the mask representing\n     *         the bits of the pixel values that represent the red\n     *         color component\n     * @param gmask specifies the mask representing\n     *         the bits of the pixel values that represent the green\n     *         color component\n     * @param bmask specifies the mask representing\n     *         the bits of the pixel values that represent\n     *         the blue color component\n     * @param amask specifies the mask representing\n     *         the bits of the pixel values that represent\n     *         the alpha component\n     * @param isAlphaPremultiplied <code>true<\/code> if color samples are\n     *        premultiplied by the alpha sample; <code>false<\/code> otherwise\n     * @param trans specifies the alpha value that can be represented by\n     *        this color model\n     * @param transferType the type of array used to represent pixel values\n     * @throws IllegalArgumentException if <code>space<\/code> is not a\n     *         TYPE_RGB space\n     * @see ColorSpace\n     */\n    public PackedColorModel(ColorSpace space, int bits, int rmask, int gmask,\n                            int bmask, int amask,\n                            boolean isAlphaPremultiplied,\n                            int trans, int transferType) {\n        super (bits, PackedColorModel.createBitsArray(rmask, gmask, bmask,\n                                                      amask),\n               space, (amask == 0 ? false : true),\n               isAlphaPremultiplied, trans, transferType);\n\n        if (space.getType() != ColorSpace.TYPE_RGB) {\n            throw new IllegalArgumentException(\"ColorSpace must be TYPE_RGB.\");\n        }\n        maskArray = new int[numComponents];\n        maskOffsets = new int[numComponents];\n        scaleFactors = new float[numComponents];\n\n        DecomposeMask(rmask, 0, \"red\");\n\n        DecomposeMask(gmask, 1, \"green\");\n\n        DecomposeMask(bmask, 2, \"blue\");\n\n        if (amask != 0) {\n            DecomposeMask(amask, 3, \"alpha\");\n            if (nBits[3] == 1) {\n                transparency = Transparency.BITMASK;\n            }\n        }\n    }"}
{"Number":"523","API Relative Path":"java.awt.image.PackedColorModel.java-PackedColorModel(ColorSpace-int-int[]-int-boolean-int-int)","Corresponding Source":"/**\n     * Constructs a <code>PackedColorModel<\/code> from a color mask array,\n     * which specifies which bits in an <code>int<\/code> pixel representation\n     * contain each of the color samples, and an alpha mask.  Color\n     * components are in the specified <code>ColorSpace<\/code>.  The length of\n     * <code>colorMaskArray<\/code> should be the number of components in\n     * the <code>ColorSpace<\/code>.  All of the bits in each mask\n     * must be contiguous and fit in the specified number of least significant\n     * bits of an <code>int<\/code> pixel representation.  If the\n     * <code>alphaMask<\/code> is 0, there is no alpha.  If there is alpha,\n     * the <code>boolean<\/code> <code>isAlphaPremultiplied<\/code> specifies\n     * how to interpret color and alpha samples in pixel values.  If the\n     * <code>boolean<\/code> is <code>true<\/code>, color samples are assumed\n     * to have been multiplied by the alpha sample.  The transparency,\n     * <code>trans<\/code>, specifies what alpha values can be represented\n     * by this color model.  The transfer type is the type of primitive\n     * array used to represent pixel values.\n     * @param space the specified <code>ColorSpace<\/code>\n     * @param bits the number of bits in the pixel values\n     * @param colorMaskArray array that specifies the masks representing\n     *         the bits of the pixel values that represent the color\n     *         components\n     * @param alphaMask specifies the mask representing\n     *         the bits of the pixel values that represent the alpha\n     *         component\n     * @param isAlphaPremultiplied <code>true<\/code> if color samples are\n     *        premultiplied by the alpha sample; <code>false<\/code> otherwise\n     * @param trans specifies the alpha value that can be represented by\n     *        this color model\n     * @param transferType the type of array used to represent pixel values\n     * @throws IllegalArgumentException if <code>bits<\/code> is less than\n     *         1 or greater than 32\n     */\n    public PackedColorModel (ColorSpace space, int bits,\n                             int[] colorMaskArray, int alphaMask,\n                             boolean isAlphaPremultiplied,\n                             int trans, int transferType) {\n        super(bits, PackedColorModel.createBitsArray(colorMaskArray,\n                                                     alphaMask),\n              space, (alphaMask == 0 ? false : true),\n              isAlphaPremultiplied, trans, transferType);\n        if (bits < 1 || bits > 32) {\n            throw new IllegalArgumentException(\"Number of bits must be between\"\n                                               +\" 1 and 32.\");\n        }\n        maskArray   = new int[numComponents];\n        maskOffsets = new int[numComponents];\n        scaleFactors = new float[numComponents];\n\n        for (int i=0; i < numColorComponents; i++) {\n            // Get the mask offset and #bits\n            DecomposeMask(colorMaskArray[i], i, space.getName(i));\n        }\n        if (alphaMask != 0) {\n            DecomposeMask(alphaMask, numColorComponents, \"alpha\");\n            if (nBits[numComponents-1] == 1) {\n                transparency = Transparency.BITMASK;\n            }\n        }\n    }"}
{"Number":"524","API Relative Path":"java.awt.image.PixelInterleavedSampleModel.java-PixelInterleavedSampleModel(int-int-int-int-int-int)","Corresponding Source":"/**\n     * Constructs a PixelInterleavedSampleModel with the specified parameters.\n     * The number of bands will be given by the length of the bandOffsets\n     * array.\n     * @param dataType  The data type for storing samples.\n     * @param w         The width (in pixels) of the region of\n     *                  image data described.\n     * @param h         The height (in pixels) of the region of\n     *                  image data described.\n     * @param pixelStride The pixel stride of the image data.\n     * @param scanlineStride The line stride of the image data.\n     * @param bandOffsets The offsets of all bands.\n     * @throws IllegalArgumentException if <code>w<\/code> or\n     *         <code>h<\/code> is not greater than 0\n     * @throws IllegalArgumentException if any offset between bands is\n     *         greater than the scanline stride\n     * @throws IllegalArgumentException if the product of\n     *         <code>pixelStride<\/code> and <code>w<\/code> is greater\n     *         than <code>scanlineStride<\/code>\n     * @throws IllegalArgumentException if <code>pixelStride<\/code> is\n     *         less than any offset between bands\n     * @throws IllegalArgumentException if <code>dataType<\/code> is not\n     *         one of the supported data types\n     */\n    public PixelInterleavedSampleModel(int dataType,\n                                       int w, int h,\n                                       int pixelStride,\n                                       int scanlineStride,\n                                       int bandOffsets[]) {\n        super(dataType, w, h, pixelStride, scanlineStride, bandOffsets);\n        int minBandOff=this.bandOffsets[0];\n        int maxBandOff=this.bandOffsets[0];\n        for (int i=1; i<this.bandOffsets.length; i++) {\n            minBandOff = Math.min(minBandOff,this.bandOffsets[i]);\n            maxBandOff = Math.max(maxBandOff,this.bandOffsets[i]);\n        }\n        maxBandOff -= minBandOff;\n        if (maxBandOff > scanlineStride) {\n            throw new IllegalArgumentException(\"Offsets between bands must be\"+\n                                               \" less than the scanline \"+\n                                               \" stride\");\n        }\n        if (pixelStride*w > scanlineStride) {\n            throw new IllegalArgumentException(\"Pixel stride times width \"+\n                                               \"must be less than or \"+\n                                               \"equal to the scanline \"+\n                                               \"stride\");\n        }\n        if (pixelStride < maxBandOff) {\n            throw new IllegalArgumentException(\"Pixel stride must be greater\"+\n                                               \" than or equal to the offsets\"+\n                                               \" between bands\");\n        }\n    }"}
{"Number":"525","API Relative Path":"java.awt.image.PixelInterleavedSampleModel.java-PixelInterleavedSampleModel(int-int-int-int-int-int)","Corresponding Source":"/**\n     * Constructs a PixelInterleavedSampleModel with the specified parameters.\n     * The number of bands will be given by the length of the bandOffsets\n     * array.\n     * @param dataType  The data type for storing samples.\n     * @param w         The width (in pixels) of the region of\n     *                  image data described.\n     * @param h         The height (in pixels) of the region of\n     *                  image data described.\n     * @param pixelStride The pixel stride of the image data.\n     * @param scanlineStride The line stride of the image data.\n     * @param bandOffsets The offsets of all bands.\n     * @throws IllegalArgumentException if <code>w<\/code> or\n     *         <code>h<\/code> is not greater than 0\n     * @throws IllegalArgumentException if any offset between bands is\n     *         greater than the scanline stride\n     * @throws IllegalArgumentException if the product of\n     *         <code>pixelStride<\/code> and <code>w<\/code> is greater\n     *         than <code>scanlineStride<\/code>\n     * @throws IllegalArgumentException if <code>pixelStride<\/code> is\n     *         less than any offset between bands\n     * @throws IllegalArgumentException if <code>dataType<\/code> is not\n     *         one of the supported data types\n     */\n    public PixelInterleavedSampleModel(int dataType,\n                                       int w, int h,\n                                       int pixelStride,\n                                       int scanlineStride,\n                                       int bandOffsets[]) {\n        super(dataType, w, h, pixelStride, scanlineStride, bandOffsets);\n        int minBandOff=this.bandOffsets[0];\n        int maxBandOff=this.bandOffsets[0];\n        for (int i=1; i<this.bandOffsets.length; i++) {\n            minBandOff = Math.min(minBandOff,this.bandOffsets[i]);\n            maxBandOff = Math.max(maxBandOff,this.bandOffsets[i]);\n        }\n        maxBandOff -= minBandOff;\n        if (maxBandOff > scanlineStride) {\n            throw new IllegalArgumentException(\"Offsets between bands must be\"+\n                                               \" less than the scanline \"+\n                                               \" stride\");\n        }\n        if (pixelStride*w > scanlineStride) {\n            throw new IllegalArgumentException(\"Pixel stride times width \"+\n                                               \"must be less than or \"+\n                                               \"equal to the scanline \"+\n                                               \"stride\");\n        }\n        if (pixelStride < maxBandOff) {\n            throw new IllegalArgumentException(\"Pixel stride must be greater\"+\n                                               \" than or equal to the offsets\"+\n                                               \" between bands\");\n        }\n    }"}
{"Number":"526","API Relative Path":"java.awt.image.PixelInterleavedSampleModel.java-PixelInterleavedSampleModel(int-int-int-int-int-int)","Corresponding Source":"/**\n     * Constructs a PixelInterleavedSampleModel with the specified parameters.\n     * The number of bands will be given by the length of the bandOffsets\n     * array.\n     * @param dataType  The data type for storing samples.\n     * @param w         The width (in pixels) of the region of\n     *                  image data described.\n     * @param h         The height (in pixels) of the region of\n     *                  image data described.\n     * @param pixelStride The pixel stride of the image data.\n     * @param scanlineStride The line stride of the image data.\n     * @param bandOffsets The offsets of all bands.\n     * @throws IllegalArgumentException if <code>w<\/code> or\n     *         <code>h<\/code> is not greater than 0\n     * @throws IllegalArgumentException if any offset between bands is\n     *         greater than the scanline stride\n     * @throws IllegalArgumentException if the product of\n     *         <code>pixelStride<\/code> and <code>w<\/code> is greater\n     *         than <code>scanlineStride<\/code>\n     * @throws IllegalArgumentException if <code>pixelStride<\/code> is\n     *         less than any offset between bands\n     * @throws IllegalArgumentException if <code>dataType<\/code> is not\n     *         one of the supported data types\n     */\n    public PixelInterleavedSampleModel(int dataType,\n                                       int w, int h,\n                                       int pixelStride,\n                                       int scanlineStride,\n                                       int bandOffsets[]) {\n        super(dataType, w, h, pixelStride, scanlineStride, bandOffsets);\n        int minBandOff=this.bandOffsets[0];\n        int maxBandOff=this.bandOffsets[0];\n        for (int i=1; i<this.bandOffsets.length; i++) {\n            minBandOff = Math.min(minBandOff,this.bandOffsets[i]);\n            maxBandOff = Math.max(maxBandOff,this.bandOffsets[i]);\n        }\n        maxBandOff -= minBandOff;\n        if (maxBandOff > scanlineStride) {\n            throw new IllegalArgumentException(\"Offsets between bands must be\"+\n                                               \" less than the scanline \"+\n                                               \" stride\");\n        }\n        if (pixelStride*w > scanlineStride) {\n            throw new IllegalArgumentException(\"Pixel stride times width \"+\n                                               \"must be less than or \"+\n                                               \"equal to the scanline \"+\n                                               \"stride\");\n        }\n        if (pixelStride < maxBandOff) {\n            throw new IllegalArgumentException(\"Pixel stride must be greater\"+\n                                               \" than or equal to the offsets\"+\n                                               \" between bands\");\n        }\n    }"}
{"Number":"527","API Relative Path":"java.awt.image.Raster.java-createBandedRaster(DataBuffer-int-int-int-int-int-Point)","Corresponding Source":"/**\n     * Creates a Raster based on a BandedSampleModel with the\n     * specified DataBuffer, width, height, scanline stride, bank\n     * indices, and band offsets.  The number of bands is inferred\n     * from bankIndices.length and bandOffsets.length, which must be\n     * the same.  The upper left corner of the Raster is given by the\n     * location argument.  If location is null, (0, 0) will be used.\n     * @param dataBuffer the <code>DataBuffer<\/code> that contains the\n     *        image data\n     * @param w         the width in pixels of the image data\n     * @param h         the height in pixels of the image data\n     * @param scanlineStride the line stride of the image data\n     * @param bankIndices the bank indices for each band\n     * @param bandOffsets the offsets of all bands\n     * @param location  the upper-left corner of the <code>Raster<\/code>\n     * @return a WritableRaster object with the specified\n     *         <code>DataBuffer<\/code>, width, height, scanline stride,\n     *         bank indices and band offsets.\n     * @throws RasterFormatException if <code>w<\/code> or <code>h<\/code>\n     *         is less than or equal to zero, or computing either\n     *         <code>location.x + w<\/code> or\n     *         <code>location.y + h<\/code> results in integer\n     *         overflow\n     * @throws IllegalArgumentException if <code>dataType<\/code> is not\n     *         one of the supported data types, which are\n     *         <code>DataBuffer.TYPE_BYTE<\/code>,\n     *         <code>DataBuffer.TYPE_USHORT<\/code>\n     *         or <code>DataBuffer.TYPE_INT<\/code>\n     * @throws NullPointerException if <code>dataBuffer<\/code> is null\n     */\n    public static WritableRaster createBandedRaster(DataBuffer dataBuffer,\n                                                    int w, int h,\n                                                    int scanlineStride,\n                                                    int bankIndices[],\n                                                    int bandOffsets[],\n                                                    Point location) {\n        if (dataBuffer == null) {\n            throw new NullPointerException(\"DataBuffer cannot be null\");\n        }\n        if (location == null) {\n           location = new Point(0,0);\n        }\n        int dataType = dataBuffer.getDataType();\n\n        int bands = bankIndices.length;\n        if (bandOffsets.length != bands) {\n            throw new IllegalArgumentException(\n                                   \"bankIndices.length != bandOffsets.length\");\n        }\n\n        BandedSampleModel bsm =\n            new BandedSampleModel(dataType, w, h,\n                                  scanlineStride,\n                                  bankIndices, bandOffsets);\n\n        switch(dataType) {\n        case DataBuffer.TYPE_BYTE:\n            return new ByteBandedRaster(bsm, dataBuffer, location);\n\n        case DataBuffer.TYPE_USHORT:\n            return new ShortBandedRaster(bsm, dataBuffer, location);\n\n        case DataBuffer.TYPE_INT:\n            return new SunWritableRaster(bsm, dataBuffer, location);\n\n        default:\n            throw new IllegalArgumentException(\"Unsupported data type \" +\n                                                dataType);\n        }\n    }"}
{"Number":"528","API Relative Path":"java.awt.image.Raster.java-createBandedRaster(int-int-int-int-int-int-Point)","Corresponding Source":"/**\n     * Creates a Raster based on a BandedSampleModel with the\n     * specified data type, width, height, scanline stride, bank\n     * indices and band offsets.  The number of bands is inferred from\n     * bankIndices.length and bandOffsets.length, which must be the\n     * same.\n     *\n     * <p> The upper left corner of the Raster is given by the\n     * location argument.  The dataType parameter should be one of the\n     * enumerated values defined in the DataBuffer class.\n     *\n     * <p> The only dataTypes supported currently are TYPE_BYTE, TYPE_USHORT,\n     * and TYPE_INT.\n     * @param dataType  the data type for storing samples\n     * @param w         the width in pixels of the image data\n     * @param h         the height in pixels of the image data\n     * @param scanlineStride the line stride of the image data\n     * @param bankIndices the bank indices for each band\n     * @param bandOffsets the offsets of all bands\n     * @param location  the upper-left corner of the <code>Raster<\/code>\n     * @return a WritableRaster object with the specified data type,\n     *         width, height, scanline stride, bank indices and band\n     *         offsets.\n     * @throws RasterFormatException if <code>w<\/code> or <code>h<\/code>\n     *         is less than or equal to zero, or computing either\n     *         <code>location.x + w<\/code> or\n     *         <code>location.y + h<\/code> results in integer\n     *         overflow\n     * @throws IllegalArgumentException if <code>dataType<\/code> is not\n     *         one of the supported data types, which are\n     *         <code>DataBuffer.TYPE_BYTE<\/code>,\n     *         <code>DataBuffer.TYPE_USHORT<\/code>\n     *         or <code>DataBuffer.TYPE_INT<\/code>\n     * @throws ArrayIndexOutOfBoundsException if <code>bankIndices<\/code>\n     *         or <code>bandOffsets<\/code> is <code>null<\/code>\n     */\n    public static WritableRaster createBandedRaster(int dataType,\n                                                    int w, int h,\n                                                    int scanlineStride,\n                                                    int bankIndices[],\n                                                    int bandOffsets[],\n                                                    Point location) {\n        DataBuffer d;\n        int bands = bandOffsets.length;\n\n        if (bankIndices == null) {\n            throw new\n                ArrayIndexOutOfBoundsException(\"Bank indices array is null\");\n        }\n        if (bandOffsets == null) {\n            throw new\n                ArrayIndexOutOfBoundsException(\"Band offsets array is null\");\n        }\n\n        // Figure out the #banks and the largest band offset\n        int maxBank = bankIndices[0];\n        int maxBandOff = bandOffsets[0];\n        for (int i = 1; i < bands; i++) {\n            if (bankIndices[i] > maxBank) {\n                maxBank = bankIndices[i];\n            }\n            if (bandOffsets[i] > maxBandOff) {\n                maxBandOff = bandOffsets[i];\n            }\n        }\n        int banks = maxBank + 1;\n        int size = maxBandOff +\n            scanlineStride * (h - 1) + // fisrt (h - 1) scans\n            w; // last scan\n\n        switch(dataType) {\n        case DataBuffer.TYPE_BYTE:\n            d = new DataBufferByte(size, banks);\n            break;\n\n        case DataBuffer.TYPE_USHORT:\n            d = new DataBufferUShort(size, banks);\n            break;\n\n        case DataBuffer.TYPE_INT:\n            d = new DataBufferInt(size, banks);\n            break;\n\n        default:\n            throw new IllegalArgumentException(\"Unsupported data type \" +\n                                                dataType);\n        }\n\n        return createBandedRaster(d, w, h, scanlineStride,\n                                  bankIndices, bandOffsets, location);\n    }"}
{"Number":"529","API Relative Path":"java.awt.image.Raster.java-createChild(int-int-int-int-int-int-int)","Corresponding Source":"/**\n     * Returns a new Raster which shares all or part of this Raster's\n     * DataBuffer.  The new Raster will possess a reference to the\n     * current Raster, accessible through its getParent() method.\n     *\n     * <p> The parentX, parentY, width and height parameters\n     * form a Rectangle in this Raster's coordinate space,\n     * indicating the area of pixels to be shared.  An error will\n     * be thrown if this Rectangle is not contained with the bounds\n     * of the current Raster.\n     *\n     * <p> The new Raster may additionally be translated to a\n     * different coordinate system for the plane than that used by the current\n     * Raster.  The childMinX and childMinY parameters give the new\n     * (x, y) coordinate of the upper-left pixel of the returned\n     * Raster; the coordinate (childMinX, childMinY) in the new Raster\n     * will map to the same pixel as the coordinate (parentX, parentY)\n     * in the current Raster.\n     *\n     * <p> The new Raster may be defined to contain only a subset of\n     * the bands of the current Raster, possibly reordered, by means\n     * of the bandList parameter.  If bandList is null, it is taken to\n     * include all of the bands of the current Raster in their current\n     * order.\n     *\n     * <p> To create a new Raster that contains a subregion of the current\n     * Raster, but shares its coordinate system and bands,\n     * this method should be called with childMinX equal to parentX,\n     * childMinY equal to parentY, and bandList equal to null.\n     *\n     * @param parentX The X coordinate of the upper-left corner\n     *        in this Raster's coordinates\n     * @param parentY The Y coordinate of the upper-left corner\n     *        in this Raster's coordinates\n     * @param width      Width of the region starting at (parentX, parentY)\n     * @param height     Height of the region starting at (parentX, parentY).\n     * @param childMinX The X coordinate of the upper-left corner\n     *                   of the returned Raster\n     * @param childMinY The Y coordinate of the upper-left corner\n     *                   of the returned Raster\n     * @param bandList   Array of band indices, or null to use all bands\n     * @return a new <code>Raster<\/code>.\n     * @exception RasterFormatException if the specified subregion is outside\n     *                               of the raster bounds.\n     * @throws RasterFormatException if <code>width<\/code> or\n     *         <code>height<\/code>\n     *         is less than or equal to zero, or computing any of\n     *         <code>parentX + width<\/code>, <code>parentY + height<\/code>,\n     *         <code>childMinX + width<\/code>, or\n     *         <code>childMinY + height<\/code> results in integer\n     *         overflow\n     */\n    public Raster createChild(int parentX, int parentY,\n                              int width, int height,\n                              int childMinX, int childMinY,\n                              int bandList[]) {\n        if (parentX < this.minX) {\n            throw new RasterFormatException(\"parentX lies outside raster\");\n        }\n        if (parentY < this.minY) {\n            throw new RasterFormatException(\"parentY lies outside raster\");\n        }\n        if ((parentX + width < parentX) ||\n            (parentX + width > this.width + this.minX)) {\n            throw new RasterFormatException(\"(parentX + width) is outside raster\");\n        }\n        if ((parentY + height < parentY) ||\n            (parentY + height > this.height + this.minY)) {\n            throw new RasterFormatException(\"(parentY + height) is outside raster\");\n        }\n\n        SampleModel subSampleModel;\n        // Note: the SampleModel for the child Raster should have the same\n        // width and height as that for the parent, since it represents\n        // the physical layout of the pixel data.  The child Raster's width\n        // and height represent a \"virtual\" view of the pixel data, so\n        // they may be different than those of the SampleModel.\n        if (bandList == null) {\n            subSampleModel = sampleModel;\n        } else {\n            subSampleModel = sampleModel.createSubsetSampleModel(bandList);\n        }\n\n        int deltaX = childMinX - parentX;\n        int deltaY = childMinY - parentY;\n\n        return new Raster(subSampleModel, getDataBuffer(),\n                          new Rectangle(childMinX, childMinY, width, height),\n                          new Point(sampleModelTranslateX + deltaX,\n                                    sampleModelTranslateY + deltaY), this);\n    }"}
{"Number":"530","API Relative Path":"java.awt.image.Raster.java-createChild(int-int-int-int-int-int-int)","Corresponding Source":"/**\n     * Returns a new Raster which shares all or part of this Raster's\n     * DataBuffer.  The new Raster will possess a reference to the\n     * current Raster, accessible through its getParent() method.\n     *\n     * <p> The parentX, parentY, width and height parameters\n     * form a Rectangle in this Raster's coordinate space,\n     * indicating the area of pixels to be shared.  An error will\n     * be thrown if this Rectangle is not contained with the bounds\n     * of the current Raster.\n     *\n     * <p> The new Raster may additionally be translated to a\n     * different coordinate system for the plane than that used by the current\n     * Raster.  The childMinX and childMinY parameters give the new\n     * (x, y) coordinate of the upper-left pixel of the returned\n     * Raster; the coordinate (childMinX, childMinY) in the new Raster\n     * will map to the same pixel as the coordinate (parentX, parentY)\n     * in the current Raster.\n     *\n     * <p> The new Raster may be defined to contain only a subset of\n     * the bands of the current Raster, possibly reordered, by means\n     * of the bandList parameter.  If bandList is null, it is taken to\n     * include all of the bands of the current Raster in their current\n     * order.\n     *\n     * <p> To create a new Raster that contains a subregion of the current\n     * Raster, but shares its coordinate system and bands,\n     * this method should be called with childMinX equal to parentX,\n     * childMinY equal to parentY, and bandList equal to null.\n     *\n     * @param parentX The X coordinate of the upper-left corner\n     *        in this Raster's coordinates\n     * @param parentY The Y coordinate of the upper-left corner\n     *        in this Raster's coordinates\n     * @param width      Width of the region starting at (parentX, parentY)\n     * @param height     Height of the region starting at (parentX, parentY).\n     * @param childMinX The X coordinate of the upper-left corner\n     *                   of the returned Raster\n     * @param childMinY The Y coordinate of the upper-left corner\n     *                   of the returned Raster\n     * @param bandList   Array of band indices, or null to use all bands\n     * @return a new <code>Raster<\/code>.\n     * @exception RasterFormatException if the specified subregion is outside\n     *                               of the raster bounds.\n     * @throws RasterFormatException if <code>width<\/code> or\n     *         <code>height<\/code>\n     *         is less than or equal to zero, or computing any of\n     *         <code>parentX + width<\/code>, <code>parentY + height<\/code>,\n     *         <code>childMinX + width<\/code>, or\n     *         <code>childMinY + height<\/code> results in integer\n     *         overflow\n     */\n    public Raster createChild(int parentX, int parentY,\n                              int width, int height,\n                              int childMinX, int childMinY,\n                              int bandList[]) {\n        if (parentX < this.minX) {\n            throw new RasterFormatException(\"parentX lies outside raster\");\n        }\n        if (parentY < this.minY) {\n            throw new RasterFormatException(\"parentY lies outside raster\");\n        }\n        if ((parentX + width < parentX) ||\n            (parentX + width > this.width + this.minX)) {\n            throw new RasterFormatException(\"(parentX + width) is outside raster\");\n        }\n        if ((parentY + height < parentY) ||\n            (parentY + height > this.height + this.minY)) {\n            throw new RasterFormatException(\"(parentY + height) is outside raster\");\n        }\n\n        SampleModel subSampleModel;\n        // Note: the SampleModel for the child Raster should have the same\n        // width and height as that for the parent, since it represents\n        // the physical layout of the pixel data.  The child Raster's width\n        // and height represent a \"virtual\" view of the pixel data, so\n        // they may be different than those of the SampleModel.\n        if (bandList == null) {\n            subSampleModel = sampleModel;\n        } else {\n            subSampleModel = sampleModel.createSubsetSampleModel(bandList);\n        }\n\n        int deltaX = childMinX - parentX;\n        int deltaY = childMinY - parentY;\n\n        return new Raster(subSampleModel, getDataBuffer(),\n                          new Rectangle(childMinX, childMinY, width, height),\n                          new Point(sampleModelTranslateX + deltaX,\n                                    sampleModelTranslateY + deltaY), this);\n    }"}
{"Number":"531","API Relative Path":"java.awt.image.Raster.java-createChild(int-int-int-int-int-int-int)","Corresponding Source":"/**\n     * Returns a new Raster which shares all or part of this Raster's\n     * DataBuffer.  The new Raster will possess a reference to the\n     * current Raster, accessible through its getParent() method.\n     *\n     * <p> The parentX, parentY, width and height parameters\n     * form a Rectangle in this Raster's coordinate space,\n     * indicating the area of pixels to be shared.  An error will\n     * be thrown if this Rectangle is not contained with the bounds\n     * of the current Raster.\n     *\n     * <p> The new Raster may additionally be translated to a\n     * different coordinate system for the plane than that used by the current\n     * Raster.  The childMinX and childMinY parameters give the new\n     * (x, y) coordinate of the upper-left pixel of the returned\n     * Raster; the coordinate (childMinX, childMinY) in the new Raster\n     * will map to the same pixel as the coordinate (parentX, parentY)\n     * in the current Raster.\n     *\n     * <p> The new Raster may be defined to contain only a subset of\n     * the bands of the current Raster, possibly reordered, by means\n     * of the bandList parameter.  If bandList is null, it is taken to\n     * include all of the bands of the current Raster in their current\n     * order.\n     *\n     * <p> To create a new Raster that contains a subregion of the current\n     * Raster, but shares its coordinate system and bands,\n     * this method should be called with childMinX equal to parentX,\n     * childMinY equal to parentY, and bandList equal to null.\n     *\n     * @param parentX The X coordinate of the upper-left corner\n     *        in this Raster's coordinates\n     * @param parentY The Y coordinate of the upper-left corner\n     *        in this Raster's coordinates\n     * @param width      Width of the region starting at (parentX, parentY)\n     * @param height     Height of the region starting at (parentX, parentY).\n     * @param childMinX The X coordinate of the upper-left corner\n     *                   of the returned Raster\n     * @param childMinY The Y coordinate of the upper-left corner\n     *                   of the returned Raster\n     * @param bandList   Array of band indices, or null to use all bands\n     * @return a new <code>Raster<\/code>.\n     * @exception RasterFormatException if the specified subregion is outside\n     *                               of the raster bounds.\n     * @throws RasterFormatException if <code>width<\/code> or\n     *         <code>height<\/code>\n     *         is less than or equal to zero, or computing any of\n     *         <code>parentX + width<\/code>, <code>parentY + height<\/code>,\n     *         <code>childMinX + width<\/code>, or\n     *         <code>childMinY + height<\/code> results in integer\n     *         overflow\n     */\n    public Raster createChild(int parentX, int parentY,\n                              int width, int height,\n                              int childMinX, int childMinY,\n                              int bandList[]) {\n        if (parentX < this.minX) {\n            throw new RasterFormatException(\"parentX lies outside raster\");\n        }\n        if (parentY < this.minY) {\n            throw new RasterFormatException(\"parentY lies outside raster\");\n        }\n        if ((parentX + width < parentX) ||\n            (parentX + width > this.width + this.minX)) {\n            throw new RasterFormatException(\"(parentX + width) is outside raster\");\n        }\n        if ((parentY + height < parentY) ||\n            (parentY + height > this.height + this.minY)) {\n            throw new RasterFormatException(\"(parentY + height) is outside raster\");\n        }\n\n        SampleModel subSampleModel;\n        // Note: the SampleModel for the child Raster should have the same\n        // width and height as that for the parent, since it represents\n        // the physical layout of the pixel data.  The child Raster's width\n        // and height represent a \"virtual\" view of the pixel data, so\n        // they may be different than those of the SampleModel.\n        if (bandList == null) {\n            subSampleModel = sampleModel;\n        } else {\n            subSampleModel = sampleModel.createSubsetSampleModel(bandList);\n        }\n\n        int deltaX = childMinX - parentX;\n        int deltaY = childMinY - parentY;\n\n        return new Raster(subSampleModel, getDataBuffer(),\n                          new Rectangle(childMinX, childMinY, width, height),\n                          new Point(sampleModelTranslateX + deltaX,\n                                    sampleModelTranslateY + deltaY), this);\n    }"}
{"Number":"532","API Relative Path":"java.awt.image.Raster.java-createChild(int-int-int-int-int-int-int)","Corresponding Source":"/**\n     * Returns a new Raster which shares all or part of this Raster's\n     * DataBuffer.  The new Raster will possess a reference to the\n     * current Raster, accessible through its getParent() method.\n     *\n     * <p> The parentX, parentY, width and height parameters\n     * form a Rectangle in this Raster's coordinate space,\n     * indicating the area of pixels to be shared.  An error will\n     * be thrown if this Rectangle is not contained with the bounds\n     * of the current Raster.\n     *\n     * <p> The new Raster may additionally be translated to a\n     * different coordinate system for the plane than that used by the current\n     * Raster.  The childMinX and childMinY parameters give the new\n     * (x, y) coordinate of the upper-left pixel of the returned\n     * Raster; the coordinate (childMinX, childMinY) in the new Raster\n     * will map to the same pixel as the coordinate (parentX, parentY)\n     * in the current Raster.\n     *\n     * <p> The new Raster may be defined to contain only a subset of\n     * the bands of the current Raster, possibly reordered, by means\n     * of the bandList parameter.  If bandList is null, it is taken to\n     * include all of the bands of the current Raster in their current\n     * order.\n     *\n     * <p> To create a new Raster that contains a subregion of the current\n     * Raster, but shares its coordinate system and bands,\n     * this method should be called with childMinX equal to parentX,\n     * childMinY equal to parentY, and bandList equal to null.\n     *\n     * @param parentX The X coordinate of the upper-left corner\n     *        in this Raster's coordinates\n     * @param parentY The Y coordinate of the upper-left corner\n     *        in this Raster's coordinates\n     * @param width      Width of the region starting at (parentX, parentY)\n     * @param height     Height of the region starting at (parentX, parentY).\n     * @param childMinX The X coordinate of the upper-left corner\n     *                   of the returned Raster\n     * @param childMinY The Y coordinate of the upper-left corner\n     *                   of the returned Raster\n     * @param bandList   Array of band indices, or null to use all bands\n     * @return a new <code>Raster<\/code>.\n     * @exception RasterFormatException if the specified subregion is outside\n     *                               of the raster bounds.\n     * @throws RasterFormatException if <code>width<\/code> or\n     *         <code>height<\/code>\n     *         is less than or equal to zero, or computing any of\n     *         <code>parentX + width<\/code>, <code>parentY + height<\/code>,\n     *         <code>childMinX + width<\/code>, or\n     *         <code>childMinY + height<\/code> results in integer\n     *         overflow\n     */\n    public Raster createChild(int parentX, int parentY,\n                              int width, int height,\n                              int childMinX, int childMinY,\n                              int bandList[]) {\n        if (parentX < this.minX) {\n            throw new RasterFormatException(\"parentX lies outside raster\");\n        }\n        if (parentY < this.minY) {\n            throw new RasterFormatException(\"parentY lies outside raster\");\n        }\n        if ((parentX + width < parentX) ||\n            (parentX + width > this.width + this.minX)) {\n            throw new RasterFormatException(\"(parentX + width) is outside raster\");\n        }\n        if ((parentY + height < parentY) ||\n            (parentY + height > this.height + this.minY)) {\n            throw new RasterFormatException(\"(parentY + height) is outside raster\");\n        }\n\n        SampleModel subSampleModel;\n        // Note: the SampleModel for the child Raster should have the same\n        // width and height as that for the parent, since it represents\n        // the physical layout of the pixel data.  The child Raster's width\n        // and height represent a \"virtual\" view of the pixel data, so\n        // they may be different than those of the SampleModel.\n        if (bandList == null) {\n            subSampleModel = sampleModel;\n        } else {\n            subSampleModel = sampleModel.createSubsetSampleModel(bandList);\n        }\n\n        int deltaX = childMinX - parentX;\n        int deltaY = childMinY - parentY;\n\n        return new Raster(subSampleModel, getDataBuffer(),\n                          new Rectangle(childMinX, childMinY, width, height),\n                          new Point(sampleModelTranslateX + deltaX,\n                                    sampleModelTranslateY + deltaY), this);\n    }"}
{"Number":"533","API Relative Path":"java.awt.image.Raster.java-createPackedRaster(int-int-int-int-int-Point)","Corresponding Source":"/**\n     * Creates a Raster based on a packed SampleModel with the\n     * specified data type, width, height, number of bands, and bits\n     * per band.  If the number of bands is one, the SampleModel will\n     * be a MultiPixelPackedSampleModel.\n     *\n     * <p> If the number of bands is more than one, the SampleModel\n     * will be a SinglePixelPackedSampleModel, with each band having\n     * bitsPerBand bits.  In either case, the requirements on dataType\n     * and bitsPerBand imposed by the corresponding SampleModel must\n     * be met.\n     *\n     * <p> The upper left corner of the Raster is given by the\n     * location argument.  If location is null, (0, 0) will be used.\n     * The dataType parameter should be one of the enumerated values\n     * defined in the DataBuffer class.\n     *\n     * <p> The only dataTypes supported currently are TYPE_BYTE, TYPE_USHORT,\n     * and TYPE_INT.\n     * @param dataType  the data type for storing samples\n     * @param w         the width in pixels of the image data\n     * @param h         the height in pixels of the image data\n     * @param bands     the number of bands\n     * @param bitsPerBand the number of bits per band\n     * @param location  the upper-left corner of the <code>Raster<\/code>\n     * @return a WritableRaster object with the specified data type,\n     *         width, height, number of bands, and bits per band.\n     * @throws RasterFormatException if <code>w<\/code> or <code>h<\/code>\n     *         is less than or equal to zero, or computing either\n     *         <code>location.x + w<\/code> or\n     *         <code>location.y + h<\/code> results in integer\n     *         overflow\n     * @throws IllegalArgumentException if the product of\n     *         <code>bitsPerBand<\/code> and <code>bands<\/code> is\n     *         greater than the number of bits held by\n     *         <code>dataType<\/code>\n     * @throws IllegalArgumentException if <code>bitsPerBand<\/code> or\n     *         <code>bands<\/code> is not greater than zero\n     * @throws IllegalArgumentException if <code>dataType<\/code> is not\n     *         one of the supported data types, which are\n     *         <code>DataBuffer.TYPE_BYTE<\/code>,\n     *         <code>DataBuffer.TYPE_USHORT<\/code>\n     *         or <code>DataBuffer.TYPE_INT<\/code>\n     */\n    public static WritableRaster createPackedRaster(int dataType,\n                                                    int w, int h,\n                                                    int bands,\n                                                    int bitsPerBand,\n                                                    Point location) {\n        DataBuffer d;\n\n        if (bands <= 0) {\n            throw new IllegalArgumentException(\"Number of bands (\"+bands+\n                                               \") must be greater than 0\");\n        }\n\n        if (bitsPerBand <= 0) {\n            throw new IllegalArgumentException(\"Bits per band (\"+bitsPerBand+\n                                               \") must be greater than 0\");\n        }\n\n        if (bands != 1) {\n            int[] masks = new int[bands];\n            int mask = (1 << bitsPerBand) - 1;\n            int shift = (bands-1)*bitsPerBand;\n\n            /* Make sure the total mask size will fit in the data type */\n            if (shift+bitsPerBand > DataBuffer.getDataTypeSize(dataType)) {\n                throw new IllegalArgumentException(\"bitsPerBand(\"+\n                                                   bitsPerBand+\") * bands is \"+\n                                                   \" greater than data type \"+\n                                                   \"size.\");\n            }\n            switch(dataType) {\n            case DataBuffer.TYPE_BYTE:\n            case DataBuffer.TYPE_USHORT:\n            case DataBuffer.TYPE_INT:\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unsupported data type \" +\n                                                    dataType);\n            }\n\n            for (int i = 0; i < bands; i++) {\n                masks[i] = mask << shift;\n                shift = shift - bitsPerBand;\n            }\n\n            return createPackedRaster(dataType, w, h, masks, location);\n        }\n        else {\n            double fw = w;\n            switch(dataType) {\n            case DataBuffer.TYPE_BYTE:\n                d = new DataBufferByte((int)(Math.ceil(fw/(8/bitsPerBand)))*h);\n                break;\n\n            case DataBuffer.TYPE_USHORT:\n                d = new DataBufferUShort((int)(Math.ceil(fw/(16/bitsPerBand)))*h);\n                break;\n\n            case DataBuffer.TYPE_INT:\n                d = new DataBufferInt((int)(Math.ceil(fw/(32/bitsPerBand)))*h);\n                break;\n\n            default:\n                throw new IllegalArgumentException(\"Unsupported data type \" +\n                                                   dataType);\n            }\n\n            return createPackedRaster(d, w, h, bitsPerBand, location);\n        }\n    }"}
{"Number":"534","API Relative Path":"java.awt.image.Raster.java-Raster(SampleModel-DataBuffer-Rectangle-Point-Raster)","Corresponding Source":"/**\n     * Constructs a Raster with the given SampleModel, DataBuffer, and\n     * parent.  aRegion specifies the bounding rectangle of the new\n     * Raster.  When translated into the base Raster's coordinate\n     * system, aRegion must be contained by the base Raster.\n     * (The base Raster is the Raster's ancestor which has no parent.)\n     * sampleModelTranslate specifies the sampleModelTranslateX and\n     * sampleModelTranslateY values of the new Raster.\n     *\n     * Note that this constructor should generally be called by other\n     * constructors or create methods, it should not be used directly.\n     * @param sampleModel     The SampleModel that specifies the layout\n     * @param dataBuffer      The DataBuffer that contains the image data\n     * @param aRegion         The Rectangle that specifies the image area\n     * @param sampleModelTranslate  The Point that specifies the translation\n     *                        from SampleModel to Raster coordinates\n     * @param parent          The parent (if any) of this raster\n     * @throws NullPointerException if any of <code>sampleModel<\/code>,\n     *         <code>dataBuffer<\/code>, <code>aRegion<\/code> or\n     *         <code>sampleModelTranslate<\/code> is null\n     * @throws RasterFormatException if <code>aRegion<\/code> has width\n     *         or height less than or equal to zero, or computing either\n     *         <code>aRegion.x + aRegion.width<\/code> or\n     *         <code>aRegion.y + aRegion.height<\/code> results in integer\n     *         overflow\n     */\n    protected Raster(SampleModel sampleModel,\n                     DataBuffer dataBuffer,\n                     Rectangle aRegion,\n                     Point sampleModelTranslate,\n                     Raster parent) {\n\n        if ((sampleModel == null) || (dataBuffer == null) ||\n            (aRegion == null) || (sampleModelTranslate == null)) {\n            throw new NullPointerException(\"SampleModel, dataBuffer, aRegion and \" +\n                                           \"sampleModelTranslate cannot be null\");\n        }\n       this.sampleModel = sampleModel;\n       this.dataBuffer = dataBuffer;\n       minX = aRegion.x;\n       minY = aRegion.y;\n       width = aRegion.width;\n       height = aRegion.height;\n       if (width <= 0 || height <= 0) {\n           throw new RasterFormatException(\"negative or zero \" +\n               ((width <= 0) ? \"width\" : \"height\"));\n       }\n       if ((minX + width) < minX) {\n           throw new RasterFormatException(\n               \"overflow condition for X coordinates of Raster\");\n       }\n       if ((minY + height) < minY) {\n           throw new RasterFormatException(\n               \"overflow condition for Y coordinates of Raster\");\n       }\n\n       sampleModelTranslateX = sampleModelTranslate.x;\n       sampleModelTranslateY = sampleModelTranslate.y;\n\n       numBands = sampleModel.getNumBands();\n       numDataElements = sampleModel.getNumDataElements();\n       this.parent = parent;\n    }"}
{"Number":"535","API Relative Path":"java.awt.image.RescaleOp.java-createCompatibleDestImage(BufferedImage-ColorModel)","Corresponding Source":"/**\n     * Creates a zeroed destination image with the correct size and number of\n     * bands.\n     * @param src       Source image for the filter operation.\n     * @param destCM    ColorModel of the destination.  If null, the\n     *                  ColorModel of the source will be used.\n     * @return the zeroed-destination image.\n     */\n    public BufferedImage createCompatibleDestImage (BufferedImage src,\n                                                    ColorModel destCM) {\n        BufferedImage image;\n        if (destCM == null) {\n            ColorModel cm = src.getColorModel();\n            image = new BufferedImage(cm,\n                                      src.getRaster().createCompatibleWritableRaster(),\n                                      cm.isAlphaPremultiplied(),\n                                      null);\n        }\n        else {\n            int w = src.getWidth();\n            int h = src.getHeight();\n            image = new BufferedImage (destCM,\n                                   destCM.createCompatibleWritableRaster(w, h),\n                                   destCM.isAlphaPremultiplied(), null);\n        }\n\n        return image;\n    }"}
{"Number":"536","API Relative Path":"java.awt.image.RescaleOp.java-filter(Raster-WritableRaster)","Corresponding Source":"/**\n     * Rescales the pixel data in the source Raster.\n     * If the destination Raster is null, a new Raster will be created.\n     * The source and destination must have the same number of bands.\n     * Otherwise, an IllegalArgumentException is thrown.\n     * Note that the number of scaling factors/offsets in this object must\n     * meet the restrictions stated in the class comments above.\n     * Otherwise, an IllegalArgumentException is thrown.\n     * @param src the <code>Raster<\/code> to be filtered\n     * @param dst the destination for the filtering operation\n     *            or <code>null<\/code>\n     * @return the filtered <code>WritableRaster<\/code>.\n     * @throws IllegalArgumentException if <code>src<\/code> and\n     *         <code>dst<\/code> do not have the same number of bands,\n     *         or if the number of scaling factors and offsets in this\n     *         <code>RescaleOp<\/code> do not meet the requirements\n     *         stated in the class comments.\n     */\n    public final WritableRaster filter (Raster src, WritableRaster dst)  {\n        int numBands = src.getNumBands();\n        int width  = src.getWidth();\n        int height = src.getHeight();\n        int[] srcPix = null;\n        int step = 0;\n        int tidx = 0;\n\n        // Create a new destination Raster, if needed\n        if (dst == null) {\n            dst = createCompatibleDestRaster(src);\n        }\n        else if (height != dst.getHeight() || width != dst.getWidth()) {\n            throw new\n               IllegalArgumentException(\"Width or height of Rasters do not \"+\n                                        \"match\");\n        }\n        else if (numBands != dst.getNumBands()) {\n            // Make sure that the number of bands are equal\n            throw new IllegalArgumentException(\"Number of bands in src \"\n                            + numBands\n                            + \" does not equal number of bands in dest \"\n                            + dst.getNumBands());\n        }\n        // Make sure that the arrays match\n        // Make sure that the low/high/constant arrays match\n        if (length != 1 && length != src.getNumBands()) {\n            throw new IllegalArgumentException(\"Number of scaling constants \"+\n                                               \"does not equal the number of\"+\n                                               \" of bands in the src raster\");\n        }\n\n\n        //\n        // Try for a native raster rescale first\n        //\n        if (ImagingLib.filter(this, src, dst) != null) {\n            return dst;\n        }\n\n        //\n        // Native raster rescale failed.\n        // Try to see if a lookup operation can be used\n        //\n        if (canUseLookup(src, dst)) {\n            int srcNgray = (1 << srcNbits);\n            int dstNgray = (1 << dstNbits);\n\n            if (dstNgray == 256) {\n                ByteLookupTable lut = createByteLut(scaleFactors, offsets,\n                                                    numBands, srcNgray);\n                LookupOp op = new LookupOp(lut, hints);\n                op.filter(src, dst);\n            } else {\n                ShortLookupTable lut = createShortLut(scaleFactors, offsets,\n                                                      numBands, srcNgray);\n                LookupOp op = new LookupOp(lut, hints);\n                op.filter(src, dst);\n            }\n        } else {\n            //\n            // Fall back to the slow code\n            //\n            if (length > 1) {\n                step = 1;\n            }\n\n            int sminX = src.getMinX();\n            int sY = src.getMinY();\n            int dminX = dst.getMinX();\n            int dY = dst.getMinY();\n            int sX;\n            int dX;\n\n            //\n            //  Determine bits per band to determine maxval for clamps.\n            //  The min is assumed to be zero.\n            //  REMIND: This must change if we ever support signed data types.\n            //\n            int nbits;\n            int dstMax[] = new int[numBands];\n            int dstMask[] = new int[numBands];\n            SampleModel dstSM = dst.getSampleModel();\n            for (int z=0; z<numBands; z++) {\n                nbits = dstSM.getSampleSize(z);\n                dstMax[z] = (1 << nbits) - 1;\n                dstMask[z] = ~(dstMax[z]);\n            }\n\n            int val;\n            for (int y=0; y < height; y++, sY++, dY++) {\n                dX = dminX;\n                sX = sminX;\n                for (int x = 0; x < width; x++, sX++, dX++) {\n                    // Get data for all bands at this x,y position\n                    srcPix = src.getPixel(sX, sY, srcPix);\n                    tidx = 0;\n                    for (int z=0; z<numBands; z++, tidx += step) {\n                        val = (int)(srcPix[z]*scaleFactors[tidx]\n                                          + offsets[tidx]);\n                        // Clamp\n                        if ((val & dstMask[z]) != 0) {\n                            if (val < 0) {\n                                val = 0;\n                            } else {\n                                val = dstMax[z];\n                            }\n                        }\n                        srcPix[z] = val;\n\n                    }\n\n                    // Put it back for all bands\n                    dst.setPixel(dX, dY, srcPix);\n                }\n            }\n        }\n        return dst;\n    }"}
{"Number":"537","API Relative Path":"java.awt.image.SampleModel.java-getDataElements(int-int-int-int-Object-DataBuffer)","Corresponding Source":"/**\n     * Returns the pixel data for the specified rectangle of pixels in a\n     * primitive array of type TransferType.\n     * For image data supported by the Java 2D API, this\n     * will be one of DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT,\n     * DataBuffer.TYPE_INT, DataBuffer.TYPE_SHORT, DataBuffer.TYPE_FLOAT,\n     * or DataBuffer.TYPE_DOUBLE.  Data may be returned in a packed format,\n     * thus increasing efficiency for data transfers. Generally, obj\n     * should be passed in as null, so that the Object will be created\n     * automatically and will be of the right primitive data type.\n     * <p>\n     * The following code illustrates transferring data for a rectangular\n     * region of pixels from\n     * DataBuffer <code>db1<\/code>, whose storage layout is described by\n     * SampleModel <code>sm1<\/code>, to DataBuffer <code>db2<\/code>, whose\n     * storage layout is described by SampleModel <code>sm2<\/code>.\n     * The transfer will generally be more efficient than using\n     * getPixels/setPixels.\n     * <pre>\n     *       SampleModel sm1, sm2;\n     *       DataBuffer db1, db2;\n     *       sm2.setDataElements(x, y, w, h, sm1.getDataElements(x, y, w,\n     *                           h, null, db1), db2);\n     * <\/pre>\n     * Using getDataElements/setDataElements to transfer between two\n     * DataBuffer/SampleModel pairs is legitimate if the SampleModels have\n     * the same number of bands, corresponding bands have the same number of\n     * bits per sample, and the TransferTypes are the same.\n     * <p>\n     * If obj is non-null, it should be a primitive array of type TransferType.\n     * Otherwise, a ClassCastException is thrown.  An\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds, or if obj is non-null and is not large enough to hold\n     * the pixel data.\n     * @param x         The minimum X coordinate of the pixel rectangle.\n     * @param y         The minimum Y coordinate of the pixel rectangle.\n     * @param w         The width of the pixel rectangle.\n     * @param h         The height of the pixel rectangle.\n     * @param obj       If non-null, a primitive array in which to return\n     *                  the pixel data.\n     * @param data      The DataBuffer containing the image data.\n     * @return the data elements for the specified region of pixels.\n     * @see #getNumDataElements\n     * @see #getTransferType\n     * @see #setDataElements(int, int, int, int, Object, DataBuffer)\n     * @see java.awt.image.DataBuffer\n     *\n     * @throws NullPointerException if data is null.\n     * @throws ArrayIndexOutOfBoundsException if the coordinates are\n     * not in bounds, or if obj is too small to hold the output.\n     */\n    public Object getDataElements(int x, int y, int w, int h,\n                                  Object obj, DataBuffer data) {\n\n        int type = getTransferType();\n        int numDataElems = getNumDataElements();\n        int cnt = 0;\n        Object o = null;\n\n        int x1 = x + w;\n        int y1 = y + h;\n\n        if (x < 0 || x >= width || w > width || x1 < 0 || x1 > width ||\n            y < 0 || y >= height || h > height || y1 < 0 || y1 > height)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Invalid coordinates.\");\n        }\n\n        switch(type) {\n\n        case DataBuffer.TYPE_BYTE:\n\n            byte[] btemp;\n            byte[] bdata;\n\n            if (obj == null)\n                bdata = new byte[numDataElems*w*h];\n            else\n                bdata = (byte[])obj;\n\n            for (int i=y; i<y1; i++) {\n                for (int j=x; j<x1; j++) {\n                    o = getDataElements(j, i, o, data);\n                    btemp = (byte[])o;\n                    for (int k=0; k<numDataElems; k++) {\n                        bdata[cnt++] = btemp[k];\n                    }\n                }\n            }\n            obj = (Object)bdata;\n            break;\n\n        case DataBuffer.TYPE_USHORT:\n        case DataBuffer.TYPE_SHORT:\n\n            short[] sdata;\n            short[] stemp;\n\n            if (obj == null)\n                sdata = new short[numDataElems*w*h];\n            else\n                sdata = (short[])obj;\n\n            for (int i=y; i<y1; i++) {\n                for (int j=x; j<x1; j++) {\n                    o = getDataElements(j, i, o, data);\n                    stemp = (short[])o;\n                    for (int k=0; k<numDataElems; k++) {\n                        sdata[cnt++] = stemp[k];\n                    }\n                }\n            }\n\n            obj = (Object)sdata;\n            break;\n\n        case DataBuffer.TYPE_INT:\n\n            int[] idata;\n            int[] itemp;\n\n            if (obj == null)\n                idata = new int[numDataElems*w*h];\n            else\n                idata = (int[])obj;\n\n            for (int i=y; i<y1; i++) {\n                for (int j=x; j<x1; j++) {\n                    o = getDataElements(j, i, o, data);\n                    itemp = (int[])o;\n                    for (int k=0; k<numDataElems; k++) {\n                        idata[cnt++] = itemp[k];\n                    }\n                }\n            }\n\n            obj = (Object)idata;\n            break;\n\n        case DataBuffer.TYPE_FLOAT:\n\n            float[] fdata;\n            float[] ftemp;\n\n            if (obj == null)\n                fdata = new float[numDataElems*w*h];\n            else\n                fdata = (float[])obj;\n\n            for (int i=y; i<y1; i++) {\n                for (int j=x; j<x1; j++) {\n                    o = getDataElements(j, i, o, data);\n                    ftemp = (float[])o;\n                    for (int k=0; k<numDataElems; k++) {\n                        fdata[cnt++] = ftemp[k];\n                    }\n                }\n            }\n\n            obj = (Object)fdata;\n            break;\n\n        case DataBuffer.TYPE_DOUBLE:\n\n            double[] ddata;\n            double[] dtemp;\n\n            if (obj == null)\n                ddata = new double[numDataElems*w*h];\n            else\n                ddata = (double[])obj;\n\n            for (int i=y; i<y1; i++) {\n                for (int j=x; j<x1; j++) {\n                    o = getDataElements(j, i, o, data);\n                    dtemp = (double[])o;\n                    for (int k=0; k<numDataElems; k++) {\n                        ddata[cnt++] = dtemp[k];\n                    }\n                }\n            }\n\n            obj = (Object)ddata;\n            break;\n        }\n\n        return obj;\n    }"}
{"Number":"538","API Relative Path":"java.awt.image.SampleModel.java-getPixels(int-int-int-int-double-DataBuffer)","Corresponding Source":"/**\n     * Returns all samples for a rectangle of pixels in a double\n     * array, one sample per array element.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the upper left pixel location.\n     * @param y         The Y coordinate of the upper left pixel location.\n     * @param w         The width of the pixel rectangle.\n     * @param h         The height of the pixel rectangle.\n     * @param dArray    If non-null, returns the samples in this array.\n     * @param data      The DataBuffer containing the image data.\n     * @return the samples for the specified region of pixels.\n     * @see #setPixels(int, int, int, int, double[], DataBuffer)\n     *\n     * @throws NullPointerException if data is null.\n     * @throws ArrayIndexOutOfBoundsException if the coordinates are\n     * not in bounds, or if dArray is too small to hold the output.\n     */\n    public double[] getPixels(int x, int y, int w, int h,\n                              double dArray[], DataBuffer data) {\n        double pixels[];\n        int    Offset = 0;\n        int x1 = x + w;\n        int y1 = y + h;\n\n        if (x < 0 || x >= width || w > width || x1 < 0 || x1 > width ||\n            y < 0 || y >= height || h > height || y1 < 0 || y1 > height)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Invalid coordinates.\");\n        }\n\n        if (dArray != null)\n            pixels = dArray;\n        else\n            pixels = new double[numBands * w * h];\n\n        // Fix 4217412\n        for (int i=y; i<y1; i++) {\n            for (int j=x; j<x1; j++) {\n                for (int k=0; k<numBands; k++) {\n                    pixels[Offset++] = getSampleDouble(j, i, k, data);\n                }\n            }\n        }\n\n        return pixels;\n    }"}
{"Number":"539","API Relative Path":"java.awt.image.SampleModel.java-getPixels(int-int-int-int-float-DataBuffer)","Corresponding Source":"/**\n     * Returns all samples for a rectangle of pixels in a float\n     * array, one sample per array element.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the upper left pixel location.\n     * @param y         The Y coordinate of the upper left pixel location.\n     * @param w         The width of the pixel rectangle.\n     * @param h         The height of the pixel rectangle.\n     * @param fArray    If non-null, returns the samples in this array.\n     * @param data      The DataBuffer containing the image data.\n     * @return the samples for the specified region of pixels.\n     * @see #setPixels(int, int, int, int, float[], DataBuffer)\n     *\n     * @throws NullPointerException if data is null.\n     * @throws ArrayIndexOutOfBoundsException if the coordinates are\n     * not in bounds, or if fArray is too small to hold the output.\n     */\n    public float[] getPixels(int x, int y, int w, int h,\n                             float fArray[], DataBuffer data) {\n\n        float pixels[];\n        int Offset = 0;\n        int x1 = x + w;\n        int y1 = y + h;\n\n        if (x < 0 || x >= width || w > width || x1 < 0 || x1 > width ||\n            y < 0 || y >= height || h > height || y1 < 0 || y1 > height)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Invalid coordinates.\");\n        }\n\n        if (fArray != null)\n            pixels = fArray;\n        else\n            pixels = new float[numBands * w * h];\n\n        for (int i=y; i<y1; i++) {\n            for(int j=x; j<x1; j++) {\n                for(int k=0; k<numBands; k++) {\n                    pixels[Offset++] = getSampleFloat(j, i, k, data);\n                }\n            }\n        }\n\n        return pixels;\n    }"}
{"Number":"540","API Relative Path":"java.awt.image.SampleModel.java-getPixels(int-int-int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Returns all samples for a rectangle of pixels in an\n     * int array, one sample per array element.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the upper left pixel location.\n     * @param y         The Y coordinate of the upper left pixel location.\n     * @param w         The width of the pixel rectangle.\n     * @param h         The height of the pixel rectangle.\n     * @param iArray    If non-null, returns the samples in this array.\n     * @param data      The DataBuffer containing the image data.\n     * @return the samples for the specified region of pixels.\n     * @see #setPixels(int, int, int, int, int[], DataBuffer)\n     *\n     * @throws NullPointerException if data is null.\n     * @throws ArrayIndexOutOfBoundsException if the coordinates are\n     * not in bounds, or if iArray is too small to hold the output.\n     */\n    public int[] getPixels(int x, int y, int w, int h,\n                           int iArray[], DataBuffer data) {\n\n        int pixels[];\n        int Offset=0;\n        int x1 = x + w;\n        int y1 = y + h;\n\n        if (x < 0 || x >= width || w > width || x1 < 0 || x1 > width ||\n            y < 0 || y >= height || h > height || y1 < 0 || y1 > height)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Invalid coordinates.\");\n        }\n\n        if (iArray != null)\n            pixels = iArray;\n        else\n            pixels = new int[numBands * w * h];\n\n        for (int i=y; i<y1; i++) {\n            for (int j=x; j<x1; j++) {\n                for(int k=0; k<numBands; k++) {\n                    pixels[Offset++] = getSample(j, i, k, data);\n                }\n            }\n        }\n\n        return pixels;\n    }"}
{"Number":"541","API Relative Path":"java.awt.image.SampleModel.java-getSamples(int-int-int-int-int-double-DataBuffer)","Corresponding Source":"/**\n     * Returns the samples for a specified band for a specified rectangle\n     * of pixels in a double array, one sample per array element.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the upper left pixel location.\n     * @param y         The Y coordinate of the upper left pixel location.\n     * @param w         The width of the pixel rectangle.\n     * @param h         The height of the pixel rectangle.\n     * @param b         The band to return.\n     * @param dArray    If non-null, returns the samples in this array.\n     * @param data      The DataBuffer containing the image data.\n     * @return the samples for the specified band for the specified region\n     *         of pixels.\n     * @see #setSamples(int, int, int, int, int, double[], DataBuffer)\n     *\n     * @throws NullPointerException if data is null.\n     * @throws ArrayIndexOutOfBoundsException if the coordinates or\n     * the band index are not in bounds, or if dArray is too small to\n     * hold the output.\n     */\n    public double[] getSamples(int x, int y, int w, int h,\n                               int b, double dArray[],\n                               DataBuffer data) {\n        double pixels[];\n        int    Offset=0;\n        int x1 = x + w;\n        int y1 = y + h;\n\n        if (x < 0 || x1 < x || x1 > width ||\n            y < 0 || y1 < y || y1 > height)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Invalid coordinates\");\n        }\n\n        if (dArray != null)\n            pixels = dArray;\n        else\n            pixels = new double[w * h];\n\n        for (int i=y; i<y1; i++) {\n            for (int j=x; j<x1; j++) {\n                pixels[Offset++] = getSampleDouble(j, i, b, data);\n            }\n        }\n\n        return pixels;\n    }"}
{"Number":"542","API Relative Path":"java.awt.image.SampleModel.java-getSamples(int-int-int-int-int-float-DataBuffer)","Corresponding Source":"/**\n     * Returns the samples for a specified band for the specified rectangle\n     * of pixels in a float array, one sample per array element.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the upper left pixel location.\n     * @param y         The Y coordinate of the upper left pixel location.\n     * @param w         The width of the pixel rectangle.\n     * @param h         The height of the pixel rectangle.\n     * @param b         The band to return.\n     * @param fArray    If non-null, returns the samples in this array.\n     * @param data      The DataBuffer containing the image data.\n     * @return the samples for the specified band for the specified region\n     *         of pixels.\n     * @see #setSamples(int, int, int, int, int, float[], DataBuffer)\n     *\n     * @throws NullPointerException if data is null.\n     * @throws ArrayIndexOutOfBoundsException if the coordinates or\n     * the band index are not in bounds, or if fArray is too small to\n     * hold the output.\n     */\n    public float[] getSamples(int x, int y, int w, int h,\n                              int b, float fArray[],\n                              DataBuffer data) {\n        float pixels[];\n        int   Offset=0;\n        int x1 = x + w;\n        int y1 = y + h;\n\n        if (x < 0 || x1 < x || x1 > width ||\n            y < 0 || y1 < y || y1 > height)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Invalid coordinates\");\n        }\n\n        if (fArray != null)\n            pixels = fArray;\n        else\n            pixels = new float[w * h];\n\n        for (int i=y; i<y1; i++) {\n            for (int j=x; j<x1; j++) {\n                pixels[Offset++] = getSampleFloat(j, i, b, data);\n            }\n        }\n\n        return pixels;\n    }"}
{"Number":"543","API Relative Path":"java.awt.image.SampleModel.java-getSamples(int-int-int-int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Returns the samples for a specified band for the specified rectangle\n     * of pixels in an int array, one sample per array element.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the upper left pixel location.\n     * @param y         The Y coordinate of the upper left pixel location.\n     * @param w         The width of the pixel rectangle.\n     * @param h         The height of the pixel rectangle.\n     * @param b         The band to return.\n     * @param iArray    If non-null, returns the samples in this array.\n     * @param data      The DataBuffer containing the image data.\n     * @return the samples for the specified band for the specified region\n     *         of pixels.\n     * @see #setSamples(int, int, int, int, int, int[], DataBuffer)\n     *\n     * @throws NullPointerException if data is null.\n     * @throws ArrayIndexOutOfBoundsException if the coordinates or\n     * the band index are not in bounds, or if iArray is too small to\n     * hold the output.\n     */\n    public int[] getSamples(int x, int y, int w, int h, int b,\n                            int iArray[], DataBuffer data) {\n        int pixels[];\n        int Offset=0;\n        int x1 = x + w;\n        int y1 = y + h;\n\n        if (x < 0 || x1 < x || x1 > width ||\n            y < 0 || y1 < y || y1 > height)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Invalid coordinates.\");\n        }\n\n        if (iArray != null)\n            pixels = iArray;\n        else\n            pixels = new int[w * h];\n\n        for(int i=y; i<y1; i++) {\n            for (int j=x; j<x1; j++) {\n                pixels[Offset++] = getSample(j, i, b, data);\n            }\n        }\n\n        return pixels;\n    }"}
{"Number":"544","API Relative Path":"java.awt.image.SampleModel.java-SampleModel(int-int-int-int)","Corresponding Source":"/**\n     * Constructs a SampleModel with the specified parameters.\n     * @param dataType  The data type of the DataBuffer storing the pixel data.\n     * @param w         The width (in pixels) of the region of image data.\n     * @param h         The height (in pixels) of the region of image data.\n     * @param numBands  The number of bands of the image data.\n     * @throws IllegalArgumentException if <code>w<\/code> or <code>h<\/code>\n     *         is not greater than 0\n     * @throws IllegalArgumentException if the product of <code>w<\/code>\n     *         and <code>h<\/code> is greater than\n     *         <code>Integer.MAX_VALUE<\/code>\n     * @throws IllegalArgumentException if <code>dataType<\/code> is not\n     *         one of the supported data types\n     */\n    public SampleModel(int dataType, int w, int h, int numBands)\n    {\n        long size = (long)w * h;\n        if (w <= 0 || h <= 0) {\n            throw new IllegalArgumentException(\"Width (\"+w+\") and height (\"+\n                                               h+\") must be > 0\");\n        }\n        if (size >= Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Dimensions (width=\"+w+\n                                               \" height=\"+h+\") are too large\");\n        }\n\n        if (dataType < DataBuffer.TYPE_BYTE ||\n            (dataType > DataBuffer.TYPE_DOUBLE &&\n             dataType != DataBuffer.TYPE_UNDEFINED))\n        {\n            throw new IllegalArgumentException(\"Unsupported dataType: \"+\n                                               dataType);\n        }\n\n        if (numBands <= 0) {\n            throw new IllegalArgumentException(\"Number of bands must be > 0\");\n        }\n\n        this.dataType = dataType;\n        this.width = w;\n        this.height = h;\n        this.numBands = numBands;\n    }"}
{"Number":"545","API Relative Path":"java.awt.image.SampleModel.java-SampleModel(int-int-int-int)","Corresponding Source":"/**\n     * Constructs a SampleModel with the specified parameters.\n     * @param dataType  The data type of the DataBuffer storing the pixel data.\n     * @param w         The width (in pixels) of the region of image data.\n     * @param h         The height (in pixels) of the region of image data.\n     * @param numBands  The number of bands of the image data.\n     * @throws IllegalArgumentException if <code>w<\/code> or <code>h<\/code>\n     *         is not greater than 0\n     * @throws IllegalArgumentException if the product of <code>w<\/code>\n     *         and <code>h<\/code> is greater than\n     *         <code>Integer.MAX_VALUE<\/code>\n     * @throws IllegalArgumentException if <code>dataType<\/code> is not\n     *         one of the supported data types\n     */\n    public SampleModel(int dataType, int w, int h, int numBands)\n    {\n        long size = (long)w * h;\n        if (w <= 0 || h <= 0) {\n            throw new IllegalArgumentException(\"Width (\"+w+\") and height (\"+\n                                               h+\") must be > 0\");\n        }\n        if (size >= Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Dimensions (width=\"+w+\n                                               \" height=\"+h+\") are too large\");\n        }\n\n        if (dataType < DataBuffer.TYPE_BYTE ||\n            (dataType > DataBuffer.TYPE_DOUBLE &&\n             dataType != DataBuffer.TYPE_UNDEFINED))\n        {\n            throw new IllegalArgumentException(\"Unsupported dataType: \"+\n                                               dataType);\n        }\n\n        if (numBands <= 0) {\n            throw new IllegalArgumentException(\"Number of bands must be > 0\");\n        }\n\n        this.dataType = dataType;\n        this.width = w;\n        this.height = h;\n        this.numBands = numBands;\n    }"}
{"Number":"546","API Relative Path":"java.awt.image.SampleModel.java-SampleModel(int-int-int-int)","Corresponding Source":"/**\n     * Constructs a SampleModel with the specified parameters.\n     * @param dataType  The data type of the DataBuffer storing the pixel data.\n     * @param w         The width (in pixels) of the region of image data.\n     * @param h         The height (in pixels) of the region of image data.\n     * @param numBands  The number of bands of the image data.\n     * @throws IllegalArgumentException if <code>w<\/code> or <code>h<\/code>\n     *         is not greater than 0\n     * @throws IllegalArgumentException if the product of <code>w<\/code>\n     *         and <code>h<\/code> is greater than\n     *         <code>Integer.MAX_VALUE<\/code>\n     * @throws IllegalArgumentException if <code>dataType<\/code> is not\n     *         one of the supported data types\n     */\n    public SampleModel(int dataType, int w, int h, int numBands)\n    {\n        long size = (long)w * h;\n        if (w <= 0 || h <= 0) {\n            throw new IllegalArgumentException(\"Width (\"+w+\") and height (\"+\n                                               h+\") must be > 0\");\n        }\n        if (size >= Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Dimensions (width=\"+w+\n                                               \" height=\"+h+\") are too large\");\n        }\n\n        if (dataType < DataBuffer.TYPE_BYTE ||\n            (dataType > DataBuffer.TYPE_DOUBLE &&\n             dataType != DataBuffer.TYPE_UNDEFINED))\n        {\n            throw new IllegalArgumentException(\"Unsupported dataType: \"+\n                                               dataType);\n        }\n\n        if (numBands <= 0) {\n            throw new IllegalArgumentException(\"Number of bands must be > 0\");\n        }\n\n        this.dataType = dataType;\n        this.width = w;\n        this.height = h;\n        this.numBands = numBands;\n    }"}
{"Number":"547","API Relative Path":"java.awt.image.SampleModel.java-setDataElements(int-int-int-int-Object-DataBuffer)","Corresponding Source":"/**\n     * Sets the data for a rectangle of pixels in the specified DataBuffer\n     * from a primitive array of type TransferType.  For image data supported\n     * by the Java 2D API, this will be one of DataBuffer.TYPE_BYTE,\n     * DataBuffer.TYPE_USHORT, DataBuffer.TYPE_INT, DataBuffer.TYPE_SHORT,\n     * DataBuffer.TYPE_FLOAT, or DataBuffer.TYPE_DOUBLE.  Data in the array\n     * may be in a packed format, thus increasing efficiency for data\n     * transfers.\n     * <p>\n     * The following code illustrates transferring data for a rectangular\n     * region of pixels from\n     * DataBuffer <code>db1<\/code>, whose storage layout is described by\n     * SampleModel <code>sm1<\/code>, to DataBuffer <code>db2<\/code>, whose\n     * storage layout is described by SampleModel <code>sm2<\/code>.\n     * The transfer will generally be more efficient than using\n     * getPixels/setPixels.\n     * <pre>\n     *       SampleModel sm1, sm2;\n     *       DataBuffer db1, db2;\n     *       sm2.setDataElements(x, y, w, h, sm1.getDataElements(x, y, w, h,\n     *                           null, db1), db2);\n     * <\/pre>\n     * Using getDataElements/setDataElements to transfer between two\n     * DataBuffer/SampleModel pairs is legitimate if the SampleModels have\n     * the same number of bands, corresponding bands have the same number of\n     * bits per sample, and the TransferTypes are the same.\n     * <p>\n     * obj must be a primitive array of type TransferType.  Otherwise,\n     * a ClassCastException is thrown.  An\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds, or if obj is not large enough to hold the pixel data.\n     * @param x         The minimum X coordinate of the pixel rectangle.\n     * @param y         The minimum Y coordinate of the pixel rectangle.\n     * @param w         The width of the pixel rectangle.\n     * @param h         The height of the pixel rectangle.\n     * @param obj       A primitive array containing pixel data.\n     * @param data      The DataBuffer containing the image data.\n     * @see #getNumDataElements\n     * @see #getTransferType\n     * @see #getDataElements(int, int, int, int, Object, DataBuffer)\n     * @see java.awt.image.DataBuffer\n     *\n     * @throws NullPointerException if data is null.\n     * @throws ArrayIndexOutOfBoundsException if the coordinates are\n     * not in bounds, or if obj is too small to hold the input.\n     */\n    public void setDataElements(int x, int y, int w, int h,\n                                Object obj, DataBuffer data) {\n\n        int cnt = 0;\n        Object o = null;\n        int type = getTransferType();\n        int numDataElems = getNumDataElements();\n\n        int x1 = x + w;\n        int y1 = y + h;\n\n        if (x < 0 || x >= width || w > width || x1 < 0 || x1 > width ||\n            y < 0 || y >= height || h > height || y1 < 0 || y1 > height)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Invalid coordinates.\");\n        }\n\n        switch(type) {\n\n        case DataBuffer.TYPE_BYTE:\n\n            byte[] barray = (byte[])obj;\n            byte[] btemp = new byte[numDataElems];\n\n            for (int i=y; i<y1; i++) {\n                for (int j=x; j<x1; j++) {\n                    for (int k=0; k<numDataElems; k++) {\n                        btemp[k] = barray[cnt++];\n                    }\n\n                    setDataElements(j, i, btemp, data);\n                }\n            }\n            break;\n\n        case DataBuffer.TYPE_USHORT:\n        case DataBuffer.TYPE_SHORT:\n\n            short[] sarray = (short[])obj;\n            short[] stemp = new short[numDataElems];\n\n            for (int i=y; i<y1; i++) {\n                for (int j=x; j<x1; j++) {\n                    for (int k=0; k<numDataElems; k++) {\n                        stemp[k] = sarray[cnt++];\n                    }\n\n                    setDataElements(j, i, stemp, data);\n                }\n            }\n            break;\n\n        case DataBuffer.TYPE_INT:\n\n            int[] iArray = (int[])obj;\n            int[] itemp = new int[numDataElems];\n\n            for (int i=y; i<y1; i++) {\n                for (int j=x; j<x1; j++) {\n                    for (int k=0; k<numDataElems; k++) {\n                        itemp[k] = iArray[cnt++];\n                    }\n\n                    setDataElements(j, i, itemp, data);\n                }\n            }\n            break;\n\n        case DataBuffer.TYPE_FLOAT:\n\n            float[] fArray = (float[])obj;\n            float[] ftemp = new float[numDataElems];\n\n            for (int i=y; i<y1; i++) {\n                for (int j=x; j<x1; j++) {\n                    for (int k=0; k<numDataElems; k++) {\n                        ftemp[k] = fArray[cnt++];\n                    }\n\n                    setDataElements(j, i, ftemp, data);\n                }\n            }\n            break;\n\n        case DataBuffer.TYPE_DOUBLE:\n\n            double[] dArray = (double[])obj;\n            double[] dtemp = new double[numDataElems];\n\n            for (int i=y; i<y1; i++) {\n                for (int j=x; j<x1; j++) {\n                    for (int k=0; k<numDataElems; k++) {\n                        dtemp[k] = dArray[cnt++];\n                    }\n\n                    setDataElements(j, i, dtemp, data);\n                }\n            }\n            break;\n        }\n\n    }"}
{"Number":"548","API Relative Path":"java.awt.image.SampleModel.java-setPixels(int-int-int-int-double-DataBuffer)","Corresponding Source":"/**\n     * Sets all samples for a rectangle of pixels from a double array\n     * containing one sample per array element.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the upper left pixel location.\n     * @param y         The Y coordinate of the upper left pixel location.\n     * @param w         The width of the pixel rectangle.\n     * @param h         The height of the pixel rectangle.\n     * @param dArray    The input samples in a double array.\n     * @param data      The DataBuffer containing the image data.\n     * @see #getPixels(int, int, int, int, double[], DataBuffer)\n     *\n     * @throws NullPointerException if dArray or data is null.\n     * @throws ArrayIndexOutOfBoundsException if the coordinates are\n     * not in bounds, or if dArray is too small to hold the input.\n     */\n    public void setPixels(int x, int y, int w, int h,\n                          double dArray[], DataBuffer data) {\n        int Offset=0;\n        int x1 = x + w;\n        int y1 = y + h;\n\n        if (x < 0 || x >= width || w > width || x1 < 0 || x1 > width ||\n            y < 0 || y >= height || h > height || y1 < 0 || y1 > height)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Invalid coordinates.\");\n        }\n\n        for (int i=y; i<y1; i++) {\n            for (int j=x; j<x1; j++) {\n                for (int k=0; k<numBands; k++) {\n                    setSample(j, i, k, dArray[Offset++], data);\n                }\n            }\n        }\n    }"}
{"Number":"549","API Relative Path":"java.awt.image.SampleModel.java-setPixels(int-int-int-int-float-DataBuffer)","Corresponding Source":"/**\n     * Sets all samples for a rectangle of pixels from a float array containing\n     * one sample per array element.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the upper left pixel location.\n     * @param y         The Y coordinate of the upper left pixel location.\n     * @param w         The width of the pixel rectangle.\n     * @param h         The height of the pixel rectangle.\n     * @param fArray    The input samples in a float array.\n     * @param data      The DataBuffer containing the image data.\n     * @see #getPixels(int, int, int, int, float[], DataBuffer)\n     *\n     * @throws NullPointerException if fArray or data is null.\n     * @throws ArrayIndexOutOfBoundsException if the coordinates are\n     * not in bounds, or if fArray is too small to hold the input.\n     */\n    public void setPixels(int x, int y, int w, int h,\n                          float fArray[], DataBuffer data) {\n        int Offset=0;\n        int x1 = x + w;\n        int y1 = y + h;\n\n        if (x < 0 || x >= width || w > width || x1 < 0 || x1 > width||\n            y < 0 || y >= height || h > height || y1 < 0 || y1 > height)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Invalid coordinates.\");\n        }\n\n        for (int i=y; i<y1; i++) {\n            for (int j=x; j<x1; j++) {\n                for(int k=0; k<numBands; k++) {\n                    setSample(j, i, k, fArray[Offset++], data);\n                }\n            }\n        }\n    }"}
{"Number":"550","API Relative Path":"java.awt.image.SampleModel.java-setPixels(int-int-int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Sets all samples for a rectangle of pixels from an int array containing\n     * one sample per array element.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the upper left pixel location.\n     * @param y         The Y coordinate of the upper left pixel location.\n     * @param w         The width of the pixel rectangle.\n     * @param h         The height of the pixel rectangle.\n     * @param iArray    The input samples in an int array.\n     * @param data      The DataBuffer containing the image data.\n     * @see #getPixels(int, int, int, int, int[], DataBuffer)\n     *\n     * @throws NullPointerException if iArray or data is null.\n     * @throws ArrayIndexOutOfBoundsException if the coordinates are\n     * not in bounds, or if iArray is too small to hold the input.\n     */\n    public void setPixels(int x, int y, int w, int h,\n                          int iArray[], DataBuffer data) {\n        int Offset=0;\n        int x1 = x + w;\n        int y1 = y + h;\n\n        if (x < 0 || x >= width || w > width || x1 < 0 || x1 > width ||\n            y < 0 || y >= height || h > height || y1 < 0 || y1 > height)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Invalid coordinates.\");\n        }\n\n        for (int i=y; i<y1; i++) {\n            for (int j=x; j<x1; j++) {\n                for (int k=0; k<numBands; k++) {\n                    setSample(j, i, k, iArray[Offset++], data);\n                }\n            }\n        }\n    }"}
{"Number":"551","API Relative Path":"java.awt.image.SampleModel.java-setSamples(int-int-int-int-int-double-DataBuffer)","Corresponding Source":"/**\n     * Sets the samples in the specified band for the specified rectangle\n     * of pixels from a double array containing one sample per array element.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the upper left pixel location.\n     * @param y         The Y coordinate of the upper left pixel location.\n     * @param w         The width of the pixel rectangle.\n     * @param h         The height of the pixel rectangle.\n     * @param b         The band to set.\n     * @param dArray    The input samples in a double array.\n     * @param data      The DataBuffer containing the image data.\n     * @see #getSamples(int, int, int, int, int, double[], DataBuffer)\n     *\n     * @throws NullPointerException if dArray or data is null.\n     * @throws ArrayIndexOutOfBoundsException if the coordinates or\n     * the band index are not in bounds, or if dArray is too small to\n     * hold the input.\n     */\n    public void setSamples(int x, int y, int w, int h, int b,\n                           double dArray[], DataBuffer data) {\n        int Offset=0;\n        int x1 = x + w;\n        int y1 = y + h;\n\n\n        if (x < 0 || x >= width || w > width || x1 < 0 || x1 > width ||\n            y < 0 || y >= height || h > height || y1 < 0 || y1 > height)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Invalid coordinates.\");\n        }\n\n        for (int i=y; i<y1; i++) {\n            for (int j=x; j<x1; j++) {\n                setSample(j, i, b, dArray[Offset++], data);\n            }\n        }\n    }"}
{"Number":"552","API Relative Path":"java.awt.image.SampleModel.java-setSamples(int-int-int-int-int-float-DataBuffer)","Corresponding Source":"/**\n     * Sets the samples in the specified band for the specified rectangle\n     * of pixels from a float array containing one sample per array element.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the upper left pixel location.\n     * @param y         The Y coordinate of the upper left pixel location.\n     * @param w         The width of the pixel rectangle.\n     * @param h         The height of the pixel rectangle.\n     * @param b         The band to set.\n     * @param fArray    The input samples in a float array.\n     * @param data      The DataBuffer containing the image data.\n     * @see #getSamples(int, int, int, int, int, float[], DataBuffer)\n     *\n     * @throws NullPointerException if fArray or data is null.\n     * @throws ArrayIndexOutOfBoundsException if the coordinates or\n     * the band index are not in bounds, or if fArray is too small to\n     * hold the input.\n     */\n    public void setSamples(int x, int y, int w, int h, int b,\n                           float fArray[], DataBuffer data) {\n        int Offset=0;\n        int x1 = x + w;\n        int y1 = y + h;\n\n        if (x < 0 || x >= width || w > width || x1 < 0 || x1 > width ||\n            y < 0 || y >= height || h > height || y1 < 0 || y1 > height)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Invalid coordinates.\");\n        }\n\n        for (int i=y; i<y1; i++) {\n            for (int j=x; j<x1; j++) {\n                setSample(j, i, b, fArray[Offset++], data);\n            }\n        }\n    }"}
{"Number":"553","API Relative Path":"java.awt.image.SampleModel.java-setSamples(int-int-int-int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Sets the samples in the specified band for the specified rectangle\n     * of pixels from an int array containing one sample per array element.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the upper left pixel location.\n     * @param y         The Y coordinate of the upper left pixel location.\n     * @param w         The width of the pixel rectangle.\n     * @param h         The height of the pixel rectangle.\n     * @param b         The band to set.\n     * @param iArray    The input samples in an int array.\n     * @param data      The DataBuffer containing the image data.\n     * @see #getSamples(int, int, int, int, int, int[], DataBuffer)\n     *\n     * @throws NullPointerException if iArray or data is null.\n     * @throws ArrayIndexOutOfBoundsException if the coordinates or\n     * the band index are not in bounds, or if iArray is too small to\n     * hold the input.\n     */\n    public void setSamples(int x, int y, int w, int h, int b,\n                           int iArray[], DataBuffer data) {\n\n        int Offset=0;\n        int x1 = x + w;\n        int y1 = y + h;\n        if (x < 0 || x >= width || w > width || x1 < 0 || x1 > width ||\n            y < 0 || y >= height || h > height || y1 < 0 || y1 > height)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Invalid coordinates.\");\n        }\n\n        for (int i=y; i<y1; i++) {\n            for (int j=x; j<x1; j++) {\n                setSample(j, i, b, iArray[Offset++], data);\n            }\n        }\n    }"}
{"Number":"554","API Relative Path":"java.awt.image.SinglePixelPackedSampleModel.java-createSubsetSampleModel(int)","Corresponding Source":"/**\n     * This creates a new SinglePixelPackedSampleModel with a subset of the\n     * bands of this SinglePixelPackedSampleModel.  The new\n     * SinglePixelPackedSampleModel can be used with any DataBuffer that the\n     * existing SinglePixelPackedSampleModel can be used with.  The new\n     * SinglePixelPackedSampleModel/DataBuffer combination will represent\n     * an image with a subset of the bands of the original\n     * SinglePixelPackedSampleModel/DataBuffer combination.\n     * @exception RasterFormatException if the length of the bands argument is\n     *                                  greater than the number of bands in\n     *                                  the sample model.\n     */\n    public SampleModel createSubsetSampleModel(int bands[]) {\n        if (bands.length > numBands)\n            throw new RasterFormatException(\"There are only \" +\n                                            numBands +\n                                            \" bands\");\n        int newBitMasks[] = new int[bands.length];\n        for (int i=0; i<bands.length; i++)\n            newBitMasks[i] = bitMasks[bands[i]];\n\n        return new SinglePixelPackedSampleModel(this.dataType, width, height,\n                                           this.scanlineStride, newBitMasks);\n    }"}
{"Number":"555","API Relative Path":"java.awt.image.SinglePixelPackedSampleModel.java-getDataElements(int-int-Object-DataBuffer)","Corresponding Source":"/**\n     * Returns data for a single pixel in a primitive array of type\n     * TransferType.  For a SinglePixelPackedSampleModel, the array will\n     * have one element, and the type will be the same as the storage\n     * data type.  Generally, obj\n     * should be passed in as null, so that the Object will be created\n     * automatically and will be of the right primitive data type.\n     * <p>\n     * The following code illustrates transferring data for one pixel from\n     * DataBuffer <code>db1<\/code>, whose storage layout is described by\n     * SinglePixelPackedSampleModel <code>sppsm1<\/code>, to\n     * DataBuffer <code>db2<\/code>, whose storage layout is described by\n     * SinglePixelPackedSampleModel <code>sppsm2<\/code>.\n     * The transfer will generally be more efficient than using\n     * getPixel/setPixel.\n     * <pre>\n     *       SinglePixelPackedSampleModel sppsm1, sppsm2;\n     *       DataBufferInt db1, db2;\n     *       sppsm2.setDataElements(x, y, sppsm1.getDataElements(x, y, null,\n     *                              db1), db2);\n     * <\/pre>\n     * Using getDataElements/setDataElements to transfer between two\n     * DataBuffer/SampleModel pairs is legitimate if the SampleModels have\n     * the same number of bands, corresponding bands have the same number of\n     * bits per sample, and the TransferTypes are the same.\n     * <p>\n     * If obj is non-null, it should be a primitive array of type TransferType.\n     * Otherwise, a ClassCastException is thrown.  An\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds, or if obj is non-null and is not large enough to hold\n     * the pixel data.\n     * @param x         The X coordinate of the pixel location.\n     * @param y         The Y coordinate of the pixel location.\n     * @param obj       If non-null, a primitive array in which to return\n     *                  the pixel data.\n     * @param data      The DataBuffer containing the image data.\n     * @return the data for the specified pixel.\n     * @see #setDataElements(int, int, Object, DataBuffer)\n     */\n    public Object getDataElements(int x, int y, Object obj, DataBuffer data) {\n        // Bounds check for 'b' will be performed automatically\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n\n        int type = getTransferType();\n\n        switch(type) {\n\n        case DataBuffer.TYPE_BYTE:\n\n            byte[] bdata;\n\n            if (obj == null)\n                bdata = new byte[1];\n            else\n                bdata = (byte[])obj;\n\n            bdata[0] = (byte)data.getElem(y * scanlineStride + x);\n\n            obj = (Object)bdata;\n            break;\n\n        case DataBuffer.TYPE_USHORT:\n\n            short[] sdata;\n\n            if (obj == null)\n                sdata = new short[1];\n            else\n                sdata = (short[])obj;\n\n            sdata[0] = (short)data.getElem(y * scanlineStride + x);\n\n            obj = (Object)sdata;\n            break;\n\n        case DataBuffer.TYPE_INT:\n\n            int[] idata;\n\n            if (obj == null)\n                idata = new int[1];\n            else\n                idata = (int[])obj;\n\n            idata[0] = data.getElem(y * scanlineStride + x);\n\n            obj = (Object)idata;\n            break;\n        }\n\n        return obj;\n    }"}
{"Number":"556","API Relative Path":"java.awt.image.SinglePixelPackedSampleModel.java-getPixel(int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Returns all samples in for the specified pixel in an int array.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the pixel location.\n     * @param y         The Y coordinate of the pixel location.\n     * @param iArray    If non-null, returns the samples in this array\n     * @param data      The DataBuffer containing the image data.\n     * @return all samples for the specified pixel.\n     * @see #setPixel(int, int, int[], DataBuffer)\n     */\n    public int [] getPixel(int x, int y, int iArray[], DataBuffer data) {\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int pixels[];\n        if (iArray == null) {\n            pixels = new int [numBands];\n        } else {\n            pixels = iArray;\n        }\n\n        int value = data.getElem(y * scanlineStride + x);\n        for (int i=0; i<numBands; i++) {\n            pixels[i] = (value & bitMasks[i]) >>> bitOffsets[i];\n        }\n        return pixels;\n    }"}
{"Number":"557","API Relative Path":"java.awt.image.SinglePixelPackedSampleModel.java-getPixels(int-int-int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Returns all samples for the specified rectangle of pixels in\n     * an int array, one sample per array element.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the upper left pixel location.\n     * @param y         The Y coordinate of the upper left pixel location.\n     * @param w         The width of the pixel rectangle.\n     * @param h         The height of the pixel rectangle.\n     * @param iArray    If non-null, returns the samples in this array.\n     * @param data      The DataBuffer containing the image data.\n     * @return all samples for the specified region of pixels.\n     * @see #setPixels(int, int, int, int, int[], DataBuffer)\n     */\n    public int[] getPixels(int x, int y, int w, int h,\n                           int iArray[], DataBuffer data) {\n        int x1 = x + w;\n        int y1 = y + h;\n\n        if (x < 0 || x >= width || w > width || x1 < 0 || x1 > width ||\n            y < 0 || y >= height || h > height || y1 < 0 || y1 >  height)\n        {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int pixels[];\n        if (iArray != null) {\n           pixels = iArray;\n        } else {\n           pixels = new int [w*h*numBands];\n        }\n        int lineOffset = y*scanlineStride + x;\n        int dstOffset = 0;\n\n        for (int i = 0; i < h; i++) {\n           for (int j = 0; j < w; j++) {\n              int value = data.getElem(lineOffset+j);\n              for (int k=0; k < numBands; k++) {\n                  pixels[dstOffset++] =\n                     ((value & bitMasks[k]) >>> bitOffsets[k]);\n              }\n           }\n           lineOffset += scanlineStride;\n        }\n        return pixels;\n    }"}
{"Number":"558","API Relative Path":"java.awt.image.SinglePixelPackedSampleModel.java-getSample(int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Returns as int the sample in a specified band for the pixel\n     * located at (x,y).\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the pixel location.\n     * @param y         The Y coordinate of the pixel location.\n     * @param b         The band to return.\n     * @param data      The DataBuffer containing the image data.\n     * @return the sample in a specified band for the specified\n     *         pixel.\n     * @see #setSample(int, int, int, int, DataBuffer)\n     */\n    public int getSample(int x, int y, int b, DataBuffer data) {\n        // Bounds check for 'b' will be performed automatically\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int sample = data.getElem(y * scanlineStride + x);\n        return ((sample & bitMasks[b]) >>> bitOffsets[b]);\n    }"}
{"Number":"559","API Relative Path":"java.awt.image.SinglePixelPackedSampleModel.java-getSamples(int-int-int-int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Returns the samples for a specified band for the specified rectangle\n     * of pixels in an int array, one sample per array element.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the upper left pixel location.\n     * @param y         The Y coordinate of the upper left pixel location.\n     * @param w         The width of the pixel rectangle.\n     * @param h         The height of the pixel rectangle.\n     * @param b         The band to return.\n     * @param iArray    If non-null, returns the samples in this array.\n     * @param data      The DataBuffer containing the image data.\n     * @return the samples for the specified band for the specified\n     *         region of pixels.\n     * @see #setSamples(int, int, int, int, int, int[], DataBuffer)\n     */\n    public int[] getSamples(int x, int y, int w, int h, int b,\n                           int iArray[], DataBuffer data) {\n        // Bounds check for 'b' will be performed automatically\n        if ((x < 0) || (y < 0) || (x + w > width) || (y + h > height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int samples[];\n        if (iArray != null) {\n           samples = iArray;\n        } else {\n           samples = new int [w*h];\n        }\n        int lineOffset = y*scanlineStride + x;\n        int dstOffset = 0;\n\n        for (int i = 0; i < h; i++) {\n           for (int j = 0; j < w; j++) {\n              int value = data.getElem(lineOffset+j);\n              samples[dstOffset++] =\n                 ((value & bitMasks[b]) >>> bitOffsets[b]);\n           }\n           lineOffset += scanlineStride;\n        }\n        return samples;\n    }"}
{"Number":"560","API Relative Path":"java.awt.image.SinglePixelPackedSampleModel.java-setDataElements(int-int-Object-DataBuffer)","Corresponding Source":"/**\n     * Sets the data for a single pixel in the specified DataBuffer from a\n     * primitive array of type TransferType.  For a\n     * SinglePixelPackedSampleModel, only the first element of the array\n     * will hold valid data, and the type of the array must be the same as\n     * the storage data type of the SinglePixelPackedSampleModel.\n     * <p>\n     * The following code illustrates transferring data for one pixel from\n     * DataBuffer <code>db1<\/code>, whose storage layout is described by\n     * SinglePixelPackedSampleModel <code>sppsm1<\/code>,\n     * to DataBuffer <code>db2<\/code>, whose storage layout is described by\n     * SinglePixelPackedSampleModel <code>sppsm2<\/code>.\n     * The transfer will generally be more efficient than using\n     * getPixel/setPixel.\n     * <pre>\n     *       SinglePixelPackedSampleModel sppsm1, sppsm2;\n     *       DataBufferInt db1, db2;\n     *       sppsm2.setDataElements(x, y, sppsm1.getDataElements(x, y, null,\n     *                              db1), db2);\n     * <\/pre>\n     * Using getDataElements/setDataElements to transfer between two\n     * DataBuffer/SampleModel pairs is legitimate if the SampleModels have\n     * the same number of bands, corresponding bands have the same number of\n     * bits per sample, and the TransferTypes are the same.\n     * <p>\n     * obj must be a primitive array of type TransferType.  Otherwise,\n     * a ClassCastException is thrown.  An\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds, or if obj is not large enough to hold the pixel data.\n     * @param x         The X coordinate of the pixel location.\n     * @param y         The Y coordinate of the pixel location.\n     * @param obj       A primitive array containing pixel data.\n     * @param data      The DataBuffer containing the image data.\n     * @see #getDataElements(int, int, Object, DataBuffer)\n     */\n    public void setDataElements(int x, int y, Object obj, DataBuffer data) {\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n\n        int type = getTransferType();\n\n        switch(type) {\n\n        case DataBuffer.TYPE_BYTE:\n\n            byte[] barray = (byte[])obj;\n            data.setElem(y*scanlineStride+x, ((int)barray[0])&0xff);\n            break;\n\n        case DataBuffer.TYPE_USHORT:\n\n            short[] sarray = (short[])obj;\n            data.setElem(y*scanlineStride+x, ((int)sarray[0])&0xffff);\n            break;\n\n        case DataBuffer.TYPE_INT:\n\n            int[] iarray = (int[])obj;\n            data.setElem(y*scanlineStride+x, iarray[0]);\n            break;\n        }\n    }"}
{"Number":"561","API Relative Path":"java.awt.image.SinglePixelPackedSampleModel.java-setPixel(int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Sets a pixel in the DataBuffer using an int array of samples for input.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the pixel location.\n     * @param y         The Y coordinate of the pixel location.\n     * @param iArray    The input samples in an int array.\n     * @param data      The DataBuffer containing the image data.\n     * @see #getPixel(int, int, int[], DataBuffer)\n     */\n    public void setPixel(int x, int y,\n                         int iArray[],\n                         DataBuffer data) {\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int lineOffset = y * scanlineStride + x;\n        int value = data.getElem(lineOffset);\n        for (int i=0; i < numBands; i++) {\n            value &= ~bitMasks[i];\n            value |= ((iArray[i] << bitOffsets[i]) & bitMasks[i]);\n        }\n        data.setElem(lineOffset, value);\n    }"}
{"Number":"562","API Relative Path":"java.awt.image.SinglePixelPackedSampleModel.java-setPixels(int-int-int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Sets all samples for a rectangle of pixels from an int array containing\n     * one sample per array element.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the upper left pixel location.\n     * @param y         The Y coordinate of the upper left pixel location.\n     * @param w         The width of the pixel rectangle.\n     * @param h         The height of the pixel rectangle.\n     * @param iArray    The input samples in an int array.\n     * @param data      The DataBuffer containing the image data.\n     * @see #getPixels(int, int, int, int, int[], DataBuffer)\n     */\n    public void setPixels(int x, int y, int w, int h,\n                          int iArray[], DataBuffer data) {\n        int x1 = x + w;\n        int y1 = y + h;\n\n        if (x < 0 || x >= width || w > width || x1 < 0 || x1 > width ||\n            y < 0 || y >= height || h > height || y1 < 0 || y1 >  height)\n        {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n\n        int lineOffset = y*scanlineStride + x;\n        int srcOffset = 0;\n\n        for (int i = 0; i < h; i++) {\n           for (int j = 0; j < w; j++) {\n               int value = data.getElem(lineOffset+j);\n               for (int k=0; k < numBands; k++) {\n                   value &= ~bitMasks[k];\n                   int srcValue = iArray[srcOffset++];\n                   value |= ((srcValue << bitOffsets[k])\n                             & bitMasks[k]);\n               }\n               data.setElem(lineOffset+j, value);\n           }\n           lineOffset += scanlineStride;\n        }\n    }"}
{"Number":"563","API Relative Path":"java.awt.image.SinglePixelPackedSampleModel.java-setSample(int-int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Sets a sample in the specified band for the pixel located at (x,y)\n     * in the DataBuffer using an int for input.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the pixel location.\n     * @param y         The Y coordinate of the pixel location.\n     * @param b         The band to set.\n     * @param s         The input sample as an int.\n     * @param data      The DataBuffer containing the image data.\n     * @see #getSample(int, int, int, DataBuffer)\n     */\n    public void setSample(int x, int y, int b, int s,\n                          DataBuffer data) {\n        // Bounds check for 'b' will be performed automatically\n        if ((x < 0) || (y < 0) || (x >= width) || (y >= height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int value = data.getElem(y*scanlineStride + x);\n        value &= ~bitMasks[b];\n        value |= (s << bitOffsets[b]) & bitMasks[b];\n        data.setElem(y*scanlineStride + x,value);\n    }"}
{"Number":"564","API Relative Path":"java.awt.image.SinglePixelPackedSampleModel.java-setSamples(int-int-int-int-int-int-DataBuffer)","Corresponding Source":"/**\n     * Sets the samples in the specified band for the specified rectangle\n     * of pixels from an int array containing one sample per array element.\n     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are\n     * not in bounds.\n     * @param x         The X coordinate of the upper left pixel location.\n     * @param y         The Y coordinate of the upper left pixel location.\n     * @param w         The width of the pixel rectangle.\n     * @param h         The height of the pixel rectangle.\n     * @param b         The band to set.\n     * @param iArray    The input samples in an int array.\n     * @param data      The DataBuffer containing the image data.\n     * @see #getSamples(int, int, int, int, int, int[], DataBuffer)\n     */\n    public void setSamples(int x, int y, int w, int h, int b,\n                          int iArray[], DataBuffer data) {\n        // Bounds check for 'b' will be performed automatically\n        if ((x < 0) || (y < 0) || (x + w > width) || (y + h > height)) {\n            throw new ArrayIndexOutOfBoundsException\n                (\"Coordinate out of bounds!\");\n        }\n        int lineOffset = y*scanlineStride + x;\n        int srcOffset = 0;\n\n        for (int i = 0; i < h; i++) {\n           for (int j = 0; j < w; j++) {\n              int value = data.getElem(lineOffset+j);\n              value &= ~bitMasks[b];\n              int sample = iArray[srcOffset++];\n              value |= ((int)sample << bitOffsets[b]) & bitMasks[b];\n              data.setElem(lineOffset+j,value);\n           }\n           lineOffset += scanlineStride;\n        }\n    }"}
{"Number":"565","API Relative Path":"java.awt.image.WritableRaster.java-createWritableChild(int-int-int-int-int-int-int)","Corresponding Source":"/**\n     * Returns a new WritableRaster which shares all or part of this\n     * WritableRaster's DataBuffer.  The new WritableRaster will\n     * possess a reference to the current WritableRaster, accessible\n     * through its getParent() and getWritableParent() methods.\n     *\n     * <p> The parentX, parentY, width and height parameters form a\n     * Rectangle in this WritableRaster's coordinate space, indicating\n     * the area of pixels to be shared.  An error will be thrown if\n     * this Rectangle is not contained with the bounds of the current\n     * WritableRaster.\n     *\n     * <p> The new WritableRaster may additionally be translated to a\n     * different coordinate system for the plane than that used by the current\n     * WritableRaster.  The childMinX and childMinY parameters give\n     * the new (x, y) coordinate of the upper-left pixel of the\n     * returned WritableRaster; the coordinate (childMinX, childMinY)\n     * in the new WritableRaster will map to the same pixel as the\n     * coordinate (parentX, parentY) in the current WritableRaster.\n     *\n     * <p> The new WritableRaster may be defined to contain only a\n     * subset of the bands of the current WritableRaster, possibly\n     * reordered, by means of the bandList parameter.  If bandList is\n     * null, it is taken to include all of the bands of the current\n     * WritableRaster in their current order.\n     *\n     * <p> To create a new WritableRaster that contains a subregion of\n     * the current WritableRaster, but shares its coordinate system\n     * and bands, this method should be called with childMinX equal to\n     * parentX, childMinY equal to parentY, and bandList equal to\n     * null.\n     *\n     * @param parentX    X coordinate of the upper left corner in this\n     *                   WritableRaster's coordinates.\n     * @param parentY    Y coordinate of the upper left corner in this\n     *                   WritableRaster's coordinates.\n     * @param w          Width of the region starting at (parentX, parentY).\n     * @param h          Height of the region starting at (parentX, parentY).\n     * @param childMinX  X coordinate of the upper left corner of\n     *                   the returned WritableRaster.\n     * @param childMinY  Y coordinate of the upper left corner of\n     *                   the returned WritableRaster.\n     * @param bandList   Array of band indices, or null to use all bands.\n     * @return a <code>WritableRaster<\/code> sharing all or part of the\n     *         <code>DataBuffer<\/code> of this <code>WritableRaster<\/code>.\n     * @exception RasterFormatException if the subregion is outside of the\n     *                               raster bounds.\n     * @throws RasterFormatException if <code>w<\/code> or\n     *         <code>h<\/code>\n     *         is less than or equal to zero, or computing any of\n     *         <code>parentX + w<\/code>, <code>parentY + h<\/code>,\n     *         <code>childMinX + w<\/code>, or\n     *         <code>childMinY + h<\/code> results in integer\n     *         overflow\n     */\n    public WritableRaster createWritableChild(int parentX, int parentY,\n                                              int w, int h,\n                                              int childMinX, int childMinY,\n                                              int bandList[]) {\n        if (parentX < this.minX) {\n            throw new RasterFormatException(\"parentX lies outside raster\");\n        }\n        if (parentY < this.minY) {\n            throw new RasterFormatException(\"parentY lies outside raster\");\n        }\n        if ((parentX+w < parentX) || (parentX+w > this.width + this.minX)) {\n            throw new RasterFormatException(\"(parentX + width) is outside raster\");\n        }\n        if ((parentY+h < parentY) || (parentY+h > this.height + this.minY)) {\n            throw new RasterFormatException(\"(parentY + height) is outside raster\");\n        }\n\n        SampleModel sm;\n        // Note: the SampleModel for the child Raster should have the same\n        // width and height as that for the parent, since it represents\n        // the physical layout of the pixel data.  The child Raster's width\n        // and height represent a \"virtual\" view of the pixel data, so\n        // they may be different than those of the SampleModel.\n        if (bandList != null) {\n            sm = sampleModel.createSubsetSampleModel(bandList);\n        }\n        else {\n            sm = sampleModel;\n        }\n\n        int deltaX = childMinX - parentX;\n        int deltaY = childMinY - parentY;\n\n        return new WritableRaster(sm,\n                                  getDataBuffer(),\n                                  new Rectangle(childMinX,childMinY,\n                                                w, h),\n                                  new Point(sampleModelTranslateX+deltaX,\n                                            sampleModelTranslateY+deltaY),\n                                  this);\n    }"}
{"Number":"566","API Relative Path":"java.awt.image.WritableRaster.java-createWritableChild(int-int-int-int-int-int-int)","Corresponding Source":"/**\n     * Returns a new WritableRaster which shares all or part of this\n     * WritableRaster's DataBuffer.  The new WritableRaster will\n     * possess a reference to the current WritableRaster, accessible\n     * through its getParent() and getWritableParent() methods.\n     *\n     * <p> The parentX, parentY, width and height parameters form a\n     * Rectangle in this WritableRaster's coordinate space, indicating\n     * the area of pixels to be shared.  An error will be thrown if\n     * this Rectangle is not contained with the bounds of the current\n     * WritableRaster.\n     *\n     * <p> The new WritableRaster may additionally be translated to a\n     * different coordinate system for the plane than that used by the current\n     * WritableRaster.  The childMinX and childMinY parameters give\n     * the new (x, y) coordinate of the upper-left pixel of the\n     * returned WritableRaster; the coordinate (childMinX, childMinY)\n     * in the new WritableRaster will map to the same pixel as the\n     * coordinate (parentX, parentY) in the current WritableRaster.\n     *\n     * <p> The new WritableRaster may be defined to contain only a\n     * subset of the bands of the current WritableRaster, possibly\n     * reordered, by means of the bandList parameter.  If bandList is\n     * null, it is taken to include all of the bands of the current\n     * WritableRaster in their current order.\n     *\n     * <p> To create a new WritableRaster that contains a subregion of\n     * the current WritableRaster, but shares its coordinate system\n     * and bands, this method should be called with childMinX equal to\n     * parentX, childMinY equal to parentY, and bandList equal to\n     * null.\n     *\n     * @param parentX    X coordinate of the upper left corner in this\n     *                   WritableRaster's coordinates.\n     * @param parentY    Y coordinate of the upper left corner in this\n     *                   WritableRaster's coordinates.\n     * @param w          Width of the region starting at (parentX, parentY).\n     * @param h          Height of the region starting at (parentX, parentY).\n     * @param childMinX  X coordinate of the upper left corner of\n     *                   the returned WritableRaster.\n     * @param childMinY  Y coordinate of the upper left corner of\n     *                   the returned WritableRaster.\n     * @param bandList   Array of band indices, or null to use all bands.\n     * @return a <code>WritableRaster<\/code> sharing all or part of the\n     *         <code>DataBuffer<\/code> of this <code>WritableRaster<\/code>.\n     * @exception RasterFormatException if the subregion is outside of the\n     *                               raster bounds.\n     * @throws RasterFormatException if <code>w<\/code> or\n     *         <code>h<\/code>\n     *         is less than or equal to zero, or computing any of\n     *         <code>parentX + w<\/code>, <code>parentY + h<\/code>,\n     *         <code>childMinX + w<\/code>, or\n     *         <code>childMinY + h<\/code> results in integer\n     *         overflow\n     */\n    public WritableRaster createWritableChild(int parentX, int parentY,\n                                              int w, int h,\n                                              int childMinX, int childMinY,\n                                              int bandList[]) {\n        if (parentX < this.minX) {\n            throw new RasterFormatException(\"parentX lies outside raster\");\n        }\n        if (parentY < this.minY) {\n            throw new RasterFormatException(\"parentY lies outside raster\");\n        }\n        if ((parentX+w < parentX) || (parentX+w > this.width + this.minX)) {\n            throw new RasterFormatException(\"(parentX + width) is outside raster\");\n        }\n        if ((parentY+h < parentY) || (parentY+h > this.height + this.minY)) {\n            throw new RasterFormatException(\"(parentY + height) is outside raster\");\n        }\n\n        SampleModel sm;\n        // Note: the SampleModel for the child Raster should have the same\n        // width and height as that for the parent, since it represents\n        // the physical layout of the pixel data.  The child Raster's width\n        // and height represent a \"virtual\" view of the pixel data, so\n        // they may be different than those of the SampleModel.\n        if (bandList != null) {\n            sm = sampleModel.createSubsetSampleModel(bandList);\n        }\n        else {\n            sm = sampleModel;\n        }\n\n        int deltaX = childMinX - parentX;\n        int deltaY = childMinY - parentY;\n\n        return new WritableRaster(sm,\n                                  getDataBuffer(),\n                                  new Rectangle(childMinX,childMinY,\n                                                w, h),\n                                  new Point(sampleModelTranslateX+deltaX,\n                                            sampleModelTranslateY+deltaY),\n                                  this);\n    }"}
{"Number":"567","API Relative Path":"java.awt.image.WritableRaster.java-createWritableChild(int-int-int-int-int-int-int)","Corresponding Source":"/**\n     * Returns a new WritableRaster which shares all or part of this\n     * WritableRaster's DataBuffer.  The new WritableRaster will\n     * possess a reference to the current WritableRaster, accessible\n     * through its getParent() and getWritableParent() methods.\n     *\n     * <p> The parentX, parentY, width and height parameters form a\n     * Rectangle in this WritableRaster's coordinate space, indicating\n     * the area of pixels to be shared.  An error will be thrown if\n     * this Rectangle is not contained with the bounds of the current\n     * WritableRaster.\n     *\n     * <p> The new WritableRaster may additionally be translated to a\n     * different coordinate system for the plane than that used by the current\n     * WritableRaster.  The childMinX and childMinY parameters give\n     * the new (x, y) coordinate of the upper-left pixel of the\n     * returned WritableRaster; the coordinate (childMinX, childMinY)\n     * in the new WritableRaster will map to the same pixel as the\n     * coordinate (parentX, parentY) in the current WritableRaster.\n     *\n     * <p> The new WritableRaster may be defined to contain only a\n     * subset of the bands of the current WritableRaster, possibly\n     * reordered, by means of the bandList parameter.  If bandList is\n     * null, it is taken to include all of the bands of the current\n     * WritableRaster in their current order.\n     *\n     * <p> To create a new WritableRaster that contains a subregion of\n     * the current WritableRaster, but shares its coordinate system\n     * and bands, this method should be called with childMinX equal to\n     * parentX, childMinY equal to parentY, and bandList equal to\n     * null.\n     *\n     * @param parentX    X coordinate of the upper left corner in this\n     *                   WritableRaster's coordinates.\n     * @param parentY    Y coordinate of the upper left corner in this\n     *                   WritableRaster's coordinates.\n     * @param w          Width of the region starting at (parentX, parentY).\n     * @param h          Height of the region starting at (parentX, parentY).\n     * @param childMinX  X coordinate of the upper left corner of\n     *                   the returned WritableRaster.\n     * @param childMinY  Y coordinate of the upper left corner of\n     *                   the returned WritableRaster.\n     * @param bandList   Array of band indices, or null to use all bands.\n     * @return a <code>WritableRaster<\/code> sharing all or part of the\n     *         <code>DataBuffer<\/code> of this <code>WritableRaster<\/code>.\n     * @exception RasterFormatException if the subregion is outside of the\n     *                               raster bounds.\n     * @throws RasterFormatException if <code>w<\/code> or\n     *         <code>h<\/code>\n     *         is less than or equal to zero, or computing any of\n     *         <code>parentX + w<\/code>, <code>parentY + h<\/code>,\n     *         <code>childMinX + w<\/code>, or\n     *         <code>childMinY + h<\/code> results in integer\n     *         overflow\n     */\n    public WritableRaster createWritableChild(int parentX, int parentY,\n                                              int w, int h,\n                                              int childMinX, int childMinY,\n                                              int bandList[]) {\n        if (parentX < this.minX) {\n            throw new RasterFormatException(\"parentX lies outside raster\");\n        }\n        if (parentY < this.minY) {\n            throw new RasterFormatException(\"parentY lies outside raster\");\n        }\n        if ((parentX+w < parentX) || (parentX+w > this.width + this.minX)) {\n            throw new RasterFormatException(\"(parentX + width) is outside raster\");\n        }\n        if ((parentY+h < parentY) || (parentY+h > this.height + this.minY)) {\n            throw new RasterFormatException(\"(parentY + height) is outside raster\");\n        }\n\n        SampleModel sm;\n        // Note: the SampleModel for the child Raster should have the same\n        // width and height as that for the parent, since it represents\n        // the physical layout of the pixel data.  The child Raster's width\n        // and height represent a \"virtual\" view of the pixel data, so\n        // they may be different than those of the SampleModel.\n        if (bandList != null) {\n            sm = sampleModel.createSubsetSampleModel(bandList);\n        }\n        else {\n            sm = sampleModel;\n        }\n\n        int deltaX = childMinX - parentX;\n        int deltaY = childMinY - parentY;\n\n        return new WritableRaster(sm,\n                                  getDataBuffer(),\n                                  new Rectangle(childMinX,childMinY,\n                                                w, h),\n                                  new Point(sampleModelTranslateX+deltaX,\n                                            sampleModelTranslateY+deltaY),\n                                  this);\n    }"}
{"Number":"568","API Relative Path":"java.awt.image.WritableRaster.java-createWritableChild(int-int-int-int-int-int-int)","Corresponding Source":"/**\n     * Returns a new WritableRaster which shares all or part of this\n     * WritableRaster's DataBuffer.  The new WritableRaster will\n     * possess a reference to the current WritableRaster, accessible\n     * through its getParent() and getWritableParent() methods.\n     *\n     * <p> The parentX, parentY, width and height parameters form a\n     * Rectangle in this WritableRaster's coordinate space, indicating\n     * the area of pixels to be shared.  An error will be thrown if\n     * this Rectangle is not contained with the bounds of the current\n     * WritableRaster.\n     *\n     * <p> The new WritableRaster may additionally be translated to a\n     * different coordinate system for the plane than that used by the current\n     * WritableRaster.  The childMinX and childMinY parameters give\n     * the new (x, y) coordinate of the upper-left pixel of the\n     * returned WritableRaster; the coordinate (childMinX, childMinY)\n     * in the new WritableRaster will map to the same pixel as the\n     * coordinate (parentX, parentY) in the current WritableRaster.\n     *\n     * <p> The new WritableRaster may be defined to contain only a\n     * subset of the bands of the current WritableRaster, possibly\n     * reordered, by means of the bandList parameter.  If bandList is\n     * null, it is taken to include all of the bands of the current\n     * WritableRaster in their current order.\n     *\n     * <p> To create a new WritableRaster that contains a subregion of\n     * the current WritableRaster, but shares its coordinate system\n     * and bands, this method should be called with childMinX equal to\n     * parentX, childMinY equal to parentY, and bandList equal to\n     * null.\n     *\n     * @param parentX    X coordinate of the upper left corner in this\n     *                   WritableRaster's coordinates.\n     * @param parentY    Y coordinate of the upper left corner in this\n     *                   WritableRaster's coordinates.\n     * @param w          Width of the region starting at (parentX, parentY).\n     * @param h          Height of the region starting at (parentX, parentY).\n     * @param childMinX  X coordinate of the upper left corner of\n     *                   the returned WritableRaster.\n     * @param childMinY  Y coordinate of the upper left corner of\n     *                   the returned WritableRaster.\n     * @param bandList   Array of band indices, or null to use all bands.\n     * @return a <code>WritableRaster<\/code> sharing all or part of the\n     *         <code>DataBuffer<\/code> of this <code>WritableRaster<\/code>.\n     * @exception RasterFormatException if the subregion is outside of the\n     *                               raster bounds.\n     * @throws RasterFormatException if <code>w<\/code> or\n     *         <code>h<\/code>\n     *         is less than or equal to zero, or computing any of\n     *         <code>parentX + w<\/code>, <code>parentY + h<\/code>,\n     *         <code>childMinX + w<\/code>, or\n     *         <code>childMinY + h<\/code> results in integer\n     *         overflow\n     */\n    public WritableRaster createWritableChild(int parentX, int parentY,\n                                              int w, int h,\n                                              int childMinX, int childMinY,\n                                              int bandList[]) {\n        if (parentX < this.minX) {\n            throw new RasterFormatException(\"parentX lies outside raster\");\n        }\n        if (parentY < this.minY) {\n            throw new RasterFormatException(\"parentY lies outside raster\");\n        }\n        if ((parentX+w < parentX) || (parentX+w > this.width + this.minX)) {\n            throw new RasterFormatException(\"(parentX + width) is outside raster\");\n        }\n        if ((parentY+h < parentY) || (parentY+h > this.height + this.minY)) {\n            throw new RasterFormatException(\"(parentY + height) is outside raster\");\n        }\n\n        SampleModel sm;\n        // Note: the SampleModel for the child Raster should have the same\n        // width and height as that for the parent, since it represents\n        // the physical layout of the pixel data.  The child Raster's width\n        // and height represent a \"virtual\" view of the pixel data, so\n        // they may be different than those of the SampleModel.\n        if (bandList != null) {\n            sm = sampleModel.createSubsetSampleModel(bandList);\n        }\n        else {\n            sm = sampleModel;\n        }\n\n        int deltaX = childMinX - parentX;\n        int deltaY = childMinY - parentY;\n\n        return new WritableRaster(sm,\n                                  getDataBuffer(),\n                                  new Rectangle(childMinX,childMinY,\n                                                w, h),\n                                  new Point(sampleModelTranslateX+deltaX,\n                                            sampleModelTranslateY+deltaY),\n                                  this);\n    }"}
{"Number":"569","API Relative Path":"java.awt.Image.java-getScaledInstance(int-int-int)","Corresponding Source":"/**\n     * Creates a scaled version of this image.\n     * A new <code>Image<\/code> object is returned which will render\n     * the image at the specified <code>width<\/code> and\n     * <code>height<\/code> by default.  The new <code>Image<\/code> object\n     * may be loaded asynchronously even if the original source image\n     * has already been loaded completely.\n     *\n     * <p>\n     *\n     * If either <code>width<\/code>\n     * or <code>height<\/code> is a negative number then a value is\n     * substituted to maintain the aspect ratio of the original image\n     * dimensions. If both <code>width<\/code> and <code>height<\/code>\n     * are negative, then the original image dimensions are used.\n     *\n     * @param width the width to which to scale the image.\n     * @param height the height to which to scale the image.\n     * @param hints flags to indicate the type of algorithm to use\n     * for image resampling.\n     * @return     a scaled version of the image.\n     * @exception IllegalArgumentException if <code>width<\/code>\n     *             or <code>height<\/code> is zero.\n     * @see        java.awt.Image#SCALE_DEFAULT\n     * @see        java.awt.Image#SCALE_FAST\n     * @see        java.awt.Image#SCALE_SMOOTH\n     * @see        java.awt.Image#SCALE_REPLICATE\n     * @see        java.awt.Image#SCALE_AREA_AVERAGING\n     * @since      JDK1.1\n     */\n    public Image getScaledInstance(int width, int height, int hints) {\n        ImageFilter filter;\n        if ((hints & (SCALE_SMOOTH | SCALE_AREA_AVERAGING)) != 0) {\n            filter = new AreaAveragingScaleFilter(width, height);\n        } else {\n            filter = new ReplicateScaleFilter(width, height);\n        }\n        ImageProducer prod;\n        prod = new FilteredImageSource(getSource(), filter);\n        return Toolkit.getDefaultToolkit().createImage(prod);\n    }"}
{"Number":"570","API Relative Path":"java.awt.JobAttributes.java-JobAttributes(int-DefaultSelectionType-DestinationType-DialogType-String-int-int-MultipleDocumentHandlingType-int[][]-String-SidesType)","Corresponding Source":"/**\n     * Constructs a <code>JobAttributes<\/code> instance with the\n     * specified values for every attribute.\n     *\n     * @param   copies an integer greater than 0\n     * @param   defaultSelection <code>DefaultSelectionType.ALL<\/code>,\n     *          <code>DefaultSelectionType.RANGE<\/code>, or\n     *          <code>DefaultSelectionType.SELECTION<\/code>\n     * @param   destination <code>DesintationType.FILE<\/code> or\n     *          <code>DesintationType.PRINTER<\/code>\n     * @param   dialog <code>DialogType.COMMON<\/code>,\n     *          <code>DialogType.NATIVE<\/code>, or\n     *          <code>DialogType.NONE<\/code>\n     * @param   fileName the possibly <code>null<\/code> file name\n     * @param   maxPage an integer greater than zero and greater than or equal\n     *          to <i>minPage<\/i>\n     * @param   minPage an integer greater than zero and less than or equal\n     *          to <i>maxPage<\/i>\n     * @param   multipleDocumentHandling\n     *     <code>MultipleDocumentHandlingType.SEPARATE_DOCUMENTS_COLLATED_COPIES<\/code> or\n     *     <code>MultipleDocumentHandlingType.SEPARATE_DOCUMENTS_UNCOLLATED_COPIES<\/code>\n     * @param   pageRanges an array of integer arrays of two elements; an array\n     *          is interpreted as a range spanning all pages including and\n     *          between the specified pages; ranges must be in ascending\n     *          order and must not overlap; specified page numbers cannot be\n     *          less than <i>minPage<\/i> nor greater than <i>maxPage<\/i>;\n     *          for example:\n     *          <pre>\n     *          (new int[][] { new int[] { 1, 3 }, new int[] { 5, 5 },\n     *                         new int[] { 15, 19 } }),\n     *          <\/pre>\n     *          specifies pages 1, 2, 3, 5, 15, 16, 17, 18, and 19. Note that\n     *          (<code>new int[][] { new int[] { 1, 1 }, new int[] { 1, 2 } }<\/code>),\n     *          is an invalid set of page ranges because the two ranges\n     *          overlap\n     * @param   printer the possibly <code>null<\/code> printer name\n     * @param   sides <code>SidesType.ONE_SIDED<\/code>,\n     *          <code>SidesType.TWO_SIDED_LONG_EDGE<\/code>, or\n     *          <code>SidesType.TWO_SIDED_SHORT_EDGE<\/code>\n     * @throws  IllegalArgumentException if one or more of the above\n     *          conditions is violated\n     */\n    public JobAttributes(int copies, DefaultSelectionType defaultSelection,\n                         DestinationType destination, DialogType dialog,\n                         String fileName, int maxPage, int minPage,\n                         MultipleDocumentHandlingType multipleDocumentHandling,\n                         int[][] pageRanges, String printer, SidesType sides) {\n        setCopies(copies);\n        setDefaultSelection(defaultSelection);\n        setDestination(destination);\n        setDialog(dialog);\n        setFileName(fileName);\n        setMaxPage(maxPage);\n        setMinPage(minPage);\n        setMultipleDocumentHandling(multipleDocumentHandling);\n        setPageRanges(pageRanges);\n        setPrinter(printer);\n        setSides(sides);\n    }"}
{"Number":"571","API Relative Path":"java.awt.JobAttributes.java-JobAttributes(int-DefaultSelectionType-DestinationType-DialogType-String-int-int-MultipleDocumentHandlingType-int[][]-String-SidesType)","Corresponding Source":"/**\n     * Constructs a <code>JobAttributes<\/code> instance with the\n     * specified values for every attribute.\n     *\n     * @param   copies an integer greater than 0\n     * @param   defaultSelection <code>DefaultSelectionType.ALL<\/code>,\n     *          <code>DefaultSelectionType.RANGE<\/code>, or\n     *          <code>DefaultSelectionType.SELECTION<\/code>\n     * @param   destination <code>DesintationType.FILE<\/code> or\n     *          <code>DesintationType.PRINTER<\/code>\n     * @param   dialog <code>DialogType.COMMON<\/code>,\n     *          <code>DialogType.NATIVE<\/code>, or\n     *          <code>DialogType.NONE<\/code>\n     * @param   fileName the possibly <code>null<\/code> file name\n     * @param   maxPage an integer greater than zero and greater than or equal\n     *          to <i>minPage<\/i>\n     * @param   minPage an integer greater than zero and less than or equal\n     *          to <i>maxPage<\/i>\n     * @param   multipleDocumentHandling\n     *     <code>MultipleDocumentHandlingType.SEPARATE_DOCUMENTS_COLLATED_COPIES<\/code> or\n     *     <code>MultipleDocumentHandlingType.SEPARATE_DOCUMENTS_UNCOLLATED_COPIES<\/code>\n     * @param   pageRanges an array of integer arrays of two elements; an array\n     *          is interpreted as a range spanning all pages including and\n     *          between the specified pages; ranges must be in ascending\n     *          order and must not overlap; specified page numbers cannot be\n     *          less than <i>minPage<\/i> nor greater than <i>maxPage<\/i>;\n     *          for example:\n     *          <pre>\n     *          (new int[][] { new int[] { 1, 3 }, new int[] { 5, 5 },\n     *                         new int[] { 15, 19 } }),\n     *          <\/pre>\n     *          specifies pages 1, 2, 3, 5, 15, 16, 17, 18, and 19. Note that\n     *          (<code>new int[][] { new int[] { 1, 1 }, new int[] { 1, 2 } }<\/code>),\n     *          is an invalid set of page ranges because the two ranges\n     *          overlap\n     * @param   printer the possibly <code>null<\/code> printer name\n     * @param   sides <code>SidesType.ONE_SIDED<\/code>,\n     *          <code>SidesType.TWO_SIDED_LONG_EDGE<\/code>, or\n     *          <code>SidesType.TWO_SIDED_SHORT_EDGE<\/code>\n     * @throws  IllegalArgumentException if one or more of the above\n     *          conditions is violated\n     */\n    public JobAttributes(int copies, DefaultSelectionType defaultSelection,\n                         DestinationType destination, DialogType dialog,\n                         String fileName, int maxPage, int minPage,\n                         MultipleDocumentHandlingType multipleDocumentHandling,\n                         int[][] pageRanges, String printer, SidesType sides) {\n        setCopies(copies);\n        setDefaultSelection(defaultSelection);\n        setDestination(destination);\n        setDialog(dialog);\n        setFileName(fileName);\n        setMaxPage(maxPage);\n        setMinPage(minPage);\n        setMultipleDocumentHandling(multipleDocumentHandling);\n        setPageRanges(pageRanges);\n        setPrinter(printer);\n        setSides(sides);\n    }"}
{"Number":"572","API Relative Path":"java.awt.JobAttributes.java-JobAttributes(int-DefaultSelectionType-DestinationType-DialogType-String-int-int-MultipleDocumentHandlingType-int[][]-String-SidesType)","Corresponding Source":"/**\n     * Constructs a <code>JobAttributes<\/code> instance with the\n     * specified values for every attribute.\n     *\n     * @param   copies an integer greater than 0\n     * @param   defaultSelection <code>DefaultSelectionType.ALL<\/code>,\n     *          <code>DefaultSelectionType.RANGE<\/code>, or\n     *          <code>DefaultSelectionType.SELECTION<\/code>\n     * @param   destination <code>DesintationType.FILE<\/code> or\n     *          <code>DesintationType.PRINTER<\/code>\n     * @param   dialog <code>DialogType.COMMON<\/code>,\n     *          <code>DialogType.NATIVE<\/code>, or\n     *          <code>DialogType.NONE<\/code>\n     * @param   fileName the possibly <code>null<\/code> file name\n     * @param   maxPage an integer greater than zero and greater than or equal\n     *          to <i>minPage<\/i>\n     * @param   minPage an integer greater than zero and less than or equal\n     *          to <i>maxPage<\/i>\n     * @param   multipleDocumentHandling\n     *     <code>MultipleDocumentHandlingType.SEPARATE_DOCUMENTS_COLLATED_COPIES<\/code> or\n     *     <code>MultipleDocumentHandlingType.SEPARATE_DOCUMENTS_UNCOLLATED_COPIES<\/code>\n     * @param   pageRanges an array of integer arrays of two elements; an array\n     *          is interpreted as a range spanning all pages including and\n     *          between the specified pages; ranges must be in ascending\n     *          order and must not overlap; specified page numbers cannot be\n     *          less than <i>minPage<\/i> nor greater than <i>maxPage<\/i>;\n     *          for example:\n     *          <pre>\n     *          (new int[][] { new int[] { 1, 3 }, new int[] { 5, 5 },\n     *                         new int[] { 15, 19 } }),\n     *          <\/pre>\n     *          specifies pages 1, 2, 3, 5, 15, 16, 17, 18, and 19. Note that\n     *          (<code>new int[][] { new int[] { 1, 1 }, new int[] { 1, 2 } }<\/code>),\n     *          is an invalid set of page ranges because the two ranges\n     *          overlap\n     * @param   printer the possibly <code>null<\/code> printer name\n     * @param   sides <code>SidesType.ONE_SIDED<\/code>,\n     *          <code>SidesType.TWO_SIDED_LONG_EDGE<\/code>, or\n     *          <code>SidesType.TWO_SIDED_SHORT_EDGE<\/code>\n     * @throws  IllegalArgumentException if one or more of the above\n     *          conditions is violated\n     */\n    public JobAttributes(int copies, DefaultSelectionType defaultSelection,\n                         DestinationType destination, DialogType dialog,\n                         String fileName, int maxPage, int minPage,\n                         MultipleDocumentHandlingType multipleDocumentHandling,\n                         int[][] pageRanges, String printer, SidesType sides) {\n        setCopies(copies);\n        setDefaultSelection(defaultSelection);\n        setDestination(destination);\n        setDialog(dialog);\n        setFileName(fileName);\n        setMaxPage(maxPage);\n        setMinPage(minPage);\n        setMultipleDocumentHandling(multipleDocumentHandling);\n        setPageRanges(pageRanges);\n        setPrinter(printer);\n        setSides(sides);\n    }"}
{"Number":"573","API Relative Path":"java.awt.JobAttributes.java-JobAttributes(int-DefaultSelectionType-DestinationType-DialogType-String-int-int-MultipleDocumentHandlingType-int[][]-String-SidesType)","Corresponding Source":"/**\n     * Constructs a <code>JobAttributes<\/code> instance with the\n     * specified values for every attribute.\n     *\n     * @param   copies an integer greater than 0\n     * @param   defaultSelection <code>DefaultSelectionType.ALL<\/code>,\n     *          <code>DefaultSelectionType.RANGE<\/code>, or\n     *          <code>DefaultSelectionType.SELECTION<\/code>\n     * @param   destination <code>DesintationType.FILE<\/code> or\n     *          <code>DesintationType.PRINTER<\/code>\n     * @param   dialog <code>DialogType.COMMON<\/code>,\n     *          <code>DialogType.NATIVE<\/code>, or\n     *          <code>DialogType.NONE<\/code>\n     * @param   fileName the possibly <code>null<\/code> file name\n     * @param   maxPage an integer greater than zero and greater than or equal\n     *          to <i>minPage<\/i>\n     * @param   minPage an integer greater than zero and less than or equal\n     *          to <i>maxPage<\/i>\n     * @param   multipleDocumentHandling\n     *     <code>MultipleDocumentHandlingType.SEPARATE_DOCUMENTS_COLLATED_COPIES<\/code> or\n     *     <code>MultipleDocumentHandlingType.SEPARATE_DOCUMENTS_UNCOLLATED_COPIES<\/code>\n     * @param   pageRanges an array of integer arrays of two elements; an array\n     *          is interpreted as a range spanning all pages including and\n     *          between the specified pages; ranges must be in ascending\n     *          order and must not overlap; specified page numbers cannot be\n     *          less than <i>minPage<\/i> nor greater than <i>maxPage<\/i>;\n     *          for example:\n     *          <pre>\n     *          (new int[][] { new int[] { 1, 3 }, new int[] { 5, 5 },\n     *                         new int[] { 15, 19 } }),\n     *          <\/pre>\n     *          specifies pages 1, 2, 3, 5, 15, 16, 17, 18, and 19. Note that\n     *          (<code>new int[][] { new int[] { 1, 1 }, new int[] { 1, 2 } }<\/code>),\n     *          is an invalid set of page ranges because the two ranges\n     *          overlap\n     * @param   printer the possibly <code>null<\/code> printer name\n     * @param   sides <code>SidesType.ONE_SIDED<\/code>,\n     *          <code>SidesType.TWO_SIDED_LONG_EDGE<\/code>, or\n     *          <code>SidesType.TWO_SIDED_SHORT_EDGE<\/code>\n     * @throws  IllegalArgumentException if one or more of the above\n     *          conditions is violated\n     */\n    public JobAttributes(int copies, DefaultSelectionType defaultSelection,\n                         DestinationType destination, DialogType dialog,\n                         String fileName, int maxPage, int minPage,\n                         MultipleDocumentHandlingType multipleDocumentHandling,\n                         int[][] pageRanges, String printer, SidesType sides) {\n        setCopies(copies);\n        setDefaultSelection(defaultSelection);\n        setDestination(destination);\n        setDialog(dialog);\n        setFileName(fileName);\n        setMaxPage(maxPage);\n        setMinPage(minPage);\n        setMultipleDocumentHandling(multipleDocumentHandling);\n        setPageRanges(pageRanges);\n        setPrinter(printer);\n        setSides(sides);\n    }"}
{"Number":"574","API Relative Path":"java.awt.JobAttributes.java-JobAttributes(int-DefaultSelectionType-DestinationType-DialogType-String-int-int-MultipleDocumentHandlingType-int[][]-String-SidesType)","Corresponding Source":"/**\n     * Constructs a <code>JobAttributes<\/code> instance with the\n     * specified values for every attribute.\n     *\n     * @param   copies an integer greater than 0\n     * @param   defaultSelection <code>DefaultSelectionType.ALL<\/code>,\n     *          <code>DefaultSelectionType.RANGE<\/code>, or\n     *          <code>DefaultSelectionType.SELECTION<\/code>\n     * @param   destination <code>DesintationType.FILE<\/code> or\n     *          <code>DesintationType.PRINTER<\/code>\n     * @param   dialog <code>DialogType.COMMON<\/code>,\n     *          <code>DialogType.NATIVE<\/code>, or\n     *          <code>DialogType.NONE<\/code>\n     * @param   fileName the possibly <code>null<\/code> file name\n     * @param   maxPage an integer greater than zero and greater than or equal\n     *          to <i>minPage<\/i>\n     * @param   minPage an integer greater than zero and less than or equal\n     *          to <i>maxPage<\/i>\n     * @param   multipleDocumentHandling\n     *     <code>MultipleDocumentHandlingType.SEPARATE_DOCUMENTS_COLLATED_COPIES<\/code> or\n     *     <code>MultipleDocumentHandlingType.SEPARATE_DOCUMENTS_UNCOLLATED_COPIES<\/code>\n     * @param   pageRanges an array of integer arrays of two elements; an array\n     *          is interpreted as a range spanning all pages including and\n     *          between the specified pages; ranges must be in ascending\n     *          order and must not overlap; specified page numbers cannot be\n     *          less than <i>minPage<\/i> nor greater than <i>maxPage<\/i>;\n     *          for example:\n     *          <pre>\n     *          (new int[][] { new int[] { 1, 3 }, new int[] { 5, 5 },\n     *                         new int[] { 15, 19 } }),\n     *          <\/pre>\n     *          specifies pages 1, 2, 3, 5, 15, 16, 17, 18, and 19. Note that\n     *          (<code>new int[][] { new int[] { 1, 1 }, new int[] { 1, 2 } }<\/code>),\n     *          is an invalid set of page ranges because the two ranges\n     *          overlap\n     * @param   printer the possibly <code>null<\/code> printer name\n     * @param   sides <code>SidesType.ONE_SIDED<\/code>,\n     *          <code>SidesType.TWO_SIDED_LONG_EDGE<\/code>, or\n     *          <code>SidesType.TWO_SIDED_SHORT_EDGE<\/code>\n     * @throws  IllegalArgumentException if one or more of the above\n     *          conditions is violated\n     */\n    public JobAttributes(int copies, DefaultSelectionType defaultSelection,\n                         DestinationType destination, DialogType dialog,\n                         String fileName, int maxPage, int minPage,\n                         MultipleDocumentHandlingType multipleDocumentHandling,\n                         int[][] pageRanges, String printer, SidesType sides) {\n        setCopies(copies);\n        setDefaultSelection(defaultSelection);\n        setDestination(destination);\n        setDialog(dialog);\n        setFileName(fileName);\n        setMaxPage(maxPage);\n        setMinPage(minPage);\n        setMultipleDocumentHandling(multipleDocumentHandling);\n        setPageRanges(pageRanges);\n        setPrinter(printer);\n        setSides(sides);\n    }"}
{"Number":"575","API Relative Path":"java.awt.JobAttributes.java-JobAttributes(int-DefaultSelectionType-DestinationType-DialogType-String-int-int-MultipleDocumentHandlingType-int[][]-String-SidesType)","Corresponding Source":"/**\n     * Constructs a <code>JobAttributes<\/code> instance with the\n     * specified values for every attribute.\n     *\n     * @param   copies an integer greater than 0\n     * @param   defaultSelection <code>DefaultSelectionType.ALL<\/code>,\n     *          <code>DefaultSelectionType.RANGE<\/code>, or\n     *          <code>DefaultSelectionType.SELECTION<\/code>\n     * @param   destination <code>DesintationType.FILE<\/code> or\n     *          <code>DesintationType.PRINTER<\/code>\n     * @param   dialog <code>DialogType.COMMON<\/code>,\n     *          <code>DialogType.NATIVE<\/code>, or\n     *          <code>DialogType.NONE<\/code>\n     * @param   fileName the possibly <code>null<\/code> file name\n     * @param   maxPage an integer greater than zero and greater than or equal\n     *          to <i>minPage<\/i>\n     * @param   minPage an integer greater than zero and less than or equal\n     *          to <i>maxPage<\/i>\n     * @param   multipleDocumentHandling\n     *     <code>MultipleDocumentHandlingType.SEPARATE_DOCUMENTS_COLLATED_COPIES<\/code> or\n     *     <code>MultipleDocumentHandlingType.SEPARATE_DOCUMENTS_UNCOLLATED_COPIES<\/code>\n     * @param   pageRanges an array of integer arrays of two elements; an array\n     *          is interpreted as a range spanning all pages including and\n     *          between the specified pages; ranges must be in ascending\n     *          order and must not overlap; specified page numbers cannot be\n     *          less than <i>minPage<\/i> nor greater than <i>maxPage<\/i>;\n     *          for example:\n     *          <pre>\n     *          (new int[][] { new int[] { 1, 3 }, new int[] { 5, 5 },\n     *                         new int[] { 15, 19 } }),\n     *          <\/pre>\n     *          specifies pages 1, 2, 3, 5, 15, 16, 17, 18, and 19. Note that\n     *          (<code>new int[][] { new int[] { 1, 1 }, new int[] { 1, 2 } }<\/code>),\n     *          is an invalid set of page ranges because the two ranges\n     *          overlap\n     * @param   printer the possibly <code>null<\/code> printer name\n     * @param   sides <code>SidesType.ONE_SIDED<\/code>,\n     *          <code>SidesType.TWO_SIDED_LONG_EDGE<\/code>, or\n     *          <code>SidesType.TWO_SIDED_SHORT_EDGE<\/code>\n     * @throws  IllegalArgumentException if one or more of the above\n     *          conditions is violated\n     */\n    public JobAttributes(int copies, DefaultSelectionType defaultSelection,\n                         DestinationType destination, DialogType dialog,\n                         String fileName, int maxPage, int minPage,\n                         MultipleDocumentHandlingType multipleDocumentHandling,\n                         int[][] pageRanges, String printer, SidesType sides) {\n        setCopies(copies);\n        setDefaultSelection(defaultSelection);\n        setDestination(destination);\n        setDialog(dialog);\n        setFileName(fileName);\n        setMaxPage(maxPage);\n        setMinPage(minPage);\n        setMultipleDocumentHandling(multipleDocumentHandling);\n        setPageRanges(pageRanges);\n        setPrinter(printer);\n        setSides(sides);\n    }"}
{"Number":"576","API Relative Path":"java.awt.JobAttributes.java-JobAttributes(int-DefaultSelectionType-DestinationType-DialogType-String-int-int-MultipleDocumentHandlingType-int[][]-String-SidesType)","Corresponding Source":"/**\n     * Constructs a <code>JobAttributes<\/code> instance with the\n     * specified values for every attribute.\n     *\n     * @param   copies an integer greater than 0\n     * @param   defaultSelection <code>DefaultSelectionType.ALL<\/code>,\n     *          <code>DefaultSelectionType.RANGE<\/code>, or\n     *          <code>DefaultSelectionType.SELECTION<\/code>\n     * @param   destination <code>DesintationType.FILE<\/code> or\n     *          <code>DesintationType.PRINTER<\/code>\n     * @param   dialog <code>DialogType.COMMON<\/code>,\n     *          <code>DialogType.NATIVE<\/code>, or\n     *          <code>DialogType.NONE<\/code>\n     * @param   fileName the possibly <code>null<\/code> file name\n     * @param   maxPage an integer greater than zero and greater than or equal\n     *          to <i>minPage<\/i>\n     * @param   minPage an integer greater than zero and less than or equal\n     *          to <i>maxPage<\/i>\n     * @param   multipleDocumentHandling\n     *     <code>MultipleDocumentHandlingType.SEPARATE_DOCUMENTS_COLLATED_COPIES<\/code> or\n     *     <code>MultipleDocumentHandlingType.SEPARATE_DOCUMENTS_UNCOLLATED_COPIES<\/code>\n     * @param   pageRanges an array of integer arrays of two elements; an array\n     *          is interpreted as a range spanning all pages including and\n     *          between the specified pages; ranges must be in ascending\n     *          order and must not overlap; specified page numbers cannot be\n     *          less than <i>minPage<\/i> nor greater than <i>maxPage<\/i>;\n     *          for example:\n     *          <pre>\n     *          (new int[][] { new int[] { 1, 3 }, new int[] { 5, 5 },\n     *                         new int[] { 15, 19 } }),\n     *          <\/pre>\n     *          specifies pages 1, 2, 3, 5, 15, 16, 17, 18, and 19. Note that\n     *          (<code>new int[][] { new int[] { 1, 1 }, new int[] { 1, 2 } }<\/code>),\n     *          is an invalid set of page ranges because the two ranges\n     *          overlap\n     * @param   printer the possibly <code>null<\/code> printer name\n     * @param   sides <code>SidesType.ONE_SIDED<\/code>,\n     *          <code>SidesType.TWO_SIDED_LONG_EDGE<\/code>, or\n     *          <code>SidesType.TWO_SIDED_SHORT_EDGE<\/code>\n     * @throws  IllegalArgumentException if one or more of the above\n     *          conditions is violated\n     */\n    public JobAttributes(int copies, DefaultSelectionType defaultSelection,\n                         DestinationType destination, DialogType dialog,\n                         String fileName, int maxPage, int minPage,\n                         MultipleDocumentHandlingType multipleDocumentHandling,\n                         int[][] pageRanges, String printer, SidesType sides) {\n        setCopies(copies);\n        setDefaultSelection(defaultSelection);\n        setDestination(destination);\n        setDialog(dialog);\n        setFileName(fileName);\n        setMaxPage(maxPage);\n        setMinPage(minPage);\n        setMultipleDocumentHandling(multipleDocumentHandling);\n        setPageRanges(pageRanges);\n        setPrinter(printer);\n        setSides(sides);\n    }"}
{"Number":"577","API Relative Path":"java.awt.JobAttributes.java-JobAttributes(int-DefaultSelectionType-DestinationType-DialogType-String-int-int-MultipleDocumentHandlingType-int[][]-String-SidesType)","Corresponding Source":"/**\n     * Constructs a <code>JobAttributes<\/code> instance with the\n     * specified values for every attribute.\n     *\n     * @param   copies an integer greater than 0\n     * @param   defaultSelection <code>DefaultSelectionType.ALL<\/code>,\n     *          <code>DefaultSelectionType.RANGE<\/code>, or\n     *          <code>DefaultSelectionType.SELECTION<\/code>\n     * @param   destination <code>DesintationType.FILE<\/code> or\n     *          <code>DesintationType.PRINTER<\/code>\n     * @param   dialog <code>DialogType.COMMON<\/code>,\n     *          <code>DialogType.NATIVE<\/code>, or\n     *          <code>DialogType.NONE<\/code>\n     * @param   fileName the possibly <code>null<\/code> file name\n     * @param   maxPage an integer greater than zero and greater than or equal\n     *          to <i>minPage<\/i>\n     * @param   minPage an integer greater than zero and less than or equal\n     *          to <i>maxPage<\/i>\n     * @param   multipleDocumentHandling\n     *     <code>MultipleDocumentHandlingType.SEPARATE_DOCUMENTS_COLLATED_COPIES<\/code> or\n     *     <code>MultipleDocumentHandlingType.SEPARATE_DOCUMENTS_UNCOLLATED_COPIES<\/code>\n     * @param   pageRanges an array of integer arrays of two elements; an array\n     *          is interpreted as a range spanning all pages including and\n     *          between the specified pages; ranges must be in ascending\n     *          order and must not overlap; specified page numbers cannot be\n     *          less than <i>minPage<\/i> nor greater than <i>maxPage<\/i>;\n     *          for example:\n     *          <pre>\n     *          (new int[][] { new int[] { 1, 3 }, new int[] { 5, 5 },\n     *                         new int[] { 15, 19 } }),\n     *          <\/pre>\n     *          specifies pages 1, 2, 3, 5, 15, 16, 17, 18, and 19. Note that\n     *          (<code>new int[][] { new int[] { 1, 1 }, new int[] { 1, 2 } }<\/code>),\n     *          is an invalid set of page ranges because the two ranges\n     *          overlap\n     * @param   printer the possibly <code>null<\/code> printer name\n     * @param   sides <code>SidesType.ONE_SIDED<\/code>,\n     *          <code>SidesType.TWO_SIDED_LONG_EDGE<\/code>, or\n     *          <code>SidesType.TWO_SIDED_SHORT_EDGE<\/code>\n     * @throws  IllegalArgumentException if one or more of the above\n     *          conditions is violated\n     */\n    public JobAttributes(int copies, DefaultSelectionType defaultSelection,\n                         DestinationType destination, DialogType dialog,\n                         String fileName, int maxPage, int minPage,\n                         MultipleDocumentHandlingType multipleDocumentHandling,\n                         int[][] pageRanges, String printer, SidesType sides) {\n        setCopies(copies);\n        setDefaultSelection(defaultSelection);\n        setDestination(destination);\n        setDialog(dialog);\n        setFileName(fileName);\n        setMaxPage(maxPage);\n        setMinPage(minPage);\n        setMultipleDocumentHandling(multipleDocumentHandling);\n        setPageRanges(pageRanges);\n        setPrinter(printer);\n        setSides(sides);\n    }"}
{"Number":"578","API Relative Path":"java.awt.JobAttributes.java-JobAttributes(int-DefaultSelectionType-DestinationType-DialogType-String-int-int-MultipleDocumentHandlingType-int[][]-String-SidesType)","Corresponding Source":"/**\n     * Constructs a <code>JobAttributes<\/code> instance with the\n     * specified values for every attribute.\n     *\n     * @param   copies an integer greater than 0\n     * @param   defaultSelection <code>DefaultSelectionType.ALL<\/code>,\n     *          <code>DefaultSelectionType.RANGE<\/code>, or\n     *          <code>DefaultSelectionType.SELECTION<\/code>\n     * @param   destination <code>DesintationType.FILE<\/code> or\n     *          <code>DesintationType.PRINTER<\/code>\n     * @param   dialog <code>DialogType.COMMON<\/code>,\n     *          <code>DialogType.NATIVE<\/code>, or\n     *          <code>DialogType.NONE<\/code>\n     * @param   fileName the possibly <code>null<\/code> file name\n     * @param   maxPage an integer greater than zero and greater than or equal\n     *          to <i>minPage<\/i>\n     * @param   minPage an integer greater than zero and less than or equal\n     *          to <i>maxPage<\/i>\n     * @param   multipleDocumentHandling\n     *     <code>MultipleDocumentHandlingType.SEPARATE_DOCUMENTS_COLLATED_COPIES<\/code> or\n     *     <code>MultipleDocumentHandlingType.SEPARATE_DOCUMENTS_UNCOLLATED_COPIES<\/code>\n     * @param   pageRanges an array of integer arrays of two elements; an array\n     *          is interpreted as a range spanning all pages including and\n     *          between the specified pages; ranges must be in ascending\n     *          order and must not overlap; specified page numbers cannot be\n     *          less than <i>minPage<\/i> nor greater than <i>maxPage<\/i>;\n     *          for example:\n     *          <pre>\n     *          (new int[][] { new int[] { 1, 3 }, new int[] { 5, 5 },\n     *                         new int[] { 15, 19 } }),\n     *          <\/pre>\n     *          specifies pages 1, 2, 3, 5, 15, 16, 17, 18, and 19. Note that\n     *          (<code>new int[][] { new int[] { 1, 1 }, new int[] { 1, 2 } }<\/code>),\n     *          is an invalid set of page ranges because the two ranges\n     *          overlap\n     * @param   printer the possibly <code>null<\/code> printer name\n     * @param   sides <code>SidesType.ONE_SIDED<\/code>,\n     *          <code>SidesType.TWO_SIDED_LONG_EDGE<\/code>, or\n     *          <code>SidesType.TWO_SIDED_SHORT_EDGE<\/code>\n     * @throws  IllegalArgumentException if one or more of the above\n     *          conditions is violated\n     */\n    public JobAttributes(int copies, DefaultSelectionType defaultSelection,\n                         DestinationType destination, DialogType dialog,\n                         String fileName, int maxPage, int minPage,\n                         MultipleDocumentHandlingType multipleDocumentHandling,\n                         int[][] pageRanges, String printer, SidesType sides) {\n        setCopies(copies);\n        setDefaultSelection(defaultSelection);\n        setDestination(destination);\n        setDialog(dialog);\n        setFileName(fileName);\n        setMaxPage(maxPage);\n        setMinPage(minPage);\n        setMultipleDocumentHandling(multipleDocumentHandling);\n        setPageRanges(pageRanges);\n        setPrinter(printer);\n        setSides(sides);\n    }"}
{"Number":"579","API Relative Path":"java.awt.JobAttributes.java-setFromPage(int)","Corresponding Source":"/**\n     * Specifies, for jobs using these attributes, the first page to be\n     * printed, if a range of pages is to be printed. If this attribute is not\n     * specified, then the values from the pageRanges attribute are used. If\n     * pageRanges and either or both of fromPage and toPage are specified,\n     * pageRanges takes precedence. Specifying none of pageRanges, fromPage,\n     * or toPage is equivalent to calling\n     * setPageRanges(new int[][] { new int[] { <i>minPage<\/i> } });\n     *\n     * @param   fromPage an integer greater than zero and less than or equal to\n     *          <i>toPage<\/i> and greater than or equal to <i>minPage<\/i> and\n     *          less than or equal to <i>maxPage<\/i>.\n     * @throws  IllegalArgumentException if one or more of the above\n     *          conditions is violated.\n     */\n    public void setFromPage(int fromPage) {\n        if (fromPage <= 0 ||\n            (toPage != 0 && fromPage > toPage) ||\n            fromPage < minPage ||\n            fromPage > maxPage) {\n            throw new IllegalArgumentException(\"Invalid value for attribute \"+\n                                               \"fromPage\");\n        }\n        this.fromPage = fromPage;\n    }"}
{"Number":"580","API Relative Path":"java.awt.JobAttributes.java-setMaxPage(int)","Corresponding Source":"/**\n     * Specifies the maximum value the user can specify as the last page to\n     * be printed for jobs using these attributes. Not specifying this\n     * attribute is equivalent to specifying <code>Integer.MAX_VALUE<\/code>.\n     *\n     * @param   maxPage an integer greater than zero and greater than or equal\n     *          to <i>minPage<\/i>\n     * @throws  IllegalArgumentException if one or more of the above\n     *          conditions is violated\n     */\n    public void setMaxPage(int maxPage) {\n        if (maxPage <= 0 || maxPage < minPage) {\n            throw new IllegalArgumentException(\"Invalid value for attribute \"+\n                                               \"maxPage\");\n        }\n        this.maxPage = maxPage;\n    }"}
{"Number":"581","API Relative Path":"java.awt.JobAttributes.java-setMinPage(int)","Corresponding Source":"/**\n     * Specifies the minimum value the user can specify as the first page to\n     * be printed for jobs using these attributes. Not specifying this\n     * attribute is equivalent to specifying <code>1<\/code>.\n     *\n     * @param   minPage an integer greater than zero and less than or equal\n     *          to <i>maxPage<\/i>.\n     * @throws  IllegalArgumentException if one or more of the above\n     *          conditions is violated.\n     */\n    public void setMinPage(int minPage) {\n        if (minPage <= 0 || minPage > maxPage) {\n            throw new IllegalArgumentException(\"Invalid value for attribute \"+\n                                               \"minPage\");\n        }\n        this.minPage = minPage;\n    }"}
{"Number":"582","API Relative Path":"java.awt.JobAttributes.java-setPageRanges(int[][])","Corresponding Source":"/**\n     * Specifies, for jobs using these attributes, the ranges of pages to be\n     * printed, if a range of pages is to be printed. All range numbers are\n     * inclusive. If this attribute is not specified, then the values from the\n     * fromPage and toPages attributes are used. If pageRanges and either or\n     * both of fromPage and toPage are specified, pageRanges takes precedence.\n     * Specifying none of pageRanges, fromPage, or toPage is equivalent to\n     * calling setPageRanges(new int[][] { new int[] { <i>minPage<\/i>,\n     *                                                 <i>minPage<\/i> } });\n     *\n     * @param   pageRanges an array of integer arrays of 2 elements. An array\n     *          is interpreted as a range spanning all pages including and\n     *          between the specified pages. Ranges must be in ascending\n     *          order and must not overlap. Specified page numbers cannot be\n     *          less than <i>minPage<\/i> nor greater than <i>maxPage<\/i>.\n     *          For example:\n     *          (new int[][] { new int[] { 1, 3 }, new int[] { 5, 5 },\n     *                         new int[] { 15, 19 } }),\n     *          specifies pages 1, 2, 3, 5, 15, 16, 17, 18, and 19. Note that\n     *          (new int[][] { new int[] { 1, 1 }, new int[] { 1, 2 } }),\n     *          is an invalid set of page ranges because the two ranges\n     *          overlap.\n     * @throws  IllegalArgumentException if one or more of the above\n     *          conditions is violated.\n     */\n    public void setPageRanges(int[][] pageRanges) {\n        String xcp = \"Invalid value for attribute pageRanges\";\n        int first = 0;\n        int last = 0;\n\n        if (pageRanges == null) {\n            throw new IllegalArgumentException(xcp);\n        }\n\n        for (int i = 0; i < pageRanges.length; i++) {\n            if (pageRanges[i] == null ||\n                pageRanges[i].length != 2 ||\n                pageRanges[i][0] <= last ||\n                pageRanges[i][1] < pageRanges[i][0]) {\n                    throw new IllegalArgumentException(xcp);\n            }\n            last = pageRanges[i][1];\n            if (first == 0) {\n                first = pageRanges[i][0];\n            }\n        }\n\n        if (first < minPage || last > maxPage) {\n            throw new IllegalArgumentException(xcp);\n        }\n\n        // Store a copy because otherwise client code could circumvent the\n        // the checks made above by holding a reference to the array and\n        // modifying it after calling setPageRanges.\n        int[][] copy = new int[pageRanges.length][2];\n        for (int i = 0; i < pageRanges.length; i++) {\n            copy[i][0] = pageRanges[i][0];\n            copy[i][1] = pageRanges[i][1];\n        }\n        this.pageRanges = copy;\n        this.prFirst = first;\n        this.prLast = last;\n    }"}
{"Number":"583","API Relative Path":"java.awt.JobAttributes.java-setToPage(int)","Corresponding Source":"/**\n     * Specifies, for jobs using these attributes, the last page (inclusive)\n     * to be printed, if a range of pages is to be printed.\n     * If this attribute is not specified, then the values from the pageRanges\n     * attribute are used. If pageRanges and either or both of fromPage and\n     * toPage are specified, pageRanges takes precedence. Specifying none of\n     * pageRanges, fromPage, or toPage is equivalent to calling\n     * setPageRanges(new int[][] { new int[] { <i>minPage<\/i> } });\n     *\n     * @param   toPage an integer greater than zero and greater than or equal\n     *          to <i>fromPage<\/i> and greater than or equal to <i>minPage<\/i>\n     *          and less than or equal to <i>maxPage<\/i>.\n     * @throws  IllegalArgumentException if one or more of the above\n     *          conditions is violated.\n     */\n    public void setToPage(int toPage) {\n        if (toPage <= 0 ||\n            (fromPage != 0 && toPage < fromPage) ||\n            toPage < minPage ||\n            toPage > maxPage) {\n            throw new IllegalArgumentException(\"Invalid value for attribute \"+\n                                               \"toPage\");\n        }\n        this.toPage = toPage;\n    }"}
{"Number":"584","API Relative Path":"java.awt.KeyboardFocusManager.java-addKeyEventDispatcher(KeyEventDispatcher)","Corresponding Source":"/**\n     * Adds a KeyEventDispatcher to this KeyboardFocusManager's dispatcher\n     * chain. This KeyboardFocusManager will request that each\n     * KeyEventDispatcher dispatch KeyEvents generated by the user before\n     * finally dispatching the KeyEvent itself. KeyEventDispatchers will be\n     * notified in the order in which they were added. Notifications will halt\n     * as soon as one KeyEventDispatcher returns <code>true<\/code> from its\n     * <code>dispatchKeyEvent<\/code> method. There is no limit to the total\n     * number of KeyEventDispatchers which can be added, nor to the number of\n     * times which a particular KeyEventDispatcher instance can be added.\n     * <p>\n     * If a null dispatcher is specified, no action is taken and no exception\n     * is thrown.\n     * <p>\n     * In a multithreaded application, {@link KeyEventDispatcher} behaves\n     * the same as other AWT listeners.  See\n     * <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for more details.\n     *\n     * @param dispatcher the KeyEventDispatcher to add to the dispatcher chain\n     * @see #removeKeyEventDispatcher\n     */\n    public void addKeyEventDispatcher(KeyEventDispatcher dispatcher) {\n        if (dispatcher != null) {\n            synchronized (this) {\n                if (keyEventDispatchers == null) {\n                    keyEventDispatchers = new java.util.LinkedList<>();\n                }\n                keyEventDispatchers.add(dispatcher);\n            }\n        }\n    }"}
{"Number":"585","API Relative Path":"java.awt.KeyboardFocusManager.java-addKeyEventPostProcessor(KeyEventPostProcessor)","Corresponding Source":"/**\n     * Adds a KeyEventPostProcessor to this KeyboardFocusManager's post-\n     * processor chain. After a KeyEvent has been dispatched to and handled by\n     * its target, KeyboardFocusManager will request that each\n     * KeyEventPostProcessor perform any necessary post-processing as part\n     * of the KeyEvent's final resolution. KeyEventPostProcessors\n     * will be notified in the order in which they were added; the current\n     * KeyboardFocusManager will be notified last. Notifications will halt\n     * as soon as one KeyEventPostProcessor returns <code>true<\/code> from its\n     * <code>postProcessKeyEvent<\/code> method. There is no limit to the the\n     * total number of KeyEventPostProcessors that can be added, nor to the\n     * number of times that a particular KeyEventPostProcessor instance can be\n     * added.\n     * <p>\n     * If a null post-processor is specified, no action is taken and no\n     * exception is thrown.\n     * <p>\n     * In a multithreaded application, {@link KeyEventPostProcessor} behaves\n     * the same as other AWT listeners.  See\n     * <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for more details.\n     *\n     * @param processor the KeyEventPostProcessor to add to the post-processor\n     *        chain\n     * @see #removeKeyEventPostProcessor\n     */\n    public void addKeyEventPostProcessor(KeyEventPostProcessor processor) {\n        if (processor != null) {\n            synchronized (this) {\n                if (keyEventPostProcessors == null) {\n                    keyEventPostProcessors = new java.util.LinkedList<>();\n                }\n                keyEventPostProcessors.add(processor);\n            }\n        }\n    }"}
{"Number":"586","API Relative Path":"java.awt.KeyboardFocusManager.java-addPropertyChangeListener(PropertyChangeListener)","Corresponding Source":"/**\n     * Adds a PropertyChangeListener to the listener list. The listener is\n     * registered for all bound properties of this class, including the\n     * following:\n     * <ul>\n     *    <li>whether the KeyboardFocusManager is currently managing focus\n     *        for this application or applet's browser context\n     *        (\"managingFocus\")<\/li>\n     *    <li>the focus owner (\"focusOwner\")<\/li>\n     *    <li>the permanent focus owner (\"permanentFocusOwner\")<\/li>\n     *    <li>the focused Window (\"focusedWindow\")<\/li>\n     *    <li>the active Window (\"activeWindow\")<\/li>\n     *    <li>the default focus traversal policy\n     *        (\"defaultFocusTraversalPolicy\")<\/li>\n     *    <li>the Set of default FORWARD_TRAVERSAL_KEYS\n     *        (\"forwardDefaultFocusTraversalKeys\")<\/li>\n     *    <li>the Set of default BACKWARD_TRAVERSAL_KEYS\n     *        (\"backwardDefaultFocusTraversalKeys\")<\/li>\n     *    <li>the Set of default UP_CYCLE_TRAVERSAL_KEYS\n     *        (\"upCycleDefaultFocusTraversalKeys\")<\/li>\n     *    <li>the Set of default DOWN_CYCLE_TRAVERSAL_KEYS\n     *        (\"downCycleDefaultFocusTraversalKeys\")<\/li>\n     *    <li>the current focus cycle root (\"currentFocusCycleRoot\")<\/li>\n     * <\/ul>\n     * If listener is null, no exception is thrown and no action is performed.\n     *\n     * @param listener the PropertyChangeListener to be added\n     * @see #removePropertyChangeListener\n     * @see #getPropertyChangeListeners\n     * @see #addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)\n     */\n    public void addPropertyChangeListener(PropertyChangeListener listener) {\n        if (listener != null) {\n            synchronized (this) {\n                if (changeSupport == null) {\n                    changeSupport = new PropertyChangeSupport(this);\n                }\n                changeSupport.addPropertyChangeListener(listener);\n            }\n        }\n    }"}
{"Number":"587","API Relative Path":"java.awt.KeyboardFocusManager.java-addPropertyChangeListener(String-PropertyChangeListener)","Corresponding Source":"/**\n     * Adds a PropertyChangeListener to the listener list for a specific\n     * property. The specified property may be user-defined, or one of the\n     * following:\n     * <ul>\n     *    <li>whether the KeyboardFocusManager is currently managing focus\n     *        for this application or applet's browser context\n     *        (\"managingFocus\")<\/li>\n     *    <li>the focus owner (\"focusOwner\")<\/li>\n     *    <li>the permanent focus owner (\"permanentFocusOwner\")<\/li>\n     *    <li>the focused Window (\"focusedWindow\")<\/li>\n     *    <li>the active Window (\"activeWindow\")<\/li>\n     *    <li>the default focus traversal policy\n     *        (\"defaultFocusTraversalPolicy\")<\/li>\n     *    <li>the Set of default FORWARD_TRAVERSAL_KEYS\n     *        (\"forwardDefaultFocusTraversalKeys\")<\/li>\n     *    <li>the Set of default BACKWARD_TRAVERSAL_KEYS\n     *        (\"backwardDefaultFocusTraversalKeys\")<\/li>\n     *    <li>the Set of default UP_CYCLE_TRAVERSAL_KEYS\n     *        (\"upCycleDefaultFocusTraversalKeys\")<\/li>\n     *    <li>the Set of default DOWN_CYCLE_TRAVERSAL_KEYS\n     *        (\"downCycleDefaultFocusTraversalKeys\")<\/li>\n     *    <li>the current focus cycle root (\"currentFocusCycleRoot\")<\/li>\n     * <\/ul>\n     * If listener is null, no exception is thrown and no action is performed.\n     *\n     * @param propertyName one of the property names listed above\n     * @param listener the PropertyChangeListener to be added\n     * @see #addPropertyChangeListener(java.beans.PropertyChangeListener)\n     * @see #removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)\n     * @see #getPropertyChangeListeners(java.lang.String)\n     */\n    public void addPropertyChangeListener(String propertyName,\n                                          PropertyChangeListener listener) {\n        if (listener != null) {\n            synchronized (this) {\n                if (changeSupport == null) {\n                    changeSupport = new PropertyChangeSupport(this);\n                }\n                changeSupport.addPropertyChangeListener(propertyName,\n                                                        listener);\n            }\n        }\n    }"}
{"Number":"588","API Relative Path":"java.awt.KeyboardFocusManager.java-addVetoableChangeListener(String-VetoableChangeListener)","Corresponding Source":"/**\n     * Adds a VetoableChangeListener to the listener list for a specific\n     * property. The specified property may be user-defined, or one of the\n     * following:\n     * <ul>\n     *    <li>the focus owner (\"focusOwner\")<\/li>\n     *    <li>the permanent focus owner (\"permanentFocusOwner\")<\/li>\n     *    <li>the focused Window (\"focusedWindow\")<\/li>\n     *    <li>the active Window (\"activeWindow\")<\/li>\n     * <\/ul>\n     * If listener is null, no exception is thrown and no action is performed.\n     *\n     * @param propertyName one of the property names listed above\n     * @param listener the VetoableChangeListener to be added\n     * @see #addVetoableChangeListener(java.beans.VetoableChangeListener)\n     * @see #removeVetoableChangeListener\n     * @see #getVetoableChangeListeners\n     */\n    public void addVetoableChangeListener(String propertyName,\n                                          VetoableChangeListener listener) {\n        if (listener != null) {\n            synchronized (this) {\n                if (vetoableSupport == null) {\n                    vetoableSupport =\n                        new VetoableChangeSupport(this);\n                }\n                vetoableSupport.addVetoableChangeListener(propertyName,\n                                                          listener);\n            }\n        }\n    }"}
{"Number":"589","API Relative Path":"java.awt.KeyboardFocusManager.java-addVetoableChangeListener(VetoableChangeListener)","Corresponding Source":"/**\n     * Adds a VetoableChangeListener to the listener list. The listener is\n     * registered for all vetoable properties of this class, including the\n     * following:\n     * <ul>\n     *    <li>the focus owner (\"focusOwner\")<\/li>\n     *    <li>the permanent focus owner (\"permanentFocusOwner\")<\/li>\n     *    <li>the focused Window (\"focusedWindow\")<\/li>\n     *    <li>the active Window (\"activeWindow\")<\/li>\n     * <\/ul>\n     * If listener is null, no exception is thrown and no action is performed.\n     *\n     * @param listener the VetoableChangeListener to be added\n     * @see #removeVetoableChangeListener\n     * @see #getVetoableChangeListeners\n     * @see #addVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener)\n     */\n    public void addVetoableChangeListener(VetoableChangeListener listener) {\n        if (listener != null) {\n            synchronized (this) {\n                if (vetoableSupport == null) {\n                    vetoableSupport =\n                        new VetoableChangeSupport(this);\n                }\n                vetoableSupport.addVetoableChangeListener(listener);\n            }\n        }\n    }"}
{"Number":"590","API Relative Path":"java.awt.KeyboardFocusManager.java-getDefaultFocusTraversalKeys(int)","Corresponding Source":"/**\n     * Returns a Set of default focus traversal keys for a given traversal\n     * operation. This traversal key Set will be in effect on all Windows that\n     * have no such Set of their own explicitly defined. This Set will also be\n     * inherited, recursively, by any child Component of those Windows that has\n     * no such Set of its own explicitly defined. (See\n     * <code>setDefaultFocusTraversalKeys<\/code> for a full description of each\n     * operation.)\n     *\n     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,\n     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or\n     *        KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS\n     * @return the <code>Set<\/code> of <code>AWTKeyStroke<\/code>s\n     *         for the specified operation; the <code>Set<\/code>\n     *         will be unmodifiable, and may be empty; <code>null<\/code>\n     *         will never be returned\n     * @see #setDefaultFocusTraversalKeys\n     * @see Component#setFocusTraversalKeys\n     * @see Component#getFocusTraversalKeys\n     * @throws IllegalArgumentException if id is not one of\n     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or\n     *         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS\n     */\n    public Set<AWTKeyStroke> getDefaultFocusTraversalKeys(int id) {\n        if (id < 0 || id >= TRAVERSAL_KEY_LENGTH) {\n            throw new IllegalArgumentException(\"invalid focus traversal key identifier\");\n        }\n\n        // Okay to return Set directly because it is an unmodifiable view\n        return defaultFocusTraversalKeys[id];\n    }"}
{"Number":"591","API Relative Path":"java.awt.KeyboardFocusManager.java-removeKeyEventDispatcher(KeyEventDispatcher)","Corresponding Source":"/**\n     * Removes a KeyEventDispatcher which was previously added to this\n     * KeyboardFocusManager's dispatcher chain. This KeyboardFocusManager\n     * cannot itself be removed, unless it was explicitly re-registered via a\n     * call to <code>addKeyEventDispatcher<\/code>.\n     * <p>\n     * If a null dispatcher is specified, if the specified dispatcher is not\n     * in the dispatcher chain, or if this KeyboardFocusManager is specified\n     * without having been explicitly re-registered, no action is taken and no\n     * exception is thrown.\n     * <p>\n     * In a multithreaded application, {@link KeyEventDispatcher} behaves\n     * the same as other AWT listeners.  See\n     * <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for more details.\n     *\n     * @param dispatcher the KeyEventDispatcher to remove from the dispatcher\n     *        chain\n     * @see #addKeyEventDispatcher\n     */\n    public void removeKeyEventDispatcher(KeyEventDispatcher dispatcher) {\n        if (dispatcher != null) {\n            synchronized (this) {\n                if (keyEventDispatchers != null) {\n                    keyEventDispatchers.remove(dispatcher);\n                }\n            }\n        }\n    }"}
{"Number":"592","API Relative Path":"java.awt.KeyboardFocusManager.java-removeKeyEventPostProcessor(KeyEventPostProcessor)","Corresponding Source":"/**\n     * Removes a previously added KeyEventPostProcessor from this\n     * KeyboardFocusManager's post-processor chain. This KeyboardFocusManager\n     * cannot itself be entirely removed from the chain. Only additional\n     * references added via <code>addKeyEventPostProcessor<\/code> can be\n     * removed.\n     * <p>\n     * If a null post-processor is specified, if the specified post-processor\n     * is not in the post-processor chain, or if this KeyboardFocusManager is\n     * specified without having been explicitly added, no action is taken and\n     * no exception is thrown.\n     * <p>\n     * In a multithreaded application, {@link KeyEventPostProcessor} behaves\n     * the same as other AWT listeners.  See\n     * <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for more details.\n     *\n     * @param processor the KeyEventPostProcessor to remove from the post-\n     *        processor chain\n     * @see #addKeyEventPostProcessor\n     */\n    public void removeKeyEventPostProcessor(KeyEventPostProcessor processor) {\n        if (processor != null) {\n            synchronized (this) {\n                if (keyEventPostProcessors != null) {\n                    keyEventPostProcessors.remove(processor);\n                }\n            }\n        }\n    }"}
{"Number":"593","API Relative Path":"java.awt.KeyboardFocusManager.java-removePropertyChangeListener(PropertyChangeListener)","Corresponding Source":"/**\n     * Removes a PropertyChangeListener from the listener list. This method\n     * should be used to remove the PropertyChangeListeners that were\n     * registered for all bound properties of this class.\n     * <p>\n     * If listener is null, no exception is thrown and no action is performed.\n     *\n     * @param listener the PropertyChangeListener to be removed\n     * @see #addPropertyChangeListener\n     * @see #getPropertyChangeListeners\n     * @see #removePropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)\n     */\n    public void removePropertyChangeListener(PropertyChangeListener listener) {\n        if (listener != null) {\n            synchronized (this) {\n                if (changeSupport != null) {\n                    changeSupport.removePropertyChangeListener(listener);\n                }\n            }\n        }\n    }"}
{"Number":"594","API Relative Path":"java.awt.KeyboardFocusManager.java-removePropertyChangeListener(String-PropertyChangeListener)","Corresponding Source":"/**\n     * Removes a PropertyChangeListener from the listener list for a specific\n     * property. This method should be used to remove PropertyChangeListeners\n     * that were registered for a specific bound property.\n     * <p>\n     * If listener is null, no exception is thrown and no action is performed.\n     *\n     * @param propertyName a valid property name\n     * @param listener the PropertyChangeListener to be removed\n     * @see #addPropertyChangeListener(java.lang.String,java.beans.PropertyChangeListener)\n     * @see #getPropertyChangeListeners(java.lang.String)\n     * @see #removePropertyChangeListener(java.beans.PropertyChangeListener)\n     */\n    public void removePropertyChangeListener(String propertyName,\n                                             PropertyChangeListener listener) {\n        if (listener != null) {\n            synchronized (this) {\n                if (changeSupport != null) {\n                    changeSupport.removePropertyChangeListener(propertyName,\n                                                               listener);\n                }\n            }\n        }\n    }"}
{"Number":"595","API Relative Path":"java.awt.KeyboardFocusManager.java-removeVetoableChangeListener(String-VetoableChangeListener)","Corresponding Source":"/**\n     * Removes a VetoableChangeListener from the listener list for a specific\n     * property. This method should be used to remove VetoableChangeListeners\n     * that were registered for a specific bound property.\n     * <p>\n     * If listener is null, no exception is thrown and no action is performed.\n     *\n     * @param propertyName a valid property name\n     * @param listener the VetoableChangeListener to be removed\n     * @see #addVetoableChangeListener\n     * @see #getVetoableChangeListeners\n     * @see #removeVetoableChangeListener(java.beans.VetoableChangeListener)\n     */\n    public void removeVetoableChangeListener(String propertyName,\n                                             VetoableChangeListener listener) {\n        if (listener != null) {\n            synchronized (this) {\n                if (vetoableSupport != null) {\n                    vetoableSupport.removeVetoableChangeListener(propertyName,\n                                                                 listener);\n                }\n            }\n        }\n    }"}
{"Number":"596","API Relative Path":"java.awt.KeyboardFocusManager.java-removeVetoableChangeListener(VetoableChangeListener)","Corresponding Source":"/**\n     * Removes a VetoableChangeListener from the listener list. This method\n     * should be used to remove the VetoableChangeListeners that were\n     * registered for all vetoable properties of this class.\n     * <p>\n     * If listener is null, no exception is thrown and no action is performed.\n     *\n     * @param listener the VetoableChangeListener to be removed\n     * @see #addVetoableChangeListener\n     * @see #getVetoableChangeListeners\n     * @see #removeVetoableChangeListener(java.lang.String,java.beans.VetoableChangeListener)\n     */\n    public void removeVetoableChangeListener(VetoableChangeListener listener) {\n        if (listener != null) {\n            synchronized (this) {\n                if (vetoableSupport != null) {\n                    vetoableSupport.removeVetoableChangeListener(listener);\n                }\n            }\n        }\n    }"}
{"Number":"597","API Relative Path":"java.awt.KeyboardFocusManager.java-setDefaultFocusTraversalKeys(int-Set)","Corresponding Source":"/**\n     * Sets the default focus traversal keys for a given traversal operation.\n     * This traversal key {@code Set} will be in effect on all\n     * {@code Window}s that have no such {@code Set} of\n     * their own explicitly defined. This {@code Set} will also be\n     * inherited, recursively, by any child {@code Component} of\n     * those {@code Windows} that has\n     * no such {@code Set} of its own explicitly defined.\n     * <p>\n     * The default values for the default focus traversal keys are\n     * implementation-dependent. Sun recommends that all implementations for a\n     * particular native platform use the same default values. The\n     * recommendations for Windows and Unix are listed below. These\n     * recommendations are used in the Sun AWT implementations.\n     *\n     * <table border=1 summary=\"Recommended default values for focus traversal keys\">\n     * <tr>\n     *    <th>Identifier<\/th>\n     *    <th>Meaning<\/th>\n     *    <th>Default<\/th>\n     * <\/tr>\n     * <tr>\n     *    <td>{@code KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS}<\/td>\n     *    <td>Normal forward keyboard traversal<\/td>\n     *    <td>{@code TAB} on {@code KEY_PRESSED},\n     *        {@code CTRL-TAB} on {@code KEY_PRESSED}<\/td>\n     * <\/tr>\n     * <tr>\n     *    <td>{@code KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS}<\/td>\n     *    <td>Normal reverse keyboard traversal<\/td>\n     *    <td>{@code SHIFT-TAB} on {@code KEY_PRESSED},\n     *        {@code CTRL-SHIFT-TAB} on {@code KEY_PRESSED}<\/td>\n     * <\/tr>\n     * <tr>\n     *    <td>{@code KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS}<\/td>\n     *    <td>Go up one focus traversal cycle<\/td>\n     *    <td>none<\/td>\n     * <\/tr>\n     * <tr>\n     *    <td>{@code KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS}<\/td>\n     *    <td>Go down one focus traversal cycle<\/td>\n     *    <td>none<\/td>\n     * <\/tr>\n     * <\/table>\n     *\n     * To disable a traversal key, use an empty {@code Set};\n     * {@code Collections.EMPTY_SET} is recommended.\n     * <p>\n     * Using the {@code AWTKeyStroke} API, client code can\n     * specify on which of two\n     * specific {@code KeyEvent}s, {@code KEY_PRESSED} or\n     * {@code KEY_RELEASED}, the focus traversal operation will\n     * occur. Regardless of which {@code KeyEvent} is specified,\n     * however, all {@code KeyEvent}s related to the focus\n     * traversal key, including the associated {@code KEY_TYPED}\n     * event, will be consumed, and will not be dispatched\n     * to any {@code Component}. It is a runtime error to\n     * specify a {@code KEY_TYPED} event as\n     * mapping to a focus traversal operation, or to map the same event to\n     * multiple default focus traversal operations.\n     * <p>\n     * This method may throw a {@code ClassCastException} if any {@code Object}\n     * in {@code keystrokes} is not an {@code AWTKeyStroke}.\n     *\n     * @param id one of\n     *        {@code KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS},\n     *        {@code KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS},\n     *        {@code KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS}, or\n     *        {@code KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS}\n     * @param keystrokes the Set of {@code AWTKeyStroke}s for the\n     *        specified operation\n     * @see #getDefaultFocusTraversalKeys\n     * @see Component#setFocusTraversalKeys\n     * @see Component#getFocusTraversalKeys\n     * @throws IllegalArgumentException if id is not one of\n     *         {@code KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS},\n     *         {@code KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS},\n     *         {@code KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS}, or\n     *         {@code KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS},\n     *         or if keystrokes is {@code null},\n     *         or if keystrokes contains {@code null},\n     *         or if any keystroke\n     *         represents a {@code KEY_TYPED} event,\n     *         or if any keystroke already maps\n     *         to another default focus traversal operation\n     * @beaninfo\n     *       bound: true\n     */\n    public void\n        setDefaultFocusTraversalKeys(int id,\n                                     Set<? extends AWTKeyStroke> keystrokes)\n    {\n        if (id < 0 || id >= TRAVERSAL_KEY_LENGTH) {\n            throw new IllegalArgumentException(\"invalid focus traversal key identifier\");\n        }\n        if (keystrokes == null) {\n            throw new IllegalArgumentException(\"cannot set null Set of default focus traversal keys\");\n        }\n\n        Set<AWTKeyStroke> oldKeys;\n\n        synchronized (this) {\n            for (AWTKeyStroke keystroke : keystrokes) {\n\n                if (keystroke == null) {\n                    throw new IllegalArgumentException(\"cannot set null focus traversal key\");\n                }\n\n                if (keystroke.getKeyChar() != KeyEvent.CHAR_UNDEFINED) {\n                    throw new IllegalArgumentException(\"focus traversal keys cannot map to KEY_TYPED events\");\n                }\n\n                // Check to see if key already maps to another traversal\n                // operation\n                for (int i = 0; i < TRAVERSAL_KEY_LENGTH; i++) {\n                    if (i == id) {\n                        continue;\n                    }\n\n                    if (defaultFocusTraversalKeys[i].contains(keystroke)) {\n                        throw new IllegalArgumentException(\"focus traversal keys must be unique for a Component\");\n                    }\n                }\n            }\n\n            oldKeys = defaultFocusTraversalKeys[id];\n            defaultFocusTraversalKeys[id] =\n                Collections.unmodifiableSet(new HashSet<>(keystrokes));\n        }\n\n        firePropertyChange(defaultFocusTraversalKeyPropertyNames[id],\n                           oldKeys, keystrokes);\n    }"}
{"Number":"598","API Relative Path":"java.awt.LinearGradientPaint.java-LinearGradientPaint(Point2D-Point2D-float[]-Color[]-CycleMethod-ColorSpaceType-AffineTransform)","Corresponding Source":"/**\n     * Constructs a {@code LinearGradientPaint}.\n     *\n     * @param start the gradient axis start {@code Point2D} in user space\n     * @param end the gradient axis end {@code Point2D} in user space\n     * @param fractions numbers ranging from 0.0 to 1.0 specifying the\n     *                  distribution of colors along the gradient\n     * @param colors array of colors corresponding to each fractional value\n     * @param cycleMethod either {@code NO_CYCLE}, {@code REFLECT},\n     *                    or {@code REPEAT}\n     * @param colorSpace which color space to use for interpolation,\n     *                   either {@code SRGB} or {@code LINEAR_RGB}\n     * @param gradientTransform transform to apply to the gradient\n     *\n     * @throws NullPointerException\n     * if one of the points is null,\n     * or {@code fractions} array is null,\n     * or {@code colors} array is null,\n     * or {@code cycleMethod} is null,\n     * or {@code colorSpace} is null,\n     * or {@code gradientTransform} is null\n     * @throws IllegalArgumentException\n     * if start and end points are the same points,\n     * or {@code fractions.length != colors.length},\n     * or {@code colors} is less than 2 in size,\n     * or a {@code fractions} value is less than 0.0 or greater than 1.0,\n     * or the {@code fractions} are not provided in strictly increasing order\n     */\n    @ConstructorProperties({ \"startPoint\", \"endPoint\", \"fractions\", \"colors\", \"cycleMethod\", \"colorSpace\", \"transform\" })\n    public LinearGradientPaint(Point2D start, Point2D end,\n                               float[] fractions, Color[] colors,\n                               CycleMethod cycleMethod,\n                               ColorSpaceType colorSpace,\n                               AffineTransform gradientTransform)\n    {\n        super(fractions, colors, cycleMethod, colorSpace, gradientTransform);\n\n        // check input parameters\n        if (start == null || end == null) {\n            throw new NullPointerException(\"Start and end points must be\" +\n                                           \"non-null\");\n        }\n\n        if (start.equals(end)) {\n            throw new IllegalArgumentException(\"Start point cannot equal\" +\n                                               \"endpoint\");\n        }\n\n        // copy the points...\n        this.start = new Point2D.Double(start.getX(), start.getY());\n        this.end = new Point2D.Double(end.getX(), end.getY());\n    }"}
{"Number":"599","API Relative Path":"java.awt.List.java-addActionListener(ActionListener)","Corresponding Source":"/**\n     * Adds the specified action listener to receive action events from\n     * this list. Action events occur when a user double-clicks\n     * on a list item or types Enter when the list has the keyboard\n     * focus.\n     * <p>\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param         l the action listener\n     * @see           #removeActionListener\n     * @see           #getActionListeners\n     * @see           java.awt.event.ActionEvent\n     * @see           java.awt.event.ActionListener\n     * @since         JDK1.1\n     */\n    public synchronized void addActionListener(ActionListener l) {\n        if (l == null) {\n            return;\n        }\n        actionListener = AWTEventMulticaster.add(actionListener, l);\n        newEventsOnly = true;\n    }"}
{"Number":"600","API Relative Path":"java.awt.List.java-addItemListener(ItemListener)","Corresponding Source":"/**\n     * Adds the specified item listener to receive item events from\n     * this list.  Item events are sent in response to user input, but not\n     * in response to calls to <code>select<\/code> or <code>deselect<\/code>.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param         l the item listener\n     * @see           #removeItemListener\n     * @see           #getItemListeners\n     * @see           #select\n     * @see           #deselect\n     * @see           java.awt.event.ItemEvent\n     * @see           java.awt.event.ItemListener\n     * @since         JDK1.1\n     */\n    public synchronized void addItemListener(ItemListener l) {\n        if (l == null) {\n            return;\n        }\n        itemListener = AWTEventMulticaster.add(itemListener, l);\n        newEventsOnly = true;\n    }"}
{"Number":"601","API Relative Path":"java.awt.List.java-removeActionListener(ActionListener)","Corresponding Source":"/**\n     * Removes the specified action listener so that it no longer\n     * receives action events from this list. Action events\n     * occur when a user double-clicks on a list item.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param           l     the action listener\n     * @see             #addActionListener\n     * @see             #getActionListeners\n     * @see             java.awt.event.ActionEvent\n     * @see             java.awt.event.ActionListener\n     * @since           JDK1.1\n     */\n    public synchronized void removeActionListener(ActionListener l) {\n        if (l == null) {\n            return;\n        }\n        actionListener = AWTEventMulticaster.remove(actionListener, l);\n    }"}
{"Number":"602","API Relative Path":"java.awt.List.java-removeActionListener(ActionListener)","Corresponding Source":"/**\n     * Removes the specified action listener so that it no longer\n     * receives action events from this list. Action events\n     * occur when a user double-clicks on a list item.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param           l     the action listener\n     * @see             #addActionListener\n     * @see             #getActionListeners\n     * @see             java.awt.event.ActionEvent\n     * @see             java.awt.event.ActionListener\n     * @since           JDK1.1\n     */\n    public synchronized void removeActionListener(ActionListener l) {\n        if (l == null) {\n            return;\n        }\n        actionListener = AWTEventMulticaster.remove(actionListener, l);\n    }"}
{"Number":"603","API Relative Path":"java.awt.List.java-removeItemListener(ItemListener)","Corresponding Source":"/**\n     * Removes the specified item listener so that it no longer\n     * receives item events from this list.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param           l the item listener\n     * @see             #addItemListener\n     * @see             #getItemListeners\n     * @see             java.awt.event.ItemEvent\n     * @see             java.awt.event.ItemListener\n     * @since           JDK1.1\n     */\n    public synchronized void removeItemListener(ItemListener l) {\n        if (l == null) {\n            return;\n        }\n        itemListener = AWTEventMulticaster.remove(itemListener, l);\n    }"}
{"Number":"604","API Relative Path":"java.awt.List.java-removeItemListener(ItemListener)","Corresponding Source":"/**\n     * Removes the specified item listener so that it no longer\n     * receives item events from this list.\n     * If listener <code>l<\/code> is <code>null<\/code>,\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param           l the item listener\n     * @see             #addItemListener\n     * @see             #getItemListeners\n     * @see             java.awt.event.ItemEvent\n     * @see             java.awt.event.ItemListener\n     * @since           JDK1.1\n     */\n    public synchronized void removeItemListener(ItemListener l) {\n        if (l == null) {\n            return;\n        }\n        itemListener = AWTEventMulticaster.remove(itemListener, l);\n    }"}
{"Number":"605","API Relative Path":"java.awt.Menu.java-insert(MenuItem-int)","Corresponding Source":"/**\n     * Inserts a menu item into this menu\n     * at the specified position.\n     *\n     * @param         menuitem  the menu item to be inserted.\n     * @param         index     the position at which the menu\n     *                          item should be inserted.\n     * @see           java.awt.Menu#add(java.lang.String)\n     * @see           java.awt.Menu#add(java.awt.MenuItem)\n     * @exception     IllegalArgumentException if the value of\n     *                    <code>index<\/code> is less than zero\n     * @since         JDK1.1\n     */\n\n    public void insert(MenuItem menuitem, int index) {\n        synchronized (getTreeLock()) {\n            if (index < 0) {\n                throw new IllegalArgumentException(\"index less than zero.\");\n            }\n\n            int nitems = getItemCount();\n            Vector<MenuItem> tempItems = new Vector<>();\n\n            /* Remove the item at index, nitems-index times\n               storing them in a temporary vector in the\n               order they appear on the menu.\n            */\n            for (int i = index ; i < nitems; i++) {\n                tempItems.addElement(getItem(index));\n                remove(index);\n            }\n\n            add(menuitem);\n\n            /* Add the removed items back to the menu, they are\n               already in the correct order in the temp vector.\n            */\n            for (int i = 0; i < tempItems.size()  ; i++) {\n                add(tempItems.elementAt(i));\n            }\n        }\n    }"}
{"Number":"606","API Relative Path":"java.awt.Menu.java-insertSeparator(int)","Corresponding Source":"/**\n     * Inserts a separator at the specified position.\n     * @param       index the position at which the\n     *                       menu separator should be inserted.\n     * @exception   IllegalArgumentException if the value of\n     *                       <code>index<\/code> is less than 0.\n     * @see         java.awt.Menu#addSeparator\n     * @since       JDK1.1\n     */\n\n    public void insertSeparator(int index) {\n        synchronized (getTreeLock()) {\n            if (index < 0) {\n                throw new IllegalArgumentException(\"index less than zero.\");\n            }\n\n            int nitems = getItemCount();\n            Vector<MenuItem> tempItems = new Vector<>();\n\n            /* Remove the item at index, nitems-index times\n               storing them in a temporary vector in the\n               order they appear on the menu.\n            */\n            for (int i = index ; i < nitems; i++) {\n                tempItems.addElement(getItem(index));\n                remove(index);\n            }\n\n            addSeparator();\n\n            /* Add the removed items back to the menu, they are\n               already in the correct order in the temp vector.\n            */\n            for (int i = 0; i < tempItems.size()  ; i++) {\n                add(tempItems.elementAt(i));\n            }\n        }\n    }"}
{"Number":"607","API Relative Path":"java.awt.MenuItem.java-addActionListener(ActionListener)","Corresponding Source":"/**\n     * Adds the specified action listener to receive action events\n     * from this menu item.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param      l the action listener.\n     * @see        #removeActionListener\n     * @see        #getActionListeners\n     * @see        java.awt.event.ActionEvent\n     * @see        java.awt.event.ActionListener\n     * @since      JDK1.1\n     */\n    public synchronized void addActionListener(ActionListener l) {\n        if (l == null) {\n            return;\n        }\n        actionListener = AWTEventMulticaster.add(actionListener, l);\n        newEventsOnly = true;\n    }"}
{"Number":"608","API Relative Path":"java.awt.MenuItem.java-removeActionListener(ActionListener)","Corresponding Source":"/**\n     * Removes the specified action listener so it no longer receives\n     * action events from this menu item.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param      l the action listener.\n     * @see        #addActionListener\n     * @see        #getActionListeners\n     * @see        java.awt.event.ActionEvent\n     * @see        java.awt.event.ActionListener\n     * @since      JDK1.1\n     */\n    public synchronized void removeActionListener(ActionListener l) {\n        if (l == null) {\n            return;\n        }\n        actionListener = AWTEventMulticaster.remove(actionListener, l);\n    }"}
{"Number":"609","API Relative Path":"java.awt.MenuItem.java-removeActionListener(ActionListener)","Corresponding Source":"/**\n     * Removes the specified action listener so it no longer receives\n     * action events from this menu item.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param      l the action listener.\n     * @see        #addActionListener\n     * @see        #getActionListeners\n     * @see        java.awt.event.ActionEvent\n     * @see        java.awt.event.ActionListener\n     * @since      JDK1.1\n     */\n    public synchronized void removeActionListener(ActionListener l) {\n        if (l == null) {\n            return;\n        }\n        actionListener = AWTEventMulticaster.remove(actionListener, l);\n    }"}
{"Number":"610","API Relative Path":"java.awt.MultipleGradientPaint.java-MultipleGradientPaint(float[]-Color[]-CycleMethod-ColorSpaceType-AffineTransform)","Corresponding Source":"/**\n     * Package-private constructor.\n     *\n     * @param fractions numbers ranging from 0.0 to 1.0 specifying the\n     *                  distribution of colors along the gradient\n     * @param colors array of colors corresponding to each fractional value\n     * @param cycleMethod either {@code NO_CYCLE}, {@code REFLECT},\n     *                    or {@code REPEAT}\n     * @param colorSpace which color space to use for interpolation,\n     *                   either {@code SRGB} or {@code LINEAR_RGB}\n     * @param gradientTransform transform to apply to the gradient\n     *\n     * @throws NullPointerException\n     * if {@code fractions} array is null,\n     * or {@code colors} array is null,\n     * or {@code gradientTransform} is null,\n     * or {@code cycleMethod} is null,\n     * or {@code colorSpace} is null\n     * @throws IllegalArgumentException\n     * if {@code fractions.length != colors.length},\n     * or {@code colors} is less than 2 in size,\n     * or a {@code fractions} value is less than 0.0 or greater than 1.0,\n     * or the {@code fractions} are not provided in strictly increasing order\n     */\n    MultipleGradientPaint(float[] fractions,\n                          Color[] colors,\n                          CycleMethod cycleMethod,\n                          ColorSpaceType colorSpace,\n                          AffineTransform gradientTransform)\n    {\n        if (fractions == null) {\n            throw new NullPointerException(\"Fractions array cannot be null\");\n        }\n\n        if (colors == null) {\n            throw new NullPointerException(\"Colors array cannot be null\");\n        }\n\n        if (cycleMethod == null) {\n            throw new NullPointerException(\"Cycle method cannot be null\");\n        }\n\n        if (colorSpace == null) {\n            throw new NullPointerException(\"Color space cannot be null\");\n        }\n\n        if (gradientTransform == null) {\n            throw new NullPointerException(\"Gradient transform cannot be \"+\n                                           \"null\");\n        }\n\n        if (fractions.length != colors.length) {\n            throw new IllegalArgumentException(\"Colors and fractions must \" +\n                                               \"have equal size\");\n        }\n\n        if (colors.length < 2) {\n            throw new IllegalArgumentException(\"User must specify at least \" +\n                                               \"2 colors\");\n        }\n\n        // check that values are in the proper range and progress\n        // in increasing order from 0 to 1\n        float previousFraction = -1.0f;\n        for (float currentFraction : fractions) {\n            if (currentFraction < 0f || currentFraction > 1f) {\n                throw new IllegalArgumentException(\"Fraction values must \" +\n                                                   \"be in the range 0 to 1: \" +\n                                                   currentFraction);\n            }\n\n            if (currentFraction <= previousFraction) {\n                throw new IllegalArgumentException(\"Keyframe fractions \" +\n                                                   \"must be increasing: \" +\n                                                   currentFraction);\n            }\n\n            previousFraction = currentFraction;\n        }\n\n        // We have to deal with the cases where the first gradient stop is not\n        // equal to 0 and/or the last gradient stop is not equal to 1.\n        // In both cases, create a new point and replicate the previous\n        // extreme point's color.\n        boolean fixFirst = false;\n        boolean fixLast = false;\n        int len = fractions.length;\n        int off = 0;\n\n        if (fractions[0] != 0f) {\n            // first stop is not equal to zero, fix this condition\n            fixFirst = true;\n            len++;\n            off++;\n        }\n        if (fractions[fractions.length-1] != 1f) {\n            // last stop is not equal to one, fix this condition\n            fixLast = true;\n            len++;\n        }\n\n        this.fractions = new float[len];\n        System.arraycopy(fractions, 0, this.fractions, off, fractions.length);\n        this.colors = new Color[len];\n        System.arraycopy(colors, 0, this.colors, off, colors.length);\n\n        if (fixFirst) {\n            this.fractions[0] = 0f;\n            this.colors[0] = colors[0];\n        }\n        if (fixLast) {\n            this.fractions[len-1] = 1f;\n            this.colors[len-1] = colors[colors.length - 1];\n        }\n\n        // copy some flags\n        this.colorSpace = colorSpace;\n        this.cycleMethod = cycleMethod;\n\n        // copy the gradient transform\n        this.gradientTransform = new AffineTransform(gradientTransform);\n\n        // determine transparency\n        boolean opaque = true;\n        for (int i = 0; i < colors.length; i++){\n            opaque = opaque && (colors[i].getAlpha() == 0xff);\n        }\n        this.transparency = opaque ? OPAQUE : TRANSLUCENT;\n    }"}
{"Number":"611","API Relative Path":"java.awt.MultipleGradientPaint.java-MultipleGradientPaint(float[]-Color[]-CycleMethod-ColorSpaceType-AffineTransform)","Corresponding Source":"/**\n     * Package-private constructor.\n     *\n     * @param fractions numbers ranging from 0.0 to 1.0 specifying the\n     *                  distribution of colors along the gradient\n     * @param colors array of colors corresponding to each fractional value\n     * @param cycleMethod either {@code NO_CYCLE}, {@code REFLECT},\n     *                    or {@code REPEAT}\n     * @param colorSpace which color space to use for interpolation,\n     *                   either {@code SRGB} or {@code LINEAR_RGB}\n     * @param gradientTransform transform to apply to the gradient\n     *\n     * @throws NullPointerException\n     * if {@code fractions} array is null,\n     * or {@code colors} array is null,\n     * or {@code gradientTransform} is null,\n     * or {@code cycleMethod} is null,\n     * or {@code colorSpace} is null\n     * @throws IllegalArgumentException\n     * if {@code fractions.length != colors.length},\n     * or {@code colors} is less than 2 in size,\n     * or a {@code fractions} value is less than 0.0 or greater than 1.0,\n     * or the {@code fractions} are not provided in strictly increasing order\n     */\n    MultipleGradientPaint(float[] fractions,\n                          Color[] colors,\n                          CycleMethod cycleMethod,\n                          ColorSpaceType colorSpace,\n                          AffineTransform gradientTransform)\n    {\n        if (fractions == null) {\n            throw new NullPointerException(\"Fractions array cannot be null\");\n        }\n\n        if (colors == null) {\n            throw new NullPointerException(\"Colors array cannot be null\");\n        }\n\n        if (cycleMethod == null) {\n            throw new NullPointerException(\"Cycle method cannot be null\");\n        }\n\n        if (colorSpace == null) {\n            throw new NullPointerException(\"Color space cannot be null\");\n        }\n\n        if (gradientTransform == null) {\n            throw new NullPointerException(\"Gradient transform cannot be \"+\n                                           \"null\");\n        }\n\n        if (fractions.length != colors.length) {\n            throw new IllegalArgumentException(\"Colors and fractions must \" +\n                                               \"have equal size\");\n        }\n\n        if (colors.length < 2) {\n            throw new IllegalArgumentException(\"User must specify at least \" +\n                                               \"2 colors\");\n        }\n\n        // check that values are in the proper range and progress\n        // in increasing order from 0 to 1\n        float previousFraction = -1.0f;\n        for (float currentFraction : fractions) {\n            if (currentFraction < 0f || currentFraction > 1f) {\n                throw new IllegalArgumentException(\"Fraction values must \" +\n                                                   \"be in the range 0 to 1: \" +\n                                                   currentFraction);\n            }\n\n            if (currentFraction <= previousFraction) {\n                throw new IllegalArgumentException(\"Keyframe fractions \" +\n                                                   \"must be increasing: \" +\n                                                   currentFraction);\n            }\n\n            previousFraction = currentFraction;\n        }\n\n        // We have to deal with the cases where the first gradient stop is not\n        // equal to 0 and/or the last gradient stop is not equal to 1.\n        // In both cases, create a new point and replicate the previous\n        // extreme point's color.\n        boolean fixFirst = false;\n        boolean fixLast = false;\n        int len = fractions.length;\n        int off = 0;\n\n        if (fractions[0] != 0f) {\n            // first stop is not equal to zero, fix this condition\n            fixFirst = true;\n            len++;\n            off++;\n        }\n        if (fractions[fractions.length-1] != 1f) {\n            // last stop is not equal to one, fix this condition\n            fixLast = true;\n            len++;\n        }\n\n        this.fractions = new float[len];\n        System.arraycopy(fractions, 0, this.fractions, off, fractions.length);\n        this.colors = new Color[len];\n        System.arraycopy(colors, 0, this.colors, off, colors.length);\n\n        if (fixFirst) {\n            this.fractions[0] = 0f;\n            this.colors[0] = colors[0];\n        }\n        if (fixLast) {\n            this.fractions[len-1] = 1f;\n            this.colors[len-1] = colors[colors.length - 1];\n        }\n\n        // copy some flags\n        this.colorSpace = colorSpace;\n        this.cycleMethod = cycleMethod;\n\n        // copy the gradient transform\n        this.gradientTransform = new AffineTransform(gradientTransform);\n\n        // determine transparency\n        boolean opaque = true;\n        for (int i = 0; i < colors.length; i++){\n            opaque = opaque && (colors[i].getAlpha() == 0xff);\n        }\n        this.transparency = opaque ? OPAQUE : TRANSLUCENT;\n    }"}
{"Number":"612","API Relative Path":"java.awt.MultipleGradientPaintContext.java-MultipleGradientPaintContext(MultipleGradientPaint-ColorModel-Rectangle-Rectangle2D-AffineTransform-RenderingHints-float[]-Color[]-CycleMethod-ColorSpaceType)","Corresponding Source":"/**\n     * Constructor for MultipleGradientPaintContext superclass.\n     */\n    protected MultipleGradientPaintContext(MultipleGradientPaint mgp,\n                                           ColorModel cm,\n                                           Rectangle deviceBounds,\n                                           Rectangle2D userBounds,\n                                           AffineTransform t,\n                                           RenderingHints hints,\n                                           float[] fractions,\n                                           Color[] colors,\n                                           CycleMethod cycleMethod,\n                                           ColorSpaceType colorSpace)\n    {\n        if (deviceBounds == null) {\n            throw new NullPointerException(\"Device bounds cannot be null\");\n        }\n\n        if (userBounds == null) {\n            throw new NullPointerException(\"User bounds cannot be null\");\n        }\n\n        if (t == null) {\n            throw new NullPointerException(\"Transform cannot be null\");\n        }\n\n        if (hints == null) {\n            throw new NullPointerException(\"RenderingHints cannot be null\");\n        }\n\n        // The inverse transform is needed to go from device to user space.\n        // Get all the components of the inverse transform matrix.\n        AffineTransform tInv;\n        try {\n            // the following assumes that the caller has copied the incoming\n            // transform and is not concerned about it being modified\n            t.invert();\n            tInv = t;\n        } catch (NoninvertibleTransformException e) {\n            // just use identity transform in this case; better to show\n            // (incorrect) results than to throw an exception and/or no-op\n            tInv = new AffineTransform();\n        }\n        double m[] = new double[6];\n        tInv.getMatrix(m);\n        a00 = (float)m[0];\n        a10 = (float)m[1];\n        a01 = (float)m[2];\n        a11 = (float)m[3];\n        a02 = (float)m[4];\n        a12 = (float)m[5];\n\n        // copy some flags\n        this.cycleMethod = cycleMethod;\n        this.colorSpace = colorSpace;\n\n        // we can avoid copying this array since we do not modify its values\n        this.fractions = fractions;\n\n        // note that only one of these values can ever be non-null (we either\n        // store the fast gradient array or the slow one, but never both\n        // at the same time)\n        int[] gradient =\n            (mgp.gradient != null) ? mgp.gradient.get() : null;\n        int[][] gradients =\n            (mgp.gradients != null) ? mgp.gradients.get() : null;\n\n        if (gradient == null && gradients == null) {\n            // we need to (re)create the appropriate values\n            calculateLookupData(colors);\n\n            // now cache the calculated values in the\n            // MultipleGradientPaint instance for future use\n            mgp.model               = this.model;\n            mgp.normalizedIntervals = this.normalizedIntervals;\n            mgp.isSimpleLookup      = this.isSimpleLookup;\n            if (isSimpleLookup) {\n                // only cache the fast array\n                mgp.fastGradientArraySize = this.fastGradientArraySize;\n                mgp.gradient = new SoftReference<int[]>(this.gradient);\n            } else {\n                // only cache the slow array\n                mgp.gradients = new SoftReference<int[][]>(this.gradients);\n            }\n        } else {\n            // use the values cached in the MultipleGradientPaint instance\n            this.model                 = mgp.model;\n            this.normalizedIntervals   = mgp.normalizedIntervals;\n            this.isSimpleLookup        = mgp.isSimpleLookup;\n            this.gradient              = gradient;\n            this.fastGradientArraySize = mgp.fastGradientArraySize;\n            this.gradients             = gradients;\n        }\n    }"}
{"Number":"613","API Relative Path":"java.awt.MultipleGradientPaintContext.java-MultipleGradientPaintContext(MultipleGradientPaint-ColorModel-Rectangle-Rectangle2D-AffineTransform-RenderingHints-float[]-Color[]-CycleMethod-ColorSpaceType)","Corresponding Source":"/**\n     * Constructor for MultipleGradientPaintContext superclass.\n     */\n    protected MultipleGradientPaintContext(MultipleGradientPaint mgp,\n                                           ColorModel cm,\n                                           Rectangle deviceBounds,\n                                           Rectangle2D userBounds,\n                                           AffineTransform t,\n                                           RenderingHints hints,\n                                           float[] fractions,\n                                           Color[] colors,\n                                           CycleMethod cycleMethod,\n                                           ColorSpaceType colorSpace)\n    {\n        if (deviceBounds == null) {\n            throw new NullPointerException(\"Device bounds cannot be null\");\n        }\n\n        if (userBounds == null) {\n            throw new NullPointerException(\"User bounds cannot be null\");\n        }\n\n        if (t == null) {\n            throw new NullPointerException(\"Transform cannot be null\");\n        }\n\n        if (hints == null) {\n            throw new NullPointerException(\"RenderingHints cannot be null\");\n        }\n\n        // The inverse transform is needed to go from device to user space.\n        // Get all the components of the inverse transform matrix.\n        AffineTransform tInv;\n        try {\n            // the following assumes that the caller has copied the incoming\n            // transform and is not concerned about it being modified\n            t.invert();\n            tInv = t;\n        } catch (NoninvertibleTransformException e) {\n            // just use identity transform in this case; better to show\n            // (incorrect) results than to throw an exception and/or no-op\n            tInv = new AffineTransform();\n        }\n        double m[] = new double[6];\n        tInv.getMatrix(m);\n        a00 = (float)m[0];\n        a10 = (float)m[1];\n        a01 = (float)m[2];\n        a11 = (float)m[3];\n        a02 = (float)m[4];\n        a12 = (float)m[5];\n\n        // copy some flags\n        this.cycleMethod = cycleMethod;\n        this.colorSpace = colorSpace;\n\n        // we can avoid copying this array since we do not modify its values\n        this.fractions = fractions;\n\n        // note that only one of these values can ever be non-null (we either\n        // store the fast gradient array or the slow one, but never both\n        // at the same time)\n        int[] gradient =\n            (mgp.gradient != null) ? mgp.gradient.get() : null;\n        int[][] gradients =\n            (mgp.gradients != null) ? mgp.gradients.get() : null;\n\n        if (gradient == null && gradients == null) {\n            // we need to (re)create the appropriate values\n            calculateLookupData(colors);\n\n            // now cache the calculated values in the\n            // MultipleGradientPaint instance for future use\n            mgp.model               = this.model;\n            mgp.normalizedIntervals = this.normalizedIntervals;\n            mgp.isSimpleLookup      = this.isSimpleLookup;\n            if (isSimpleLookup) {\n                // only cache the fast array\n                mgp.fastGradientArraySize = this.fastGradientArraySize;\n                mgp.gradient = new SoftReference<int[]>(this.gradient);\n            } else {\n                // only cache the slow array\n                mgp.gradients = new SoftReference<int[][]>(this.gradients);\n            }\n        } else {\n            // use the values cached in the MultipleGradientPaint instance\n            this.model                 = mgp.model;\n            this.normalizedIntervals   = mgp.normalizedIntervals;\n            this.isSimpleLookup        = mgp.isSimpleLookup;\n            this.gradient              = gradient;\n            this.fastGradientArraySize = mgp.fastGradientArraySize;\n            this.gradients             = gradients;\n        }\n    }"}
{"Number":"614","API Relative Path":"java.awt.MultipleGradientPaintContext.java-MultipleGradientPaintContext(MultipleGradientPaint-ColorModel-Rectangle-Rectangle2D-AffineTransform-RenderingHints-float[]-Color[]-CycleMethod-ColorSpaceType)","Corresponding Source":"/**\n     * Constructor for MultipleGradientPaintContext superclass.\n     */\n    protected MultipleGradientPaintContext(MultipleGradientPaint mgp,\n                                           ColorModel cm,\n                                           Rectangle deviceBounds,\n                                           Rectangle2D userBounds,\n                                           AffineTransform t,\n                                           RenderingHints hints,\n                                           float[] fractions,\n                                           Color[] colors,\n                                           CycleMethod cycleMethod,\n                                           ColorSpaceType colorSpace)\n    {\n        if (deviceBounds == null) {\n            throw new NullPointerException(\"Device bounds cannot be null\");\n        }\n\n        if (userBounds == null) {\n            throw new NullPointerException(\"User bounds cannot be null\");\n        }\n\n        if (t == null) {\n            throw new NullPointerException(\"Transform cannot be null\");\n        }\n\n        if (hints == null) {\n            throw new NullPointerException(\"RenderingHints cannot be null\");\n        }\n\n        // The inverse transform is needed to go from device to user space.\n        // Get all the components of the inverse transform matrix.\n        AffineTransform tInv;\n        try {\n            // the following assumes that the caller has copied the incoming\n            // transform and is not concerned about it being modified\n            t.invert();\n            tInv = t;\n        } catch (NoninvertibleTransformException e) {\n            // just use identity transform in this case; better to show\n            // (incorrect) results than to throw an exception and/or no-op\n            tInv = new AffineTransform();\n        }\n        double m[] = new double[6];\n        tInv.getMatrix(m);\n        a00 = (float)m[0];\n        a10 = (float)m[1];\n        a01 = (float)m[2];\n        a11 = (float)m[3];\n        a02 = (float)m[4];\n        a12 = (float)m[5];\n\n        // copy some flags\n        this.cycleMethod = cycleMethod;\n        this.colorSpace = colorSpace;\n\n        // we can avoid copying this array since we do not modify its values\n        this.fractions = fractions;\n\n        // note that only one of these values can ever be non-null (we either\n        // store the fast gradient array or the slow one, but never both\n        // at the same time)\n        int[] gradient =\n            (mgp.gradient != null) ? mgp.gradient.get() : null;\n        int[][] gradients =\n            (mgp.gradients != null) ? mgp.gradients.get() : null;\n\n        if (gradient == null && gradients == null) {\n            // we need to (re)create the appropriate values\n            calculateLookupData(colors);\n\n            // now cache the calculated values in the\n            // MultipleGradientPaint instance for future use\n            mgp.model               = this.model;\n            mgp.normalizedIntervals = this.normalizedIntervals;\n            mgp.isSimpleLookup      = this.isSimpleLookup;\n            if (isSimpleLookup) {\n                // only cache the fast array\n                mgp.fastGradientArraySize = this.fastGradientArraySize;\n                mgp.gradient = new SoftReference<int[]>(this.gradient);\n            } else {\n                // only cache the slow array\n                mgp.gradients = new SoftReference<int[][]>(this.gradients);\n            }\n        } else {\n            // use the values cached in the MultipleGradientPaint instance\n            this.model                 = mgp.model;\n            this.normalizedIntervals   = mgp.normalizedIntervals;\n            this.isSimpleLookup        = mgp.isSimpleLookup;\n            this.gradient              = gradient;\n            this.fastGradientArraySize = mgp.fastGradientArraySize;\n            this.gradients             = gradients;\n        }\n    }"}
{"Number":"615","API Relative Path":"java.awt.MultipleGradientPaintContext.java-MultipleGradientPaintContext(MultipleGradientPaint-ColorModel-Rectangle-Rectangle2D-AffineTransform-RenderingHints-float[]-Color[]-CycleMethod-ColorSpaceType)","Corresponding Source":"/**\n     * Constructor for MultipleGradientPaintContext superclass.\n     */\n    protected MultipleGradientPaintContext(MultipleGradientPaint mgp,\n                                           ColorModel cm,\n                                           Rectangle deviceBounds,\n                                           Rectangle2D userBounds,\n                                           AffineTransform t,\n                                           RenderingHints hints,\n                                           float[] fractions,\n                                           Color[] colors,\n                                           CycleMethod cycleMethod,\n                                           ColorSpaceType colorSpace)\n    {\n        if (deviceBounds == null) {\n            throw new NullPointerException(\"Device bounds cannot be null\");\n        }\n\n        if (userBounds == null) {\n            throw new NullPointerException(\"User bounds cannot be null\");\n        }\n\n        if (t == null) {\n            throw new NullPointerException(\"Transform cannot be null\");\n        }\n\n        if (hints == null) {\n            throw new NullPointerException(\"RenderingHints cannot be null\");\n        }\n\n        // The inverse transform is needed to go from device to user space.\n        // Get all the components of the inverse transform matrix.\n        AffineTransform tInv;\n        try {\n            // the following assumes that the caller has copied the incoming\n            // transform and is not concerned about it being modified\n            t.invert();\n            tInv = t;\n        } catch (NoninvertibleTransformException e) {\n            // just use identity transform in this case; better to show\n            // (incorrect) results than to throw an exception and/or no-op\n            tInv = new AffineTransform();\n        }\n        double m[] = new double[6];\n        tInv.getMatrix(m);\n        a00 = (float)m[0];\n        a10 = (float)m[1];\n        a01 = (float)m[2];\n        a11 = (float)m[3];\n        a02 = (float)m[4];\n        a12 = (float)m[5];\n\n        // copy some flags\n        this.cycleMethod = cycleMethod;\n        this.colorSpace = colorSpace;\n\n        // we can avoid copying this array since we do not modify its values\n        this.fractions = fractions;\n\n        // note that only one of these values can ever be non-null (we either\n        // store the fast gradient array or the slow one, but never both\n        // at the same time)\n        int[] gradient =\n            (mgp.gradient != null) ? mgp.gradient.get() : null;\n        int[][] gradients =\n            (mgp.gradients != null) ? mgp.gradients.get() : null;\n\n        if (gradient == null && gradients == null) {\n            // we need to (re)create the appropriate values\n            calculateLookupData(colors);\n\n            // now cache the calculated values in the\n            // MultipleGradientPaint instance for future use\n            mgp.model               = this.model;\n            mgp.normalizedIntervals = this.normalizedIntervals;\n            mgp.isSimpleLookup      = this.isSimpleLookup;\n            if (isSimpleLookup) {\n                // only cache the fast array\n                mgp.fastGradientArraySize = this.fastGradientArraySize;\n                mgp.gradient = new SoftReference<int[]>(this.gradient);\n            } else {\n                // only cache the slow array\n                mgp.gradients = new SoftReference<int[][]>(this.gradients);\n            }\n        } else {\n            // use the values cached in the MultipleGradientPaint instance\n            this.model                 = mgp.model;\n            this.normalizedIntervals   = mgp.normalizedIntervals;\n            this.isSimpleLookup        = mgp.isSimpleLookup;\n            this.gradient              = gradient;\n            this.fastGradientArraySize = mgp.fastGradientArraySize;\n            this.gradients             = gradients;\n        }\n    }"}
{"Number":"616","API Relative Path":"java.awt.PageAttributes.java-PageAttributes(ColorType-MediaType-OrientationRequestedType-OriginType-PrintQualityType-int[])","Corresponding Source":"/**\n     * Constructs a PageAttributes instance with the specified values for\n     * every attribute.\n     *\n     * @param   color ColorType.COLOR or ColorType.MONOCHROME.\n     * @param   media one of the constant fields of the MediaType class.\n     * @param   orientationRequested OrientationRequestedType.PORTRAIT or\n     *          OrientationRequestedType.LANDSCAPE.\n     * @param   origin OriginType.PHYSICAL or OriginType.PRINTABLE\n     * @param   printQuality PrintQualityType.DRAFT, PrintQualityType.NORMAL,\n     *          or PrintQualityType.HIGH\n     * @param   printerResolution an integer array of 3 elements. The first\n     *          element must be greater than 0. The second element must be\n     *          must be greater than 0. The third element must be either\n     *          <code>3<\/code> or <code>4<\/code>.\n     * @throws  IllegalArgumentException if one or more of the above\n     *          conditions is violated.\n     */\n    public PageAttributes(ColorType color, MediaType media,\n                          OrientationRequestedType orientationRequested,\n                          OriginType origin, PrintQualityType printQuality,\n                          int[] printerResolution) {\n        setColor(color);\n        setMedia(media);\n        setOrientationRequested(orientationRequested);\n        setOrigin(origin);\n        setPrintQuality(printQuality);\n        setPrinterResolution(printerResolution);\n    }"}
{"Number":"617","API Relative Path":"java.awt.PageAttributes.java-PageAttributes(ColorType-MediaType-OrientationRequestedType-OriginType-PrintQualityType-int[])","Corresponding Source":"/**\n     * Constructs a PageAttributes instance with the specified values for\n     * every attribute.\n     *\n     * @param   color ColorType.COLOR or ColorType.MONOCHROME.\n     * @param   media one of the constant fields of the MediaType class.\n     * @param   orientationRequested OrientationRequestedType.PORTRAIT or\n     *          OrientationRequestedType.LANDSCAPE.\n     * @param   origin OriginType.PHYSICAL or OriginType.PRINTABLE\n     * @param   printQuality PrintQualityType.DRAFT, PrintQualityType.NORMAL,\n     *          or PrintQualityType.HIGH\n     * @param   printerResolution an integer array of 3 elements. The first\n     *          element must be greater than 0. The second element must be\n     *          must be greater than 0. The third element must be either\n     *          <code>3<\/code> or <code>4<\/code>.\n     * @throws  IllegalArgumentException if one or more of the above\n     *          conditions is violated.\n     */\n    public PageAttributes(ColorType color, MediaType media,\n                          OrientationRequestedType orientationRequested,\n                          OriginType origin, PrintQualityType printQuality,\n                          int[] printerResolution) {\n        setColor(color);\n        setMedia(media);\n        setOrientationRequested(orientationRequested);\n        setOrigin(origin);\n        setPrintQuality(printQuality);\n        setPrinterResolution(printerResolution);\n    }"}
{"Number":"618","API Relative Path":"java.awt.PageAttributes.java-PageAttributes(ColorType-MediaType-OrientationRequestedType-OriginType-PrintQualityType-int[])","Corresponding Source":"/**\n     * Constructs a PageAttributes instance with the specified values for\n     * every attribute.\n     *\n     * @param   color ColorType.COLOR or ColorType.MONOCHROME.\n     * @param   media one of the constant fields of the MediaType class.\n     * @param   orientationRequested OrientationRequestedType.PORTRAIT or\n     *          OrientationRequestedType.LANDSCAPE.\n     * @param   origin OriginType.PHYSICAL or OriginType.PRINTABLE\n     * @param   printQuality PrintQualityType.DRAFT, PrintQualityType.NORMAL,\n     *          or PrintQualityType.HIGH\n     * @param   printerResolution an integer array of 3 elements. The first\n     *          element must be greater than 0. The second element must be\n     *          must be greater than 0. The third element must be either\n     *          <code>3<\/code> or <code>4<\/code>.\n     * @throws  IllegalArgumentException if one or more of the above\n     *          conditions is violated.\n     */\n    public PageAttributes(ColorType color, MediaType media,\n                          OrientationRequestedType orientationRequested,\n                          OriginType origin, PrintQualityType printQuality,\n                          int[] printerResolution) {\n        setColor(color);\n        setMedia(media);\n        setOrientationRequested(orientationRequested);\n        setOrigin(origin);\n        setPrintQuality(printQuality);\n        setPrinterResolution(printerResolution);\n    }"}
{"Number":"619","API Relative Path":"java.awt.PageAttributes.java-PageAttributes(ColorType-MediaType-OrientationRequestedType-OriginType-PrintQualityType-int[])","Corresponding Source":"/**\n     * Constructs a PageAttributes instance with the specified values for\n     * every attribute.\n     *\n     * @param   color ColorType.COLOR or ColorType.MONOCHROME.\n     * @param   media one of the constant fields of the MediaType class.\n     * @param   orientationRequested OrientationRequestedType.PORTRAIT or\n     *          OrientationRequestedType.LANDSCAPE.\n     * @param   origin OriginType.PHYSICAL or OriginType.PRINTABLE\n     * @param   printQuality PrintQualityType.DRAFT, PrintQualityType.NORMAL,\n     *          or PrintQualityType.HIGH\n     * @param   printerResolution an integer array of 3 elements. The first\n     *          element must be greater than 0. The second element must be\n     *          must be greater than 0. The third element must be either\n     *          <code>3<\/code> or <code>4<\/code>.\n     * @throws  IllegalArgumentException if one or more of the above\n     *          conditions is violated.\n     */\n    public PageAttributes(ColorType color, MediaType media,\n                          OrientationRequestedType orientationRequested,\n                          OriginType origin, PrintQualityType printQuality,\n                          int[] printerResolution) {\n        setColor(color);\n        setMedia(media);\n        setOrientationRequested(orientationRequested);\n        setOrigin(origin);\n        setPrintQuality(printQuality);\n        setPrinterResolution(printerResolution);\n    }"}
{"Number":"620","API Relative Path":"java.awt.PageAttributes.java-PageAttributes(ColorType-MediaType-OrientationRequestedType-OriginType-PrintQualityType-int[])","Corresponding Source":"/**\n     * Constructs a PageAttributes instance with the specified values for\n     * every attribute.\n     *\n     * @param   color ColorType.COLOR or ColorType.MONOCHROME.\n     * @param   media one of the constant fields of the MediaType class.\n     * @param   orientationRequested OrientationRequestedType.PORTRAIT or\n     *          OrientationRequestedType.LANDSCAPE.\n     * @param   origin OriginType.PHYSICAL or OriginType.PRINTABLE\n     * @param   printQuality PrintQualityType.DRAFT, PrintQualityType.NORMAL,\n     *          or PrintQualityType.HIGH\n     * @param   printerResolution an integer array of 3 elements. The first\n     *          element must be greater than 0. The second element must be\n     *          must be greater than 0. The third element must be either\n     *          <code>3<\/code> or <code>4<\/code>.\n     * @throws  IllegalArgumentException if one or more of the above\n     *          conditions is violated.\n     */\n    public PageAttributes(ColorType color, MediaType media,\n                          OrientationRequestedType orientationRequested,\n                          OriginType origin, PrintQualityType printQuality,\n                          int[] printerResolution) {\n        setColor(color);\n        setMedia(media);\n        setOrientationRequested(orientationRequested);\n        setOrigin(origin);\n        setPrintQuality(printQuality);\n        setPrinterResolution(printerResolution);\n    }"}
{"Number":"621","API Relative Path":"java.awt.PageAttributes.java-PageAttributes(ColorType-MediaType-OrientationRequestedType-OriginType-PrintQualityType-int[])","Corresponding Source":"/**\n     * Constructs a PageAttributes instance with the specified values for\n     * every attribute.\n     *\n     * @param   color ColorType.COLOR or ColorType.MONOCHROME.\n     * @param   media one of the constant fields of the MediaType class.\n     * @param   orientationRequested OrientationRequestedType.PORTRAIT or\n     *          OrientationRequestedType.LANDSCAPE.\n     * @param   origin OriginType.PHYSICAL or OriginType.PRINTABLE\n     * @param   printQuality PrintQualityType.DRAFT, PrintQualityType.NORMAL,\n     *          or PrintQualityType.HIGH\n     * @param   printerResolution an integer array of 3 elements. The first\n     *          element must be greater than 0. The second element must be\n     *          must be greater than 0. The third element must be either\n     *          <code>3<\/code> or <code>4<\/code>.\n     * @throws  IllegalArgumentException if one or more of the above\n     *          conditions is violated.\n     */\n    public PageAttributes(ColorType color, MediaType media,\n                          OrientationRequestedType orientationRequested,\n                          OriginType origin, PrintQualityType printQuality,\n                          int[] printerResolution) {\n        setColor(color);\n        setMedia(media);\n        setOrientationRequested(orientationRequested);\n        setOrigin(origin);\n        setPrintQuality(printQuality);\n        setPrinterResolution(printerResolution);\n    }"}
{"Number":"622","API Relative Path":"java.awt.PageAttributes.java-setPrinterResolution(int[])","Corresponding Source":"/**\n     * Specifies the desired cross feed and feed print resolutions in dots per\n     * inch for pages using these attributes. The same value is used for both\n     * resolutions. The actual resolutions will be determined by the\n     * limitations of the implementation and the target printer. Not\n     * specifying the property is equivalent to specifying <code>72<\/code>.\n     *\n     * @param   printerResolution an integer greater than 0.\n     * @throws  IllegalArgumentException if printerResolution is less than or\n     *          equal to 0.\n     */\n    public void setPrinterResolution(int printerResolution) {\n        setPrinterResolution(new int[] { printerResolution, printerResolution,\n                                         3 } );\n    }"}
{"Number":"623","API Relative Path":"java.awt.Polygon.java-Polygon(int-int-int)","Corresponding Source":"/**\n     * Constructs and initializes a <code>Polygon<\/code> from the specified\n     * parameters.\n     * @param xpoints an array of X coordinates\n     * @param ypoints an array of Y coordinates\n     * @param npoints the total number of points in the\n     *                          <code>Polygon<\/code>\n     * @exception  NegativeArraySizeException if the value of\n     *                       <code>npoints<\/code> is negative.\n     * @exception  IndexOutOfBoundsException if <code>npoints<\/code> is\n     *             greater than the length of <code>xpoints<\/code>\n     *             or the length of <code>ypoints<\/code>.\n     * @exception  NullPointerException if <code>xpoints<\/code> or\n     *             <code>ypoints<\/code> is <code>null<\/code>.\n     * @since 1.0\n     */\n    public Polygon(int xpoints[], int ypoints[], int npoints) {\n        // Fix 4489009: should throw IndexOutofBoundsException instead\n        // of OutofMemoryException if npoints is huge and > {x,y}points.length\n        if (npoints > xpoints.length || npoints > ypoints.length) {\n            throw new IndexOutOfBoundsException(\"npoints > xpoints.length || \"+\n                                                \"npoints > ypoints.length\");\n        }\n        // Fix 6191114: should throw NegativeArraySizeException with\n        // negative npoints\n        if (npoints < 0) {\n            throw new NegativeArraySizeException(\"npoints < 0\");\n        }\n        // Fix 6343431: Applet compatibility problems if arrays are not\n        // exactly npoints in length\n        this.npoints = npoints;\n        this.xpoints = Arrays.copyOf(xpoints, npoints);\n        this.ypoints = Arrays.copyOf(ypoints, npoints);\n    }"}
{"Number":"624","API Relative Path":"java.awt.Polygon.java-Polygon(int-int-int)","Corresponding Source":"/**\n     * Constructs and initializes a <code>Polygon<\/code> from the specified\n     * parameters.\n     * @param xpoints an array of X coordinates\n     * @param ypoints an array of Y coordinates\n     * @param npoints the total number of points in the\n     *                          <code>Polygon<\/code>\n     * @exception  NegativeArraySizeException if the value of\n     *                       <code>npoints<\/code> is negative.\n     * @exception  IndexOutOfBoundsException if <code>npoints<\/code> is\n     *             greater than the length of <code>xpoints<\/code>\n     *             or the length of <code>ypoints<\/code>.\n     * @exception  NullPointerException if <code>xpoints<\/code> or\n     *             <code>ypoints<\/code> is <code>null<\/code>.\n     * @since 1.0\n     */\n    public Polygon(int xpoints[], int ypoints[], int npoints) {\n        // Fix 4489009: should throw IndexOutofBoundsException instead\n        // of OutofMemoryException if npoints is huge and > {x,y}points.length\n        if (npoints > xpoints.length || npoints > ypoints.length) {\n            throw new IndexOutOfBoundsException(\"npoints > xpoints.length || \"+\n                                                \"npoints > ypoints.length\");\n        }\n        // Fix 6191114: should throw NegativeArraySizeException with\n        // negative npoints\n        if (npoints < 0) {\n            throw new NegativeArraySizeException(\"npoints < 0\");\n        }\n        // Fix 6343431: Applet compatibility problems if arrays are not\n        // exactly npoints in length\n        this.npoints = npoints;\n        this.xpoints = Arrays.copyOf(xpoints, npoints);\n        this.ypoints = Arrays.copyOf(ypoints, npoints);\n    }"}
{"Number":"625","API Relative Path":"java.awt.PopupMenu.java-show(Component-int-int)","Corresponding Source":"/**\n     * Shows the popup menu at the x, y position relative to an origin\n     * component.\n     * The origin component must be contained within the component\n     * hierarchy of the popup menu's parent.  Both the origin and the parent\n     * must be showing on the screen for this method to be valid.\n     * <p>\n     * If this <code>PopupMenu<\/code> is being used as a <code>Menu<\/code>\n     * (i.e., it has a non-<code>Component<\/code> parent),\n     * then you cannot call this method on the <code>PopupMenu<\/code>.\n     *\n     * @param origin the component which defines the coordinate space\n     * @param x the x coordinate position to popup the menu\n     * @param y the y coordinate position to popup the menu\n     * @exception NullPointerException  if the parent is <code>null<\/code>\n     * @exception IllegalArgumentException  if this <code>PopupMenu<\/code>\n     *                has a non-<code>Component<\/code> parent\n     * @exception IllegalArgumentException if the origin is not in the\n     *                parent's hierarchy\n     * @exception RuntimeException if the parent is not showing on screen\n     */\n    public void show(Component origin, int x, int y) {\n        // Use localParent for thread safety.\n        MenuContainer localParent = parent;\n        if (localParent == null) {\n            throw new NullPointerException(\"parent is null\");\n        }\n        if (!(localParent instanceof Component)) {\n            throw new IllegalArgumentException(\n                \"PopupMenus with non-Component parents cannot be shown\");\n        }\n        Component compParent = (Component)localParent;\n        //Fixed 6278745: Incorrect exception throwing in PopupMenu.show() method\n        //Exception was not thrown if compParent was not equal to origin and\n        //was not Container\n        if (compParent != origin) {\n            if (compParent instanceof Container) {\n                if (!((Container)compParent).isAncestorOf(origin)) {\n                    throw new IllegalArgumentException(\"origin not in parent's hierarchy\");\n                }\n            } else {\n                throw new IllegalArgumentException(\"origin not in parent's hierarchy\");\n            }\n        }\n        if (compParent.getPeer() == null || !compParent.isShowing()) {\n            throw new RuntimeException(\"parent not showing on screen\");\n        }\n        if (peer == null) {\n            addNotify();\n        }\n        synchronized (getTreeLock()) {\n            if (peer != null) {\n                ((PopupMenuPeer)peer).show(\n                    new Event(origin, 0, Event.MOUSE_DOWN, x, y, 0, 0));\n            }\n        }\n    }"}
{"Number":"626","API Relative Path":"java.awt.print.Book.java-setPage(int-Printable-PageFormat)","Corresponding Source":"/**\n     * Sets the <code>PageFormat<\/code> and the <code>Painter<\/code> for a\n     * specified page number.\n     * @param pageIndex the zero based index of the page whose\n     *                  painter and format is altered\n     * @param painter   the <code>Printable<\/code> instance that\n     *                  renders the page\n     * @param page      the size and orientation of the page\n     * @throws IndexOutOfBoundsException if the specified\n     *          page is not already in this <code>Book<\/code>\n     * @throws NullPointerException if the <code>painter<\/code> or\n     *          <code>page<\/code> argument is <code>null<\/code>\n     */\n    public void setPage(int pageIndex, Printable painter, PageFormat page)\n        throws IndexOutOfBoundsException\n    {\n        if (painter == null) {\n            throw new NullPointerException(\"painter is null\");\n        }\n\n        if (page == null) {\n            throw new NullPointerException(\"page is null\");\n        }\n\n        mPages.setElementAt(new BookPage(painter, page), pageIndex);\n    }"}
{"Number":"627","API Relative Path":"java.awt.print.PageFormat.java-setOrientation(int)","Corresponding Source":"/**\n     * Sets the page orientation. <code>orientation<\/code> must be\n     * one of the constants: PORTRAIT, LANDSCAPE,\n     * or REVERSE_LANDSCAPE.\n     * @param orientation the new orientation for the page\n     * @throws IllegalArgumentException if\n     *          an unknown orientation was requested\n     * @see #getOrientation\n     */\n    public void setOrientation(int orientation) throws IllegalArgumentException\n    {\n        if (0 <= orientation && orientation <= REVERSE_LANDSCAPE) {\n            mOrientation = orientation;\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }"}
{"Number":"628","API Relative Path":"java.awt.RadialGradientPaint.java-RadialGradientPaint(Point2D-float-Point2D-float[]-Color[]-CycleMethod-ColorSpaceType-AffineTransform)","Corresponding Source":"/**\n     * Constructs a {@code RadialGradientPaint}.\n     *\n     * @param center the center point in user space of the circle defining the\n     *               gradient.  The last color of the gradient is mapped to\n     *               the perimeter of this circle.\n     * @param radius the radius of the circle defining the extents of the\n     *               color gradient\n     * @param focus the point in user space to which the first color is mapped\n     * @param fractions numbers ranging from 0.0 to 1.0 specifying the\n     *                  distribution of colors along the gradient\n     * @param colors array of colors to use in the gradient.  The first color\n     *               is used at the focus point, the last color around the\n     *               perimeter of the circle.\n     * @param cycleMethod either {@code NO_CYCLE}, {@code REFLECT},\n     *                    or {@code REPEAT}\n     * @param colorSpace which color space to use for interpolation,\n     *                   either {@code SRGB} or {@code LINEAR_RGB}\n     * @param gradientTransform transform to apply to the gradient\n     *\n     * @throws NullPointerException\n     * if one of the points is null,\n     * or {@code fractions} array is null,\n     * or {@code colors} array is null,\n     * or {@code cycleMethod} is null,\n     * or {@code colorSpace} is null,\n     * or {@code gradientTransform} is null\n     * @throws IllegalArgumentException\n     * if {@code radius} is non-positive,\n     * or {@code fractions.length != colors.length},\n     * or {@code colors} is less than 2 in size,\n     * or a {@code fractions} value is less than 0.0 or greater than 1.0,\n     * or the {@code fractions} are not provided in strictly increasing order\n     */\n    @ConstructorProperties({ \"centerPoint\", \"radius\", \"focusPoint\", \"fractions\", \"colors\", \"cycleMethod\", \"colorSpace\", \"transform\" })\n    public RadialGradientPaint(Point2D center,\n                               float radius,\n                               Point2D focus,\n                               float[] fractions, Color[] colors,\n                               CycleMethod cycleMethod,\n                               ColorSpaceType colorSpace,\n                               AffineTransform gradientTransform)\n    {\n        super(fractions, colors, cycleMethod, colorSpace, gradientTransform);\n\n        // check input arguments\n        if (center == null) {\n            throw new NullPointerException(\"Center point must be non-null\");\n        }\n\n        if (focus == null) {\n            throw new NullPointerException(\"Focus point must be non-null\");\n        }\n\n        if (radius <= 0) {\n            throw new IllegalArgumentException(\"Radius must be greater \" +\n                                               \"than zero\");\n        }\n\n        // copy parameters\n        this.center = new Point2D.Double(center.getX(), center.getY());\n        this.focus = new Point2D.Double(focus.getX(), focus.getY());\n        this.radius = radius;\n    }"}
{"Number":"629","API Relative Path":"java.awt.RadialGradientPaint.java-RadialGradientPaint(Point2D-float-Point2D-float[]-Color[]-CycleMethod-ColorSpaceType-AffineTransform)","Corresponding Source":"/**\n     * Constructs a {@code RadialGradientPaint}.\n     *\n     * @param center the center point in user space of the circle defining the\n     *               gradient.  The last color of the gradient is mapped to\n     *               the perimeter of this circle.\n     * @param radius the radius of the circle defining the extents of the\n     *               color gradient\n     * @param focus the point in user space to which the first color is mapped\n     * @param fractions numbers ranging from 0.0 to 1.0 specifying the\n     *                  distribution of colors along the gradient\n     * @param colors array of colors to use in the gradient.  The first color\n     *               is used at the focus point, the last color around the\n     *               perimeter of the circle.\n     * @param cycleMethod either {@code NO_CYCLE}, {@code REFLECT},\n     *                    or {@code REPEAT}\n     * @param colorSpace which color space to use for interpolation,\n     *                   either {@code SRGB} or {@code LINEAR_RGB}\n     * @param gradientTransform transform to apply to the gradient\n     *\n     * @throws NullPointerException\n     * if one of the points is null,\n     * or {@code fractions} array is null,\n     * or {@code colors} array is null,\n     * or {@code cycleMethod} is null,\n     * or {@code colorSpace} is null,\n     * or {@code gradientTransform} is null\n     * @throws IllegalArgumentException\n     * if {@code radius} is non-positive,\n     * or {@code fractions.length != colors.length},\n     * or {@code colors} is less than 2 in size,\n     * or a {@code fractions} value is less than 0.0 or greater than 1.0,\n     * or the {@code fractions} are not provided in strictly increasing order\n     */\n    @ConstructorProperties({ \"centerPoint\", \"radius\", \"focusPoint\", \"fractions\", \"colors\", \"cycleMethod\", \"colorSpace\", \"transform\" })\n    public RadialGradientPaint(Point2D center,\n                               float radius,\n                               Point2D focus,\n                               float[] fractions, Color[] colors,\n                               CycleMethod cycleMethod,\n                               ColorSpaceType colorSpace,\n                               AffineTransform gradientTransform)\n    {\n        super(fractions, colors, cycleMethod, colorSpace, gradientTransform);\n\n        // check input arguments\n        if (center == null) {\n            throw new NullPointerException(\"Center point must be non-null\");\n        }\n\n        if (focus == null) {\n            throw new NullPointerException(\"Focus point must be non-null\");\n        }\n\n        if (radius <= 0) {\n            throw new IllegalArgumentException(\"Radius must be greater \" +\n                                               \"than zero\");\n        }\n\n        // copy parameters\n        this.center = new Point2D.Double(center.getX(), center.getY());\n        this.focus = new Point2D.Double(focus.getX(), focus.getY());\n        this.radius = radius;\n    }"}
{"Number":"630","API Relative Path":"java.awt.RadialGradientPaint.java-RadialGradientPaint(Point2D-float-Point2D-float[]-Color[]-CycleMethod-ColorSpaceType-AffineTransform)","Corresponding Source":"/**\n     * Constructs a {@code RadialGradientPaint}.\n     *\n     * @param center the center point in user space of the circle defining the\n     *               gradient.  The last color of the gradient is mapped to\n     *               the perimeter of this circle.\n     * @param radius the radius of the circle defining the extents of the\n     *               color gradient\n     * @param focus the point in user space to which the first color is mapped\n     * @param fractions numbers ranging from 0.0 to 1.0 specifying the\n     *                  distribution of colors along the gradient\n     * @param colors array of colors to use in the gradient.  The first color\n     *               is used at the focus point, the last color around the\n     *               perimeter of the circle.\n     * @param cycleMethod either {@code NO_CYCLE}, {@code REFLECT},\n     *                    or {@code REPEAT}\n     * @param colorSpace which color space to use for interpolation,\n     *                   either {@code SRGB} or {@code LINEAR_RGB}\n     * @param gradientTransform transform to apply to the gradient\n     *\n     * @throws NullPointerException\n     * if one of the points is null,\n     * or {@code fractions} array is null,\n     * or {@code colors} array is null,\n     * or {@code cycleMethod} is null,\n     * or {@code colorSpace} is null,\n     * or {@code gradientTransform} is null\n     * @throws IllegalArgumentException\n     * if {@code radius} is non-positive,\n     * or {@code fractions.length != colors.length},\n     * or {@code colors} is less than 2 in size,\n     * or a {@code fractions} value is less than 0.0 or greater than 1.0,\n     * or the {@code fractions} are not provided in strictly increasing order\n     */\n    @ConstructorProperties({ \"centerPoint\", \"radius\", \"focusPoint\", \"fractions\", \"colors\", \"cycleMethod\", \"colorSpace\", \"transform\" })\n    public RadialGradientPaint(Point2D center,\n                               float radius,\n                               Point2D focus,\n                               float[] fractions, Color[] colors,\n                               CycleMethod cycleMethod,\n                               ColorSpaceType colorSpace,\n                               AffineTransform gradientTransform)\n    {\n        super(fractions, colors, cycleMethod, colorSpace, gradientTransform);\n\n        // check input arguments\n        if (center == null) {\n            throw new NullPointerException(\"Center point must be non-null\");\n        }\n\n        if (focus == null) {\n            throw new NullPointerException(\"Focus point must be non-null\");\n        }\n\n        if (radius <= 0) {\n            throw new IllegalArgumentException(\"Radius must be greater \" +\n                                               \"than zero\");\n        }\n\n        // copy parameters\n        this.center = new Point2D.Double(center.getX(), center.getY());\n        this.focus = new Point2D.Double(focus.getX(), focus.getY());\n        this.radius = radius;\n    }"}
{"Number":"631","API Relative Path":"java.awt.RenderingHints.java-RenderingHints(Map)","Corresponding Source":"/**\n     * Constructs a new object with keys and values initialized\n     * from the specified Map object which may be null.\n     * @param init a map of key/value pairs to initialize the hints\n     *          or null if the object should be empty\n     */\n    public RenderingHints(Map<Key,?> init) {\n        if (init != null) {\n            hintmap.putAll(init);\n        }\n    }"}
{"Number":"632","API Relative Path":"java.awt.Robot.java-createScreenCapture(Rectangle)","Corresponding Source":"/**\n     * Creates an image containing pixels read from the screen.  This image does\n     * not include the mouse cursor.\n     * @param   screenRect      Rect to capture in screen coordinates\n     * @return  The captured image\n     * @throws  IllegalArgumentException if <code>screenRect<\/code> width and height are not greater than zero\n     * @throws  SecurityException if <code>readDisplayPixels<\/code> permission is not granted\n     * @see     SecurityManager#checkPermission\n     * @see     AWTPermission\n     */\n    public synchronized BufferedImage createScreenCapture(Rectangle screenRect) {\n        checkScreenCaptureAllowed();\n\n        checkValidRect(screenRect);\n\n        BufferedImage image;\n        DataBufferInt buffer;\n        WritableRaster raster;\n\n        if (screenCapCM == null) {\n            /*\n             * Fix for 4285201\n             * Create a DirectColorModel equivalent to the default RGB ColorModel,\n             * except with no Alpha component.\n             */\n\n            screenCapCM = new DirectColorModel(24,\n                                               /* red mask */    0x00FF0000,\n                                               /* green mask */  0x0000FF00,\n                                               /* blue mask */   0x000000FF);\n        }\n\n        // need to sync the toolkit prior to grabbing the pixels since in some\n        // cases rendering to the screen may be delayed\n        Toolkit.getDefaultToolkit().sync();\n\n        int pixels[];\n        int[] bandmasks = new int[3];\n\n        pixels = peer.getRGBPixels(screenRect);\n        buffer = new DataBufferInt(pixels, pixels.length);\n\n        bandmasks[0] = screenCapCM.getRedMask();\n        bandmasks[1] = screenCapCM.getGreenMask();\n        bandmasks[2] = screenCapCM.getBlueMask();\n\n        raster = Raster.createPackedRaster(buffer, screenRect.width, screenRect.height, screenRect.width, bandmasks, null);\n        SunWritableRaster.makeTrackable(buffer);\n\n        image = new BufferedImage(screenCapCM, raster, false, null);\n\n        return image;\n    }"}
{"Number":"633","API Relative Path":"java.awt.Robot.java-delay(int)","Corresponding Source":"/**\n     * Sleeps for the specified time.\n     * To catch any <code>InterruptedException<\/code>s that occur,\n     * <code>Thread.sleep()<\/code> may be used instead.\n     * @param   ms      time to sleep in milliseconds\n     * @throws  IllegalArgumentException if <code>ms<\/code> is not between 0 and 60,000 milliseconds inclusive\n     * @see     java.lang.Thread#sleep\n     */\n    public synchronized void delay(int ms) {\n        checkDelayArgument(ms);\n        try {\n            Thread.sleep(ms);\n        } catch(InterruptedException ite) {\n            ite.printStackTrace();\n        }\n    }"}
{"Number":"634","API Relative Path":"java.awt.Robot.java-keyPress(int)","Corresponding Source":"/**\n     * Presses a given key.  The key should be released using the\n     * <code>keyRelease<\/code> method.\n     * <p>\n     * Key codes that have more than one physical key associated with them\n     * (e.g. <code>KeyEvent.VK_SHIFT<\/code> could mean either the\n     * left or right shift key) will map to the left key.\n     *\n     * @param   keycode Key to press (e.g. <code>KeyEvent.VK_A<\/code>)\n     * @throws  IllegalArgumentException if <code>keycode<\/code> is not\n     *          a valid key\n     * @see     #keyRelease(int)\n     * @see     java.awt.event.KeyEvent\n     */\n    public synchronized void keyPress(int keycode) {\n        checkKeycodeArgument(keycode);\n        peer.keyPress(keycode);\n        afterEvent();\n    }"}
{"Number":"635","API Relative Path":"java.awt.Robot.java-keyRelease(int)","Corresponding Source":"/**\n     * Releases a given key.\n     * <p>\n     * Key codes that have more than one physical key associated with them\n     * (e.g. <code>KeyEvent.VK_SHIFT<\/code> could mean either the\n     * left or right shift key) will map to the left key.\n     *\n     * @param   keycode Key to release (e.g. <code>KeyEvent.VK_A<\/code>)\n     * @throws  IllegalArgumentException if <code>keycode<\/code> is not a\n     *          valid key\n     * @see  #keyPress(int)\n     * @see     java.awt.event.KeyEvent\n     */\n    public synchronized void keyRelease(int keycode) {\n        checkKeycodeArgument(keycode);\n        peer.keyRelease(keycode);\n        afterEvent();\n    }"}
{"Number":"636","API Relative Path":"java.awt.Robot.java-mousePress(int)","Corresponding Source":"/**\n     * Presses one or more mouse buttons.  The mouse buttons should\n     * be released using the {@link #mouseRelease(int)} method.\n     *\n     * @param buttons the Button mask; a combination of one or more\n     * mouse button masks.\n     * <p>\n     * It is allowed to use only a combination of valid values as a {@code buttons} parameter.\n     * A valid combination consists of {@code InputEvent.BUTTON1_DOWN_MASK},\n     * {@code InputEvent.BUTTON2_DOWN_MASK}, {@code InputEvent.BUTTON3_DOWN_MASK}\n     * and values returned by the\n     * {@link InputEvent#getMaskForButton(int) InputEvent.getMaskForButton(button)} method.\n     *\n     * The valid combination also depends on a\n     * {@link Toolkit#areExtraMouseButtonsEnabled() Toolkit.areExtraMouseButtonsEnabled()} value as follows:\n     * <ul>\n     * <li> If support for extended mouse buttons is\n     * {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java\n     * then it is allowed to use only the following standard button masks:\n     * {@code InputEvent.BUTTON1_DOWN_MASK}, {@code InputEvent.BUTTON2_DOWN_MASK},\n     * {@code InputEvent.BUTTON3_DOWN_MASK}.\n     * <li> If support for extended mouse buttons is\n     * {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java\n     * then it is allowed to use the standard button masks\n     * and masks for existing extended mouse buttons, if the mouse has more then three buttons.\n     * In that way, it is allowed to use the button masks corresponding to the buttons\n     * in the range from 1 to {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()}.\n     * <br>\n     * It is recommended to use the {@link InputEvent#getMaskForButton(int) InputEvent.getMaskForButton(button)}\n     * method to obtain the mask for any mouse button by its number.\n     * <\/ul>\n     * <p>\n     * The following standard button masks are also accepted:\n     * <ul>\n     * <li>{@code InputEvent.BUTTON1_MASK}\n     * <li>{@code InputEvent.BUTTON2_MASK}\n     * <li>{@code InputEvent.BUTTON3_MASK}\n     * <\/ul>\n     * However, it is recommended to use {@code InputEvent.BUTTON1_DOWN_MASK},\n     * {@code InputEvent.BUTTON2_DOWN_MASK},  {@code InputEvent.BUTTON3_DOWN_MASK} instead.\n     * Either extended {@code _DOWN_MASK} or old {@code _MASK} values\n     * should be used, but both those models should not be mixed.\n     * @throws IllegalArgumentException if the {@code buttons} mask contains the mask for extra mouse button\n     *         and support for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java\n     * @throws IllegalArgumentException if the {@code buttons} mask contains the mask for extra mouse button\n     *         that does not exist on the mouse and support for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java\n     * @see #mouseRelease(int)\n     * @see InputEvent#getMaskForButton(int)\n     * @see Toolkit#areExtraMouseButtonsEnabled()\n     * @see java.awt.MouseInfo#getNumberOfButtons()\n     * @see java.awt.event.MouseEvent\n     */\n    public synchronized void mousePress(int buttons) {\n        checkButtonsArgument(buttons);\n        peer.mousePress(buttons);\n        afterEvent();\n    }"}
{"Number":"637","API Relative Path":"java.awt.Robot.java-mouseRelease(int)","Corresponding Source":"/**\n     * Releases one or more mouse buttons.\n     *\n     * @param buttons the Button mask; a combination of one or more\n     * mouse button masks.\n     * <p>\n     * It is allowed to use only a combination of valid values as a {@code buttons} parameter.\n     * A valid combination consists of {@code InputEvent.BUTTON1_DOWN_MASK},\n     * {@code InputEvent.BUTTON2_DOWN_MASK}, {@code InputEvent.BUTTON3_DOWN_MASK}\n     * and values returned by the\n     * {@link InputEvent#getMaskForButton(int) InputEvent.getMaskForButton(button)} method.\n     *\n     * The valid combination also depends on a\n     * {@link Toolkit#areExtraMouseButtonsEnabled() Toolkit.areExtraMouseButtonsEnabled()} value as follows:\n     * <ul>\n     * <li> If the support for extended mouse buttons is\n     * {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java\n     * then it is allowed to use only the following standard button masks:\n     * {@code InputEvent.BUTTON1_DOWN_MASK}, {@code InputEvent.BUTTON2_DOWN_MASK},\n     * {@code InputEvent.BUTTON3_DOWN_MASK}.\n     * <li> If the support for extended mouse buttons is\n     * {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java\n     * then it is allowed to use the standard button masks\n     * and masks for existing extended mouse buttons, if the mouse has more then three buttons.\n     * In that way, it is allowed to use the button masks corresponding to the buttons\n     * in the range from 1 to {@link java.awt.MouseInfo#getNumberOfButtons() MouseInfo.getNumberOfButtons()}.\n     * <br>\n     * It is recommended to use the {@link InputEvent#getMaskForButton(int) InputEvent.getMaskForButton(button)}\n     * method to obtain the mask for any mouse button by its number.\n     * <\/ul>\n     * <p>\n     * The following standard button masks are also accepted:\n     * <ul>\n     * <li>{@code InputEvent.BUTTON1_MASK}\n     * <li>{@code InputEvent.BUTTON2_MASK}\n     * <li>{@code InputEvent.BUTTON3_MASK}\n     * <\/ul>\n     * However, it is recommended to use {@code InputEvent.BUTTON1_DOWN_MASK},\n     * {@code InputEvent.BUTTON2_DOWN_MASK},  {@code InputEvent.BUTTON3_DOWN_MASK} instead.\n     * Either extended {@code _DOWN_MASK} or old {@code _MASK} values\n     * should be used, but both those models should not be mixed.\n     * @throws IllegalArgumentException if the {@code buttons} mask contains the mask for extra mouse button\n     *         and support for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() disabled} by Java\n     * @throws IllegalArgumentException if the {@code buttons} mask contains the mask for extra mouse button\n     *         that does not exist on the mouse and support for extended mouse buttons is {@link Toolkit#areExtraMouseButtonsEnabled() enabled} by Java\n     * @see #mousePress(int)\n     * @see InputEvent#getMaskForButton(int)\n     * @see Toolkit#areExtraMouseButtonsEnabled()\n     * @see java.awt.MouseInfo#getNumberOfButtons()\n     * @see java.awt.event.MouseEvent\n     */\n    public synchronized void mouseRelease(int buttons) {\n        checkButtonsArgument(buttons);\n        peer.mouseRelease(buttons);\n        afterEvent();\n    }"}
{"Number":"638","API Relative Path":"java.awt.Robot.java-Robot(GraphicsDevice)","Corresponding Source":"/**\n     * Creates a Robot for the given screen device. Coordinates passed\n     * to Robot method calls like mouseMove and createScreenCapture will\n     * be interpreted as being in the same coordinate system as the\n     * specified screen. Note that depending on the platform configuration,\n     * multiple screens may either:\n     * <ul>\n     * <li>share the same coordinate system to form a combined virtual screen<\/li>\n     * <li>use different coordinate systems to act as independent screens<\/li>\n     * <\/ul>\n     * This constructor is meant for the latter case.\n     * <p>\n     * If screen devices are reconfigured such that the coordinate system is\n     * affected, the behavior of existing Robot objects is undefined.\n     *\n     * @param screen    A screen GraphicsDevice indicating the coordinate\n     *                  system the Robot will operate in.\n     * @throws  AWTException if the platform configuration does not allow\n     * low-level input control.  This exception is always thrown when\n     * GraphicsEnvironment.isHeadless() returns true.\n     * @throws  IllegalArgumentException if <code>screen<\/code> is not a screen\n     *          GraphicsDevice.\n     * @throws  SecurityException if <code>createRobot<\/code> permission is not granted\n     * @see     java.awt.GraphicsEnvironment#isHeadless\n     * @see     GraphicsDevice\n     * @see     SecurityManager#checkPermission\n     * @see     AWTPermission\n     */\n    public Robot(GraphicsDevice screen) throws AWTException {\n        checkIsScreenDevice(screen);\n        init(screen);\n    }"}
{"Number":"639","API Relative Path":"java.awt.Robot.java-Robot(GraphicsDevice)","Corresponding Source":"/**\n     * Creates a Robot for the given screen device. Coordinates passed\n     * to Robot method calls like mouseMove and createScreenCapture will\n     * be interpreted as being in the same coordinate system as the\n     * specified screen. Note that depending on the platform configuration,\n     * multiple screens may either:\n     * <ul>\n     * <li>share the same coordinate system to form a combined virtual screen<\/li>\n     * <li>use different coordinate systems to act as independent screens<\/li>\n     * <\/ul>\n     * This constructor is meant for the latter case.\n     * <p>\n     * If screen devices are reconfigured such that the coordinate system is\n     * affected, the behavior of existing Robot objects is undefined.\n     *\n     * @param screen    A screen GraphicsDevice indicating the coordinate\n     *                  system the Robot will operate in.\n     * @throws  AWTException if the platform configuration does not allow\n     * low-level input control.  This exception is always thrown when\n     * GraphicsEnvironment.isHeadless() returns true.\n     * @throws  IllegalArgumentException if <code>screen<\/code> is not a screen\n     *          GraphicsDevice.\n     * @throws  SecurityException if <code>createRobot<\/code> permission is not granted\n     * @see     java.awt.GraphicsEnvironment#isHeadless\n     * @see     GraphicsDevice\n     * @see     SecurityManager#checkPermission\n     * @see     AWTPermission\n     */\n    public Robot(GraphicsDevice screen) throws AWTException {\n        checkIsScreenDevice(screen);\n        init(screen);\n    }"}
{"Number":"640","API Relative Path":"java.awt.Robot.java-setAutoDelay(int)","Corresponding Source":"/**\n     * Sets the number of milliseconds this Robot sleeps after generating an event.\n     * @throws  IllegalArgumentException If <code>ms<\/code> is not between 0 and 60,000 milliseconds inclusive\n     */\n    public synchronized void setAutoDelay(int ms) {\n        checkDelayArgument(ms);\n        autoDelay = ms;\n    }"}
{"Number":"641","API Relative Path":"java.awt.Scrollbar.java-addAdjustmentListener(AdjustmentListener)","Corresponding Source":"/**\n     * Adds the specified adjustment listener to receive instances of\n     * <code>AdjustmentEvent<\/code> from this scroll bar.\n     * If l is <code>null<\/code>, no exception is thrown and no\n     * action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param        l the adjustment listener\n     * @see          #removeAdjustmentListener\n     * @see          #getAdjustmentListeners\n     * @see          java.awt.event.AdjustmentEvent\n     * @see          java.awt.event.AdjustmentListener\n     * @since        JDK1.1\n     */\n    public synchronized void addAdjustmentListener(AdjustmentListener l) {\n        if (l == null) {\n            return;\n        }\n        adjustmentListener = AWTEventMulticaster.add(adjustmentListener, l);\n        newEventsOnly = true;\n    }"}
{"Number":"642","API Relative Path":"java.awt.Scrollbar.java-removeAdjustmentListener(AdjustmentListener)","Corresponding Source":"/**\n     * Removes the specified adjustment listener so that it no longer\n     * receives instances of <code>AdjustmentEvent<\/code> from this scroll bar.\n     * If l is <code>null<\/code>, no exception is thrown and no action\n     * is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param           l    the adjustment listener\n     * @see             #addAdjustmentListener\n     * @see             #getAdjustmentListeners\n     * @see             java.awt.event.AdjustmentEvent\n     * @see             java.awt.event.AdjustmentListener\n     * @since           JDK1.1\n     */\n    public synchronized void removeAdjustmentListener(AdjustmentListener l) {\n        if (l == null) {\n            return;\n        }\n        adjustmentListener = AWTEventMulticaster.remove(adjustmentListener, l);\n    }"}
{"Number":"643","API Relative Path":"java.awt.Scrollbar.java-removeAdjustmentListener(AdjustmentListener)","Corresponding Source":"/**\n     * Removes the specified adjustment listener so that it no longer\n     * receives instances of <code>AdjustmentEvent<\/code> from this scroll bar.\n     * If l is <code>null<\/code>, no exception is thrown and no action\n     * is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param           l    the adjustment listener\n     * @see             #addAdjustmentListener\n     * @see             #getAdjustmentListeners\n     * @see             java.awt.event.AdjustmentEvent\n     * @see             java.awt.event.AdjustmentListener\n     * @since           JDK1.1\n     */\n    public synchronized void removeAdjustmentListener(AdjustmentListener l) {\n        if (l == null) {\n            return;\n        }\n        adjustmentListener = AWTEventMulticaster.remove(adjustmentListener, l);\n    }"}
{"Number":"644","API Relative Path":"java.awt.ScrollPane.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified component to this scroll pane container.\n     * If the scroll pane has an existing child component, that\n     * component is removed and the new one is added.\n     * @param comp the component to be added\n     * @param constraints  not applicable\n     * @param index position of child component (must be &lt;= 0)\n     */\n    protected final void addImpl(Component comp, Object constraints, int index) {\n        synchronized (getTreeLock()) {\n            if (getComponentCount() > 0) {\n                remove(0);\n            }\n            if (index > 0) {\n                throw new IllegalArgumentException(\"position greater than 0\");\n            }\n\n            if (!SunToolkit.isLightweightOrUnknown(comp)) {\n                super.addImpl(comp, constraints, index);\n            } else {\n                addToPanel(comp, constraints, index);\n            }\n        }\n    }"}
{"Number":"645","API Relative Path":"java.awt.ScrollPaneAdjustable.java-addAdjustmentListener(AdjustmentListener)","Corresponding Source":"/**\n     * Adds the specified adjustment listener to receive adjustment\n     * events from this <code>ScrollPaneAdjustable<\/code>.\n     * If <code>l<\/code> is <code>null<\/code>, no exception is thrown\n     * and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    l   the adjustment listener.\n     * @see      #removeAdjustmentListener\n     * @see      #getAdjustmentListeners\n     * @see      java.awt.event.AdjustmentListener\n     * @see      java.awt.event.AdjustmentEvent\n     */\n    public synchronized void addAdjustmentListener(AdjustmentListener l) {\n        if (l == null) {\n            return;\n        }\n        adjustmentListener = AWTEventMulticaster.add(adjustmentListener, l);\n    }"}
{"Number":"646","API Relative Path":"java.awt.ScrollPaneAdjustable.java-removeAdjustmentListener(AdjustmentListener)","Corresponding Source":"/**\n     * Removes the specified adjustment listener so that it no longer\n     * receives adjustment events from this <code>ScrollPaneAdjustable<\/code>.\n     * If <code>l<\/code> is <code>null<\/code>, no exception is thrown\n     * and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param         l     the adjustment listener.\n     * @see           #addAdjustmentListener\n     * @see           #getAdjustmentListeners\n     * @see           java.awt.event.AdjustmentListener\n     * @see           java.awt.event.AdjustmentEvent\n     * @since         JDK1.1\n     */\n    public synchronized void removeAdjustmentListener(AdjustmentListener l){\n        if (l == null) {\n            return;\n        }\n        adjustmentListener = AWTEventMulticaster.remove(adjustmentListener, l);\n    }"}
{"Number":"647","API Relative Path":"java.awt.ScrollPaneAdjustable.java-removeAdjustmentListener(AdjustmentListener)","Corresponding Source":"/**\n     * Removes the specified adjustment listener so that it no longer\n     * receives adjustment events from this <code>ScrollPaneAdjustable<\/code>.\n     * If <code>l<\/code> is <code>null<\/code>, no exception is thrown\n     * and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param         l     the adjustment listener.\n     * @see           #addAdjustmentListener\n     * @see           #getAdjustmentListeners\n     * @see           java.awt.event.AdjustmentListener\n     * @see           java.awt.event.AdjustmentEvent\n     * @since         JDK1.1\n     */\n    public synchronized void removeAdjustmentListener(AdjustmentListener l){\n        if (l == null) {\n            return;\n        }\n        adjustmentListener = AWTEventMulticaster.remove(adjustmentListener, l);\n    }"}
{"Number":"648","API Relative Path":"java.awt.ScrollPaneAdjustable.java-ScrollPaneAdjustable(ScrollPane-AdjustmentListener-int)","Corresponding Source":"/**\n     * Constructs a new object to represent specified scrollabar\n     * of the specified <code>ScrollPane<\/code>.\n     * Only ScrollPane creates instances of this class.\n     * @param sp           <code>ScrollPane<\/code>\n     * @param l            <code>AdjustmentListener<\/code> to add upon creation.\n     * @param orientation  specifies which scrollbar this object represents,\n     *                     can be either  <code>Adjustable.HORIZONTAL<\/code>\n     *                     or <code>Adjustable.VERTICAL<\/code>.\n     */\n    ScrollPaneAdjustable(ScrollPane sp, AdjustmentListener l, int orientation) {\n        this.sp = sp;\n        this.orientation = orientation;\n        addAdjustmentListener(l);\n    }"}
{"Number":"649","API Relative Path":"java.awt.SystemTray.java-addPropertyChangeListener(String-PropertyChangeListener)","Corresponding Source":"/**\n     * Adds a {@code PropertyChangeListener} to the list of listeners for the\n     * specific property. The following properties are currently supported:\n     *\n     * <table border=1 summary=\"SystemTray properties\">\n     * <tr>\n     *    <th>Property<\/th>\n     *    <th>Description<\/th>\n     * <\/tr>\n     * <tr>\n     *    <td>{@code trayIcons}<\/td>\n     *    <td>The {@code SystemTray}'s array of {@code TrayIcon} objects.\n     *        The array is accessed via the {@link #getTrayIcons} method.<br>\n     *        This property is changed when a tray icon is added to (or removed\n     *        from) the system tray.<br> For example, this property is changed\n     *        when the system tray becomes unavailable on the desktop<br>\n     *        and the tray icons are automatically removed.<\/td>\n     * <\/tr>\n     * <tr>\n     *    <td>{@code systemTray}<\/td>\n     *    <td>This property contains {@code SystemTray} instance when the system tray\n     *        is available or <code>null<\/code> otherwise.<br> This property is changed\n     *        when the system tray becomes available or unavailable on the desktop.<br>\n     *        The property is accessed by the {@link #getSystemTray} method.<\/td>\n     * <\/tr>\n     * <\/table>\n     * <p>\n     * The {@code listener} listens to property changes only in this context.\n     * <p>\n     * If {@code listener} is {@code null}, no exception is thrown\n     * and no action is performed.\n     *\n     * @param propertyName the specified property\n     * @param listener the property change listener to be added\n     *\n     * @see #removePropertyChangeListener\n     * @see #getPropertyChangeListeners\n     */\n    public synchronized void addPropertyChangeListener(String propertyName,\n                                                       PropertyChangeListener listener)\n    {\n        if (listener == null) {\n            return;\n        }\n        getCurrentChangeSupport().addPropertyChangeListener(propertyName, listener);\n    }"}
{"Number":"650","API Relative Path":"java.awt.SystemTray.java-remove(TrayIcon)","Corresponding Source":"/**\n     * Removes the specified <code>TrayIcon<\/code> from the\n     * <code>SystemTray<\/code>.\n     *\n     * <p> All icons added by the application are automatically\n     * removed from the <code>SystemTray<\/code> upon application exit\n     * and also when the desktop system tray becomes unavailable.\n     *\n     * <p> If <code>trayIcon<\/code> is <code>null<\/code> or was not\n     * added to the system tray, no exception is thrown and no action\n     * is performed.\n     *\n     * @param trayIcon the <code>TrayIcon<\/code> to be removed\n     * @see #add(TrayIcon)\n     * @see TrayIcon\n     */\n    public void remove(TrayIcon trayIcon) {\n        if (trayIcon == null) {\n            return;\n        }\n        TrayIcon[] oldArray = null, newArray = null;\n        synchronized (this) {\n            oldArray = systemTray.getTrayIcons();\n            Vector<TrayIcon> icons = (Vector<TrayIcon>)AppContext.getAppContext().get(TrayIcon.class);\n            // TrayIcon with no peer is not contained in the array.\n            if (icons == null || !icons.remove(trayIcon)) {\n                return;\n            }\n            trayIcon.removeNotify();\n            newArray = systemTray.getTrayIcons();\n        }\n        firePropertyChange(\"trayIcons\", oldArray, newArray);\n    }"}
{"Number":"651","API Relative Path":"java.awt.SystemTray.java-removePropertyChangeListener(String-PropertyChangeListener)","Corresponding Source":"/**\n     * Removes a {@code PropertyChangeListener} from the listener list\n     * for a specific property.\n     * <p>\n     * The {@code PropertyChangeListener} must be from this context.\n     * <p>\n     * If {@code propertyName} or {@code listener} is {@code null} or invalid,\n     * no exception is thrown and no action is taken.\n     *\n     * @param propertyName the specified property\n     * @param listener the PropertyChangeListener to be removed\n     *\n     * @see #addPropertyChangeListener\n     * @see #getPropertyChangeListeners\n     */\n    public synchronized void removePropertyChangeListener(String propertyName,\n                                                          PropertyChangeListener listener)\n    {\n        if (listener == null) {\n            return;\n        }\n        getCurrentChangeSupport().removePropertyChangeListener(propertyName, listener);\n    }"}
{"Number":"652","API Relative Path":"java.awt.TextComponent.java-addTextListener(TextListener)","Corresponding Source":"/**\n     * Adds the specified text event listener to receive text events\n     * from this text component.\n     * If <code>l<\/code> is <code>null<\/code>, no exception is\n     * thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param l the text event listener\n     * @see             #removeTextListener\n     * @see             #getTextListeners\n     * @see             java.awt.event.TextListener\n     */\n    public synchronized void addTextListener(TextListener l) {\n        if (l == null) {\n            return;\n        }\n        textListener = AWTEventMulticaster.add(textListener, l);\n        newEventsOnly = true;\n    }"}
{"Number":"653","API Relative Path":"java.awt.TextComponent.java-removeTextListener(TextListener)","Corresponding Source":"/**\n     * Removes the specified text event listener so that it no longer\n     * receives text events from this text component\n     * If <code>l<\/code> is <code>null<\/code>, no exception is\n     * thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param           l     the text listener\n     * @see             #addTextListener\n     * @see             #getTextListeners\n     * @see             java.awt.event.TextListener\n     * @since           JDK1.1\n     */\n    public synchronized void removeTextListener(TextListener l) {\n        if (l == null) {\n            return;\n        }\n        textListener = AWTEventMulticaster.remove(textListener, l);\n    }"}
{"Number":"654","API Relative Path":"java.awt.TextComponent.java-removeTextListener(TextListener)","Corresponding Source":"/**\n     * Removes the specified text event listener so that it no longer\n     * receives text events from this text component\n     * If <code>l<\/code> is <code>null<\/code>, no exception is\n     * thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param           l     the text listener\n     * @see             #addTextListener\n     * @see             #getTextListeners\n     * @see             java.awt.event.TextListener\n     * @since           JDK1.1\n     */\n    public synchronized void removeTextListener(TextListener l) {\n        if (l == null) {\n            return;\n        }\n        textListener = AWTEventMulticaster.remove(textListener, l);\n    }"}
{"Number":"655","API Relative Path":"java.awt.TextField.java-addActionListener(ActionListener)","Corresponding Source":"/**\n     * Adds the specified action listener to receive\n     * action events from this text field.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param      l the action listener.\n     * @see        #removeActionListener\n     * @see        #getActionListeners\n     * @see        java.awt.event.ActionListener\n     * @since      JDK1.1\n     */\n    public synchronized void addActionListener(ActionListener l) {\n        if (l == null) {\n            return;\n        }\n        actionListener = AWTEventMulticaster.add(actionListener, l);\n        newEventsOnly = true;\n    }"}
{"Number":"656","API Relative Path":"java.awt.TextField.java-removeActionListener(ActionListener)","Corresponding Source":"/**\n     * Removes the specified action listener so that it no longer\n     * receives action events from this text field.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param           l the action listener.\n     * @see             #addActionListener\n     * @see             #getActionListeners\n     * @see             java.awt.event.ActionListener\n     * @since           JDK1.1\n     */\n    public synchronized void removeActionListener(ActionListener l) {\n        if (l == null) {\n            return;\n        }\n        actionListener = AWTEventMulticaster.remove(actionListener, l);\n    }"}
{"Number":"657","API Relative Path":"java.awt.TextField.java-removeActionListener(ActionListener)","Corresponding Source":"/**\n     * Removes the specified action listener so that it no longer\n     * receives action events from this text field.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param           l the action listener.\n     * @see             #addActionListener\n     * @see             #getActionListeners\n     * @see             java.awt.event.ActionListener\n     * @since           JDK1.1\n     */\n    public synchronized void removeActionListener(ActionListener l) {\n        if (l == null) {\n            return;\n        }\n        actionListener = AWTEventMulticaster.remove(actionListener, l);\n    }"}
{"Number":"658","API Relative Path":"java.awt.Toolkit.java-getLockingKeyState(int)","Corresponding Source":"/**\n     * Returns whether the given locking key on the keyboard is currently in\n     * its \"on\" state.\n     * Valid key codes are\n     * {@link java.awt.event.KeyEvent#VK_CAPS_LOCK VK_CAPS_LOCK},\n     * {@link java.awt.event.KeyEvent#VK_NUM_LOCK VK_NUM_LOCK},\n     * {@link java.awt.event.KeyEvent#VK_SCROLL_LOCK VK_SCROLL_LOCK}, and\n     * {@link java.awt.event.KeyEvent#VK_KANA_LOCK VK_KANA_LOCK}.\n     *\n     * @exception java.lang.IllegalArgumentException if <code>keyCode<\/code>\n     * is not one of the valid key codes\n     * @exception java.lang.UnsupportedOperationException if the host system doesn't\n     * allow getting the state of this key programmatically, or if the keyboard\n     * doesn't have this key\n     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n     * returns true\n     * @see       java.awt.GraphicsEnvironment#isHeadless\n     * @since 1.3\n     */\n    public boolean getLockingKeyState(int keyCode)\n        throws UnsupportedOperationException\n    {\n        GraphicsEnvironment.checkHeadless();\n\n        if (! (keyCode == KeyEvent.VK_CAPS_LOCK || keyCode == KeyEvent.VK_NUM_LOCK ||\n               keyCode == KeyEvent.VK_SCROLL_LOCK || keyCode == KeyEvent.VK_KANA_LOCK)) {\n            throw new IllegalArgumentException(\"invalid key for Toolkit.getLockingKeyState\");\n        }\n        throw new UnsupportedOperationException(\"Toolkit.getLockingKeyState\");\n    }"}
{"Number":"659","API Relative Path":"java.awt.Toolkit.java-removeAWTEventListener(AWTEventListener)","Corresponding Source":"/**\n     * Removes an AWTEventListener from receiving dispatched AWTEvents.\n     * <p>\n     * First, if there is a security manager, its <code>checkPermission<\/code>\n     * method is called with an\n     * <code>AWTPermission(\"listenToAllAWTEvents\")<\/code> permission.\n     * This may result in a SecurityException.\n     * <p>\n     * Note:  event listener use is not recommended for normal\n     * application use, but are intended solely to support special\n     * purpose facilities including support for accessibility,\n     * event record/playback, and diagnostic tracing.\n     *\n     * If listener is null, no exception is thrown and no action is performed.\n     *\n     * @param    listener   the event listener.\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        <code>checkPermission<\/code> method doesn't allow the operation.\n     * @see      #addAWTEventListener\n     * @see      #getAWTEventListeners\n     * @see      SecurityManager#checkPermission\n     * @see      java.awt.AWTEvent\n     * @see      java.awt.AWTPermission\n     * @see      java.awt.event.AWTEventListener\n     * @see      java.awt.event.AWTEventListenerProxy\n     * @since    1.2\n     */\n    public void removeAWTEventListener(AWTEventListener listener) {\n        AWTEventListener localL = deProxyAWTEventListener(listener);\n\n        if (listener == null) {\n            return;\n        }\n        SecurityManager security = System.getSecurityManager();\n        if (security != null) {\n            security.checkPermission(SecurityConstants.AWT.ALL_AWT_EVENTS_PERMISSION);\n        }\n\n        synchronized (this) {\n            SelectiveAWTEventListener selectiveListener =\n                listener2SelectiveListener.get(localL);\n\n            if (selectiveListener != null) {\n                listener2SelectiveListener.remove(localL);\n                int[] listenerCalls = selectiveListener.getCalls();\n                for (int i=0; i<LONG_BITS; i++) {\n                    calls[i] -= listenerCalls[i];\n                    assert calls[i] >= 0: \"Negative Listeners count\";\n\n                    if (calls[i] == 0) {\n                        enabledOnToolkitMask &= ~(1L<<i);\n                    }\n                }\n            }\n            eventListener = ToolkitEventMulticaster.remove(eventListener,\n            (selectiveListener == null) ? localL : selectiveListener);\n        }\n    }"}
{"Number":"660","API Relative Path":"java.awt.Toolkit.java-setLockingKeyState(int-boolean)","Corresponding Source":"/**\n     * Sets the state of the given locking key on the keyboard.\n     * Valid key codes are\n     * {@link java.awt.event.KeyEvent#VK_CAPS_LOCK VK_CAPS_LOCK},\n     * {@link java.awt.event.KeyEvent#VK_NUM_LOCK VK_NUM_LOCK},\n     * {@link java.awt.event.KeyEvent#VK_SCROLL_LOCK VK_SCROLL_LOCK}, and\n     * {@link java.awt.event.KeyEvent#VK_KANA_LOCK VK_KANA_LOCK}.\n     * <p>\n     * Depending on the platform, setting the state of a locking key may\n     * involve event processing and therefore may not be immediately\n     * observable through getLockingKeyState.\n     *\n     * @exception java.lang.IllegalArgumentException if <code>keyCode<\/code>\n     * is not one of the valid key codes\n     * @exception java.lang.UnsupportedOperationException if the host system doesn't\n     * allow setting the state of this key programmatically, or if the keyboard\n     * doesn't have this key\n     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n     * returns true\n     * @see       java.awt.GraphicsEnvironment#isHeadless\n     * @since 1.3\n     */\n    public void setLockingKeyState(int keyCode, boolean on)\n        throws UnsupportedOperationException\n    {\n        GraphicsEnvironment.checkHeadless();\n\n        if (! (keyCode == KeyEvent.VK_CAPS_LOCK || keyCode == KeyEvent.VK_NUM_LOCK ||\n               keyCode == KeyEvent.VK_SCROLL_LOCK || keyCode == KeyEvent.VK_KANA_LOCK)) {\n            throw new IllegalArgumentException(\"invalid key for Toolkit.setLockingKeyState\");\n        }\n        throw new UnsupportedOperationException(\"Toolkit.setLockingKeyState\");\n    }"}
{"Number":"661","API Relative Path":"java.awt.TrayIcon.java-addActionListener(ActionListener)","Corresponding Source":"/**\n     * Adds the specified action listener to receive\n     * <code>ActionEvent<\/code>s from this <code>TrayIcon<\/code>.\n     * Action events usually occur when a user selects the tray icon,\n     * using either the mouse or keyboard.  The conditions in which\n     * action events are generated are platform-dependent.\n     *\n     * <p>Calling this method with a <code>null<\/code> value has no\n     * effect.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param         listener the action listener\n     * @see           #removeActionListener\n     * @see           #getActionListeners\n     * @see           java.awt.event.ActionListener\n     * @see #setActionCommand(String)\n     */\n    public synchronized void addActionListener(ActionListener listener) {\n        if (listener == null) {\n            return;\n        }\n        actionListener = AWTEventMulticaster.add(actionListener, listener);\n    }"}
{"Number":"662","API Relative Path":"java.awt.TrayIcon.java-addMouseListener(MouseListener)","Corresponding Source":"/**\n     * Adds the specified mouse listener to receive mouse events from\n     * this <code>TrayIcon<\/code>.  Calling this method with a\n     * <code>null<\/code> value has no effect.\n     *\n     * <p><b>Note<\/b>: The {@code MouseEvent}'s coordinates (received\n     * from the {@code TrayIcon}) are relative to the screen, not the\n     * {@code TrayIcon}.\n     *\n     * <p> <b>Note: <\/b>The <code>MOUSE_ENTERED<\/code> and\n     * <code>MOUSE_EXITED<\/code> mouse events are not supported.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    listener the mouse listener\n     * @see      java.awt.event.MouseEvent\n     * @see      java.awt.event.MouseListener\n     * @see      #removeMouseListener(MouseListener)\n     * @see      #getMouseListeners\n     */\n    public synchronized void addMouseListener(MouseListener listener) {\n        if (listener == null) {\n            return;\n        }\n        mouseListener = AWTEventMulticaster.add(mouseListener, listener);\n    }"}
{"Number":"663","API Relative Path":"java.awt.TrayIcon.java-addMouseMotionListener(MouseMotionListener)","Corresponding Source":"/**\n     * Adds the specified mouse listener to receive mouse-motion\n     * events from this <code>TrayIcon<\/code>.  Calling this method\n     * with a <code>null<\/code> value has no effect.\n     *\n     * <p><b>Note<\/b>: The {@code MouseEvent}'s coordinates (received\n     * from the {@code TrayIcon}) are relative to the screen, not the\n     * {@code TrayIcon}.\n     *\n     * <p> <b>Note: <\/b>The <code>MOUSE_DRAGGED<\/code> mouse event is not supported.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    listener   the mouse listener\n     * @see      java.awt.event.MouseEvent\n     * @see      java.awt.event.MouseMotionListener\n     * @see      #removeMouseMotionListener(MouseMotionListener)\n     * @see      #getMouseMotionListeners\n     */\n    public synchronized void addMouseMotionListener(MouseMotionListener listener) {\n        if (listener == null) {\n            return;\n        }\n        mouseMotionListener = AWTEventMulticaster.add(mouseMotionListener, listener);\n    }"}
{"Number":"664","API Relative Path":"java.awt.TrayIcon.java-removeActionListener(ActionListener)","Corresponding Source":"/**\n     * Removes the specified action listener.  Calling this method with\n     * <code>null<\/code> or an invalid value has no effect.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    listener   the action listener\n     * @see      java.awt.event.ActionEvent\n     * @see      java.awt.event.ActionListener\n     * @see      #addActionListener(ActionListener)\n     * @see      #getActionListeners\n     * @see #setActionCommand(String)\n     */\n    public synchronized void removeActionListener(ActionListener listener) {\n        if (listener == null) {\n            return;\n        }\n        actionListener = AWTEventMulticaster.remove(actionListener, listener);\n    }"}
{"Number":"665","API Relative Path":"java.awt.TrayIcon.java-removeMouseListener(MouseListener)","Corresponding Source":"/**\n     * Removes the specified mouse listener.  Calling this method with\n     * <code>null<\/code> or an invalid value has no effect.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    listener   the mouse listener\n     * @see      java.awt.event.MouseEvent\n     * @see      java.awt.event.MouseListener\n     * @see      #addMouseListener(MouseListener)\n     * @see      #getMouseListeners\n     */\n    public synchronized void removeMouseListener(MouseListener listener) {\n        if (listener == null) {\n            return;\n        }\n        mouseListener = AWTEventMulticaster.remove(mouseListener, listener);\n    }"}
{"Number":"666","API Relative Path":"java.awt.TrayIcon.java-removeMouseMotionListener(MouseMotionListener)","Corresponding Source":"/**\n     * Removes the specified mouse-motion listener.  Calling this method with\n     * <code>null<\/code> or an invalid value has no effect.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param    listener   the mouse listener\n     * @see      java.awt.event.MouseEvent\n     * @see      java.awt.event.MouseMotionListener\n     * @see      #addMouseMotionListener(MouseMotionListener)\n     * @see      #getMouseMotionListeners\n     */\n    public synchronized void removeMouseMotionListener(MouseMotionListener listener) {\n        if (listener == null) {\n            return;\n        }\n        mouseMotionListener = AWTEventMulticaster.remove(mouseMotionListener, listener);\n    }"}
{"Number":"667","API Relative Path":"java.awt.TrayIcon.java-setPopupMenu(PopupMenu)","Corresponding Source":"/**\n     * Sets the popup menu for this <code>TrayIcon<\/code>.  If\n     * <code>popup<\/code> is <code>null<\/code>, no popup menu will be\n     * associated with this <code>TrayIcon<\/code>.\n     *\n     * <p>Note that this <code>popup<\/code> must not be added to any\n     * parent before or after it is set on the tray icon.  If you add\n     * it to some parent, the <code>popup<\/code> may be removed from\n     * that parent.\n     *\n     * <p>The {@code popup} can be set on one {@code TrayIcon} only.\n     * Setting the same popup on multiple {@code TrayIcon}s will cause\n     * an {@code IllegalArgumentException}.\n     *\n     * <p><strong>Note:<\/strong> Some platforms may not support\n     * showing the user-specified popup menu component when the user\n     * right-clicks the tray icon.  In this situation, either no menu\n     * will be displayed or, on some systems, a native version of the\n     * menu may be displayed.\n     *\n     * @throws IllegalArgumentException if the {@code popup} is already\n     * set for another {@code TrayIcon}\n     * @param popup a <code>PopupMenu<\/code> or <code>null<\/code> to\n     * remove any popup menu\n     * @see #getPopupMenu\n     */\n    public void setPopupMenu(PopupMenu popup) {\n        if (popup == this.popup) {\n            return;\n        }\n        synchronized (TrayIcon.class) {\n            if (popup != null) {\n                if (popup.isTrayIconPopup) {\n                    throw new IllegalArgumentException(\"the PopupMenu is already set for another TrayIcon\");\n                }\n                popup.isTrayIconPopup = true;\n            }\n            if (this.popup != null) {\n                this.popup.isTrayIconPopup = false;\n            }\n            this.popup = popup;\n        }\n    }"}
{"Number":"668","API Relative Path":"java.awt.TrayIcon.java-TrayIcon(Image)","Corresponding Source":"/**\n     * Creates a <code>TrayIcon<\/code> with the specified image.\n     *\n     * @param image the <code>Image<\/code> to be used\n     * @throws IllegalArgumentException if <code>image<\/code> is\n     * <code>null<\/code>\n     * @throws UnsupportedOperationException if the system tray isn't\n     * supported by the current platform\n     * @throws HeadlessException if\n     * {@code GraphicsEnvironment.isHeadless()} returns {@code true}\n     * @throws SecurityException if {@code accessSystemTray} permission\n     * is not granted\n     * @see SystemTray#add(TrayIcon)\n     * @see TrayIcon#TrayIcon(Image, String, PopupMenu)\n     * @see TrayIcon#TrayIcon(Image, String)\n     * @see SecurityManager#checkPermission\n     * @see AWTPermission\n     */\n    public TrayIcon(Image image) {\n        this();\n        if (image == null) {\n            throw new IllegalArgumentException(\"creating TrayIcon with null Image\");\n        }\n        setImage(image);\n    }"}
{"Number":"669","API Relative Path":"java.awt.TrayIcon.java-TrayIcon(Image-String-PopupMenu)","Corresponding Source":"/**\n     * Creates a <code>TrayIcon<\/code> with the specified image,\n     * tooltip and popup menu.\n     *\n     * @param image the <code>Image<\/code> to be used\n     * @param tooltip the string to be used as tooltip text; if the\n     * value is <code>null<\/code> no tooltip is shown\n     * @param popup the menu to be used for the tray icon's popup\n     * menu; if the value is <code>null<\/code> no popup menu is shown\n     * @throws IllegalArgumentException if <code>image<\/code> is <code>null<\/code>\n     * @throws UnsupportedOperationException if the system tray isn't\n     * supported by the current platform\n     * @throws HeadlessException if\n     * {@code GraphicsEnvironment.isHeadless()} returns {@code true}\n     * @throws SecurityException if {@code accessSystemTray} permission\n     * is not granted\n     * @see SystemTray#add(TrayIcon)\n     * @see TrayIcon#TrayIcon(Image, String)\n     * @see TrayIcon#TrayIcon(Image)\n     * @see PopupMenu\n     * @see MouseListener\n     * @see #addMouseListener(MouseListener)\n     * @see SecurityManager#checkPermission\n     * @see AWTPermission\n     */\n    public TrayIcon(Image image, String tooltip, PopupMenu popup) {\n        this(image, tooltip);\n        setPopupMenu(popup);\n    }"}
{"Number":"670","API Relative Path":"java.awt.WaitDispatchSupport.java-WaitDispatchSupport(EventDispatchThread-Conditional)","Corresponding Source":"/**\n     * Creates a {@code WaitDispatchSupport} instance to\n     * serve the given event dispatch thread.\n     *\n     * @param dispatchThread An event dispatch thread that\n     *        should not stop dispatching events while waiting\n     * @param extCond A conditional object used to determine\n     *        if the loop should be terminated\n     *\n     * @since 1.7\n     */\n    public WaitDispatchSupport(EventDispatchThread dispatchThread,\n                               Conditional extCond)\n    {\n        if (dispatchThread == null) {\n            throw new IllegalArgumentException(\"The dispatchThread can not be null\");\n        }\n\n        this.dispatchThread = dispatchThread;\n        this.extCondition = extCond;\n        this.condition = new Conditional() {\n            @Override\n            public boolean evaluate() {\n                if (log.isLoggable(PlatformLogger.Level.FINEST)) {\n                    log.finest(\"evaluate(): blockingEDT=\" + keepBlockingEDT.get() +\n                               \", blockingCT=\" + keepBlockingCT.get());\n                }\n                boolean extEvaluate =\n                    (extCondition != null) ? extCondition.evaluate() : true;\n                if (!keepBlockingEDT.get() || !extEvaluate) {\n                    if (timerTask != null) {\n                        timerTask.cancel();\n                        timerTask = null;\n                    }\n                    return false;\n                }\n                return true;\n            }\n        };\n    }"}
{"Number":"671","API Relative Path":"java.awt.WaitDispatchSupport.java-WaitDispatchSupport(EventDispatchThread-Conditional-EventFilter-long)","Corresponding Source":"/**\n     * Creates a {@code WaitDispatchSupport} instance to\n     * serve the given event dispatch thread.\n     * <p>\n     * The {@link EventFilter} is set on the {@code dispatchThread}\n     * while waiting. The filter is removed on completion of the\n     * waiting process.\n     * <p>\n     *\n     *\n     * @param dispatchThread An event dispatch thread that\n     *        should not stop dispatching events while waiting\n     * @param filter {@code EventFilter} to be set\n     * @param interval A time interval to wait for. Note that\n     *        when the waiting process takes place on EDT\n     *        there is no guarantee to stop it in the given time\n     *\n     * @since 1.7\n     */\n    public WaitDispatchSupport(EventDispatchThread dispatchThread,\n                               Conditional extCondition,\n                               EventFilter filter, long interval)\n    {\n        this(dispatchThread, extCondition);\n        this.filter = filter;\n        if (interval < 0) {\n            throw new IllegalArgumentException(\"The interval value must be >= 0\");\n        }\n        this.interval = interval;\n        if (interval != 0) {\n            initializeTimer();\n        }\n    }"}
{"Number":"672","API Relative Path":"java.awt.Window.java-addWindowFocusListener(WindowFocusListener)","Corresponding Source":"/**\n     * Adds the specified window focus listener to receive window events\n     * from this window.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param   l the window focus listener\n     * @see #removeWindowFocusListener\n     * @see #getWindowFocusListeners\n     * @since 1.4\n     */\n    public synchronized void addWindowFocusListener(WindowFocusListener l) {\n        if (l == null) {\n            return;\n        }\n        windowFocusListener = AWTEventMulticaster.add(windowFocusListener, l);\n        newEventsOnly = true;\n    }"}
{"Number":"673","API Relative Path":"java.awt.Window.java-addWindowListener(WindowListener)","Corresponding Source":"/**\n     * Adds the specified window listener to receive window events from\n     * this window.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param   l the window listener\n     * @see #removeWindowListener\n     * @see #getWindowListeners\n     */\n    public synchronized void addWindowListener(WindowListener l) {\n        if (l == null) {\n            return;\n        }\n        newEventsOnly = true;\n        windowListener = AWTEventMulticaster.add(windowListener, l);\n    }"}
{"Number":"674","API Relative Path":"java.awt.Window.java-addWindowStateListener(WindowStateListener)","Corresponding Source":"/**\n     * Adds the specified window state listener to receive window\n     * events from this window.  If {@code l} is {@code null},\n     * no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param   l the window state listener\n     * @see #removeWindowStateListener\n     * @see #getWindowStateListeners\n     * @since 1.4\n     */\n    public synchronized void addWindowStateListener(WindowStateListener l) {\n        if (l == null) {\n            return;\n        }\n        windowStateListener = AWTEventMulticaster.add(windowStateListener, l);\n        newEventsOnly = true;\n    }"}
{"Number":"675","API Relative Path":"java.awt.Window.java-getFocusTraversalKeys(int)","Corresponding Source":"/**\n     * Gets a focus traversal key for this Window. (See {@code\n     * setFocusTraversalKeys} for a full description of each key.)\n     * <p>\n     * If the traversal key has not been explicitly set for this Window,\n     * then this Window's parent's traversal key is returned. If the\n     * traversal key has not been explicitly set for any of this Window's\n     * ancestors, then the current KeyboardFocusManager's default traversal key\n     * is returned.\n     *\n     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or\n     *         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS\n     * @return the AWTKeyStroke for the specified key\n     * @see Container#setFocusTraversalKeys\n     * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#DOWN_CYCLE_TRAVERSAL_KEYS\n     * @throws IllegalArgumentException if id is not one of\n     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or\n     *         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS\n     * @since 1.4\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Set<AWTKeyStroke> getFocusTraversalKeys(int id) {\n        if (id < 0 || id >= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH) {\n            throw new IllegalArgumentException(\"invalid focus traversal key identifier\");\n        }\n\n        // Okay to return Set directly because it is an unmodifiable view\n        @SuppressWarnings(\"rawtypes\")\n        Set keystrokes = (focusTraversalKeys != null)\n            ? focusTraversalKeys[id]\n            : null;\n\n        if (keystrokes != null) {\n            return keystrokes;\n        } else {\n            return KeyboardFocusManager.getCurrentKeyboardFocusManager().\n                getDefaultFocusTraversalKeys(id);\n        }\n    }"}
{"Number":"676","API Relative Path":"java.awt.Window.java-getFocusTraversalKeys(int)","Corresponding Source":"/**\n     * Gets a focus traversal key for this Window. (See {@code\n     * setFocusTraversalKeys} for a full description of each key.)\n     * <p>\n     * If the traversal key has not been explicitly set for this Window,\n     * then this Window's parent's traversal key is returned. If the\n     * traversal key has not been explicitly set for any of this Window's\n     * ancestors, then the current KeyboardFocusManager's default traversal key\n     * is returned.\n     *\n     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or\n     *         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS\n     * @return the AWTKeyStroke for the specified key\n     * @see Container#setFocusTraversalKeys\n     * @see KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS\n     * @see KeyboardFocusManager#DOWN_CYCLE_TRAVERSAL_KEYS\n     * @throws IllegalArgumentException if id is not one of\n     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or\n     *         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS\n     * @since 1.4\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Set<AWTKeyStroke> getFocusTraversalKeys(int id) {\n        if (id < 0 || id >= KeyboardFocusManager.TRAVERSAL_KEY_LENGTH) {\n            throw new IllegalArgumentException(\"invalid focus traversal key identifier\");\n        }\n\n        // Okay to return Set directly because it is an unmodifiable view\n        @SuppressWarnings(\"rawtypes\")\n        Set keystrokes = (focusTraversalKeys != null)\n            ? focusTraversalKeys[id]\n            : null;\n\n        if (keystrokes != null) {\n            return keystrokes;\n        } else {\n            return KeyboardFocusManager.getCurrentKeyboardFocusManager().\n                getDefaultFocusTraversalKeys(id);\n        }\n    }"}
{"Number":"677","API Relative Path":"java.awt.Window.java-removeWindowFocusListener(WindowFocusListener)","Corresponding Source":"/**\n     * Removes the specified window focus listener so that it no longer\n     * receives window events from this window.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param   l the window focus listener\n     * @see #addWindowFocusListener\n     * @see #getWindowFocusListeners\n     * @since 1.4\n     */\n    public synchronized void removeWindowFocusListener(WindowFocusListener l) {\n        if (l == null) {\n            return;\n        }\n        windowFocusListener = AWTEventMulticaster.remove(windowFocusListener, l);\n    }"}
{"Number":"678","API Relative Path":"java.awt.Window.java-removeWindowFocusListener(WindowFocusListener)","Corresponding Source":"/**\n     * Removes the specified window focus listener so that it no longer\n     * receives window events from this window.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param   l the window focus listener\n     * @see #addWindowFocusListener\n     * @see #getWindowFocusListeners\n     * @since 1.4\n     */\n    public synchronized void removeWindowFocusListener(WindowFocusListener l) {\n        if (l == null) {\n            return;\n        }\n        windowFocusListener = AWTEventMulticaster.remove(windowFocusListener, l);\n    }"}
{"Number":"679","API Relative Path":"java.awt.Window.java-removeWindowListener(WindowListener)","Corresponding Source":"/**\n     * Removes the specified window listener so that it no longer\n     * receives window events from this window.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param   l the window listener\n     * @see #addWindowListener\n     * @see #getWindowListeners\n     */\n    public synchronized void removeWindowListener(WindowListener l) {\n        if (l == null) {\n            return;\n        }\n        windowListener = AWTEventMulticaster.remove(windowListener, l);\n    }"}
{"Number":"680","API Relative Path":"java.awt.Window.java-removeWindowListener(WindowListener)","Corresponding Source":"/**\n     * Removes the specified window listener so that it no longer\n     * receives window events from this window.\n     * If l is null, no exception is thrown and no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param   l the window listener\n     * @see #addWindowListener\n     * @see #getWindowListeners\n     */\n    public synchronized void removeWindowListener(WindowListener l) {\n        if (l == null) {\n            return;\n        }\n        windowListener = AWTEventMulticaster.remove(windowListener, l);\n    }"}
{"Number":"681","API Relative Path":"java.awt.Window.java-removeWindowStateListener(WindowStateListener)","Corresponding Source":"/**\n     * Removes the specified window state listener so that it no\n     * longer receives window events from this window.  If\n     * {@code l} is {@code null}, no exception is thrown and\n     * no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param   l the window state listener\n     * @see #addWindowStateListener\n     * @see #getWindowStateListeners\n     * @since 1.4\n     */\n    public synchronized void removeWindowStateListener(WindowStateListener l) {\n        if (l == null) {\n            return;\n        }\n        windowStateListener = AWTEventMulticaster.remove(windowStateListener, l);\n    }"}
{"Number":"682","API Relative Path":"java.awt.Window.java-removeWindowStateListener(WindowStateListener)","Corresponding Source":"/**\n     * Removes the specified window state listener so that it no\n     * longer receives window events from this window.  If\n     * {@code l} is {@code null}, no exception is thrown and\n     * no action is performed.\n     * <p>Refer to <a href=\"doc-files/AWTThreadIssues.html#ListenersThreads\"\n     * >AWT Threading Issues<\/a> for details on AWT's threading model.\n     *\n     * @param   l the window state listener\n     * @see #addWindowStateListener\n     * @see #getWindowStateListeners\n     * @since 1.4\n     */\n    public synchronized void removeWindowStateListener(WindowStateListener l) {\n        if (l == null) {\n            return;\n        }\n        windowStateListener = AWTEventMulticaster.remove(windowStateListener, l);\n    }"}
{"Number":"683","API Relative Path":"java.awt.Window.java-setBackground(Color)","Corresponding Source":"/**\n     * Sets the background color of this window.\n     * <p>\n     * If the windowing system supports the {@link\n     * GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT PERPIXEL_TRANSLUCENT}\n     * translucency, the alpha component of the given background color\n     * may effect the mode of operation for this window: it indicates whether\n     * this window must be opaque (alpha equals {@code 1.0f}) or per-pixel translucent\n     * (alpha is less than {@code 1.0f}). If the given background color is\n     * {@code null}, the window is considered completely opaque.\n     * <p>\n     * All the following conditions must be met to enable the per-pixel\n     * transparency mode for this window:\n     * <ul>\n     * <li>The {@link GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT\n     * PERPIXEL_TRANSLUCENT} translucency must be supported by the graphics\n     * device where this window is located\n     * <li>The window must be undecorated (see {@link Frame#setUndecorated}\n     * and {@link Dialog#setUndecorated})\n     * <li>The window must not be in full-screen mode (see {@link\n     * GraphicsDevice#setFullScreenWindow(Window)})\n     * <\/ul>\n     * <p>\n     * If the alpha component of the requested background color is less than\n     * {@code 1.0f}, and any of the above conditions are not met, the background\n     * color of this window will not change, the alpha component of the given\n     * background color will not affect the mode of operation for this window,\n     * and either the {@code UnsupportedOperationException} or {@code\n     * IllegalComponentStateException} will be thrown.\n     * <p>\n     * When the window is per-pixel translucent, the drawing sub-system\n     * respects the alpha value of each individual pixel. If a pixel gets\n     * painted with the alpha color component equal to zero, it becomes\n     * visually transparent. If the alpha of the pixel is equal to 1.0f, the\n     * pixel is fully opaque. Interim values of the alpha color component make\n     * the pixel semi-transparent. In this mode, the background of the window\n     * gets painted with the alpha value of the given background color. If the\n     * alpha value of the argument of this method is equal to {@code 0}, the\n     * background is not painted at all.\n     * <p>\n     * The actual level of translucency of a given pixel also depends on window\n     * opacity (see {@link #setOpacity(float)}), as well as the current shape of\n     * this window (see {@link #setShape(Shape)}).\n     * <p>\n     * Note that painting a pixel with the alpha value of {@code 0} may or may\n     * not disable the mouse event handling on this pixel. This is a\n     * platform-dependent behavior. To make sure the mouse events do not get\n     * dispatched to a particular pixel, the pixel must be excluded from the\n     * shape of the window.\n     * <p>\n     * Enabling the per-pixel translucency mode may change the graphics\n     * configuration of this window due to the native platform requirements.\n     *\n     * @param bgColor the color to become this window's background color.\n     *\n     * @throws IllegalComponentStateException if the alpha value of the given\n     *     background color is less than {@code 1.0f} and the window is decorated\n     * @throws IllegalComponentStateException if the alpha value of the given\n     *     background color is less than {@code 1.0f} and the window is in\n     *     full-screen mode\n     * @throws UnsupportedOperationException if the alpha value of the given\n     *     background color is less than {@code 1.0f} and {@link\n     *     GraphicsDevice.WindowTranslucency#PERPIXEL_TRANSLUCENT\n     *     PERPIXEL_TRANSLUCENT} translucency is not supported\n     *\n     * @see Window#getBackground\n     * @see Window#isOpaque\n     * @see Window#setOpacity(float)\n     * @see Window#setShape(Shape)\n     * @see Frame#isUndecorated\n     * @see Dialog#isUndecorated\n     * @see GraphicsDevice.WindowTranslucency\n     * @see GraphicsDevice#isWindowTranslucencySupported(GraphicsDevice.WindowTranslucency)\n     * @see GraphicsConfiguration#isTranslucencyCapable()\n     */\n    @Override\n    public void setBackground(Color bgColor) {\n        Color oldBg = getBackground();\n        super.setBackground(bgColor);\n        if (oldBg != null && oldBg.equals(bgColor)) {\n            return;\n        }\n        int oldAlpha = oldBg != null ? oldBg.getAlpha() : 255;\n        int alpha = bgColor != null ? bgColor.getAlpha() : 255;\n        if ((oldAlpha == 255) && (alpha < 255)) { // non-opaque window\n            GraphicsConfiguration gc = getGraphicsConfiguration();\n            GraphicsDevice gd = gc.getDevice();\n            if (gc.getDevice().getFullScreenWindow() == this) {\n                throw new IllegalComponentStateException(\n                    \"Making full-screen window non opaque is not supported.\");\n            }\n            if (!gc.isTranslucencyCapable()) {\n                GraphicsConfiguration capableGC = gd.getTranslucencyCapableGC();\n                if (capableGC == null) {\n                    throw new UnsupportedOperationException(\n                        \"PERPIXEL_TRANSLUCENT translucency is not supported\");\n                }\n                setGraphicsConfiguration(capableGC);\n            }\n            setLayersOpaque(this, false);\n        } else if ((oldAlpha < 255) && (alpha == 255)) {\n            setLayersOpaque(this, true);\n        }\n        WindowPeer peer = (WindowPeer)getPeer();\n        if (peer != null) {\n            peer.setOpaque(alpha == 255);\n        }\n    }"}
{"Number":"684","API Relative Path":"java.awt.Window.java-setOpacity(float)","Corresponding Source":"/**\n     * Sets the opacity of the window.\n     * <p>\n     * The opacity value is in the range [0..1]. Note that setting the opacity\n     * level of 0 may or may not disable the mouse event handling on this\n     * window. This is a platform-dependent behavior.\n     * <p>\n     * The following conditions must be met in order to set the opacity value\n     * less than {@code 1.0f}:\n     * <ul>\n     * <li>The {@link GraphicsDevice.WindowTranslucency#TRANSLUCENT TRANSLUCENT}\n     * translucency must be supported by the underlying system\n     * <li>The window must be undecorated (see {@link Frame#setUndecorated}\n     * and {@link Dialog#setUndecorated})\n     * <li>The window must not be in full-screen mode (see {@link\n     * GraphicsDevice#setFullScreenWindow(Window)})\n     * <\/ul>\n     * <p>\n     * If the requested opacity value is less than {@code 1.0f}, and any of the\n     * above conditions are not met, the window opacity will not change,\n     * and the {@code IllegalComponentStateException} will be thrown.\n     * <p>\n     * The translucency levels of individual pixels may also be effected by the\n     * alpha component of their color (see {@link Window#setBackground(Color)}) and the\n     * current shape of this window (see {@link #setShape(Shape)}).\n     *\n     * @param opacity the opacity level to set to the window\n     *\n     * @throws IllegalArgumentException if the opacity is out of the range\n     *     [0..1]\n     * @throws IllegalComponentStateException if the window is decorated and\n     *     the opacity is less than {@code 1.0f}\n     * @throws IllegalComponentStateException if the window is in full screen\n     *     mode, and the opacity is less than {@code 1.0f}\n     * @throws UnsupportedOperationException if the {@code\n     *     GraphicsDevice.WindowTranslucency#TRANSLUCENT TRANSLUCENT}\n     *     translucency is not supported and the opacity is less than\n     *     {@code 1.0f}\n     *\n     * @see Window#getOpacity\n     * @see Window#setBackground(Color)\n     * @see Window#setShape(Shape)\n     * @see Frame#isUndecorated\n     * @see Dialog#isUndecorated\n     * @see GraphicsDevice.WindowTranslucency\n     * @see GraphicsDevice#isWindowTranslucencySupported(GraphicsDevice.WindowTranslucency)\n     *\n     * @since 1.7\n     */\n    public void setOpacity(float opacity) {\n        synchronized (getTreeLock()) {\n            if (opacity < 0.0f || opacity > 1.0f) {\n                throw new IllegalArgumentException(\n                    \"The value of opacity should be in the range [0.0f .. 1.0f].\");\n            }\n            if (opacity < 1.0f) {\n                GraphicsConfiguration gc = getGraphicsConfiguration();\n                GraphicsDevice gd = gc.getDevice();\n                if (gc.getDevice().getFullScreenWindow() == this) {\n                    throw new IllegalComponentStateException(\n                        \"Setting opacity for full-screen window is not supported.\");\n                }\n                if (!gd.isWindowTranslucencySupported(\n                    GraphicsDevice.WindowTranslucency.TRANSLUCENT))\n                {\n                    throw new UnsupportedOperationException(\n                        \"TRANSLUCENT translucency is not supported.\");\n                }\n            }\n            this.opacity = opacity;\n            WindowPeer peer = (WindowPeer)getPeer();\n            if (peer != null) {\n                peer.setOpacity(opacity);\n            }\n        }\n    }"}
{"Number":"685","API Relative Path":"javafx.animation.FadeTransition.java-FadeTransition(Duration-Node)","Corresponding Source":"/**\n     * The constructor of {@code FadeTransition}\n     *\n     * @param duration\n     *            The duration of the {@code FadeTransition}\n     * @param node\n     *            The {@code node} which opacity will be animated\n     */\n    public FadeTransition(Duration duration, Node node) {\n        setDuration(duration);\n        setNode(node);\n        setCycleDuration(duration);\n    }"}
{"Number":"686","API Relative Path":"javafx.animation.FadeTransition.java-FadeTransition(Duration-Node)","Corresponding Source":"/**\n     * The constructor of {@code FadeTransition}\n     *\n     * @param duration\n     *            The duration of the {@code FadeTransition}\n     * @param node\n     *            The {@code node} which opacity will be animated\n     */\n    public FadeTransition(Duration duration, Node node) {\n        setDuration(duration);\n        setNode(node);\n        setCycleDuration(duration);\n    }"}
{"Number":"687","API Relative Path":"javafx.animation.FadeTransition.java-FadeTransition(Duration-Node)","Corresponding Source":"/**\n     * The constructor of {@code FadeTransition}\n     *\n     * @param duration\n     *            The duration of the {@code FadeTransition}\n     * @param node\n     *            The {@code node} which opacity will be animated\n     */\n    public FadeTransition(Duration duration, Node node) {\n        setDuration(duration);\n        setNode(node);\n        setCycleDuration(duration);\n    }"}
{"Number":"688","API Relative Path":"javafx.animation.FillTransition.java-FillTransition(Duration-Shape-Color-Color)","Corresponding Source":"/**\n     * The constructor of {@code FillTransition}\n     * @param duration The duration of the {@code FillTransition}\n     * @param shape The {@code shape} which filling will be animated\n     * @param fromValue The start value of the color-animation\n     * @param toValue The end value of the color-animation\n     */\n    public FillTransition(Duration duration, Shape shape, Color fromValue,\n            Color toValue) {\n        setDuration(duration);\n        setShape(shape);\n        setFromValue(fromValue);\n        setToValue(toValue);\n        setCycleDuration(duration);\n    }"}
{"Number":"689","API Relative Path":"javafx.animation.FillTransition.java-FillTransition(Duration-Shape-Color-Color)","Corresponding Source":"/**\n     * The constructor of {@code FillTransition}\n     * @param duration The duration of the {@code FillTransition}\n     * @param shape The {@code shape} which filling will be animated\n     * @param fromValue The start value of the color-animation\n     * @param toValue The end value of the color-animation\n     */\n    public FillTransition(Duration duration, Shape shape, Color fromValue,\n            Color toValue) {\n        setDuration(duration);\n        setShape(shape);\n        setFromValue(fromValue);\n        setToValue(toValue);\n        setCycleDuration(duration);\n    }"}
{"Number":"690","API Relative Path":"javafx.animation.FillTransition.java-FillTransition(Duration-Shape-Color-Color)","Corresponding Source":"/**\n     * The constructor of {@code FillTransition}\n     * @param duration The duration of the {@code FillTransition}\n     * @param shape The {@code shape} which filling will be animated\n     * @param fromValue The start value of the color-animation\n     * @param toValue The end value of the color-animation\n     */\n    public FillTransition(Duration duration, Shape shape, Color fromValue,\n            Color toValue) {\n        setDuration(duration);\n        setShape(shape);\n        setFromValue(fromValue);\n        setToValue(toValue);\n        setCycleDuration(duration);\n    }"}
{"Number":"691","API Relative Path":"javafx.animation.FillTransition.java-FillTransition(Duration-Shape-Color-Color)","Corresponding Source":"/**\n     * The constructor of {@code FillTransition}\n     * @param duration The duration of the {@code FillTransition}\n     * @param shape The {@code shape} which filling will be animated\n     * @param fromValue The start value of the color-animation\n     * @param toValue The end value of the color-animation\n     */\n    public FillTransition(Duration duration, Shape shape, Color fromValue,\n            Color toValue) {\n        setDuration(duration);\n        setShape(shape);\n        setFromValue(fromValue);\n        setToValue(toValue);\n        setCycleDuration(duration);\n    }"}
{"Number":"692","API Relative Path":"javafx.animation.FillTransition.java-FillTransition(Duration-Shape-Color-Color)","Corresponding Source":"/**\n     * The constructor of {@code FillTransition}\n     * @param duration The duration of the {@code FillTransition}\n     * @param shape The {@code shape} which filling will be animated\n     * @param fromValue The start value of the color-animation\n     * @param toValue The end value of the color-animation\n     */\n    public FillTransition(Duration duration, Shape shape, Color fromValue,\n            Color toValue) {\n        setDuration(duration);\n        setShape(shape);\n        setFromValue(fromValue);\n        setToValue(toValue);\n        setCycleDuration(duration);\n    }"}
{"Number":"693","API Relative Path":"javafx.animation.Interpolator.java-SPLINE(double-double-double-double)","Corresponding Source":"/**\n     * Creates an {@code Interpolator}, which {@link #curve(double) curve()} is\n     * shaped using the spline control points defined by ({@code x1}, {@code y1}\n     * ) and ({@code x2}, {@code y2}). The anchor points of the spline are\n     * implicitly defined as ({@code 0.0}, {@code 0.0}) and ({@code 1.0},\n     * {@code 1.0}).\n     *\n     * @param x1\n     *            x coordinate of the first control point\n     * @param y1\n     *            y coordinate of the first control point\n     * @param x2\n     *            x coordinate of the second control point\n     * @param y2\n     *            y coordinate of the second control point\n     * @return A spline interpolator\n     */\n    public static Interpolator SPLINE(double x1, double y1, double x2, double y2) {\n        return new SplineInterpolator(x1, y1, x2, y2);\n    }"}
{"Number":"694","API Relative Path":"javafx.animation.KeyValue.java-KeyValue(WritableValue-T-Interpolator)","Corresponding Source":"/**\n     * Creates a {@code KeyValue}.\n     *\n     * @param target\n     *            the target\n     * @param endValue\n     *            the end value\n     * @param interpolator\n     *            the {@link Interpolator}\n     * @throws NullPointerException\n     *             if {@code target} or {@code interpolator} are {@code null}\n     */\n    public <T> KeyValue(@NamedArg(\"target\") WritableValue<T> target, @NamedArg(\"endValue\") T endValue,\n            @NamedArg(\"interpolator\") Interpolator interpolator) {\n        if (target == null) {\n            throw new NullPointerException(\"Target needs to be specified\");\n        }\n        if (interpolator == null) {\n            throw new NullPointerException(\"Interpolator needs to be specified\");\n        }\n\n        this.target = target;\n        this.endValue = endValue;\n        this.interpolator = interpolator;\n        this.type = (target instanceof WritableNumberValue) ? (target instanceof WritableDoubleValue) ? Type.DOUBLE\n                : (target instanceof WritableIntegerValue) ? Type.INTEGER\n                        : (target instanceof WritableFloatValue) ? Type.FLOAT\n                                : (target instanceof WritableLongValue) ? Type.LONG\n                                        : Type.OBJECT\n                : (target instanceof WritableBooleanValue) ? Type.BOOLEAN\n                        : Type.OBJECT;\n    }"}
{"Number":"695","API Relative Path":"javafx.animation.ParallelTransition.java-ParallelTransition(Node)","Corresponding Source":"/**\n     * The constructor of {@code ParallelTransition}.\n     *\n     * @param node\n     *            The target {@link javafx.scene.Node} to be used in child\n     *            {@link Transition Transitions} that have no {@code Node} specified\n     *            themselves\n     */\n    public ParallelTransition(Node node) {\n        setInterpolator(Interpolator.LINEAR);\n        setNode(node);\n    }"}
{"Number":"696","API Relative Path":"javafx.animation.PathTransition.java-PathTransition(Duration-Shape-Node)","Corresponding Source":"/**\n     * The constructor of {@code PathTransition}.\n     *\n     * @param duration\n     *            The {@link #duration} of this {@code PathTransition}\n     * @param path\n     *            The {@link #path} of this {@code PathTransition}\n     * @param node\n     *            The {@link #node} of this {@code PathTransition}\n     */\n    public PathTransition(Duration duration, Shape path, Node node) {\n        setDuration(duration);\n        setPath(path);\n        setNode(node);\n        setCycleDuration(duration);\n    }"}
{"Number":"697","API Relative Path":"javafx.animation.PathTransition.java-PathTransition(Duration-Shape-Node)","Corresponding Source":"/**\n     * The constructor of {@code PathTransition}.\n     *\n     * @param duration\n     *            The {@link #duration} of this {@code PathTransition}\n     * @param path\n     *            The {@link #path} of this {@code PathTransition}\n     * @param node\n     *            The {@link #node} of this {@code PathTransition}\n     */\n    public PathTransition(Duration duration, Shape path, Node node) {\n        setDuration(duration);\n        setPath(path);\n        setNode(node);\n        setCycleDuration(duration);\n    }"}
{"Number":"698","API Relative Path":"javafx.animation.PathTransition.java-PathTransition(Duration-Shape-Node)","Corresponding Source":"/**\n     * The constructor of {@code PathTransition}.\n     *\n     * @param duration\n     *            The {@link #duration} of this {@code PathTransition}\n     * @param path\n     *            The {@link #path} of this {@code PathTransition}\n     * @param node\n     *            The {@link #node} of this {@code PathTransition}\n     */\n    public PathTransition(Duration duration, Shape path, Node node) {\n        setDuration(duration);\n        setPath(path);\n        setNode(node);\n        setCycleDuration(duration);\n    }"}
{"Number":"699","API Relative Path":"javafx.animation.PathTransition.java-PathTransition(Duration-Shape-Node)","Corresponding Source":"/**\n     * The constructor of {@code PathTransition}.\n     *\n     * @param duration\n     *            The {@link #duration} of this {@code PathTransition}\n     * @param path\n     *            The {@link #path} of this {@code PathTransition}\n     * @param node\n     *            The {@link #node} of this {@code PathTransition}\n     */\n    public PathTransition(Duration duration, Shape path, Node node) {\n        setDuration(duration);\n        setPath(path);\n        setNode(node);\n        setCycleDuration(duration);\n    }"}
{"Number":"700","API Relative Path":"javafx.animation.PauseTransition.java-PauseTransition(Duration)","Corresponding Source":"/**\n     * The constructor of {@code PauseTransition}.\n     *\n     * @param duration\n     *            The duration of the {@code PauseTransition}\n     */\n    public PauseTransition(Duration duration) {\n        setDuration(duration);\n        setCycleDuration(duration);\n    }"}
{"Number":"701","API Relative Path":"javafx.animation.PauseTransition.java-PauseTransition(Duration)","Corresponding Source":"/**\n     * The constructor of {@code PauseTransition}.\n     *\n     * @param duration\n     *            The duration of the {@code PauseTransition}\n     */\n    public PauseTransition(Duration duration) {\n        setDuration(duration);\n        setCycleDuration(duration);\n    }"}
{"Number":"702","API Relative Path":"javafx.animation.RotateTransition.java-RotateTransition(Duration-Node)","Corresponding Source":"/**\n     * The constructor of {@code RotateTransition}\n     *\n     * @param duration\n     *            The duration of the {@code RotateTransition}\n     * @param node\n     *            The {@code node} which will be rotated\n     */\n    public RotateTransition(Duration duration, Node node) {\n        setDuration(duration);\n        setNode(node);\n        setCycleDuration(duration);\n    }"}
{"Number":"703","API Relative Path":"javafx.animation.RotateTransition.java-RotateTransition(Duration-Node)","Corresponding Source":"/**\n     * The constructor of {@code RotateTransition}\n     *\n     * @param duration\n     *            The duration of the {@code RotateTransition}\n     * @param node\n     *            The {@code node} which will be rotated\n     */\n    public RotateTransition(Duration duration, Node node) {\n        setDuration(duration);\n        setNode(node);\n        setCycleDuration(duration);\n    }"}
{"Number":"704","API Relative Path":"javafx.animation.RotateTransition.java-RotateTransition(Duration-Node)","Corresponding Source":"/**\n     * The constructor of {@code RotateTransition}\n     *\n     * @param duration\n     *            The duration of the {@code RotateTransition}\n     * @param node\n     *            The {@code node} which will be rotated\n     */\n    public RotateTransition(Duration duration, Node node) {\n        setDuration(duration);\n        setNode(node);\n        setCycleDuration(duration);\n    }"}
{"Number":"705","API Relative Path":"javafx.animation.ScaleTransition.java-ScaleTransition(Duration-Node)","Corresponding Source":"/**\n     * The constructor of {@code ScaleTransition}\n     *\n     * @param duration\n     *            The duration of the {@code ScaleTransition}\n     * @param node\n     *            The {@code node} which will be scaled\n     */\n    public ScaleTransition(Duration duration, Node node) {\n        setDuration(duration);\n        setNode(node);\n        setCycleDuration(duration);\n    }"}
{"Number":"706","API Relative Path":"javafx.animation.ScaleTransition.java-ScaleTransition(Duration-Node)","Corresponding Source":"/**\n     * The constructor of {@code ScaleTransition}\n     *\n     * @param duration\n     *            The duration of the {@code ScaleTransition}\n     * @param node\n     *            The {@code node} which will be scaled\n     */\n    public ScaleTransition(Duration duration, Node node) {\n        setDuration(duration);\n        setNode(node);\n        setCycleDuration(duration);\n    }"}
{"Number":"707","API Relative Path":"javafx.animation.ScaleTransition.java-ScaleTransition(Duration-Node)","Corresponding Source":"/**\n     * The constructor of {@code ScaleTransition}\n     *\n     * @param duration\n     *            The duration of the {@code ScaleTransition}\n     * @param node\n     *            The {@code node} which will be scaled\n     */\n    public ScaleTransition(Duration duration, Node node) {\n        setDuration(duration);\n        setNode(node);\n        setCycleDuration(duration);\n    }"}
{"Number":"708","API Relative Path":"javafx.animation.SequentialTransition.java-SequentialTransition(Node)","Corresponding Source":"/**\n     * The constructor of {@code SequentialTransition}.\n     *\n     * @param node\n     *            The target {@link javafx.scene.Node} to be used in child\n     *            {@link Transition Transitions} that have no {@code Node} specified\n     *            themselves\n     */\n    public SequentialTransition(Node node) {\n        setInterpolator(Interpolator.LINEAR);\n        setNode(node);\n    }"}
{"Number":"709","API Relative Path":"javafx.animation.StrokeTransition.java-StrokeTransition(Duration-Shape-Color-Color)","Corresponding Source":"/**\n     * The constructor of {@code StrokeTransition}\n     * @param duration The duration of the {@code StrokeTransition}\n     * @param shape The {@code shape} which filling will be animated\n     * @param fromValue The start value of the color-animation\n     * @param toValue The end value of the color-animation\n     */\n    public StrokeTransition(Duration duration, Shape shape, Color fromValue,\n            Color toValue) {\n        setDuration(duration);\n        setShape(shape);\n        setFromValue(fromValue);\n        setToValue(toValue);\n        setCycleDuration(duration);\n    }"}
{"Number":"710","API Relative Path":"javafx.animation.StrokeTransition.java-StrokeTransition(Duration-Shape-Color-Color)","Corresponding Source":"/**\n     * The constructor of {@code StrokeTransition}\n     * @param duration The duration of the {@code StrokeTransition}\n     * @param shape The {@code shape} which filling will be animated\n     * @param fromValue The start value of the color-animation\n     * @param toValue The end value of the color-animation\n     */\n    public StrokeTransition(Duration duration, Shape shape, Color fromValue,\n            Color toValue) {\n        setDuration(duration);\n        setShape(shape);\n        setFromValue(fromValue);\n        setToValue(toValue);\n        setCycleDuration(duration);\n    }"}
{"Number":"711","API Relative Path":"javafx.animation.StrokeTransition.java-StrokeTransition(Duration-Shape-Color-Color)","Corresponding Source":"/**\n     * The constructor of {@code StrokeTransition}\n     * @param duration The duration of the {@code StrokeTransition}\n     * @param shape The {@code shape} which filling will be animated\n     * @param fromValue The start value of the color-animation\n     * @param toValue The end value of the color-animation\n     */\n    public StrokeTransition(Duration duration, Shape shape, Color fromValue,\n            Color toValue) {\n        setDuration(duration);\n        setShape(shape);\n        setFromValue(fromValue);\n        setToValue(toValue);\n        setCycleDuration(duration);\n    }"}
{"Number":"712","API Relative Path":"javafx.animation.StrokeTransition.java-StrokeTransition(Duration-Shape-Color-Color)","Corresponding Source":"/**\n     * The constructor of {@code StrokeTransition}\n     * @param duration The duration of the {@code StrokeTransition}\n     * @param shape The {@code shape} which filling will be animated\n     * @param fromValue The start value of the color-animation\n     * @param toValue The end value of the color-animation\n     */\n    public StrokeTransition(Duration duration, Shape shape, Color fromValue,\n            Color toValue) {\n        setDuration(duration);\n        setShape(shape);\n        setFromValue(fromValue);\n        setToValue(toValue);\n        setCycleDuration(duration);\n    }"}
{"Number":"713","API Relative Path":"javafx.animation.StrokeTransition.java-StrokeTransition(Duration-Shape-Color-Color)","Corresponding Source":"/**\n     * The constructor of {@code StrokeTransition}\n     * @param duration The duration of the {@code StrokeTransition}\n     * @param shape The {@code shape} which filling will be animated\n     * @param fromValue The start value of the color-animation\n     * @param toValue The end value of the color-animation\n     */\n    public StrokeTransition(Duration duration, Shape shape, Color fromValue,\n            Color toValue) {\n        setDuration(duration);\n        setShape(shape);\n        setFromValue(fromValue);\n        setToValue(toValue);\n        setCycleDuration(duration);\n    }"}
{"Number":"714","API Relative Path":"javafx.animation.TranslateTransition.java-TranslateTransition(Duration-Node)","Corresponding Source":"/**\n     * The constructor of {@code TranslateTransition}\n     *\n     * @param duration\n     *            The duration of the {@code TranslateTransition}\n     * @param node\n     *            The {@code node} which will be translated\n     */\n    public TranslateTransition(Duration duration, Node node) {\n        setDuration(duration);\n        setNode(node);\n        setCycleDuration(duration);\n    }"}
{"Number":"715","API Relative Path":"javafx.animation.TranslateTransition.java-TranslateTransition(Duration-Node)","Corresponding Source":"/**\n     * The constructor of {@code TranslateTransition}\n     *\n     * @param duration\n     *            The duration of the {@code TranslateTransition}\n     * @param node\n     *            The {@code node} which will be translated\n     */\n    public TranslateTransition(Duration duration, Node node) {\n        setDuration(duration);\n        setNode(node);\n        setCycleDuration(duration);\n    }"}
{"Number":"716","API Relative Path":"javafx.animation.TranslateTransition.java-TranslateTransition(Duration-Node)","Corresponding Source":"/**\n     * The constructor of {@code TranslateTransition}\n     *\n     * @param duration\n     *            The duration of the {@code TranslateTransition}\n     * @param node\n     *            The {@code node} which will be translated\n     */\n    public TranslateTransition(Duration duration, Node node) {\n        setDuration(duration);\n        setNode(node);\n        setCycleDuration(duration);\n    }"}
{"Number":"717","API Relative Path":"javafx.beans.binding.Bindings.java-and(ObservableBooleanValue-ObservableBooleanValue)","Corresponding Source":"/**\n     * Creates a {@link BooleanBinding} that calculates the conditional-AND\n     * operation on the value of two instance of\n     * {@link javafx.beans.value.ObservableBooleanValue}.\n     *\n     * @param op1\n     *            first {@code ObservableBooleanValue}\n     * @param op2\n     *            second {@code ObservableBooleanValue}\n     * @return the new {@code BooleanBinding}\n     * @throws NullPointerException\n     *             if one of the operands is {@code null}\n     */\n    public static BooleanBinding and(final ObservableBooleanValue op1, final ObservableBooleanValue op2) {\n        if ((op1 == null) || (op2 == null)) {\n            throw new NullPointerException(\"Operands cannot be null.\");\n        }\n\n        return new BooleanAndBinding(op1, op2);\n    }"}
{"Number":"718","API Relative Path":"javafx.beans.binding.Bindings.java-bindBidirectional(Property-Property)","Corresponding Source":"/**\n     * Delete a bidirectional binding that was previously defined with\n     * {@link #bindBidirectional(Property, Property)}.\n     *\n     * @param <T>\n     *            the types of the properties\n     * @param property1\n     *            the first {@code Property<T>}\n     * @param property2\n     *            the second {@code Property<T>}\n     * @throws NullPointerException\n     *            if one of the properties is {@code null}\n     * @throws IllegalArgumentException\n     *            if both properties are equal\n     */\n    public static <T> void unbindBidirectional(Property<T> property1, Property<T> property2) {\n        BidirectionalBinding.unbind(property1, property2);\n    }"}
{"Number":"719","API Relative Path":"javafx.beans.binding.Bindings.java-bindBidirectional(Property-Property)","Corresponding Source":"/**\n     * Delete a bidirectional binding that was previously defined with\n     * {@link #bindBidirectional(Property, Property)}.\n     *\n     * @param <T>\n     *            the types of the properties\n     * @param property1\n     *            the first {@code Property<T>}\n     * @param property2\n     *            the second {@code Property<T>}\n     * @throws NullPointerException\n     *            if one of the properties is {@code null}\n     * @throws IllegalArgumentException\n     *            if both properties are equal\n     */\n    public static <T> void unbindBidirectional(Property<T> property1, Property<T> property2) {\n        BidirectionalBinding.unbind(property1, property2);\n    }"}
{"Number":"720","API Relative Path":"javafx.beans.binding.Bindings.java-bindBidirectional(Property-Property-Format)","Corresponding Source":"/**\n     * Generates a bidirectional binding (or \"bind with inverse\") between a\n     * {@code String}-{@link javafx.beans.property.Property} and another {@code Property}\n     * using the specified {@code Format} for conversion.\n     * <p>\n     * A bidirectional binding is a binding that works in both directions. If\n     * two properties {@code a} and {@code b} are linked with a bidirectional\n     * binding and the value of {@code a} changes, {@code b} is set to the same\n     * value automatically. And vice versa, if {@code b} changes, {@code a} is\n     * set to the same value.\n     * <p>\n     * A bidirectional binding can be removed with\n     * {@link #unbindBidirectional(Object, Object)}.\n     * <p>\n     * Note: this implementation of a bidirectional binding behaves differently\n     * from all other bindings here in two important aspects. A property that is\n     * linked to another property with a bidirectional binding can still be set\n     * (usually bindings would throw an exception). Secondly bidirectional\n     * bindings are calculated eagerly, i.e. a bound property is updated\n     * immediately.\n     *\n     * @param stringProperty\n     *            the {@code String} {@code Property}\n     * @param otherProperty\n     *            the other (non-{@code String}) {@code Property}\n     * @param format\n     *            the {@code Format} used to convert between the properties\n     * @throws NullPointerException\n     *            if one of the properties or the {@code format} is {@code null}\n     * @throws IllegalArgumentException\n     *            if both properties are equal\n     * @since JavaFX 2.1\n     */\n    public  static void bindBidirectional(Property<String> stringProperty, Property<?> otherProperty, Format format) {\n        BidirectionalBinding.bind(stringProperty, otherProperty, format);\n    }"}
{"Number":"721","API Relative Path":"javafx.beans.binding.Bindings.java-bindBidirectional(Property-Property-Format)","Corresponding Source":"/**\n     * Generates a bidirectional binding (or \"bind with inverse\") between a\n     * {@code String}-{@link javafx.beans.property.Property} and another {@code Property}\n     * using the specified {@code Format} for conversion.\n     * <p>\n     * A bidirectional binding is a binding that works in both directions. If\n     * two properties {@code a} and {@code b} are linked with a bidirectional\n     * binding and the value of {@code a} changes, {@code b} is set to the same\n     * value automatically. And vice versa, if {@code b} changes, {@code a} is\n     * set to the same value.\n     * <p>\n     * A bidirectional binding can be removed with\n     * {@link #unbindBidirectional(Object, Object)}.\n     * <p>\n     * Note: this implementation of a bidirectional binding behaves differently\n     * from all other bindings here in two important aspects. A property that is\n     * linked to another property with a bidirectional binding can still be set\n     * (usually bindings would throw an exception). Secondly bidirectional\n     * bindings are calculated eagerly, i.e. a bound property is updated\n     * immediately.\n     *\n     * @param stringProperty\n     *            the {@code String} {@code Property}\n     * @param otherProperty\n     *            the other (non-{@code String}) {@code Property}\n     * @param format\n     *            the {@code Format} used to convert between the properties\n     * @throws NullPointerException\n     *            if one of the properties or the {@code format} is {@code null}\n     * @throws IllegalArgumentException\n     *            if both properties are equal\n     * @since JavaFX 2.1\n     */\n    public  static void bindBidirectional(Property<String> stringProperty, Property<?> otherProperty, Format format) {\n        BidirectionalBinding.bind(stringProperty, otherProperty, format);\n    }"}
{"Number":"722","API Relative Path":"javafx.beans.binding.Bindings.java-bindBidirectional(Property-Property-StringConverter)","Corresponding Source":"/**\n     * Generates a bidirectional binding (or \"bind with inverse\") between a\n     * {@code String}-{@link javafx.beans.property.Property} and another {@code Property}\n     * using the specified {@link javafx.util.StringConverter} for conversion.\n     * <p>\n     * A bidirectional binding is a binding that works in both directions. If\n     * two properties {@code a} and {@code b} are linked with a bidirectional\n     * binding and the value of {@code a} changes, {@code b} is set to the same\n     * value automatically. And vice versa, if {@code b} changes, {@code a} is\n     * set to the same value.\n     * <p>\n     * A bidirectional binding can be removed with\n     * {@link #unbindBidirectional(Object, Object)}.\n     * <p>\n     * Note: this implementation of a bidirectional binding behaves differently\n     * from all other bindings here in two important aspects. A property that is\n     * linked to another property with a bidirectional binding can still be set\n     * (usually bindings would throw an exception). Secondly bidirectional\n     * bindings are calculated eagerly, i.e. a bound property is updated\n     * immediately.\n     *\n     * @param stringProperty\n     *            the {@code String} {@code Property}\n     * @param otherProperty\n     *            the other (non-{@code String}) {@code Property}\n     * @param converter\n     *            the {@code StringConverter} used to convert between the properties\n     * @throws NullPointerException\n     *            if one of the properties or the {@code converter} is {@code null}\n     * @throws IllegalArgumentException\n     *            if both properties are equal\n     * @since JavaFX 2.1\n     */\n    public static <T> void bindBidirectional(Property<String> stringProperty, Property<T> otherProperty, StringConverter<T> converter) {\n        BidirectionalBinding.bind(stringProperty, otherProperty, converter);\n    }"}
{"Number":"723","API Relative Path":"javafx.beans.binding.Bindings.java-bindBidirectional(Property-Property-StringConverter)","Corresponding Source":"/**\n     * Generates a bidirectional binding (or \"bind with inverse\") between a\n     * {@code String}-{@link javafx.beans.property.Property} and another {@code Property}\n     * using the specified {@link javafx.util.StringConverter} for conversion.\n     * <p>\n     * A bidirectional binding is a binding that works in both directions. If\n     * two properties {@code a} and {@code b} are linked with a bidirectional\n     * binding and the value of {@code a} changes, {@code b} is set to the same\n     * value automatically. And vice versa, if {@code b} changes, {@code a} is\n     * set to the same value.\n     * <p>\n     * A bidirectional binding can be removed with\n     * {@link #unbindBidirectional(Object, Object)}.\n     * <p>\n     * Note: this implementation of a bidirectional binding behaves differently\n     * from all other bindings here in two important aspects. A property that is\n     * linked to another property with a bidirectional binding can still be set\n     * (usually bindings would throw an exception). Secondly bidirectional\n     * bindings are calculated eagerly, i.e. a bound property is updated\n     * immediately.\n     *\n     * @param stringProperty\n     *            the {@code String} {@code Property}\n     * @param otherProperty\n     *            the other (non-{@code String}) {@code Property}\n     * @param converter\n     *            the {@code StringConverter} used to convert between the properties\n     * @throws NullPointerException\n     *            if one of the properties or the {@code converter} is {@code null}\n     * @throws IllegalArgumentException\n     *            if both properties are equal\n     * @since JavaFX 2.1\n     */\n    public static <T> void bindBidirectional(Property<String> stringProperty, Property<T> otherProperty, StringConverter<T> converter) {\n        BidirectionalBinding.bind(stringProperty, otherProperty, converter);\n    }"}
{"Number":"724","API Relative Path":"javafx.beans.binding.Bindings.java-bindContent(List-ObservableList)","Corresponding Source":"/**\n     * Generates a content binding between an {@link javafx.collections.ObservableList} and a {@link java.util.List}.\n     * <p>\n     * A content binding ensures that the {@code List} contains the same elements as the {@code ObservableList}.\n     * If the content of the {@code ObservableList} changes, the {@code List} will be updated automatically.\n     * <p>\n     * Once a {@code List} is bound to an {@code ObservableList}, the {@code List} must not be changed directly\n     * anymore. Doing so would lead to unexpected results.\n     * <p>\n     * A content-binding can be removed with {@link #unbindContent(Object, Object)}.\n     *\n     * @param <E>\n     *            the type of the {@code List} elements\n     * @param list1\n     *            the {@code List}\n     * @param list2\n     *            the {@code ObservableList}\n     * @since JavaFX 2.1\n     */\n    public static <E> void bindContent(List<E> list1, ObservableList<? extends E> list2) {\n        ContentBinding.bind(list1, list2);\n    }"}
{"Number":"725","API Relative Path":"javafx.beans.binding.Bindings.java-bindContent(List-ObservableList)","Corresponding Source":"/**\n     * Generates a content binding between an {@link javafx.collections.ObservableList} and a {@link java.util.List}.\n     * <p>\n     * A content binding ensures that the {@code List} contains the same elements as the {@code ObservableList}.\n     * If the content of the {@code ObservableList} changes, the {@code List} will be updated automatically.\n     * <p>\n     * Once a {@code List} is bound to an {@code ObservableList}, the {@code List} must not be changed directly\n     * anymore. Doing so would lead to unexpected results.\n     * <p>\n     * A content-binding can be removed with {@link #unbindContent(Object, Object)}.\n     *\n     * @param <E>\n     *            the type of the {@code List} elements\n     * @param list1\n     *            the {@code List}\n     * @param list2\n     *            the {@code ObservableList}\n     * @since JavaFX 2.1\n     */\n    public static <E> void bindContent(List<E> list1, ObservableList<? extends E> list2) {\n        ContentBinding.bind(list1, list2);\n    }"}
{"Number":"726","API Relative Path":"javafx.beans.binding.Bindings.java-bindContent(Map-ObservableMap)","Corresponding Source":"/**\n     * Generates a content binding between an {@link javafx.collections.ObservableMap} and a {@link java.util.Map}.\n     * <p>\n     * A content binding ensures that the {@code Map} contains the same elements as the {@code ObservableMap}.\n     * If the content of the {@code ObservableMap} changes, the {@code Map} will be updated automatically.\n     * <p>\n     * Once a {@code Map} is bound to an {@code ObservableMap}, the {@code Map} must not be changed directly\n     * anymore. Doing so would lead to unexpected results.\n     * <p>\n     * A content-binding can be removed with {@link #unbindContent(Object, Object)}.\n     *\n     * @param <K>\n     *            the type of the key elements of the {@code Map}\n     * @param <V>\n     *            the type of the value elements of the {@code Map}\n     * @param map1\n     *            the {@code Map}\n     * @param map2\n     *            the {@code ObservableMap}\n     * @throws NullPointerException\n     *            if one of the maps is {@code null}\n     * @throws IllegalArgumentException\n     *            if {@code map1} == {@code map2}\n     * @since JavaFX 2.1\n     */\n    public static <K, V> void bindContent(Map<K, V> map1, ObservableMap<? extends K, ? extends V> map2) {\n        ContentBinding.bind(map1, map2);\n    }"}
{"Number":"727","API Relative Path":"javafx.beans.binding.Bindings.java-bindContent(Set-ObservableSet)","Corresponding Source":"/**\n     * Generates a content binding between an {@link javafx.collections.ObservableSet} and a {@link java.util.Set}.\n     * <p>\n     * A content binding ensures that the {@code Set} contains the same elements as the {@code ObservableSet}.\n     * If the content of the {@code ObservableSet} changes, the {@code Set} will be updated automatically.\n     * <p>\n     * Once a {@code Set} is bound to an {@code ObservableSet}, the {@code Set} must not be changed directly\n     * anymore. Doing so would lead to unexpected results.\n     * <p>\n     * A content-binding can be removed with {@link #unbindContent(Object, Object)}.\n     *\n     * @param <E>\n     *            the type of the {@code Set} elements\n     * @param set1\n     *            the {@code Set}\n     * @param set2\n     *            the {@code ObservableSet}\n     * @throws NullPointerException\n     *            if one of the sets is {@code null}\n     * @throws IllegalArgumentException\n     *            if {@code set1} == {@code set2}\n     * @since JavaFX 2.1\n     */\n    public static <E> void bindContent(Set<E> set1, ObservableSet<? extends E> set2) {\n        ContentBinding.bind(set1, set2);\n    }"}
{"Number":"728","API Relative Path":"javafx.beans.binding.Bindings.java-bindContentBidirectional(ObservableList-ObservableList)","Corresponding Source":"/**\n     * Generates a bidirectional binding (or \"bind with inverse\") between two\n     * instances of {@link javafx.collections.ObservableList}.\n     * <p>\n     * A bidirectional binding is a binding that works in both directions. If\n     * two properties {@code a} and {@code b} are linked with a bidirectional\n     * binding and the value of {@code a} changes, {@code b} is set to the same\n     * value automatically. And vice versa, if {@code b} changes, {@code a} is\n     * set to the same value.\n     * <p>\n     * Only the content of the two lists is synchronized, which means that\n     * both lists are different, but they contain the same elements.\n     * <p>\n     * A bidirectional content-binding can be removed with\n     * {@link #unbindContentBidirectional(Object, Object)}.\n     * <p>\n     * Note: this implementation of a bidirectional binding behaves differently\n     * from all other bindings here in two important aspects. A property that is\n     * linked to another property with a bidirectional binding can still be set\n     * (usually bindings would throw an exception). Secondly bidirectional\n     * bindings are calculated eagerly, i.e. a bound property is updated\n     * immediately.\n     *\n     * @param <E>\n     *            the type of the list elements\n     * @param list1\n     *            the first {@code ObservableList<E>}\n     * @param list2\n     *            the second {@code ObservableList<E>}\n     * @throws NullPointerException\n     *            if one of the lists is {@code null}\n     * @throws IllegalArgumentException\n     *            if {@code list1} == {@code list2}\n     * @since JavaFX 2.1\n     */\n    public static <E> void bindContentBidirectional(ObservableList<E> list1, ObservableList<E> list2) {\n        BidirectionalContentBinding.bind(list1, list2);\n    }"}
{"Number":"729","API Relative Path":"javafx.beans.binding.Bindings.java-bindContentBidirectional(ObservableMap-ObservableMap)","Corresponding Source":"/**\n     * Generates a bidirectional binding (or \"bind with inverse\") between two\n     * instances of {@link javafx.collections.ObservableMap}.\n     * <p>\n     * A bidirectional binding is a binding that works in both directions. If\n     * two properties {@code a} and {@code b} are linked with a bidirectional\n     * binding and the value of {@code a} changes, {@code b} is set to the same\n     * value automatically. And vice versa, if {@code b} changes, {@code a} is\n     * set to the same value.\n     * <p>\n     * Only the content of the two maps is synchronized, which means that\n     * both maps are different, but they contain the same elements.\n     * <p>\n     * A bidirectional content-binding can be removed with\n     * {@link #unbindContentBidirectional(Object, Object)}.\n     * <p>\n     * Note: this implementation of a bidirectional binding behaves differently\n     * from all other bindings here in two important aspects. A property that is\n     * linked to another property with a bidirectional binding can still be set\n     * (usually bindings would throw an exception). Secondly bidirectional\n     * bindings are calculated eagerly, i.e. a bound property is updated\n     * immediately.\n     *\n     * @param <K>\n     *            the type of the key elements\n     * @param <V>\n     *            the type of the value elements\n     * @param map1\n     *            the first {@code ObservableMap<K, V>}\n     * @param map2\n     *            the second {@code ObservableMap<K, V>}\n     * @since JavaFX 2.1\n     */\n    public static <K, V> void bindContentBidirectional(ObservableMap<K, V> map1, ObservableMap<K, V> map2) {\n        BidirectionalContentBinding.bind(map1, map2);\n    }"}
{"Number":"730","API Relative Path":"javafx.beans.binding.Bindings.java-bindContentBidirectional(ObservableMap-ObservableMap)","Corresponding Source":"/**\n     * Generates a bidirectional binding (or \"bind with inverse\") between two\n     * instances of {@link javafx.collections.ObservableMap}.\n     * <p>\n     * A bidirectional binding is a binding that works in both directions. If\n     * two properties {@code a} and {@code b} are linked with a bidirectional\n     * binding and the value of {@code a} changes, {@code b} is set to the same\n     * value automatically. And vice versa, if {@code b} changes, {@code a} is\n     * set to the same value.\n     * <p>\n     * Only the content of the two maps is synchronized, which means that\n     * both maps are different, but they contain the same elements.\n     * <p>\n     * A bidirectional content-binding can be removed with\n     * {@link #unbindContentBidirectional(Object, Object)}.\n     * <p>\n     * Note: this implementation of a bidirectional binding behaves differently\n     * from all other bindings here in two important aspects. A property that is\n     * linked to another property with a bidirectional binding can still be set\n     * (usually bindings would throw an exception). Secondly bidirectional\n     * bindings are calculated eagerly, i.e. a bound property is updated\n     * immediately.\n     *\n     * @param <K>\n     *            the type of the key elements\n     * @param <V>\n     *            the type of the value elements\n     * @param map1\n     *            the first {@code ObservableMap<K, V>}\n     * @param map2\n     *            the second {@code ObservableMap<K, V>}\n     * @since JavaFX 2.1\n     */\n    public static <K, V> void bindContentBidirectional(ObservableMap<K, V> map1, ObservableMap<K, V> map2) {\n        BidirectionalContentBinding.bind(map1, map2);\n    }"}
{"Number":"731","API Relative Path":"javafx.beans.binding.Bindings.java-bindContentBidirectional(ObservableSet-ObservableSet)","Corresponding Source":"/**\n     * Generates a bidirectional binding (or \"bind with inverse\") between two\n     * instances of {@link javafx.collections.ObservableSet}.\n     * <p>\n     * A bidirectional binding is a binding that works in both directions. If\n     * two properties {@code a} and {@code b} are linked with a bidirectional\n     * binding and the value of {@code a} changes, {@code b} is set to the same\n     * value automatically. And vice versa, if {@code b} changes, {@code a} is\n     * set to the same value.\n     * <p>\n     * Only the content of the two sets is synchronized, which means that\n     * both sets are different, but they contain the same elements.\n     * <p>\n     * A bidirectional content-binding can be removed with\n     * {@link #unbindContentBidirectional(Object, Object)}.\n     * <p>\n     * Note: this implementation of a bidirectional binding behaves differently\n     * from all other bindings here in two important aspects. A property that is\n     * linked to another property with a bidirectional binding can still be set\n     * (usually bindings would throw an exception). Secondly bidirectional\n     * bindings are calculated eagerly, i.e. a bound property is updated\n     * immediately.\n     *\n     * @param <E>\n     *            the type of the set elements\n     * @param set1\n     *            the first {@code ObservableSet<E>}\n     * @param set2\n     *            the second {@code ObservableSet<E>}\n     * @throws NullPointerException\n     *            if one of the sets is {@code null}\n     * @throws IllegalArgumentException\n     *            if {@code set1} == {@code set2}\n     * @since JavaFX 2.1\n     */\n    public static <E> void bindContentBidirectional(ObservableSet<E> set1, ObservableSet<E> set2) {\n        BidirectionalContentBinding.bind(set1, set2);\n    }"}
{"Number":"732","API Relative Path":"javafx.beans.binding.Bindings.java-booleanValueAt(ObservableList-ObservableNumberValue)","Corresponding Source":"/**\n     * Creates a new {@link javafx.beans.binding.BooleanBinding} that contains the element\n     * of an {@link javafx.collections.ObservableList} at the specified position. The {@code BooleanBinding}\n     * will hold {@code false}, if the {@code index} is outside of the {@code ObservableList}.\n     *\n     * @param op the {@code ObservableList}\n     * @param index the position in the {@code List}, converted to int\n     * @return the new {@code BooleanBinding}\n     * @throws NullPointerException if the {@code ObservableList} or {@code index} is {@code null}\n     * @since JavaFX 8.0\n     */\n    public static BooleanBinding booleanValueAt(final ObservableList<Boolean> op, final ObservableNumberValue index) {\n        if ((op == null) || (index == null)) {\n            throw new NullPointerException(\"Operands cannot be null.\");\n        }\n\n        return new BooleanBinding() {\n            {\n                super.bind(op, index);\n            }\n\n            @Override\n            public void dispose() {\n                super.unbind(op, index);\n            }\n\n            @Override\n            protected boolean computeValue() {\n                try {\n                    final Boolean value = op.get(index.intValue());\n                    if (value == null) {\n                        Logging.getLogger().fine(\"List element is null, returning default value instead.\", new NullPointerException());\n                    } else {\n                        return value;\n                    }\n                } catch (IndexOutOfBoundsException ex) {\n                    Logging.getLogger().fine(\"Exception while evaluating binding\", ex);\n                }\n                return false;\n            }\n\n            @Override\n            @ReturnsUnmodifiableCollection\n            public ObservableList<?> getDependencies() {\n                return new ImmutableObservableList<Observable>(op, index);\n            }\n        };\n    }"}
{"Number":"733","API Relative Path":"javafx.beans.binding.Bindings.java-booleanValueAt(ObservableMap-ObservableValue)","Corresponding Source":"/**\n     * Creates a new {@link javafx.beans.binding.BooleanBinding} that contains the mapping of a specific key\n     * in an {@link javafx.collections.ObservableMap}. The {@code BooleanBinding}\n     * will hold {@code false}, if the {@code key} cannot be found in the {@code ObservableMap}.\n     *\n     * @param op the {@code ObservableMap}\n     * @param key the key in the {@code Map}\n     * @param <K> type of the key elements of the {@code Map}\n     * @return the new {@code BooleanBinding}\n     * @throws NullPointerException if the {@code ObservableMap} or {@code key} is {@code null}\n     * @since JavaFX 2.1\n     */\n    public static <K> BooleanBinding booleanValueAt(final ObservableMap<K, Boolean> op, final ObservableValue<? extends K> key) {\n        if ((op == null) || (key == null)) {\n            throw new NullPointerException(\"Operands cannot be null.\");\n        }\n\n        return new BooleanBinding() {\n            {\n                super.bind(op, key);\n            }\n\n            @Override\n            public void dispose() {\n                super.unbind(op, key);\n            }\n\n            @Override\n            protected boolean computeValue() {\n                try {\n                    final Boolean value = op.get(key.getValue());\n                    if (value == null) {\n                        Logging.getLogger().fine(\"Element not found in map, returning default value instead.\", new NullPointerException());\n                    } else {\n                        return value;\n                    }\n                } catch (ClassCastException ex) {\n                    Logging.getLogger().warning(\"Exception while evaluating binding\", ex);\n                    // ignore\n                } catch (NullPointerException ex) {\n                    Logging.getLogger().warning(\"Exception while evaluating binding\", ex);\n                    // ignore\n                }\n                return false;\n            }\n\n            @Override\n            @ReturnsUnmodifiableCollection\n            public ObservableList<?> getDependencies() {\n                return new ImmutableObservableList<Observable>(op, key);\n            }\n        };\n    }"}
{"Number":"734","API Relative Path":"javafx.beans.binding.Bindings.java-doubleValueAt(ObservableList-ObservableNumberValue)","Corresponding Source":"/**\n     * Creates a new {@link javafx.beans.binding.DoubleBinding} that contains the element\n     * of an {@link javafx.collections.ObservableList} at the specified position. The {@code DoubleBinding}\n     * will hold {@code 0.0}, if the {@code index} is outside of the {@code ObservableList}.\n     *\n     * @param op the {@code ObservableList}\n     * @param index the position in the {@code List}, converted to int\n     * @return the new {@code DoubleBinding}\n     * @throws NullPointerException if the {@code ObservableList} or {@code index} is {@code null}\n     * @since JavaFX 8.0\n     */\n    public static DoubleBinding doubleValueAt(final ObservableList<? extends Number> op, final ObservableNumberValue index) {\n        if ((op == null) || (index == null)) {\n            throw new NullPointerException(\"Operands cannot be null.\");\n        }\n\n        return new DoubleBinding() {\n            {\n                super.bind(op, index);\n            }\n\n            @Override\n            public void dispose() {\n                super.unbind(op, index);\n            }\n\n            @Override\n            protected double computeValue() {\n                try {\n                    final Number value = op.get(index.intValue());\n                    if (value == null) {\n                        Logging.getLogger().fine(\"List element is null, returning default value instead.\", new NullPointerException());\n                    } else {\n                        return value.doubleValue();\n                    }\n                } catch (IndexOutOfBoundsException ex) {\n                    Logging.getLogger().fine(\"Exception while evaluating binding\", ex);\n                }\n                return 0.0;\n            }\n\n            @Override\n            @ReturnsUnmodifiableCollection\n            public ObservableList<?> getDependencies() {\n                return new ImmutableObservableList<Observable>(op, index);\n            }\n        };\n    }"}
{"Number":"735","API Relative Path":"javafx.beans.binding.Bindings.java-doubleValueAt(ObservableMap-ObservableValue)","Corresponding Source":"/**\n     * Creates a new {@link javafx.beans.binding.DoubleBinding} that contains the mapping of a specific key\n     * in an {@link javafx.collections.ObservableMap}. The {@code DoubleBinding}\n     * will hold {@code 0.0}, if the {@code key} cannot be found in the {@code ObservableMap}.\n     *\n     * @param op the {@code ObservableMap}\n     * @param key the key in the {@code Map}\n     * @param <K> type of the key elements of the {@code Map}\n     * @return the new {@code DoubleBinding}\n     * @throws NullPointerException if the {@code ObservableMap} or {@code key} is {@code null}\n     * @since JavaFX 2.1\n     */\n    public static <K> DoubleBinding doubleValueAt(final ObservableMap<K, ? extends Number> op, final ObservableValue<? extends K> key) {\n        if ((op == null) || (key == null)) {\n            throw new NullPointerException(\"Operands cannot be null.\");\n        }\n\n        return new DoubleBinding() {\n            {\n                super.bind(op, key);\n            }\n\n            @Override\n            public void dispose() {\n                super.unbind(op, key);\n            }\n\n            @Override\n            protected double computeValue() {\n                try {\n                    final Number value = op.get(key.getValue());\n                    if (value == null) {\n                        Logging.getLogger().fine(\"Element not found in map, returning default value instead.\", new NullPointerException());\n                    } else {\n                        return value.doubleValue();\n                    }\n                } catch (ClassCastException ex) {\n                    Logging.getLogger().warning(\"Exception while evaluating binding\", ex);\n                    // ignore\n                } catch (NullPointerException ex) {\n                    Logging.getLogger().warning(\"Exception while evaluating binding\", ex);\n                    // ignore\n                }\n                return 0.0;\n            }\n\n            @Override\n            @ReturnsUnmodifiableCollection\n            public ObservableList<?> getDependencies() {\n                return new ImmutableObservableList<Observable>(op, key);\n            }\n        };\n    }"}
{"Number":"736","API Relative Path":"javafx.beans.binding.Bindings.java-equal(ObservableBooleanValue-ObservableBooleanValue)","Corresponding Source":"/**\n     * Creates a new {@link BooleanBinding} that holds {@code true} if the values of two\n     * instances of {@link javafx.beans.value.ObservableBooleanValue} are not\n     * equal.\n     *\n     * @param op1\n     *            the first operand\n     * @param op2\n     *            the second operand\n     * @return the new {@code BooleanBinding}\n     * @throws NullPointerException\n     *             if one of the operands is {@code null}\n     */\n    public static BooleanBinding notEqual(final ObservableBooleanValue op1, final ObservableBooleanValue op2) {\n        if ((op1 == null) || (op2 == null)) {\n            throw new NullPointerException(\"Operands cannot be null.\");\n        }\n\n        return new BooleanBinding() {\n            {\n                super.bind(op1, op2);\n            }\n\n            @Override\n            public void dispose() {\n                super.unbind(op1, op2);\n            }\n\n            @Override\n            protected boolean computeValue() {\n                return op1.get() != op2.get();\n            }\n\n            @Override\n            @ReturnsUnmodifiableCollection\n            public ObservableList<?> getDependencies() {\n                return new ImmutableObservableList<ObservableBooleanValue>(op1, op2);\n            }\n        };\n    }"}
{"Number":"737","API Relative Path":"javafx.beans.binding.Bindings.java-floatValueAt(ObservableFloatArray-int)","Corresponding Source":"/**\n     * Creates a new {@link javafx.beans.binding.FloatBinding} that contains the element\n     * of an {@link javafx.collections.ObservableArray} at the specified position. The {@code FloatBinding}\n     * will hold {@code 0.0f}, if the {@code index} is outside of the {@code ObservableArray}.\n     *\n     * @param op the {@code ObservableArray}\n     * @param index the position in the {@code ObservableArray}\n     * @return the new {@code FloatBinding}\n     * @throws NullPointerException if the {@code ObservableArray} or {@code index} is {@code null}\n     * @since JavaFX 8.0\n     */\n    public static FloatBinding floatValueAt(final ObservableFloatArray op, final ObservableIntegerValue index) {\n        return floatValueAt(op, (ObservableNumberValue)index);\n    }"}
{"Number":"738","API Relative Path":"javafx.beans.binding.Bindings.java-floatValueAt(ObservableFloatArray-ObservableNumberValue)","Corresponding Source":"/**\n     * Creates a new {@link javafx.beans.binding.FloatBinding} that contains the element\n     * of an {@link javafx.collections.ObservableArray} at the specified position. The {@code FloatBinding}\n     * will hold {@code 0.0f}, if the {@code index} is outside of the {@code ObservableArray}.\n     *\n     * @param op the {@code ObservableArray}\n     * @param index the position in the {@code ObservableArray}, converted to int\n     * @return the new {@code FloatBinding}\n     * @throws NullPointerException if the {@code ObservableArray} or {@code index} is {@code null}\n     * @since JavaFX 8.0\n     */\n    public static FloatBinding floatValueAt(final ObservableFloatArray op, final ObservableNumberValue index) {\n        if ((op == null) || (index == null)) {\n            throw new NullPointerException(\"Operands cannot be null.\");\n        }\n\n        return new FloatBinding() {\n            {\n                super.bind(op, index);\n            }\n\n            @Override\n            public void dispose() {\n                super.unbind(op, index);\n            }\n\n            @Override\n            protected float computeValue() {\n                try {\n                    return op.get(index.intValue());\n                } catch (IndexOutOfBoundsException ex) {\n                    Logging.getLogger().fine(\"Exception while evaluating binding\", ex);\n                }\n                return 0.0f;\n            }\n\n            @Override\n            @ReturnsUnmodifiableCollection\n            public ObservableList<?> getDependencies() {\n                return new ImmutableObservableList<>(op, index);\n            }\n        };\n    }"}
{"Number":"739","API Relative Path":"javafx.beans.binding.Bindings.java-floatValueAt(ObservableList-ObservableNumberValue)","Corresponding Source":"/**\n     * Creates a new {@link javafx.beans.binding.FloatBinding} that contains the element\n     * of an {@link javafx.collections.ObservableList} at the specified position. The {@code FloatBinding}\n     * will hold {@code 0.0f}, if the {@code index} is outside of the {@code ObservableList}.\n     *\n     * @param op the {@code ObservableList}\n     * @param index the position in the {@code List}, converted to int\n     * @return the new {@code FloatBinding}\n     * @throws NullPointerException if the {@code ObservableList} or {@code index} is {@code null}\n     * @since JavaFX 8.0\n     */\n    public static FloatBinding floatValueAt(final ObservableList<? extends Number> op, final ObservableNumberValue index) {\n        if ((op == null) || (index == null)) {\n            throw new NullPointerException(\"Operands cannot be null.\");\n        }\n\n        return new FloatBinding() {\n            {\n                super.bind(op, index);\n            }\n\n            @Override\n            public void dispose() {\n                super.unbind(op, index);\n            }\n\n            @Override\n            protected float computeValue() {\n                try {\n                    final Number value = op.get(index.intValue());\n                    if (value == null) {\n                        Logging.getLogger().fine(\"List element is null, returning default value instead.\", new NullPointerException());\n                    } else {\n                        return value.floatValue();\n                    }\n                } catch (IndexOutOfBoundsException ex) {\n                    Logging.getLogger().fine(\"Exception while evaluating binding\", ex);\n                }\n                return 0.0f;\n            }\n\n            @Override\n            @ReturnsUnmodifiableCollection\n            public ObservableList<?> getDependencies() {\n                return new ImmutableObservableList<Observable>(op, index);\n            }\n        };\n    }"}
{"Number":"740","API Relative Path":"javafx.beans.binding.Bindings.java-floatValueAt(ObservableMap-ObservableValue)","Corresponding Source":"/**\n     * Creates a new {@link javafx.beans.binding.FloatBinding} that contains the mapping of a specific key\n     * in an {@link javafx.collections.ObservableMap}. The {@code FloatBinding}\n     * will hold {@code 0.0f}, if the {@code key} cannot be found in the {@code ObservableMap}.\n     *\n     * @param op the {@code ObservableMap}\n     * @param key the key in the {@code Map}\n     * @param <K> type of the key elements of the {@code Map}\n     * @return the new {@code FloatBinding}\n     * @throws NullPointerException if the {@code ObservableMap} or {@code key} is {@code null}\n     * @since JavaFX 2.1\n     */\n    public static <K> FloatBinding floatValueAt(final ObservableMap<K, ? extends Number> op, final ObservableValue<? extends K> key) {\n        if ((op == null) || (key == null)) {\n            throw new NullPointerException(\"Operands cannot be null.\");\n        }\n\n        return new FloatBinding() {\n            {\n                super.bind(op, key);\n            }\n\n            @Override\n            public void dispose() {\n                super.unbind(op, key);\n            }\n\n            @Override\n            protected float computeValue() {\n                try {\n                    final Number value = op.get(key.getValue());\n                    if (value == null) {\n                        Logging.getLogger().fine(\"Element not found in map, returning default value instead.\", new NullPointerException());\n                    } else {\n                        return value.floatValue();\n                    }\n                } catch (ClassCastException ex) {\n                    Logging.getLogger().warning(\"Exception while evaluating binding\", ex);\n                    // ignore\n                } catch (NullPointerException ex) {\n                    Logging.getLogger().warning(\"Exception while evaluating binding\", ex);\n                    // ignore\n                }\n                return 0.0f;\n            }\n\n            @Override\n            @ReturnsUnmodifiableCollection\n            public ObservableList<?> getDependencies() {\n                return new ImmutableObservableList<Observable>(op, key);\n            }\n        };\n    }"}
{"Number":"741","API Relative Path":"javafx.beans.binding.Bindings.java-integerValueAt(ObservableIntegerArray-int)","Corresponding Source":"/**\n     * Creates a new {@link javafx.beans.binding.IntegerBinding} that contains the element\n     * of an {@link javafx.collections.ObservableArray} at the specified position. The {@code IntegerBinding}\n     * will hold {@code 0}, if the {@code index} is outside of the {@code ObservableArray}.\n     *\n     * @param op the {@code ObservableArray}\n     * @param index the position in the {@code ObservableArray}\n     * @return the new {@code IntegerBinding}\n     * @throws NullPointerException if the {@code ObservableArray} or {@code index} is {@code null}\n     * @since JavaFX 8.0\n     */\n    public static IntegerBinding integerValueAt(final ObservableIntegerArray op, final ObservableIntegerValue index) {\n        return integerValueAt(op, (ObservableNumberValue)index);\n    }"}
{"Number":"742","API Relative Path":"javafx.beans.binding.Bindings.java-integerValueAt(ObservableIntegerArray-ObservableNumberValue)","Corresponding Source":"/**\n     * Creates a new {@link javafx.beans.binding.IntegerBinding} that contains the element\n     * of an {@link javafx.collections.ObservableArray} at the specified position. The {@code IntegerBinding}\n     * will hold {@code 0}, if the {@code index} is outside of the {@code ObservableArray}.\n     *\n     * @param op the {@code ObservableArray}\n     * @param index the position in the {@code ObservableArray}, converted to int\n     * @return the new {@code IntegerBinding}\n     * @throws NullPointerException if the {@code ObservableArray} or {@code index} is {@code null}\n     * @since JavaFX 8.0\n     */\n    public static IntegerBinding integerValueAt(final ObservableIntegerArray op, final ObservableNumberValue index) {\n        if ((op == null) || (index == null)) {\n            throw new NullPointerException(\"Operands cannot be null.\");\n        }\n\n        return new IntegerBinding() {\n            {\n                super.bind(op, index);\n            }\n\n            @Override\n            public void dispose() {\n                super.unbind(op, index);\n            }\n\n            @Override\n            protected int computeValue() {\n                try {\n                    return op.get(index.intValue());\n                } catch (IndexOutOfBoundsException ex) {\n                    Logging.getLogger().fine(\"Exception while evaluating binding\", ex);\n                }\n                return 0;\n            }\n\n            @Override\n            @ReturnsUnmodifiableCollection\n            public ObservableList<?> getDependencies() {\n                return new ImmutableObservableList<>(op, index);\n            }\n        };\n    }"}
{"Number":"743","API Relative Path":"javafx.beans.binding.Bindings.java-integerValueAt(ObservableList-ObservableNumberValue)","Corresponding Source":"/**\n     * Creates a new {@link javafx.beans.binding.IntegerBinding} that contains the element\n     * of an {@link javafx.collections.ObservableList} at the specified position. The {@code IntegerBinding}\n     * will hold {@code 0}, if the {@code index} is outside of the {@code ObservableList}.\n     *\n     * @param op the {@code ObservableList}\n     * @param index the position in the {@code List}, converted to int\n     * @return the new {@code IntegerBinding}\n     * @throws NullPointerException if the {@code ObservableList} or {@code index} is {@code null}\n     * @since JavaFX 8.0\n     */\n    public static IntegerBinding integerValueAt(final ObservableList<? extends Number> op, final ObservableNumberValue index) {\n        if ((op == null) || (index == null)) {\n            throw new NullPointerException(\"Operands cannot be null.\");\n        }\n\n        return new IntegerBinding() {\n            {\n                super.bind(op, index);\n            }\n\n            @Override\n            public void dispose() {\n                super.unbind(op, index);\n            }\n\n            @Override\n            protected int computeValue() {\n                try {\n                    final Number value = op.get(index.intValue());\n                    if (value == null) {\n                        Logging.getLogger().fine(\"List element is null, returning default value instead.\", new NullPointerException());\n                    } else {\n                        return value.intValue();\n                    }\n                } catch (IndexOutOfBoundsException ex) {\n                    Logging.getLogger().fine(\"Exception while evaluating binding\", ex);\n                }\n                return 0;\n            }\n\n            @Override\n            @ReturnsUnmodifiableCollection\n            public ObservableList<?> getDependencies() {\n                return new ImmutableObservableList<Observable>(op, index);\n            }\n        };\n    }"}
{"Number":"744","API Relative Path":"javafx.beans.binding.Bindings.java-integerValueAt(ObservableMap-ObservableValue)","Corresponding Source":"/**\n     * Creates a new {@link javafx.beans.binding.IntegerBinding} that contains the mapping of a specific key\n     * in an {@link javafx.collections.ObservableMap}. The {@code IntegerBinding}\n     * will hold {@code 0}, if the {@code key} cannot be found in the {@code ObservableMap}.\n     *\n     * @param op the {@code ObservableMap}\n     * @param key the key in the {@code Map}\n     * @param <K> type of the key elements of the {@code Map}\n     * @return the new {@code IntegerBinding}\n     * @throws NullPointerException if the {@code ObservableMap} or {@code key} is {@code null}\n     * @since JavaFX 2.1\n     */\n    public static <K> IntegerBinding integerValueAt(final ObservableMap<K, ? extends Number> op, final ObservableValue<? extends K> key) {\n        if ((op == null) || (key == null)) {\n            throw new NullPointerException(\"Operands cannot be null.\");\n        }\n\n        return new IntegerBinding() {\n            {\n                super.bind(op, key);\n            }\n\n            @Override\n            public void dispose() {\n                super.unbind(op, key);\n            }\n\n            @Override\n            protected int computeValue() {\n                try {\n                    final Number value = op.get(key.getValue());\n                    if (value == null) {\n                        Logging.getLogger().fine(\"Element not found in map, returning default value instead.\", new NullPointerException());\n                    } else {\n                        return value.intValue();\n                    }\n                } catch (ClassCastException ex) {\n                    Logging.getLogger().warning(\"Exception while evaluating binding\", ex);\n                    // ignore\n                } catch (NullPointerException ex) {\n                    Logging.getLogger().warning(\"Exception while evaluating binding\", ex);\n                    // ignore\n                }\n                return 0;\n            }\n\n            @Override\n            @ReturnsUnmodifiableCollection\n            public ObservableList<?> getDependencies() {\n                return new ImmutableObservableList<Observable>(op, key);\n            }\n        };\n    }"}
{"Number":"745","API Relative Path":"javafx.beans.binding.Bindings.java-longValueAt(ObservableList-ObservableNumberValue)","Corresponding Source":"/**\n     * Creates a new {@link javafx.beans.binding.LongBinding} that contains the element\n     * of an {@link javafx.collections.ObservableList} at the specified position. The {@code LongBinding}\n     * will hold {@code 0L}, if the {@code index} is outside of the {@code ObservableList}.\n     *\n     * @param op the {@code ObservableList}\n     * @param index the position in the {@code List}, converted to int\n     * @return the new {@code LongBinding}\n     * @throws NullPointerException if the {@code ObservableList} or {@code index} is {@code null}\n     * @since JavaFX 8.0\n     */\n    public static LongBinding longValueAt(final ObservableList<? extends Number> op, final ObservableNumberValue index) {\n        if ((op == null) || (index == null)) {\n            throw new NullPointerException(\"Operands cannot be null.\");\n        }\n\n        return new LongBinding() {\n            {\n                super.bind(op, index);\n            }\n\n            @Override\n            public void dispose() {\n                super.unbind(op, index);\n            }\n\n            @Override\n            protected long computeValue() {\n                try {\n                    final Number value = op.get(index.intValue());\n                    if (value == null) {\n                        Logging.getLogger().fine(\"List element is null, returning default value instead.\", new NullPointerException());\n                    } else {\n                        return value.longValue();\n                    }\n                } catch (IndexOutOfBoundsException ex) {\n                    Logging.getLogger().fine(\"Exception while evaluating binding\", ex);\n                }\n                return 0L;\n            }\n\n            @Override\n            @ReturnsUnmodifiableCollection\n            public ObservableList<?> getDependencies() {\n                return new ImmutableObservableList<Observable>(op, index);\n            }\n        };\n    }"}
{"Number":"746","API Relative Path":"javafx.beans.binding.Bindings.java-longValueAt(ObservableMap-ObservableValue)","Corresponding Source":"/**\n     * Creates a new {@link javafx.beans.binding.LongBinding} that contains the mapping of a specific key\n     * in an {@link javafx.collections.ObservableMap}. The {@code LongBinding}\n     * will hold {@code 0L}, if the {@code key} cannot be found in the {@code ObservableMap}.\n     *\n     * @param op the {@code ObservableMap}\n     * @param key the key in the {@code Map}\n     * @param <K> type of the key elements of the {@code Map}\n     * @return the new {@code LongBinding}\n     * @throws NullPointerException if the {@code ObservableMap} or {@code key} is {@code null}\n     * @since JavaFX 2.1\n     */\n    public static <K> LongBinding longValueAt(final ObservableMap<K, ? extends Number> op, final ObservableValue<? extends K> key) {\n        if ((op == null) || (key == null)) {\n            throw new NullPointerException(\"Operands cannot be null.\");\n        }\n\n        return new LongBinding() {\n            {\n                super.bind(op, key);\n            }\n\n            @Override\n            public void dispose() {\n                super.unbind(op, key);\n            }\n\n            @Override\n            protected long computeValue() {\n                try {\n                    final Number value = op.get(key.getValue());\n                    if (value == null) {\n                        Logging.getLogger().fine(\"Element not found in map, returning default value instead.\", new NullPointerException());\n                    } else {\n                        return value.longValue();\n                    }\n                } catch (ClassCastException ex) {\n                    Logging.getLogger().warning(\"Exception while evaluating binding\", ex);\n                    // ignore\n                } catch (NullPointerException ex) {\n                    Logging.getLogger().warning(\"Exception while evaluating binding\", ex);\n                    // ignore\n                }\n                return 0L;\n            }\n\n            @Override\n            @ReturnsUnmodifiableCollection\n            public ObservableList<?> getDependencies() {\n                return new ImmutableObservableList<Observable>(op, key);\n            }\n        };\n    }"}
{"Number":"747","API Relative Path":"javafx.beans.binding.Bindings.java-not(ObservableBooleanValue)","Corresponding Source":"/**\n     * Creates a {@link BooleanBinding} that calculates the inverse of the value\n     * of a {@link javafx.beans.value.ObservableBooleanValue}.\n     *\n     * @param op\n     *            the {@code ObservableBooleanValue}\n     * @return the new {@code BooleanBinding}\n     * @throws NullPointerException\n     *             if the operand is {@code null}\n     */\n    public static BooleanBinding not(final ObservableBooleanValue op) {\n        if (op == null) {\n            throw new NullPointerException(\"Operand cannot be null.\");\n        }\n\n        return new BooleanBinding() {\n            {\n                super.bind(op);\n            }\n\n            @Override\n            public void dispose() {\n                super.unbind(op);\n            }\n\n            @Override\n            protected boolean computeValue() {\n                return !op.get();\n            }\n\n            @Override\n            @ReturnsUnmodifiableCollection\n            public ObservableList<?> getDependencies() {\n                return FXCollections.singletonObservableList(op);\n            }\n        };\n    }"}
{"Number":"748","API Relative Path":"javafx.beans.binding.Bindings.java-notEqual(ObservableBooleanValue-ObservableBooleanValue)","Corresponding Source":"/**\n     * Creates a new {@link BooleanBinding} that holds {@code true} if the values of two\n     * instances of {@link javafx.beans.value.ObservableBooleanValue} are not\n     * equal.\n     *\n     * @param op1\n     *            the first operand\n     * @param op2\n     *            the second operand\n     * @return the new {@code BooleanBinding}\n     * @throws NullPointerException\n     *             if one of the operands is {@code null}\n     */\n    public static BooleanBinding notEqual(final ObservableBooleanValue op1, final ObservableBooleanValue op2) {\n        if ((op1 == null) || (op2 == null)) {\n            throw new NullPointerException(\"Operands cannot be null.\");\n        }\n\n        return new BooleanBinding() {\n            {\n                super.bind(op1, op2);\n            }\n\n            @Override\n            public void dispose() {\n                super.unbind(op1, op2);\n            }\n\n            @Override\n            protected boolean computeValue() {\n                return op1.get() != op2.get();\n            }\n\n            @Override\n            @ReturnsUnmodifiableCollection\n            public ObservableList<?> getDependencies() {\n                return new ImmutableObservableList<ObservableBooleanValue>(op1, op2);\n            }\n        };\n    }"}
{"Number":"749","API Relative Path":"javafx.beans.binding.Bindings.java-or(ObservableBooleanValue-ObservableBooleanValue)","Corresponding Source":"/**\n     * Creates a {@link BooleanBinding} that calculates the conditional-OR\n     * operation on the value of two instance of\n     * {@link javafx.beans.value.ObservableBooleanValue}.\n     *\n     * @param op1\n     *            first {@code ObservableBooleanValue}\n     * @param op2\n     *            second {@code ObservableBooleanValue}\n     * @return the new {@code BooleanBinding}\n     * @throws NullPointerException\n     *             if one of the operands is {@code null}\n     */\n    public static BooleanBinding or(final ObservableBooleanValue op1, final ObservableBooleanValue op2) {\n        if ((op1 == null) || (op2 == null)) {\n            throw new NullPointerException(\"Operands cannot be null.\");\n        }\n\n        return new BooleanOrBinding(op1, op2);\n    }"}
{"Number":"750","API Relative Path":"javafx.beans.binding.Bindings.java-stringValueAt(ObservableList-ObservableNumberValue)","Corresponding Source":"/**\n     * Creates a new {@link javafx.beans.binding.StringBinding} that contains the element\n     * of an {@link javafx.collections.ObservableList} at the specified position. The {@code StringBinding}\n     * will hold {@code \"\"}, if the {@code index} is outside of the {@code ObservableList}.\n     *\n     * @param op the {@code ObservableList}\n     * @param index the position in the {@code List}, converted to int\n     * @return the new {@code StringBinding}\n     * @throws NullPointerException if the {@code ObservableList} or {@code index} is {@code null}\n     * @since JavaFX 8.0\n     */\n    public static StringBinding stringValueAt(final ObservableList<String> op, final ObservableNumberValue index) {\n        if ((op == null) || (index == null)) {\n            throw new NullPointerException(\"Operands cannot be null.\");\n        }\n\n        return new StringBinding() {\n            {\n                super.bind(op, index);\n            }\n\n            @Override\n            public void dispose() {\n                super.unbind(op, index);\n            }\n\n            @Override\n            protected String computeValue() {\n                try {\n                    return op.get(index.intValue());\n                } catch (IndexOutOfBoundsException ex) {\n                    Logging.getLogger().fine(\"Exception while evaluating binding\", ex);\n                }\n                return null;\n            }\n\n            @Override\n            @ReturnsUnmodifiableCollection\n            public ObservableList<?> getDependencies() {\n                return new ImmutableObservableList<Observable>(op, index);\n            }\n        };\n    }"}
{"Number":"751","API Relative Path":"javafx.beans.binding.Bindings.java-stringValueAt(ObservableMap-ObservableValue)","Corresponding Source":"/**\n     * Creates a new {@link javafx.beans.binding.StringBinding} that contains the mapping of a specific key\n     * in an {@link javafx.collections.ObservableMap}. The {@code StringBinding}\n     * will hold {@code \"\"}, if the {@code key} cannot be found in the {@code ObservableMap}.\n     *\n     * @param op the {@code ObservableMap}\n     * @param key the key in the {@code Map}\n     * @param <K> type of the key elements of the {@code Map}\n     * @return the new {@code StringBinding}\n     * @throws NullPointerException if the {@code ObservableMap} or {@code key} is {@code null}\n     * @since JavaFX 2.1\n     */\n    public static <K> StringBinding stringValueAt(final ObservableMap<K, String> op, final ObservableValue<? extends K> key) {\n        if ((op == null) || (key == null)) {\n            throw new NullPointerException(\"Operands cannot be null.\");\n        }\n\n        return new StringBinding() {\n            {\n                super.bind(op, key);\n            }\n\n            @Override\n            public void dispose() {\n                super.unbind(op, key);\n            }\n\n            @Override\n            protected String computeValue() {\n                try {\n                    return op.get(key.getValue());\n                } catch (ClassCastException ex) {\n                    Logging.getLogger().warning(\"Exception while evaluating binding\", ex);\n                    // ignore\n                } catch (NullPointerException ex) {\n                    Logging.getLogger().warning(\"Exception while evaluating binding\", ex);\n                    // ignore\n                }\n                return null;\n            }\n\n            @Override\n            @ReturnsUnmodifiableCollection\n            public ObservableList<?> getDependencies() {\n                return new ImmutableObservableList<Observable>(op, key);\n            }\n        };\n    }"}
{"Number":"752","API Relative Path":"javafx.beans.binding.Bindings.java-unbindBidirectional(Object-Object)","Corresponding Source":"/**\n     * Delete a bidirectional binding that was previously defined with\n     * {@link #bindBidirectional(Property, Property)} or\n     * {@link #bindBidirectional(javafx.beans.property.Property, javafx.beans.property.Property, java.text.Format)}.\n     *\n     * @param property1\n     *            the first {@code Property<T>}\n     * @param property2\n     *            the second {@code Property<T>}\n     * @throws NullPointerException\n     *            if one of the properties is {@code null}\n     * @throws IllegalArgumentException\n     *            if both properties are equal\n     * @since JavaFX 2.1\n     */\n    public static void unbindBidirectional(Object property1, Object property2) {\n        BidirectionalBinding.unbind(property1, property2);\n    }"}
{"Number":"753","API Relative Path":"javafx.beans.binding.Bindings.java-unbindBidirectional(Object-Object)","Corresponding Source":"/**\n     * Delete a bidirectional binding that was previously defined with\n     * {@link #bindBidirectional(Property, Property)} or\n     * {@link #bindBidirectional(javafx.beans.property.Property, javafx.beans.property.Property, java.text.Format)}.\n     *\n     * @param property1\n     *            the first {@code Property<T>}\n     * @param property2\n     *            the second {@code Property<T>}\n     * @throws NullPointerException\n     *            if one of the properties is {@code null}\n     * @throws IllegalArgumentException\n     *            if both properties are equal\n     * @since JavaFX 2.1\n     */\n    public static void unbindBidirectional(Object property1, Object property2) {\n        BidirectionalBinding.unbind(property1, property2);\n    }"}
{"Number":"754","API Relative Path":"javafx.beans.binding.Bindings.java-unbindBidirectional(Property-Property)","Corresponding Source":"/**\n     * Delete a bidirectional binding that was previously defined with\n     * {@link #bindBidirectional(Property, Property)}.\n     *\n     * @param <T>\n     *            the types of the properties\n     * @param property1\n     *            the first {@code Property<T>}\n     * @param property2\n     *            the second {@code Property<T>}\n     * @throws NullPointerException\n     *            if one of the properties is {@code null}\n     * @throws IllegalArgumentException\n     *            if both properties are equal\n     */\n    public static <T> void unbindBidirectional(Property<T> property1, Property<T> property2) {\n        BidirectionalBinding.unbind(property1, property2);\n    }"}
{"Number":"755","API Relative Path":"javafx.beans.binding.Bindings.java-unbindBidirectional(Property-Property)","Corresponding Source":"/**\n     * Delete a bidirectional binding that was previously defined with\n     * {@link #bindBidirectional(Property, Property)}.\n     *\n     * @param <T>\n     *            the types of the properties\n     * @param property1\n     *            the first {@code Property<T>}\n     * @param property2\n     *            the second {@code Property<T>}\n     * @throws NullPointerException\n     *            if one of the properties is {@code null}\n     * @throws IllegalArgumentException\n     *            if both properties are equal\n     */\n    public static <T> void unbindBidirectional(Property<T> property1, Property<T> property2) {\n        BidirectionalBinding.unbind(property1, property2);\n    }"}
{"Number":"756","API Relative Path":"javafx.beans.binding.Bindings.java-unbindContent(Object-Object)","Corresponding Source":"/**\n     * Remove a content binding.\n     *\n     * @param obj1\n     *            the first {@code Object}\n     * @param obj2\n     *            the second {@code Object}\n     * @throws NullPointerException\n     *            if one of the {@code Objects} is {@code null}\n     * @throws IllegalArgumentException\n     *            if {@code obj1} == {@code obj2}\n     * @since JavaFX 2.1\n     */\n    public static void unbindContent(Object obj1, Object obj2) {\n        ContentBinding.unbind(obj1, obj2);\n    }"}
{"Number":"757","API Relative Path":"javafx.beans.binding.Bindings.java-unbindContentBidirectional(Object-Object)","Corresponding Source":"/**\n     * Remove a bidirectional content binding.\n     *\n     * @param obj1\n     *            the first {@code Object}\n     * @param obj2\n     *            the second {@code Object}\n     * @since JavaFX 2.1\n     */\n    public static void unbindContentBidirectional(Object obj1, Object obj2) {\n        BidirectionalContentBinding.unbind(obj1, obj2);\n    }"}
{"Number":"758","API Relative Path":"javafx.beans.binding.Bindings.java-unbindContentBidirectional(Object-Object)","Corresponding Source":"/**\n     * Remove a bidirectional content binding.\n     *\n     * @param obj1\n     *            the first {@code Object}\n     * @param obj2\n     *            the second {@code Object}\n     * @since JavaFX 2.1\n     */\n    public static void unbindContentBidirectional(Object obj1, Object obj2) {\n        BidirectionalContentBinding.unbind(obj1, obj2);\n    }"}
{"Number":"759","API Relative Path":"javafx.beans.binding.Bindings.java-valueAt(ObservableList-ObservableNumberValue)","Corresponding Source":"/**\n     * Creates a new {@link javafx.beans.binding.StringBinding} that contains the element\n     * of an {@link javafx.collections.ObservableList} at the specified position. The {@code StringBinding}\n     * will hold {@code \"\"}, if the {@code index} is outside of the {@code ObservableList}.\n     *\n     * @param op the {@code ObservableList}\n     * @param index the position in the {@code List}, converted to int\n     * @return the new {@code StringBinding}\n     * @throws NullPointerException if the {@code ObservableList} or {@code index} is {@code null}\n     * @since JavaFX 8.0\n     */\n    public static StringBinding stringValueAt(final ObservableList<String> op, final ObservableNumberValue index) {\n        if ((op == null) || (index == null)) {\n            throw new NullPointerException(\"Operands cannot be null.\");\n        }\n\n        return new StringBinding() {\n            {\n                super.bind(op, index);\n            }\n\n            @Override\n            public void dispose() {\n                super.unbind(op, index);\n            }\n\n            @Override\n            protected String computeValue() {\n                try {\n                    return op.get(index.intValue());\n                } catch (IndexOutOfBoundsException ex) {\n                    Logging.getLogger().fine(\"Exception while evaluating binding\", ex);\n                }\n                return null;\n            }\n\n            @Override\n            @ReturnsUnmodifiableCollection\n            public ObservableList<?> getDependencies() {\n                return new ImmutableObservableList<Observable>(op, index);\n            }\n        };\n    }"}
{"Number":"760","API Relative Path":"javafx.beans.binding.Bindings.java-valueAt(ObservableMap-ObservableValue)","Corresponding Source":"/**\n     * Creates a new {@link javafx.beans.binding.StringBinding} that contains the mapping of a specific key\n     * in an {@link javafx.collections.ObservableMap}. The {@code StringBinding}\n     * will hold {@code \"\"}, if the {@code key} cannot be found in the {@code ObservableMap}.\n     *\n     * @param op the {@code ObservableMap}\n     * @param key the key in the {@code Map}\n     * @param <K> type of the key elements of the {@code Map}\n     * @return the new {@code StringBinding}\n     * @throws NullPointerException if the {@code ObservableMap} or {@code key} is {@code null}\n     * @since JavaFX 2.1\n     */\n    public static <K> StringBinding stringValueAt(final ObservableMap<K, String> op, final ObservableValue<? extends K> key) {\n        if ((op == null) || (key == null)) {\n            throw new NullPointerException(\"Operands cannot be null.\");\n        }\n\n        return new StringBinding() {\n            {\n                super.bind(op, key);\n            }\n\n            @Override\n            public void dispose() {\n                super.unbind(op, key);\n            }\n\n            @Override\n            protected String computeValue() {\n                try {\n                    return op.get(key.getValue());\n                } catch (ClassCastException ex) {\n                    Logging.getLogger().warning(\"Exception while evaluating binding\", ex);\n                    // ignore\n                } catch (NullPointerException ex) {\n                    Logging.getLogger().warning(\"Exception while evaluating binding\", ex);\n                    // ignore\n                }\n                return null;\n            }\n\n            @Override\n            @ReturnsUnmodifiableCollection\n            public ObservableList<?> getDependencies() {\n                return new ImmutableObservableList<Observable>(op, key);\n            }\n        };\n    }"}
{"Number":"761","API Relative Path":"javafx.beans.binding.Bindings.java-when(ObservableBooleanValue)","Corresponding Source":"/**\n     * Creates a binding that calculates the result of a ternary expression. See\n     * the description of class {@link When} for details.\n     *\n     * @see When\n     *\n     * @param condition\n     *            the condition of the ternary expression\n     * @return an intermediate class to build the complete binding\n     */\n    public static When when(final ObservableBooleanValue condition) {\n        return new When(condition);\n    }"}
{"Number":"762","API Relative Path":"javafx.beans.binding.BooleanBinding.java-bind(Observable)","Corresponding Source":"/**\n     * Stop observing the dependencies for changes.\n     *\n     * @param dependencies\n     *            the dependencies to stop observing\n     */\n    protected final void unbind(Observable... dependencies) {\n        if (observer != null) {\n            for (final Observable dep : dependencies) {\n                dep.removeListener(observer);\n            }\n            observer = null;\n        }\n    }"}
{"Number":"763","API Relative Path":"javafx.beans.binding.DoubleBinding.java-bind(Observable)","Corresponding Source":"/**\n     * Stop observing the dependencies for changes.\n     *\n     * @param dependencies\n     *            the dependencies to stop observing\n     */\n    protected final void unbind(Observable... dependencies) {\n        if (observer != null) {\n            for (final Observable dep : dependencies) {\n                dep.removeListener(observer);\n            }\n            observer = null;\n        }\n    }"}
{"Number":"764","API Relative Path":"javafx.beans.binding.FloatBinding.java-bind(Observable)","Corresponding Source":"/**\n     * Stop observing the dependencies for changes.\n     *\n     * @param dependencies\n     *            the dependencies to stop observing\n     */\n    protected final void unbind(Observable... dependencies) {\n        if (observer != null) {\n            for (final Observable dep : dependencies) {\n                dep.removeListener(observer);\n            }\n            observer = null;\n        }\n    }"}
{"Number":"765","API Relative Path":"javafx.beans.binding.IntegerBinding.java-bind(Observable)","Corresponding Source":"/**\n     * Stop observing the dependencies for changes.\n     *\n     * @param dependencies\n     *            the dependencies to stop observing\n     */\n    protected final void unbind(Observable... dependencies) {\n        if (observer != null) {\n            for (final Observable dep : dependencies) {\n                dep.removeListener(observer);\n            }\n            observer = null;\n        }\n    }"}
{"Number":"766","API Relative Path":"javafx.beans.binding.ListBinding.java-bind(Observable)","Corresponding Source":"/**\n     * Stop observing the dependencies for changes.\n     *\n     * @param dependencies\n     *            the dependencies to stop observing\n     */\n    protected final void unbind(Observable... dependencies) {\n        if (observer != null) {\n            for (final Observable dep : dependencies) {\n                if (dep != null) {\n                    dep.removeListener(observer);\n                }\n            }\n            observer = null;\n        }\n    }"}
{"Number":"767","API Relative Path":"javafx.beans.binding.LongBinding.java-bind(Observable)","Corresponding Source":"/**\n     * Stop observing the dependencies for changes.\n     *\n     * @param dependencies\n     *            the dependencies to stop observing\n     */\n    protected final void unbind(Observable... dependencies) {\n        if (observer != null) {\n            for (final Observable dep : dependencies) {\n                dep.removeListener(observer);\n            }\n            observer = null;\n        }\n    }"}
{"Number":"768","API Relative Path":"javafx.beans.binding.MapBinding.java-bind(Observable)","Corresponding Source":"/**\n     * Stop observing the dependencies for changes.\n     *\n     * @param dependencies\n     *            the dependencies to stop observing\n     */\n    protected final void unbind(Observable... dependencies) {\n        if (observer != null) {\n            for (final Observable dep : dependencies) {\n                if (dep != null) {\n                    dep.removeListener(observer);\n                }\n            }\n            observer = null;\n        }\n    }"}
{"Number":"769","API Relative Path":"javafx.beans.binding.ObjectBinding.java-bind(Observable)","Corresponding Source":"/**\n     * Stop observing the dependencies for changes.\n     *\n     * @param dependencies\n     *            the dependencies to stop observing\n     */\n    protected final void unbind(Observable... dependencies) {\n        if (observer != null) {\n            for (final Observable dep : dependencies) {\n                dep.removeListener(observer);\n            }\n            observer = null;\n        }\n    }"}
{"Number":"770","API Relative Path":"javafx.beans.binding.SetBinding.java-bind(Observable)","Corresponding Source":"/**\n     * Stop observing the dependencies for changes.\n     *\n     * @param dependencies\n     *            the dependencies to stop observing\n     */\n    protected final void unbind(Observable... dependencies) {\n        if (observer != null) {\n            for (final Observable dep : dependencies) {\n                if (dep != null) {\n                    dep.removeListener(observer);\n                }\n            }\n            observer = null;\n        }\n    }"}
{"Number":"771","API Relative Path":"javafx.beans.binding.StringBinding.java-bind(Observable)","Corresponding Source":"/**\n     * Stop observing the dependencies for changes.\n     *\n     * @param dependencies\n     *            the dependencies to stop observing\n     */\n    protected final void unbind(Observable... dependencies) {\n        if (observer != null) {\n            for (final Observable dep : dependencies) {\n                dep.removeListener(observer);\n            }\n            observer = null;\n        }\n    }"}
{"Number":"772","API Relative Path":"javafx.beans.binding.When.java-then(ObservableBooleanValue)","Corresponding Source":"/**\n     * Defines the {@link javafx.beans.value.ObservableBooleanValue} which value\n     * is returned by the ternary expression if the condition is {@code true}.\n     *\n     * @param thenValue\n     *            the value\n     * @return the intermediate result which still requires the otherwise-branch\n     */\n    public BooleanConditionBuilder then(final ObservableBooleanValue thenValue) {\n        if (thenValue == null) {\n            throw new NullPointerException(\"Value needs to be specified\");\n        }\n        return new BooleanConditionBuilder(thenValue);\n    }"}
{"Number":"773","API Relative Path":"javafx.beans.binding.When.java-then(ObservableNumberValue)","Corresponding Source":"/**\n     * Defines the {@link javafx.beans.value.ObservableNumberValue} which value\n     * is returned by the ternary expression if the condition is {@code true}.\n     *\n     * @param thenValue\n     *            the value\n     * @return the intermediate result which still requires the otherwise-branch\n     */\n    public NumberConditionBuilder then(final ObservableNumberValue thenValue) {\n        if (thenValue == null) {\n            throw new NullPointerException(\"Value needs to be specified\");\n        }\n        return new NumberConditionBuilder(thenValue);\n    }"}
{"Number":"774","API Relative Path":"javafx.beans.binding.When.java-then(ObservableObjectValue)","Corresponding Source":"/**\n     * Defines the {@link javafx.beans.value.ObservableObjectValue} which value\n     * is returned by the ternary expression if the condition is {@code true}.\n     *\n     * @param thenValue\n     *            the value\n     * @return the intermediate result which still requires the otherwise-branch\n     */\n    public <T> ObjectConditionBuilder<T> then(final ObservableObjectValue<T> thenValue) {\n        if (thenValue == null) {\n            throw new NullPointerException(\"Value needs to be specified\");\n        }\n        return new ObjectConditionBuilder<T>(thenValue);\n    }"}
{"Number":"775","API Relative Path":"javafx.beans.binding.When.java-then(ObservableStringValue)","Corresponding Source":"/**\n     * Defines the {@link javafx.beans.value.ObservableStringValue} which value\n     * is returned by the ternary expression if the condition is {@code true}.\n     *\n     * @param thenValue\n     *            the value\n     * @return the intermediate result which still requires the otherwise-branch\n     */\n    public StringConditionBuilder then(final ObservableStringValue thenValue) {\n        if (thenValue == null) {\n            throw new NullPointerException(\"Value needs to be specified\");\n        }\n        return new StringConditionBuilder(thenValue);\n    }"}
{"Number":"776","API Relative Path":"javafx.beans.binding.When.java-When(ObservableBooleanValue)","Corresponding Source":"/**\n     * The constructor of {@code When}.\n     *\n     * @param condition\n     *            the condition of the ternary expression\n     */\n    public When(final @NamedArg(\"condition\") ObservableBooleanValue condition) {\n        if (condition == null) {\n            throw new NullPointerException(\"Condition must be specified.\");\n        }\n        this.condition = condition;\n    }"}
{"Number":"777","API Relative Path":"javafx.beans.property.adapter.JavaBeanBooleanProperty.java-bind(ObservableValue)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void bind(ObservableValue<? extends Boolean> observable) {\n        if (observable == null) {\n            throw new NullPointerException(\"Cannot bind to null\");\n        }\n\n        if (!observable.equals(this.observable)) {\n            unbind();\n            set(observable.getValue());\n            this.observable = observable;\n            this.observable.addListener(listener);\n        }\n    }"}
{"Number":"778","API Relative Path":"javafx.beans.property.adapter.JavaBeanDoubleProperty.java-bind(ObservableValue)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void bind(ObservableValue<? extends Number> observable) {\n        if (observable == null) {\n            throw new NullPointerException(\"Cannot bind to null\");\n        }\n\n        if (!observable.equals(this.observable)) {\n            unbind();\n            set(observable.getValue().doubleValue());\n            this.observable = observable;\n            this.observable.addListener(listener);\n        }\n    }"}
{"Number":"779","API Relative Path":"javafx.beans.property.adapter.JavaBeanFloatProperty.java-bind(ObservableValue)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void bind(ObservableValue<? extends Number> observable) {\n        if (observable == null) {\n            throw new NullPointerException(\"Cannot bind to null\");\n        }\n\n        if (!observable.equals(this.observable)) {\n            unbind();\n            set(observable.getValue().floatValue());\n            this.observable = observable;\n            this.observable.addListener(listener);\n        }\n    }"}
{"Number":"780","API Relative Path":"javafx.beans.property.adapter.JavaBeanIntegerProperty.java-bind(ObservableValue)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void bind(ObservableValue<? extends Number> observable) {\n        if (observable == null) {\n            throw new NullPointerException(\"Cannot bind to null\");\n        }\n\n        if (!observable.equals(this.observable)) {\n            unbind();\n            set(observable.getValue().intValue());\n            this.observable = observable;\n            this.observable.addListener(listener);\n        }\n    }"}
{"Number":"781","API Relative Path":"javafx.beans.property.adapter.JavaBeanLongProperty.java-bind(ObservableValue)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void bind(ObservableValue<? extends Number> observable) {\n        if (observable == null) {\n            throw new NullPointerException(\"Cannot bind to null\");\n        }\n\n        if (!observable.equals(this.observable)) {\n            unbind();\n            set(observable.getValue().longValue());\n            this.observable = observable;\n            this.observable.addListener(listener);\n        }\n    }"}
{"Number":"782","API Relative Path":"javafx.beans.property.adapter.JavaBeanObjectProperty.java-bind(ObservableValue)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void bind(ObservableValue<? extends T> observable) {\n        if (observable == null) {\n            throw new NullPointerException(\"Cannot bind to null\");\n        }\n\n        if (!observable.equals(this.observable)) {\n            unbind();\n            set(observable.getValue());\n            this.observable = observable;\n            this.observable.addListener(listener);\n        }\n    }"}
{"Number":"783","API Relative Path":"javafx.beans.property.adapter.JavaBeanStringProperty.java-bind(ObservableValue)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void bind(ObservableValue<? extends String> observable) {\n        if (observable == null) {\n            throw new NullPointerException(\"Cannot bind to null\");\n        }\n\n        if (!observable.equals(this.observable)) {\n            unbind();\n            set(observable.getValue());\n            this.observable = observable;\n            this.observable.addListener(listener);\n        }\n    }"}
{"Number":"784","API Relative Path":"javafx.beans.property.BooleanPropertyBase.java-bind(ObservableValue)","Corresponding Source":"/**\n     * {@inheritDoc}\n     * Note:\n     */\n    @Override\n    public void bind(final ObservableValue<? extends Boolean> rawObservable) {\n        if (rawObservable == null) {\n            throw new NullPointerException(\"Cannot bind to null\");\n        }\n\n        final ObservableBooleanValue newObservable = (rawObservable instanceof ObservableBooleanValue) ? (ObservableBooleanValue) rawObservable\n                : new BooleanBinding() {\n                    {\n                        super.bind(rawObservable);\n                    }\n\n                    @Override\n                    protected boolean computeValue() {\n                        final Boolean value = rawObservable.getValue();\n                        return (value == null)? false : value;\n                    }\n                };\n\n        if (!newObservable.equals(observable)) {\n            unbind();\n            observable = newObservable;\n            if (listener == null) {\n                listener = new Listener(this);\n            }\n            observable.addListener(listener);\n            markInvalid();\n        }\n    }"}
{"Number":"785","API Relative Path":"javafx.beans.property.DoublePropertyBase.java-bind(ObservableValue)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void bind(final ObservableValue<? extends Number> rawObservable) {\n        if (rawObservable == null) {\n            throw new NullPointerException(\"Cannot bind to null\");\n        }\n\n        ObservableDoubleValue newObservable;\n        if (rawObservable instanceof ObservableDoubleValue) {\n            newObservable = (ObservableDoubleValue)rawObservable;\n        } else if (rawObservable instanceof ObservableNumberValue) {\n            final ObservableNumberValue numberValue = (ObservableNumberValue)rawObservable;\n            newObservable = new DoubleBinding() {\n                {\n                    super.bind(rawObservable);\n                }\n\n                @Override\n                protected double computeValue() {\n                    return numberValue.doubleValue();\n                }\n            };\n        } else {\n            newObservable = new DoubleBinding() {\n                {\n                    super.bind(rawObservable);\n                }\n\n                @Override\n                protected double computeValue() {\n                    final Number value = rawObservable.getValue();\n                    return (value == null)? 0.0 : value.doubleValue();\n                }\n            };\n        }\n\n        if (!newObservable.equals(observable)) {\n            unbind();\n            observable = newObservable;\n            if (listener == null) {\n                listener = new Listener(this);\n            }\n            observable.addListener(listener);\n            markInvalid();\n        }\n    }"}
{"Number":"786","API Relative Path":"javafx.beans.property.FloatPropertyBase.java-bind(ObservableValue)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void bind(final ObservableValue<? extends Number> rawObservable) {\n        if (rawObservable == null) {\n            throw new NullPointerException(\"Cannot bind to null\");\n        }\n\n        ObservableFloatValue newObservable;\n        if (rawObservable instanceof ObservableFloatValue) {\n            newObservable = (ObservableFloatValue)rawObservable;\n        } else if (rawObservable instanceof ObservableNumberValue) {\n            final ObservableNumberValue numberValue = (ObservableNumberValue)rawObservable;\n            newObservable = new FloatBinding() {\n                {\n                    super.bind(rawObservable);\n                }\n\n                @Override\n                protected float computeValue() {\n                    return numberValue.floatValue();\n                }\n            };\n        } else {\n            newObservable = new FloatBinding() {\n                {\n                    super.bind(rawObservable);\n                }\n\n                @Override\n                protected float computeValue() {\n                    final Number value = rawObservable.getValue();\n                    return (value == null)? 0.0f : value.floatValue();\n                }\n            };\n        }\n\n\n        if (!newObservable.equals(observable)) {\n            unbind();\n            observable = newObservable;\n            if (listener == null) {\n                listener = new Listener(this);\n            }\n            observable.addListener(listener);\n            markInvalid();\n        }\n    }"}
{"Number":"787","API Relative Path":"javafx.beans.property.IntegerPropertyBase.java-bind(ObservableValue)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void bind(final ObservableValue<? extends Number> rawObservable) {\n        if (rawObservable == null) {\n            throw new NullPointerException(\"Cannot bind to null\");\n        }\n\n        ObservableIntegerValue newObservable;\n        if (rawObservable instanceof ObservableIntegerValue) {\n            newObservable = (ObservableIntegerValue)rawObservable;\n        } else if (rawObservable instanceof ObservableNumberValue) {\n            final ObservableNumberValue numberValue = (ObservableNumberValue)rawObservable;\n            newObservable = new IntegerBinding() {\n                {\n                    super.bind(rawObservable);\n                }\n\n                @Override\n                protected int computeValue() {\n                    return numberValue.intValue();\n                }\n            };\n        } else {\n            newObservable = new IntegerBinding() {\n                {\n                    super.bind(rawObservable);\n                }\n\n                @Override\n                protected int computeValue() {\n                    final Number value = rawObservable.getValue();\n                    return (value == null)? 0 : value.intValue();\n                }\n            };\n        }\n\n        if (!newObservable.equals(observable)) {\n            unbind();\n            observable = newObservable;\n            if (listener == null) {\n                listener = new Listener(this);\n            }\n            observable.addListener(listener);\n            markInvalid();\n        }\n    }"}
{"Number":"788","API Relative Path":"javafx.beans.property.ListPropertyBase.java-ListPropertyBase(ObservableList)","Corresponding Source":"/**\n     * The constructor of the {@code ListPropertyBase}.\n     *\n     * @param initialValue\n     *            the initial value of the wrapped value\n     */\n    public ListPropertyBase(ObservableList<E> initialValue) {\n        this.value = initialValue;\n        if (initialValue != null) {\n            initialValue.addListener(listChangeListener);\n        }\n    }"}
{"Number":"789","API Relative Path":"javafx.beans.property.LongPropertyBase.java-bind(ObservableValue)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void bind(final ObservableValue<? extends Number> rawObservable) {\n        if (rawObservable == null) {\n            throw new NullPointerException(\"Cannot bind to null\");\n        }\n\n        ObservableLongValue newObservable;\n        if (rawObservable instanceof ObservableLongValue) {\n            newObservable = (ObservableLongValue)rawObservable;\n        } else if (rawObservable instanceof ObservableNumberValue) {\n            final ObservableNumberValue numberValue = (ObservableNumberValue)rawObservable;\n            newObservable = new LongBinding() {\n                {\n                    super.bind(rawObservable);\n                }\n\n                @Override\n                protected long computeValue() {\n                    return numberValue.longValue();\n                }\n            };\n        } else {\n            newObservable = new LongBinding() {\n                {\n                    super.bind(rawObservable);\n                }\n\n                @Override\n                protected long computeValue() {\n                    final Number value = rawObservable.getValue();\n                    return (value == null)? 0L : value.longValue();\n                }\n            };\n        }\n\n        if (!newObservable.equals(observable)) {\n            unbind();\n            observable = newObservable;\n            if (listener == null) {\n                listener = new Listener(this);\n            }\n            observable.addListener(listener);\n            markInvalid();\n        }\n    }"}
{"Number":"790","API Relative Path":"javafx.beans.property.MapPropertyBase.java-MapPropertyBase(ObservableMap)","Corresponding Source":"/**\n     * The constructor of the {@code MapPropertyBase}.\n     *\n     * @param initialValue\n     *            the initial value of the wrapped value\n     */\n    public MapPropertyBase(ObservableMap<K, V> initialValue) {\n        this.value = initialValue;\n        if (initialValue != null) {\n            initialValue.addListener(mapChangeListener);\n        }\n    }"}
{"Number":"791","API Relative Path":"javafx.beans.property.ObjectPropertyBase.java-bind(ObservableValue)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void bind(final ObservableValue<? extends T> newObservable) {\n        if (newObservable == null) {\n            throw new NullPointerException(\"Cannot bind to null\");\n        }\n\n        if (!newObservable.equals(this.observable)) {\n            unbind();\n            observable = newObservable;\n            if (listener == null) {\n                listener = new Listener(this);\n            }\n            observable.addListener(listener);\n            markInvalid();\n        }\n    }"}
{"Number":"792","API Relative Path":"javafx.beans.property.SetPropertyBase.java-SetPropertyBase(ObservableSet)","Corresponding Source":"/**\n     * The constructor of the {@code SetPropertyBase}.\n     *\n     * @param initialValue\n     *            the initial value of the wrapped value\n     */\n    public SetPropertyBase(ObservableSet<E> initialValue) {\n        this.value = initialValue;\n        if (initialValue != null) {\n            initialValue.addListener(setChangeListener);\n        }\n    }"}
{"Number":"793","API Relative Path":"javafx.beans.property.StringPropertyBase.java-bind(ObservableValue)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public void bind(ObservableValue<? extends String> newObservable) {\n        if (newObservable == null) {\n            throw new NullPointerException(\"Cannot bind to null\");\n        }\n        if (!newObservable.equals(observable)) {\n            unbind();\n            observable = newObservable;\n            if (listener == null) {\n                listener = new Listener(this);\n            }\n            observable.addListener(listener);\n            markInvalid();\n        }\n    }"}
{"Number":"794","API Relative Path":"javafx.beans.value.WeakChangeListener.java-WeakChangeListener(ChangeListener)","Corresponding Source":"/**\n     * The constructor of {@code WeakChangeListener}.\n     *\n     * @param listener\n     *            The original listener that should be notified\n     */\n    public WeakChangeListener(@NamedArg(\"listener\") ChangeListener<T> listener) {\n        if (listener == null) {\n            throw new NullPointerException(\"Listener must be specified.\");\n        }\n        this.ref = new WeakReference<ChangeListener<T>>(listener);\n    }"}
{"Number":"795","API Relative Path":"javafx.beans.WeakInvalidationListener.java-WeakInvalidationListener(InvalidationListener)","Corresponding Source":"/**\n     * The constructor of {@code WeakInvalidationListener}.\n     *\n     * @param listener\n     *            The original listener that should be notified\n     */\n    public WeakInvalidationListener(@NamedArg(\"listener\") InvalidationListener listener) {\n        if (listener == null) {\n            throw new NullPointerException(\"Listener must be specified.\");\n        }\n        this.ref = new WeakReference<InvalidationListener>(listener);\n    }"}
{"Number":"796","API Relative Path":"javafx.collections.FXCollections.java-checkedObservableList(ObservableList-Class)","Corresponding Source":"/**\n     * Creates and returns a typesafe wrapper on top of provided observable list.\n     * @param list  an Observable list to be wrapped\n     * @param type   the type of element that <tt>list<\/tt> is permitted to hold\n     * @return a dynamically typesafe view of the specified list\n     * @see Collections#checkedList(java.util.List, java.lang.Class)\n     */\n    public static<E> ObservableList<E> checkedObservableList(ObservableList<E> list, Class<E> type) {\n        if (list == null) {\n            throw new NullPointerException();\n        }\n        return new CheckedObservableList<E>(list, type);\n    }"}
{"Number":"797","API Relative Path":"javafx.collections.FXCollections.java-checkedObservableMap(ObservableMap-Class-Class)","Corresponding Source":"/**\n     * Creates and returns a typesafe wrapper on top of provided observable map.\n     * @param map an Observable map to be wrapped\n     * @param keyType the type of key that {@code map} is permitted to hold\n     * @param valueType the type of value that {@code map} is permitted to hold\n     * @return a dynamically typesafe view of the specified map\n     * @see Collections#checkedMap(java.util.Map, java.lang.Class)\n     * @since JavaFX 8.0\n     */\n    public static <K, V> ObservableMap<K, V> checkedObservableMap(ObservableMap<K, V> map, Class<K> keyType, Class<V> valueType) {\n        if (map == null || keyType == null || valueType == null) {\n            throw new NullPointerException();\n        }\n        return new CheckedObservableMap<K, V>(map, keyType, valueType);\n    }"}
{"Number":"798","API Relative Path":"javafx.collections.FXCollections.java-checkedObservableSet(ObservableSet-Class)","Corresponding Source":"/**\n     * Creates and returns a typesafe wrapper on top of provided observable set.\n     * @param set an Observable set to be wrapped\n     * @param type  the type of element that <tt>set<\/tt> is permitted to hold\n     * @return a dynamically typesafe view of the specified set\n     * @see Collections#checkedSet(java.util.Set, java.lang.Class)\n     * @since JavaFX 8.0\n     */\n    public static<E> ObservableSet<E> checkedObservableSet(ObservableSet<E> set, Class<E> type) {\n        if (set == null) {\n            throw new NullPointerException();\n        }\n        return new CheckedObservableSet<E>(set, type);\n    }"}
{"Number":"799","API Relative Path":"javafx.collections.FXCollections.java-observableArrayList(Callback)","Corresponding Source":"/**\n     * Creates a new empty observable list backed by an arraylist.\n     *\n     * This list reports element updates.\n     * @param extractor element to Observable[] convertor. Observable objects are listened for changes on the element.\n     * @see #observableList(java.util.List, javafx.util.Callback)\n     * @since JavaFX 2.1\n     * @return a newly created ObservableList\n     */\n    public static <E> ObservableList<E> observableArrayList(Callback<E, Observable[]> extractor) {\n        return observableList(new ArrayList(), extractor);\n    }"}
{"Number":"800","API Relative Path":"javafx.collections.FXCollections.java-observableList(List)","Corresponding Source":"/**\n     * Constructs an ObservableList that is backed by the specified list.\n     * Mutation operations on the ObservableList instance will be reported\n     * to observers that have registered on that instance.<br>\n     * Note that mutation operations made directly to the underlying list are\n     * <em>not<\/em> reported to observers of any ObservableList that\n     * wraps it.\n     *\n     * @param list a concrete List that backs this ObservableList\n     * @return a newly created ObservableList\n     */\n    public static <E> ObservableList<E> observableList(List<E> list) {\n        if (list == null) {\n            throw new NullPointerException();\n        }\n        return list instanceof RandomAccess ? new ObservableListWrapper<E>(list) :\n                new ObservableSequentialListWrapper<E>(list);\n    }"}
{"Number":"801","API Relative Path":"javafx.collections.FXCollections.java-observableList(List-Callback)","Corresponding Source":"/**\n     * Constructs an ObservableList that is backed by the specified list.\n     * Mutation operations on the ObservableList instance will be reported\n     * to observers that have registered on that instance.<br>\n     * Note that mutation operations made directly to the underlying list are\n     * <em>not<\/em> reported to observers of any ObservableList that\n     * wraps it.\n     * <br>\n     * This list also reports mutations of the elements in it by using <code>extractor<\/code>.\n     * Observable objects returned by extractor (applied to each list element) are listened for changes\n     * and transformed into \"update\" change of ListChangeListener.\n     *\n     * @param list a concrete List that backs this ObservableList\n     * @param extractor element to Observable[] convertor\n     * @since JavaFX 2.1\n     * @return a newly created ObservableList\n     */\n    public static <E> ObservableList<E> observableList(List<E> list, Callback<E, Observable[]> extractor) {\n        if (list == null || extractor == null) {\n            throw new NullPointerException();\n        }\n        return list instanceof RandomAccess ? new ObservableListWrapper<E>(list, extractor) :\n            new ObservableSequentialListWrapper<E>(list, extractor);\n    }"}
{"Number":"802","API Relative Path":"javafx.collections.FXCollections.java-observableMap(Map)","Corresponding Source":"/**\n     * Constructs an ObservableMap that is backed by the specified map.\n     * Mutation operations on the ObservableMap instance will be reported\n     * to observers that have registered on that instance.<br>\n     * Note that mutation operations made directly to the underlying map are <em>not<\/em>\n     * reported to observers of any ObservableMap that wraps it.\n     * @param map a Map that backs this ObservableMap\n     * @return a newly created ObservableMap\n     */\n    public static <K, V> ObservableMap<K, V> observableMap(Map<K, V> map) {\n        if (map == null) {\n            throw new NullPointerException();\n        }\n        return new ObservableMapWrapper<K, V>(map);\n    }"}
{"Number":"803","API Relative Path":"javafx.collections.FXCollections.java-observableSet(E)","Corresponding Source":"/**\n     * Constructs an ObservableSet backed by a HashSet\n     * that contains all the specified elements.\n     * @param elements elements that will be added into returned ObservableSet\n     * @return a newly created ObservableSet\n     * @since JavaFX 2.1\n     */\n    public static <E> ObservableSet<E> observableSet(E... elements) {\n        if (elements == null) {\n            throw new NullPointerException();\n        }\n        Set<E> set = new HashSet<E>(elements.length);\n        Collections.addAll(set, elements);\n        return new ObservableSetWrapper<E>(set);\n    }"}
{"Number":"804","API Relative Path":"javafx.collections.FXCollections.java-observableSet(Set)","Corresponding Source":"/**\n     * Constructs an ObservableSet that is backed by the specified set.\n     * Mutation operations on the ObservableSet instance will be reported\n     * to observers that have registered on that instance.<br>\n     * Note that mutation operations made directly to the underlying set are <em>not<\/em>\n     * reported to observers of any ObservableSet that wraps it.\n     * @param set a Set that backs this ObservableSet\n     * @return a newly created ObservableSet\n     * @since JavaFX 2.1\n     */\n    public static <E> ObservableSet<E> observableSet(Set<E> set) {\n        if (set == null) {\n            throw new NullPointerException();\n        }\n        return new ObservableSetWrapper<E>(set);\n    }"}
{"Number":"805","API Relative Path":"javafx.collections.FXCollections.java-synchronizedObservableList(ObservableList)","Corresponding Source":"/**\n     * Creates and returns a synchronized wrapper on top of provided observable list.\n     * @param  list the list to be \"wrapped\" in a synchronized list.\n     * @return A synchronized version of the observable list\n     * @see Collections#synchronizedList(java.util.List)\n     */\n    public static<E> ObservableList<E> synchronizedObservableList(ObservableList<E> list) {\n        if (list == null) {\n            throw new NullPointerException();\n        }\n        return new SynchronizedObservableList<E>(list);\n    }"}
{"Number":"806","API Relative Path":"javafx.collections.FXCollections.java-synchronizedObservableMap(ObservableMap)","Corresponding Source":"/**\n     * Creates and returns a synchronized wrapper on top of provided observable map.\n     * @param  map the map to be \"wrapped\" in a synchronized map.\n     * @return A synchronized version of the observable map\n     * @see Collections#synchronizedMap(java.util.Map)\n     * @since JavaFX 8.0\n     */\n    public static <K, V> ObservableMap<K, V> synchronizedObservableMap(ObservableMap<K, V> map) {\n        if (map == null) {\n            throw new NullPointerException();\n        }\n        return new SynchronizedObservableMap<K, V>(map);\n    }"}
{"Number":"807","API Relative Path":"javafx.collections.FXCollections.java-synchronizedObservableSet(ObservableSet)","Corresponding Source":"/**\n     * Creates and returns a synchronized wrapper on top of provided observable set.\n     * @param  set the set to be \"wrapped\" in a synchronized set.\n     * @return A synchronized version of the observable set\n     * @see Collections#synchronizedSet(java.util.Set)\n     * @since JavaFX 8.0\n     */\n    public static<E> ObservableSet<E> synchronizedObservableSet(ObservableSet<E> set) {\n        if (set == null) {\n            throw new NullPointerException();\n        }\n        return new SynchronizedObservableSet<E>(set);\n    }"}
{"Number":"808","API Relative Path":"javafx.collections.FXCollections.java-unmodifiableObservableList(ObservableList)","Corresponding Source":"/**\n     * Creates and returns unmodifiable wrapper list on top of provided observable list.\n     * @param list  an ObservableList that is to be wrapped\n     * @return an ObserableList wrapper that is unmodifiable\n     * @see Collections#unmodifiableList(java.util.List)\n     */\n    @ReturnsUnmodifiableCollection\n    public static<E> ObservableList<E> unmodifiableObservableList(ObservableList<E> list) {\n        if (list == null) {\n            throw new NullPointerException();\n        }\n        return new UnmodifiableObservableListImpl<E>(list);\n    }"}
{"Number":"809","API Relative Path":"javafx.collections.FXCollections.java-unmodifiableObservableMap(ObservableMap)","Corresponding Source":"/**\n     * Constructs a read-only interface to the specified ObservableMap. Only\n     * mutation operations made to the underlying ObservableMap will be reported\n     * to observers that have registered on the unmodifiable instance. This allows\n     * clients to track changes in a Map but disallows the ability to modify it.\n     * @param map an ObservableMap that is to be monitored by this interface\n     * @return a newly created UnmodifiableObservableMap\n     */\n    @ReturnsUnmodifiableCollection\n    public static <K, V> ObservableMap<K, V> unmodifiableObservableMap(ObservableMap<K, V> map) {\n        if (map == null) {\n            throw new NullPointerException();\n        }\n        return new com.sun.javafx.collections.UnmodifiableObservableMap<K, V>(map);\n    }"}
{"Number":"810","API Relative Path":"javafx.collections.FXCollections.java-unmodifiableObservableSet(ObservableSet)","Corresponding Source":"/**\n     * Creates and returns unmodifiable wrapper on top of provided observable set.\n     * @param set an ObservableSet that is to be wrapped\n     * @return an ObserableSet wrapper that is unmodifiable\n     * @see Collections#unmodifiableSet(java.util.Set)\n     * @since JavaFX 8.0\n     */\n    @ReturnsUnmodifiableCollection\n    public static<E> ObservableSet<E> unmodifiableObservableSet(ObservableSet<E> set) {\n        if (set == null) {\n            throw new NullPointerException();\n        }\n        return new UnmodifiableObservableSet<E>(set);\n    }"}
{"Number":"811","API Relative Path":"javafx.collections.transformation.FilteredList.java-get(int)","Corresponding Source":"/**\n     * Returns the element at the specified position in this list.\n     *\n     * @param  index index of the element to return\n     * @return the element at the specified position in this list\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public E get(int index) {\n        if (index >= size) {\n            throw new IndexOutOfBoundsException();\n        }\n        return getSource().get(filtered[index]);\n    }"}
{"Number":"812","API Relative Path":"javafx.collections.transformation.SortedList.java-get(int)","Corresponding Source":"/**\n     * Returns the element at the specified position in this list.\n     *\n     * @param  index index of the element to return\n     * @return the element at the specified position in this list\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public E get(int index) {\n        if (index >= size) {\n            throw new IndexOutOfBoundsException();\n        }\n        return sorted[index].e;\n    }"}
{"Number":"813","API Relative Path":"javafx.collections.transformation.TransformationList.java-TransformationList(ObservableList)","Corresponding Source":"/**\n     * Creates a new Transformation list wrapped around the source list.\n     * @param source the wrapped list\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected TransformationList(ObservableList<? extends F> source) {\n        if (source == null) {\n            throw new NullPointerException();\n        }\n        this.source = source;\n        source.addListener(new WeakListChangeListener<>(getListener()));\n    }"}
{"Number":"814","API Relative Path":"javafx.collections.WeakListChangeListener.java-WeakListChangeListener(ListChangeListener)","Corresponding Source":"/**\n     * The constructor of {@code WeakListChangeListener}.\n     *\n     * @param listener\n     *            The original listener that should be notified\n     */\n    public WeakListChangeListener(@NamedArg(\"listener\") ListChangeListener<E> listener) {\n        if (listener == null) {\n            throw new NullPointerException(\"Listener must be specified.\");\n        }\n        this.ref = new WeakReference<ListChangeListener<E>>(listener);\n    }"}
{"Number":"815","API Relative Path":"javafx.collections.WeakMapChangeListener.java-WeakMapChangeListener(MapChangeListener)","Corresponding Source":"/**\n     * The constructor of {@code WeakMapChangeListener}.\n     *\n     * @param listener\n     *            The original listener that should be notified\n     */\n    public WeakMapChangeListener(@NamedArg(\"listener\") MapChangeListener<K, V> listener) {\n        if (listener == null) {\n            throw new NullPointerException(\"Listener must be specified.\");\n        }\n        this.ref = new WeakReference<MapChangeListener<K, V>>(listener);\n    }"}
{"Number":"816","API Relative Path":"javafx.collections.WeakSetChangeListener.java-WeakSetChangeListener(SetChangeListener)","Corresponding Source":"/**\n     * The constructor of {@code WeakSetChangeListener}.\n     *\n     * @param listener\n     *            The original listener that should be notified\n     */\n    public WeakSetChangeListener(@NamedArg(\"listener\") SetChangeListener<E> listener) {\n        if (listener == null) {\n            throw new NullPointerException(\"Listener must be specified.\");\n        }\n        this.ref = new WeakReference<SetChangeListener<E>>(listener);\n    }"}
{"Number":"817","API Relative Path":"javafx.css.CssMetaData.java-CssMetaData(String-StyleConverter-V-boolean-List)","Corresponding Source":"/**\n     * Construct a CssMetaData with the given parameters and no sub-properties.\n     * @param property the CSS property\n     * @param converter the StyleConverter used to convert the CSS parsed value to a Java object.\n     * @param initialValue The initial or default value of the corresponding StyleableProperty\n     * @param inherits true if this property uses CSS inheritance\n     * @param subProperties the sub-properties of this property. For example,\n     * the -fx-font property has the sub-properties -fx-font-family,\n     * -fx-font-size, -fx-font-weight, and -fx-font-style.\n     */\n    protected CssMetaData(\n            final String property,\n            final StyleConverter<?,V> converter,\n            final V initialValue,\n            boolean inherits,\n            final List<CssMetaData<? extends Styleable, ?>> subProperties) {\n\n        this.property = property;\n        this.converter = converter;\n        this.initialValue = initialValue;\n        this.inherits = inherits;\n        this.subProperties = subProperties != null ? Collections.unmodifiableList(subProperties) : null;\n\n        if (this.property == null || this.converter == null) {\n            throw new IllegalArgumentException(\"neither property nor converter can be null\");\n        }\n    }"}
{"Number":"818","API Relative Path":"javafx.event.EventType.java-EventType(EventType-String)","Corresponding Source":"/**\n     * Constructs a new {@code EventType} with the specified super type and\n     * name.\n     *\n     * @param superType the event super type\n     * @param name the name\n     * @throws IllegalArgumentException if an EventType with the same name and\n     * superType exists\n     */\n    public EventType(final EventType<? super T> superType,\n            final String name) {\n        if (superType == null) {\n            throw new NullPointerException(\n                    \"Event super type must not be null!\");\n        }\n\n        this.superType = superType;\n        this.name = name;\n        superType.register(this);\n    }"}
{"Number":"819","API Relative Path":"javafx.event.EventType.java-EventType(String-EventType)","Corresponding Source":"/**\n     * Internal constructor that skips various checks\n     */\n    EventType(final String name,\n                      final EventType<? super T> superType) {\n        this.superType = superType;\n        this.name = name;\n        if (superType != null) {\n            if (superType.subTypes != null) {\n                for (Iterator i = superType.subTypes.keySet().iterator(); i.hasNext();) {\n                    EventType t  = (EventType) i.next();\n                    if (name == null && t.name == null || (name != null && name.equals(t.name))) {\n                        i.remove();\n                    }\n                }\n            }\n            superType.register(this);\n        }\n    }"}
{"Number":"820","API Relative Path":"javafx.fxml.FXMLLoader.java-FXMLLoader(URL-ResourceBundle-BuilderFactory-Callback-Charset-LinkedList)","Corresponding Source":"/**\n     * Creates a new FXMLLoader instance.\n     *\n     * @param location\n     * @param resources\n     * @param builderFactory\n     * @param controllerFactory\n     * @param charset\n     * @param loaders\n     * @since JavaFX 2.1\n     */\n    public FXMLLoader(URL location, ResourceBundle resources, BuilderFactory builderFactory,\n        Callback<Class<?>, Object> controllerFactory, Charset charset,\n        LinkedList<FXMLLoader> loaders) {\n        setLocation(location);\n        setResources(resources);\n        setBuilderFactory(builderFactory);\n        setControllerFactory(controllerFactory);\n        setCharset(charset);\n\n        this.loaders = new LinkedList(loaders);\n    }"}
{"Number":"821","API Relative Path":"javafx.fxml.FXMLLoader.java-load(InputStream)","Corresponding Source":"/**\n     * Loads an object hierarchy from a FXML document.\n     *\n     * @param inputStream\n     * An input stream containing the FXML data to load.\n     *\n     * @return\n     * The loaded object hierarchy.\n     */\n    @CallerSensitive\n    public <T> T load(InputStream inputStream) throws IOException {\n        return loadImpl(inputStream, (System.getSecurityManager() != null)\n                                         ? Reflection.getCallerClass()\n                                         : null);\n    }"}
{"Number":"822","API Relative Path":"javafx.fxml.FXMLLoader.java-load(URL-ResourceBundle-BuilderFactory-Callback-Charset)","Corresponding Source":"/**\n     * Loads an object hierarchy from a FXML document.\n     *\n     * @param location\n     * @param resources\n     * @param builderFactory\n     * @param controllerFactory\n     * @param charset\n     * @since JavaFX 2.1\n     */\n    @CallerSensitive\n    public static <T> T load(URL location, ResourceBundle resources,\n                             BuilderFactory builderFactory,\n                             Callback<Class<?>, Object> controllerFactory,\n                             Charset charset) throws IOException {\n        return loadImpl(location, resources, builderFactory, controllerFactory,\n                        charset,\n                        (System.getSecurityManager() != null)\n                            ? Reflection.getCallerClass()\n                            : null);\n    }"}
{"Number":"823","API Relative Path":"javafx.fxml.FXMLLoader.java-setCharset(Charset)","Corresponding Source":"/**\n     * Sets the charset used by this loader.\n     *\n     * @param charset\n     * @since JavaFX 2.1\n     */\n    public void setCharset(Charset charset) {\n        if (charset == null) {\n            throw new NullPointerException(\"charset is null.\");\n        }\n\n        this.charset = charset;\n    }"}
{"Number":"824","API Relative Path":"javafx.fxml.FXMLLoader.java-setClassLoader(ClassLoader)","Corresponding Source":"/**\n     * Sets the classloader used by this serializer and clears any existing\n     * imports\n     *\n     * @param classLoader\n     * @since JavaFX 2.1\n     */\n    public void setClassLoader(ClassLoader classLoader) {\n        if (classLoader == null) {\n            throw new IllegalArgumentException();\n        }\n\n        this.classLoader = classLoader;\n\n        clearImports();\n    }"}
{"Number":"825","API Relative Path":"javafx.fxml.FXMLLoader.java-setDefaultClassLoader(ClassLoader)","Corresponding Source":"/**\n     * Sets the default class loader.\n     *\n     * @param defaultClassLoader\n     * The default class loader to use when loading classes.\n     * @since JavaFX 2.1\n     */\n    public static void setDefaultClassLoader(ClassLoader defaultClassLoader) {\n        if (defaultClassLoader == null) {\n            throw new NullPointerException();\n        }\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new AllPermission());\n        }\n\n        FXMLLoader.defaultClassLoader = defaultClassLoader;\n    }"}
{"Number":"826","API Relative Path":"javafx.fxml.JavaFXBuilderFactory.java-JavaFXBuilderFactory(ClassLoader-boolean)","Corresponding Source":"/**\n     * @treatAsPrivate\n     * This constructor is for internal use only.\n     *\n     * @deprecated\n     * @since JavaFX 2.1\n     */\n    public JavaFXBuilderFactory(ClassLoader classLoader, boolean alwaysUseBuilders) {\n        // SB-dependency: RT-21230 has been filed to track this\n        if (classLoader == null) {\n            throw new NullPointerException();\n        }\n\n        this.classLoader = classLoader;\n        this.alwaysUseBuilders = alwaysUseBuilders;\n        this.webSupported = Platform.isSupported(ConditionalFeature.WEB);\n    }"}
{"Number":"827","API Relative Path":"javafx.geometry.Rectangle2D.java-Rectangle2D(double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of {@code Rectangle2D}.\n     * @param minX The x coordinate of the upper-left corner of the {@code Rectangle2D}\n     * @param minY The y coordinate of the upper-left corner of the {@code Rectangle2D}\n     * @param width The width of the {@code Rectangle2D}\n     * @param height The height of the {@code Rectangle2D}\n     */\n    public Rectangle2D(@NamedArg(\"minX\") double minX, @NamedArg(\"minY\") double minY, @NamedArg(\"width\") double width, @NamedArg(\"height\") double height) {\n        if (width < 0 || height < 0) {\n            throw new IllegalArgumentException(\"Both width and height must be >= 0\");\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.width = width;\n        this.height = height;\n        this.maxX = minX + width;\n        this.maxY = minY + height;\n    }"}
{"Number":"828","API Relative Path":"javafx.print.JobSettings.java-setPrintResolution(PrintResolution)","Corresponding Source":"/**\n     * Set the <code>PrintResolution<\/code> property.\n     * A null value is ignored.\n     * <p>\n     * Note that quality and resolution overlapping concepts.\n     * Therefore a printer may support setting one, or the other but\n     * not both. Applications setting these programmatically should\n     * query both properties and select appropriately from the supported\n     * values. If a printer supports non-standard values, code likely\n     * cannot distinguish the printer's interpretation of these values\n     * and is safest to stick to selecting from the standard value that\n     * matches the requirement.\n     * @param resolution new setting for print resolution.\n     */\n    public void setPrintResolution(PrintResolution resolution) {\n        if (resolution == null || resolution == getPrintResolution()) {\n            return;\n        }\n        printResolutionProperty().set(resolution);\n    }"}
{"Number":"829","API Relative Path":"javafx.print.PageLayout.java-PageLayout(Paper-PageOrientation-double-double-double-double)","Corresponding Source":"/**\n     * Note that the margins are to be specified as applying after\n     * the rotation due to the orientation. Thus the left margin\n     * always defines the x origin of the printable area,\n     * and the top margin always defines its y origin.\n     * @param paper the paper to use\n     * @param orient orientation of the layout\n     * @param leftMargin the left margin in points.\n     * @param rightMargin the left margin in points.\n     * @param topMargin the top margin in points.\n     * @param bottomMargin the bottom margin in points.\n     * @throws IllegalArgumentException if the margins exceed the\n     * corresponding paper dimension, or are negative, or if\n     * paper or orient is null.\n     */\n    PageLayout(Paper paper, PageOrientation orient,\n               double leftMargin, double rightMargin,\n               double topMargin, double bottomMargin) {\n\n        if (paper == null || orient == null ||\n            leftMargin < 0 || rightMargin < 0 ||\n            topMargin < 0 || bottomMargin < 0) {\n            throw new IllegalArgumentException(\"Illegal parameters\");\n        }\n        if (orient == PORTRAIT || orient == REVERSE_PORTRAIT) {\n            if (leftMargin+rightMargin > paper.getWidth() ||\n                topMargin+bottomMargin > paper.getHeight()) {\n                throw new IllegalArgumentException(\"Bad margins\");\n            }\n        } else if (leftMargin+rightMargin > paper.getHeight() ||\n                   topMargin+bottomMargin > paper.getWidth()) {\n            throw new IllegalArgumentException(\"Bad margins\");\n        }\n        this.paper = paper;\n        this.orient = orient;\n        this.lMargin = leftMargin;\n        this.rMargin = rightMargin;\n        this.tMargin = topMargin;\n        this.bMargin = bottomMargin;\n    }"}
{"Number":"830","API Relative Path":"javafx.print.PageRange.java-PageRange(int-int)","Corresponding Source":"/**\n     * Create a new PageRange with the specified start and end page numbers.\n     * @param startPage the first page in the range.\n     * @param endPage the last page in the range.\n     * @throws IllegalArgumentException if the page range is not valid\n     */\n    public PageRange(@NamedArg(\"startPage\") int startPage, @NamedArg(\"endPage\") int endPage) {\n        if (startPage <= 0 || startPage > endPage) {\n            throw new IllegalArgumentException(\"Invalid range : \" +\n                                               startPage + \" -> \" + endPage);\n        }\n        startPageImplProperty().set(startPage);\n        endPageImplProperty().set(endPage);\n    }"}
{"Number":"831","API Relative Path":"javafx.print.Printer.java-createPageLayout(Paper-PageOrientation-double-double-double-double)","Corresponding Source":"/**\n     * Obtain a new PageLayout for this printer using the specified\n     * parameters.\n     * The paper should be one of the supported papers and\n     * the orientation should be a supported orientation.\n     * <p>\n     * Margin values are specified in 1/72 of an inch points.\n     * Margins will be validated against the printer supported margins,\n     * and adjusted if necessary. This method is generally useful to\n     * a client that wants margins that are different (eg wider)\n     * than the default margins, such as 1\" at top and bottom and\n     * 0.5\" to the left and right.\n     * <p>A client that needs to know what margin values are legal should first\n     * obtain a PageLayout using the <code>HARDWARE_MINIMUM<\/code> margins.\n     * <p>\n     * If the printer cannot support the layout as specified, it\n     * will adjust the returned layout to a supported configuration\n     * @param paper The paper to use\n     * @param orient The orientation to use\n     * @param lMargin the left margin to use in pts.\n     * @param rMargin the right margin to use in pts.\n     * @param tMargin the top margin to use in pts.\n     * @param bMargin the bottom margin to use in pts.\n     * @return PageLayout based on the specified parameters.\n     * @throws NullPointerException if paper or orient are null.\n     * @throws IllegalArgumentException if any of the margins values are\n     * less than zero.\n     */\n    public PageLayout createPageLayout(Paper paper, PageOrientation orient,\n                                       double lMargin, double rMargin,\n                                       double tMargin, double bMargin) {\n\n        if (paper == null || orient == null) {\n            throw new NullPointerException(\"Parameters cannot be null\");\n        }\n        if (lMargin < 0 || rMargin < 0 || tMargin < 0 || bMargin < 0) {\n            throw new IllegalArgumentException(\"Margins must be >= 0\");\n        }\n        // TBD: Adjust paper to a supported one first.\n        Rectangle2D imgArea = impl.printableArea(paper);\n        double width = paper.getWidth() / 72.0;\n        double height = paper.getHeight() / 72.0;\n        double plm = imgArea.getMinX();\n        double ptm = imgArea.getMinY();\n        double prm = width - imgArea.getMaxX();\n        double pbm = height - imgArea.getMaxY();\n\n        lMargin /= 72.0;\n        rMargin /= 72.0;\n        tMargin /= 72.0;\n        bMargin /= 72.0;\n\n        // Check if the requested margins exceed the paper and\n        // if they do, ignore them.\n        boolean useDefault = false;\n        if (orient == PORTRAIT || orient == REVERSE_PORTRAIT) {\n            if ((lMargin + rMargin > width) ||\n                (tMargin + bMargin > height)) {\n                useDefault = true;\n            }\n        } else {\n            if ((lMargin + rMargin > height) ||\n                (tMargin + bMargin > width)) {\n                useDefault = true;\n            }\n        }\n        if (useDefault) {\n            return createPageLayout(paper, orient, MarginType.DEFAULT);\n        }\n\n        double lm, rm, tm, bm;\n        // TBD: Adjust orient to a supported one first.\n        switch (orient) {\n        case LANDSCAPE: lm = pbm; rm = ptm; tm = plm; bm = prm;\n            break;\n        case REVERSE_LANDSCAPE: lm = ptm; rm = pbm; tm = prm; bm = plm;\n            break;\n        case REVERSE_PORTRAIT: lm = prm; rm = plm; tm = pbm; bm = ptm;\n            break;\n        default: lm = plm; rm = prm; tm = ptm; bm = pbm;\n        }\n\n        lm = (lMargin >= lm) ? lMargin : lm;\n        rm = (rMargin >= rm) ? rMargin : rm;\n        tm = (tMargin >= tm) ? tMargin : tm;\n        bm = (bMargin >= bm) ? bMargin : bm;\n\n        lm *= 72;\n        rm *= 72;\n        tm *= 72;\n        bm *= 72;\n\n        return new PageLayout(paper, orient, lm, rm, tm, bm);\n    }"}
{"Number":"832","API Relative Path":"javafx.print.Printer.java-createPageLayout(Paper-PageOrientation-double-double-double-double)","Corresponding Source":"/**\n     * Obtain a new PageLayout for this printer using the specified\n     * parameters.\n     * The paper should be one of the supported papers and\n     * the orientation should be a supported orientation.\n     * <p>\n     * Margin values are specified in 1/72 of an inch points.\n     * Margins will be validated against the printer supported margins,\n     * and adjusted if necessary. This method is generally useful to\n     * a client that wants margins that are different (eg wider)\n     * than the default margins, such as 1\" at top and bottom and\n     * 0.5\" to the left and right.\n     * <p>A client that needs to know what margin values are legal should first\n     * obtain a PageLayout using the <code>HARDWARE_MINIMUM<\/code> margins.\n     * <p>\n     * If the printer cannot support the layout as specified, it\n     * will adjust the returned layout to a supported configuration\n     * @param paper The paper to use\n     * @param orient The orientation to use\n     * @param lMargin the left margin to use in pts.\n     * @param rMargin the right margin to use in pts.\n     * @param tMargin the top margin to use in pts.\n     * @param bMargin the bottom margin to use in pts.\n     * @return PageLayout based on the specified parameters.\n     * @throws NullPointerException if paper or orient are null.\n     * @throws IllegalArgumentException if any of the margins values are\n     * less than zero.\n     */\n    public PageLayout createPageLayout(Paper paper, PageOrientation orient,\n                                       double lMargin, double rMargin,\n                                       double tMargin, double bMargin) {\n\n        if (paper == null || orient == null) {\n            throw new NullPointerException(\"Parameters cannot be null\");\n        }\n        if (lMargin < 0 || rMargin < 0 || tMargin < 0 || bMargin < 0) {\n            throw new IllegalArgumentException(\"Margins must be >= 0\");\n        }\n        // TBD: Adjust paper to a supported one first.\n        Rectangle2D imgArea = impl.printableArea(paper);\n        double width = paper.getWidth() / 72.0;\n        double height = paper.getHeight() / 72.0;\n        double plm = imgArea.getMinX();\n        double ptm = imgArea.getMinY();\n        double prm = width - imgArea.getMaxX();\n        double pbm = height - imgArea.getMaxY();\n\n        lMargin /= 72.0;\n        rMargin /= 72.0;\n        tMargin /= 72.0;\n        bMargin /= 72.0;\n\n        // Check if the requested margins exceed the paper and\n        // if they do, ignore them.\n        boolean useDefault = false;\n        if (orient == PORTRAIT || orient == REVERSE_PORTRAIT) {\n            if ((lMargin + rMargin > width) ||\n                (tMargin + bMargin > height)) {\n                useDefault = true;\n            }\n        } else {\n            if ((lMargin + rMargin > height) ||\n                (tMargin + bMargin > width)) {\n                useDefault = true;\n            }\n        }\n        if (useDefault) {\n            return createPageLayout(paper, orient, MarginType.DEFAULT);\n        }\n\n        double lm, rm, tm, bm;\n        // TBD: Adjust orient to a supported one first.\n        switch (orient) {\n        case LANDSCAPE: lm = pbm; rm = ptm; tm = plm; bm = prm;\n            break;\n        case REVERSE_LANDSCAPE: lm = ptm; rm = pbm; tm = prm; bm = plm;\n            break;\n        case REVERSE_PORTRAIT: lm = prm; rm = plm; tm = pbm; bm = ptm;\n            break;\n        default: lm = plm; rm = prm; tm = ptm; bm = pbm;\n        }\n\n        lm = (lMargin >= lm) ? lMargin : lm;\n        rm = (rMargin >= rm) ? rMargin : rm;\n        tm = (tMargin >= tm) ? tMargin : tm;\n        bm = (bMargin >= bm) ? bMargin : bm;\n\n        lm *= 72;\n        rm *= 72;\n        tm *= 72;\n        bm *= 72;\n\n        return new PageLayout(paper, orient, lm, rm, tm, bm);\n    }"}
{"Number":"833","API Relative Path":"javafx.print.Printer.java-createPageLayout(Paper-PageOrientation-MarginType)","Corresponding Source":"/**\n     * Obtain a new PageLayout instance for this printer using the specified\n     * parameters.\n     * The paper should be one of the supported papers and\n     * the orientation should be a supported orientation.\n     * If the printer cannot support the layout as specified, it\n     * will adjust the returned layout to a supported configuration\n     * @param paper The paper to use\n     * @param orient The orientation to use\n     * @param mType the margin type to use\n     * @return PageLayout based on the specified parameters.\n     * @throws NullPointerException if any of the parameters are null.\n     */\n    public PageLayout createPageLayout(Paper paper, PageOrientation orient,\n                        MarginType mType) {\n\n        if (paper == null || orient == null || mType == null) {\n            throw new NullPointerException(\"Parameters cannot be null\");\n        }\n\n        // TBD: Adjust paper to a supported one first.\n        Rectangle2D imgArea = impl.printableArea(paper);\n        double width = paper.getWidth() / 72.0;\n        double height = paper.getHeight() / 72.0;\n        double plm = imgArea.getMinX();\n        double ptm = imgArea.getMinY();\n        double prm = width - imgArea.getMaxX();\n        double pbm = height - imgArea.getMaxY();\n        // fix for FP error\n        if (Math.abs(plm) < 0.01) plm = 0;\n        if (Math.abs(prm) < 0.01) prm = 0;\n        if (Math.abs(ptm) < 0.01) ptm = 0;\n        if (Math.abs(pbm) < 0.01) pbm = 0;\n\n        switch (mType) {\n        case DEFAULT:\n            plm = (plm <= 0.75) ? 0.75 : plm;\n            prm = (prm <= 0.75) ? 0.75 : prm;\n            ptm = (ptm <= 0.75) ? 0.75 : ptm;\n            pbm = (pbm <= 0.75) ? 0.75 : pbm;\n            break;\n        case EQUAL: {\n            double maxH = (double)Math.max(plm, prm);\n            double maxV = (double)Math.max(ptm, pbm);\n            double maxM = (double)Math.max(maxH, maxV);\n            plm = prm = ptm = pbm = maxM;\n            break;\n        }\n        case EQUAL_OPPOSITES: {\n            double maxH = (double)Math.max(plm, prm);\n            double maxV = (double)Math.max(ptm, pbm);\n            plm = prm = maxH;\n            ptm = pbm = maxV;\n            break;\n        }\n        case HARDWARE_MINIMUM:\n        default: // Use hardware margins as is.\n            break;\n        }\n\n        double lm, rm, tm, bm;\n        // Now we gave the margins, they need to be adjusted into\n        // the orientation of the paper. If the orientation is not\n        // supported by the printer, then that needs to adjusted first.\n\n        // TBD: Adjust orient to a supported one first.\n        switch (orient) {\n        case LANDSCAPE: lm = pbm; rm = ptm; tm = plm; bm = prm;\n            break;\n        case REVERSE_LANDSCAPE: lm = ptm; rm = pbm; tm = prm; bm = plm;\n            break;\n        case REVERSE_PORTRAIT: lm = prm; rm = plm; tm = pbm; bm = ptm;\n            break;\n        default: lm = plm; rm = prm; tm = ptm; bm = pbm;\n        }\n        lm *= 72;\n        rm *= 72;\n        tm *= 72;\n        bm *= 72;\n        return new PageLayout(paper, orient, lm, rm, tm, bm);\n    }"}
{"Number":"834","API Relative Path":"javafx.print.Printer.java-createPageLayout(Paper-PageOrientation-MarginType)","Corresponding Source":"/**\n     * Obtain a new PageLayout instance for this printer using the specified\n     * parameters.\n     * The paper should be one of the supported papers and\n     * the orientation should be a supported orientation.\n     * If the printer cannot support the layout as specified, it\n     * will adjust the returned layout to a supported configuration\n     * @param paper The paper to use\n     * @param orient The orientation to use\n     * @param mType the margin type to use\n     * @return PageLayout based on the specified parameters.\n     * @throws NullPointerException if any of the parameters are null.\n     */\n    public PageLayout createPageLayout(Paper paper, PageOrientation orient,\n                        MarginType mType) {\n\n        if (paper == null || orient == null || mType == null) {\n            throw new NullPointerException(\"Parameters cannot be null\");\n        }\n\n        // TBD: Adjust paper to a supported one first.\n        Rectangle2D imgArea = impl.printableArea(paper);\n        double width = paper.getWidth() / 72.0;\n        double height = paper.getHeight() / 72.0;\n        double plm = imgArea.getMinX();\n        double ptm = imgArea.getMinY();\n        double prm = width - imgArea.getMaxX();\n        double pbm = height - imgArea.getMaxY();\n        // fix for FP error\n        if (Math.abs(plm) < 0.01) plm = 0;\n        if (Math.abs(prm) < 0.01) prm = 0;\n        if (Math.abs(ptm) < 0.01) ptm = 0;\n        if (Math.abs(pbm) < 0.01) pbm = 0;\n\n        switch (mType) {\n        case DEFAULT:\n            plm = (plm <= 0.75) ? 0.75 : plm;\n            prm = (prm <= 0.75) ? 0.75 : prm;\n            ptm = (ptm <= 0.75) ? 0.75 : ptm;\n            pbm = (pbm <= 0.75) ? 0.75 : pbm;\n            break;\n        case EQUAL: {\n            double maxH = (double)Math.max(plm, prm);\n            double maxV = (double)Math.max(ptm, pbm);\n            double maxM = (double)Math.max(maxH, maxV);\n            plm = prm = ptm = pbm = maxM;\n            break;\n        }\n        case EQUAL_OPPOSITES: {\n            double maxH = (double)Math.max(plm, prm);\n            double maxV = (double)Math.max(ptm, pbm);\n            plm = prm = maxH;\n            ptm = pbm = maxV;\n            break;\n        }\n        case HARDWARE_MINIMUM:\n        default: // Use hardware margins as is.\n            break;\n        }\n\n        double lm, rm, tm, bm;\n        // Now we gave the margins, they need to be adjusted into\n        // the orientation of the paper. If the orientation is not\n        // supported by the printer, then that needs to adjusted first.\n\n        // TBD: Adjust orient to a supported one first.\n        switch (orient) {\n        case LANDSCAPE: lm = pbm; rm = ptm; tm = plm; bm = prm;\n            break;\n        case REVERSE_LANDSCAPE: lm = ptm; rm = pbm; tm = prm; bm = plm;\n            break;\n        case REVERSE_PORTRAIT: lm = prm; rm = plm; tm = pbm; bm = ptm;\n            break;\n        default: lm = plm; rm = prm; tm = ptm; bm = pbm;\n        }\n        lm *= 72;\n        rm *= 72;\n        tm *= 72;\n        bm *= 72;\n        return new PageLayout(paper, orient, lm, rm, tm, bm);\n    }"}
{"Number":"835","API Relative Path":"javafx.print.PrintResolution.java-PrintResolution(int-int)","Corresponding Source":"/**\n     * Represents the dots-per-inch (DPI) resolution of a printer device.\n     * When printing in a portrait orientation\n     * cross feed direction is usually x/horizontal resolution, and\n     * feed direction is usually y/horizontal resolution.\n     * On most printers these are the same value, but rarely they may be\n     * different.\n     * @param crossFeedResolution - resolution across the paper feed direction.\n     * @param feedResolution - resolution in the paper feed direction.\n     * @throws IllegalArgumentException if the values are not greater\n     * than zero.\n     */\n     PrintResolution(int crossFeedResolution, int feedResolution)\n        throws IllegalArgumentException\n    {\n        if (crossFeedResolution <= 0 || feedResolution <= 0) {\n            throw new IllegalArgumentException(\"Values must be positive\");\n        }\n        cfRes = crossFeedResolution;\n        fRes  = feedResolution;\n    }"}
{"Number":"836","API Relative Path":"javafx.scene.canvas.GraphicsContext.java-appendSVGPath(String)","Corresponding Source":"/**\n     * Appends an SVG Path string to the current path. If there is no current\n     * path the string must then start with either type of move command.\n     * A {@code null} value or incorrect SVG path will be ignored.\n     * The coordinates are transformed by the current transform as they are\n     * added to the path and unaffected by subsequent changes to the transform.\n     * The current path is a <a href=\"#path-attr\">path attribute<\/a>\n     * used for any of the path methods as specified in the\n     * <a href=\"#attr-ops-table\">Rendering Attributes Table<\/a>\n     * and <b>is not affected<\/b> by the {@link #save()} and\n     * {@link #restore()} operations.\n     *\n     * @param svgpath the SVG Path string.\n     */\n    public void appendSVGPath(String svgpath) {\n        if (svgpath == null) return;\n        boolean prependMoveto = true;\n        boolean skipMoveto = true;\n        for (int i = 0; i < svgpath.length(); i++) {\n            switch (svgpath.charAt(i)) {\n                case ' ':\n                case '\\t':\n                case '\\r':\n                case '\\n':\n                    continue;\n                case 'M':\n                    prependMoveto = skipMoveto = false;\n                    break;\n                case 'm':\n                    if (path.getNumCommands() == 0) {\n                        // An initial relative moveTo becomes absolute\n                        prependMoveto = false;\n                    }\n                    // Even if we prepend an initial moveTo in the temp\n                    // path, we do not want to delete the resulting initial\n                    // moveTo because the relative moveto will be folded\n                    // into it by an optimization in the Path2D object.\n                    skipMoveto = false;\n                    break;\n            }\n            break;\n        }\n        Path2D p2d = new Path2D();\n        if (prependMoveto && path.getNumCommands() > 0) {\n            float x0, y0;\n            if (curState.transform.isTranslateOrIdentity()) {\n                x0 = (float) (path.getCurrentX() - curState.transform.getMxt());\n                y0 = (float) (path.getCurrentY() - curState.transform.getMyt());\n            } else {\n                coords[0] = path.getCurrentX();\n                coords[1] = path.getCurrentY();\n                try {\n                    curState.transform.inverseTransform(coords, 0, coords, 0, 1);\n                } catch (NoninvertibleTransformException e) {\n                }\n                x0 = coords[0];\n                y0 = coords[1];\n            }\n            p2d.moveTo(x0, y0);\n        } else {\n            skipMoveto = false;\n        }\n        try {\n            p2d.appendSVGPath(svgpath);\n            PathIterator pi = p2d.getPathIterator(curState.transform);\n            if (skipMoveto) {\n                // We need to delete the initial moveto and let the path\n                // extend from the actual existing geometry.\n                pi.next();\n            }\n            path.append(pi, false);\n        } catch (IllegalArgumentException | IllegalPathStateException ex) {\n            //Ignore incorrect path\n        }\n    }"}
{"Number":"837","API Relative Path":"javafx.scene.canvas.GraphicsContext.java-drawImage(Image-double-double)","Corresponding Source":"/**\n     * Draws an image at the given x, y position using the width\n     * and height of the given image.\n     * A {@code null} image value or an image still in progress will be ignored.\n     * <p>\n     * This method will be affected by any of the\n     * <a href=\"#comm-attr\">global common<\/a>\n     * attributes as specified in the\n     * <a href=\"#attr-ops-table\">Rendering Attributes Table<\/a>.\n     * <\/p>\n     *\n     * @param img the image to be drawn or null.\n     * @param x the X coordinate on the destination for the upper left of the image.\n     * @param y the Y coordinate on the destination for the upper left of the image.\n     */\n    public void drawImage(Image img, double x, double y) {\n        if (img == null) return;\n        double sw = img.getWidth();\n        double sh = img.getHeight();\n        writeImage(img, x, y, sw, sh);\n    }"}
{"Number":"838","API Relative Path":"javafx.scene.canvas.GraphicsContext.java-fillText(String-double-double-double)","Corresponding Source":"/**\n     * Fills text and includes a maximum width of the string.\n     * If the width of the text extends past max width, then it will be sized\n     * to fit.\n     * A {@code null} text value will be ignored.\n     * <p>\n     * This method will be affected by any of the\n     * <a href=\"#comm-attr\">global common<\/a>,\n     * <a href=\"#fill-attr\">fill<\/a>,\n     * or <a href=\"#text-attr\">text<\/a>\n     * attributes as specified in the\n     * <a href=\"#attr-ops-table\">Rendering Attributes Table<\/a>.\n     * <\/p>\n     *\n     * @param text the string of text or null.\n     * @param x position on the x axis.\n     * @param y position on the y axis.\n     * @param maxWidth  maximum width the text string can have.\n     */\n    public void fillText(String text, double x, double y, double maxWidth) {\n        if (maxWidth <= 0) return;\n        writeText(text, x, y, maxWidth, NGCanvas.FILL_TEXT);\n    }"}
{"Number":"839","API Relative Path":"javafx.scene.canvas.GraphicsContext.java-setFill(Paint)","Corresponding Source":"/**\n     * Sets the current fill paint attribute.\n     * The default value is {@link Color#BLACK BLACK}.\n     * The fill paint is a <a href=\"#fill-attr\">fill attribute<\/a>\n     * used for any of the fill methods as specified in the\n     * <a href=\"#attr-ops-table\">Rendering Attributes Table<\/a>.\n     * A {@code null} value will be ignored and the current value will remain unchanged.\n     *\n     * @param p The {@code Paint} to be used as the fill {@code Paint} or null.\n     */\n    public void setFill(Paint p) {\n        if (p != null && curState.fill != p) {\n            curState.fill = p;\n            writePaint(p, NGCanvas.FILL_PAINT);\n        }\n    }"}
{"Number":"840","API Relative Path":"javafx.scene.canvas.GraphicsContext.java-setFillRule(FillRule)","Corresponding Source":"/**\n     * Set the filling rule attribute for determining the interior of paths\n     * in fill or clip operations.\n     * The default value is {@code FillRule.NON_ZERO}.\n     * A {@code null} value will be ignored and the current value will remain unchanged.\n     * The fill rule is a <a href=\"#path-attr\">path attribute<\/a>\n     * used for any of the fill or clip path methods as specified in the\n     * <a href=\"#attr-ops-table\">Rendering Attributes Table<\/a>.\n     *\n     * @param fillRule {@code FillRule} with a value of  Even_odd or Non_zero or null.\n     */\n     public void setFillRule(FillRule fillRule) {\n         if (fillRule != null && curState.fillRule != fillRule) {\n            byte b;\n            if (fillRule == FillRule.EVEN_ODD) {\n                b = NGCanvas.FILL_RULE_EVEN_ODD;\n            } else {\n                b = NGCanvas.FILL_RULE_NON_ZERO;\n            }\n            curState.fillRule = fillRule;\n            writeParam(b, NGCanvas.FILL_RULE);\n        }\n     }"}
{"Number":"841","API Relative Path":"javafx.scene.canvas.GraphicsContext.java-setFont(Font)","Corresponding Source":"/**\n     * Sets the current Font.\n     * The default value is specified by {@link Font#getDefault()}.\n     * The font is a <a href=\"#text-attr\">text attribute<\/a>\n     * used for any of the text methods as specified in the\n     * <a href=\"#attr-ops-table\">Rendering Attributes Table<\/a>.\n     * A {@code null} value will be ignored and the current value will remain unchanged.\n     *\n     * @param f the Font or null.\n     */\n    public void setFont(Font f) {\n        if (f != null && curState.font != f) {\n            curState.font = f;\n            GrowableDataBuffer buf = getBuffer();\n            buf.putByte(NGCanvas.FONT);\n            buf.putObject(f.impl_getNativeFont());\n        }\n    }"}
{"Number":"842","API Relative Path":"javafx.scene.canvas.GraphicsContext.java-setFontSmoothingType(FontSmoothingType)","Corresponding Source":"/**\n     * Sets the current Font Smoothing Type.\n     * The default value is {@link FontSmoothingType#GRAY GRAY}.\n     * The font smoothing type is a <a href=\"#text-attr\">text attribute<\/a>\n     * used for any of the text methods as specified in the\n     * <a href=\"#attr-ops-table\">Rendering Attributes Table<\/a>.\n     * A {@code null} value will be ignored and the current value will remain unchanged.\n     * <p>\n     * <b>Note<\/b> that the {@code FontSmoothingType} value of\n     * {@link FontSmoothingType#LCD LCD} is only supported over an opaque\n     * background.  {@code LCD} text will generally appear as {@code GRAY}\n     * text over transparent or partially transparent pixels, and in some\n     * implementations it may not be supported at all on a {@link Canvas}\n     * because the required support does not exist for surfaces which contain\n     * an alpha channel as all {@code Canvas} objects do.\n     *\n     * @param fontsmoothing the {@link FontSmoothingType} or null\n     * @since JavaFX 8u40\n     */\n    public void setFontSmoothingType(FontSmoothingType fontsmoothing) {\n        if (fontsmoothing != null && fontsmoothing != curState.fontsmoothing) {\n            curState.fontsmoothing = fontsmoothing;\n            writeParam((byte) fontsmoothing.ordinal(), NGCanvas.FONT_SMOOTH);\n        }\n    }"}
{"Number":"843","API Relative Path":"javafx.scene.canvas.GraphicsContext.java-setGlobalBlendMode(BlendMode)","Corresponding Source":"/**\n     * Sets the global blend mode.\n     * The default value is {@link BlendMode#SRC_OVER SRC_OVER}.\n     * A {@code null} value will be ignored and the current value will remain unchanged.\n     * The blend mode is a <a href=\"#comm-attr\">common attribute<\/a>\n     * used for nearly all rendering methods as specified in the\n     * <a href=\"#attr-ops-table\">Rendering Attributes Table<\/a>.\n     *\n     * @param op the {@code BlendMode} that will be set or null.\n     */\n    public void setGlobalBlendMode(BlendMode op) {\n        if (op != null && op != curState.blendop) {\n            GrowableDataBuffer buf = getBuffer();\n            curState.blendop = op;\n            buf.putByte(NGCanvas.COMP_MODE);\n            buf.putObject(Blend.impl_getToolkitMode(op));\n        }\n    }"}
{"Number":"844","API Relative Path":"javafx.scene.canvas.GraphicsContext.java-setGlobalBlendMode(BlendMode)","Corresponding Source":"/**\n     * Sets the global blend mode.\n     * The default value is {@link BlendMode#SRC_OVER SRC_OVER}.\n     * A {@code null} value will be ignored and the current value will remain unchanged.\n     * The blend mode is a <a href=\"#comm-attr\">common attribute<\/a>\n     * used for nearly all rendering methods as specified in the\n     * <a href=\"#attr-ops-table\">Rendering Attributes Table<\/a>.\n     *\n     * @param op the {@code BlendMode} that will be set or null.\n     */\n    public void setGlobalBlendMode(BlendMode op) {\n        if (op != null && op != curState.blendop) {\n            GrowableDataBuffer buf = getBuffer();\n            curState.blendop = op;\n            buf.putByte(NGCanvas.COMP_MODE);\n            buf.putObject(Blend.impl_getToolkitMode(op));\n        }\n    }"}
{"Number":"845","API Relative Path":"javafx.scene.canvas.GraphicsContext.java-setLineCap(StrokeLineCap)","Corresponding Source":"/**\n     * Sets the current stroke line cap.\n     * The default value is {@link StrokeLineCap#SQUARE SQUARE}.\n     * The line cap is a <a href=\"#strk-attr\">stroke attribute<\/a>\n     * used for any of the stroke methods as specified in the\n     * <a href=\"#attr-ops-table\">Rendering Attributes Table<\/a>.\n     * A {@code null} value will be ignored and the current value will remain unchanged.\n     *\n     * @param cap {@code StrokeLineCap} with a value of Butt, Round, or Square or null.\n     */\n    public void setLineCap(StrokeLineCap cap) {\n        if (cap != null && curState.linecap != cap) {\n            byte v;\n            switch (cap) {\n                case BUTT: v = NGCanvas.CAP_BUTT; break;\n                case ROUND: v = NGCanvas.CAP_ROUND; break;\n                case SQUARE: v = NGCanvas.CAP_SQUARE; break;\n                default: return;\n            }\n            curState.linecap = cap;\n            writeParam(v, NGCanvas.LINE_CAP);\n        }\n    }"}
{"Number":"846","API Relative Path":"javafx.scene.canvas.GraphicsContext.java-setLineDashes(double)","Corresponding Source":"/**\n     * Sets the current stroke line dash pattern to a normalized copy of\n     * the argument.\n     * The default value is {@code null}.\n     * The line dash array is a <a href=\"#strk-attr\">stroke attribute<\/a>\n     * used for any of the stroke methods as specified in the\n     * <a href=\"#attr-ops-table\">Rendering Attributes Table<\/a>.\n     * If the array is {@code null} or empty or contains all {@code 0} elements\n     * then dashing will be disabled and the current dash array will be set\n     * to {@code null}.\n     * If any of the elements of the array are a negative, infinite, or NaN\n     * value outside the range {@code [0, +inf)} then the entire array will\n     * be ignored and the current dash array will remain unchanged.\n     * If the array is an odd length then it will be treated as if it\n     * were two copies of the array appended to each other.\n     *\n     * @param dashes the array of finite non-negative dash lengths\n     * @since JavaFX 8u40\n     */\n    public void setLineDashes(double... dashes) {\n        if (dashes == null || dashes.length == 0) {\n            if (curState.dashes == null) {\n                return;\n            }\n            curState.dashes = null;\n        } else {\n            boolean allZeros = true;\n            for (int i = 0; i < dashes.length; i++) {\n                double d = dashes[i];\n                if (d >= 0.0 && d < Double.POSITIVE_INFINITY) {\n                    // Non-NaN, finite, non-negative\n                    // Test cannot be inverted or it will not implicitly test for NaN\n                    if (d > 0) {\n                        allZeros = false;\n                    }\n                } else {\n                    return;\n                }\n            }\n            if (allZeros) {\n                if (curState.dashes == null) {\n                    return;\n                }\n                curState.dashes = null;\n            } else {\n                int dashlen = dashes.length;\n                if ((dashlen & 1) == 0) {\n                    curState.dashes = Arrays.copyOf(dashes, dashlen);\n                } else {\n                    curState.dashes = Arrays.copyOf(dashes, dashlen * 2);\n                    System.arraycopy(dashes, 0, curState.dashes, dashlen, dashlen);\n                }\n            }\n        }\n        GrowableDataBuffer buf = getBuffer();\n        buf.putByte(NGCanvas.DASH_ARRAY);\n        buf.putObject(curState.dashes);\n    }"}
{"Number":"847","API Relative Path":"javafx.scene.canvas.GraphicsContext.java-setLineJoin(StrokeLineJoin)","Corresponding Source":"/**\n     * Sets the current stroke line join.\n     * The default value is {@link StrokeLineJoin#MITER}.\n     * The line join is a <a href=\"#strk-attr\">stroke attribute<\/a>\n     * used for any of the stroke methods as specified in the\n     * <a href=\"#attr-ops-table\">Rendering Attributes Table<\/a>.\n     * A {@code null} value will be ignored and the current value will remain unchanged.\n     *\n     * @param join {@code StrokeLineJoin} with a value of Miter, Bevel, or Round or null.\n     */\n    public void setLineJoin(StrokeLineJoin join) {\n        if (join != null && curState.linejoin != join) {\n            byte v;\n            switch (join) {\n                case MITER: v = NGCanvas.JOIN_MITER; break;\n                case BEVEL: v = NGCanvas.JOIN_BEVEL; break;\n                case ROUND: v = NGCanvas.JOIN_ROUND; break;\n                default: return;\n            }\n            curState.linejoin = join;\n            writeParam(v, NGCanvas.LINE_JOIN);\n        }\n    }"}
{"Number":"848","API Relative Path":"javafx.scene.canvas.GraphicsContext.java-setStroke(Paint)","Corresponding Source":"/**\n     * Sets the current stroke paint attribute.\n     * The default value is {@link Color#BLACK BLACK}.\n     * The stroke paint is a <a href=\"#strk-attr\">stroke attribute<\/a>\n     * used for any of the stroke methods as specified in the\n     * <a href=\"#attr-ops-table\">Rendering Attributes Table<\/a>.\n     * A {@code null} value will be ignored and the current value will remain unchanged.\n     *\n     * @param p The Paint to be used as the stroke Paint or null.\n     */\n    public void setStroke(Paint p) {\n        if (p != null && curState.stroke != p) {\n            curState.stroke = p;\n            writePaint(p, NGCanvas.STROKE_PAINT);\n        }\n    }"}
{"Number":"849","API Relative Path":"javafx.scene.canvas.GraphicsContext.java-setTextAlign(TextAlignment)","Corresponding Source":"/**\n     * Defines horizontal text alignment, relative to the text {@code x} origin.\n     * The default value is {@link TextAlignment#LEFT LEFT}.\n     * The text alignment is a <a href=\"#text-attr\">text attribute<\/a>\n     * used for any of the text methods as specified in the\n     * <a href=\"#attr-ops-table\">Rendering Attributes Table<\/a>.\n     * <p>\n     * Let horizontal bounds represent the logical width of a single line of\n     * text. Where each line of text has a separate horizontal bounds.\n     * <p>\n     * Then TextAlignment is specified as:\n     * <ul>\n     * <li>Left: the left edge of the horizontal bounds will be at {@code x}.\n     * <li>Center: the center, halfway between left and right edge, of the\n     * horizontal bounds will be at {@code x}.\n     * <li>Right: the right edge of the horizontal bounds will be at {@code x}.\n     * <\/ul>\n     * <p>\n     *\n     * Note: Canvas does not support line wrapping, therefore the text\n     * alignment Justify is identical to left aligned text.\n     * <p>\n     * A {@code null} value will be ignored and the current value will remain unchanged.\n     *\n     * @param align {@code TextAlignment} with values of Left, Center, Right or null.\n     */\n    public void setTextAlign(TextAlignment align) {\n        if (align != null && curState.textalign != align) {\n            byte a;\n            switch (align) {\n                case LEFT: a = NGCanvas.ALIGN_LEFT; break;\n                case CENTER: a = NGCanvas.ALIGN_CENTER; break;\n                case RIGHT: a = NGCanvas.ALIGN_RIGHT; break;\n                case JUSTIFY: a = NGCanvas.ALIGN_JUSTIFY; break;\n                default: return;\n            }\n            curState.textalign = align;\n            writeParam(a, NGCanvas.TEXT_ALIGN);\n        }\n    }"}
{"Number":"850","API Relative Path":"javafx.scene.canvas.GraphicsContext.java-setTextBaseline(VPos)","Corresponding Source":"/**\n     * Sets the current Text Baseline.\n     * The default value is {@link VPos#BASELINE BASELINE}.\n     * The text baseline is a <a href=\"#text-attr\">text attribute<\/a>\n     * used for any of the text methods as specified in the\n     * <a href=\"#attr-ops-table\">Rendering Attributes Table<\/a>.\n     * A {@code null} value will be ignored and the current value will remain unchanged.\n     *\n     * @param baseline {@code VPos} with values of Top, Center, Baseline, or Bottom or null.\n     */\n    public void setTextBaseline(VPos baseline) {\n        if (baseline != null && curState.textbaseline != baseline) {\n            byte b;\n            switch (baseline) {\n                case TOP: b = NGCanvas.BASE_TOP; break;\n                case CENTER: b = NGCanvas.BASE_MIDDLE; break;\n                case BASELINE: b = NGCanvas.BASE_ALPHABETIC; break;\n                case BOTTOM: b = NGCanvas.BASE_BOTTOM; break;\n                default: return;\n            }\n            curState.textbaseline = baseline;\n            writeParam(b, NGCanvas.TEXT_BASELINE);\n        }\n    }"}
{"Number":"851","API Relative Path":"javafx.scene.canvas.GraphicsContext.java-strokeText(String-double-double-double)","Corresponding Source":"/**\n     * Draws text with stroke paint and includes a maximum width of the string.\n     * If the width of the text extends past max width, then it will be sized\n     * to fit.\n     * A {@code null} text value will be ignored.\n     * <p>\n     * This method will be affected by any of the\n     * <a href=\"#comm-attr\">global common<\/a>,\n     * <a href=\"#strk-attr\">stroke<\/a>,\n     * or <a href=\"#text-attr\">text<\/a>\n     * attributes as specified in the\n     * <a href=\"#attr-ops-table\">Rendering Attributes Table<\/a>.\n     * <\/p>\n     *\n     * @param text the string of text or null.\n     * @param x position on the x axis.\n     * @param y position on the y axis.\n     * @param maxWidth  maximum width the text string can have.\n     */\n    public void strokeText(String text, double x, double y, double maxWidth) {\n        if (maxWidth <= 0) return;\n        writeText(text, x, y, maxWidth, NGCanvas.STROKE_TEXT);\n    }"}
{"Number":"852","API Relative Path":"javafx.scene.chart.BarChart.java-BarChart(Axis-Axis-ObservableList)","Corresponding Source":"/**\n     * Construct a new BarChart with the given axis and data. The two axis should be a ValueAxis/NumberAxis and a\n     * CategoryAxis, they can be in either order depending on if you want a horizontal or vertical bar chart.\n     *\n     * @param xAxis The x axis to use\n     * @param yAxis The y axis to use\n     * @param data The data to use, this is the actual list used so any changes to it will be reflected in the chart\n     */\n    public BarChart(@NamedArg(\"xAxis\") Axis<X> xAxis, @NamedArg(\"yAxis\") Axis<Y> yAxis, @NamedArg(\"data\") ObservableList<Series<X,Y>> data) {\n        super(xAxis, yAxis);\n        getStyleClass().add(\"bar-chart\");\n        setLegend(legend);\n        if (!((xAxis instanceof ValueAxis && yAxis instanceof CategoryAxis) ||\n             (yAxis instanceof ValueAxis && xAxis instanceof CategoryAxis))) {\n            throw new IllegalArgumentException(\"Axis type incorrect, one of X,Y should be CategoryAxis and the other NumberAxis\");\n        }\n        if (xAxis instanceof CategoryAxis) {\n            categoryAxis = (CategoryAxis)xAxis;\n            valueAxis = (ValueAxis)yAxis;\n            orientation = Orientation.VERTICAL;\n        } else {\n            categoryAxis = (CategoryAxis)yAxis;\n            valueAxis = (ValueAxis)xAxis;\n            orientation = Orientation.HORIZONTAL;\n        }\n        // update css\n        pseudoClassStateChanged(HORIZONTAL_PSEUDOCLASS_STATE, orientation == Orientation.HORIZONTAL);\n        pseudoClassStateChanged(VERTICAL_PSEUDOCLASS_STATE, orientation == Orientation.VERTICAL);\n        setData(data);\n    }"}
{"Number":"853","API Relative Path":"javafx.scene.chart.BubbleChart.java-BubbleChart(Axis-Axis-ObservableList)","Corresponding Source":"/**\n     * Construct a new BubbleChart with the given axis and data. BubbleChart does not\n     * use a Category Axis. Both X and Y axes should be of type NumberAxis.\n     *\n     * @param xAxis The x axis to use\n     * @param yAxis The y axis to use\n     * @param data The data to use, this is the actual list used so any changes to it will be reflected in the chart\n     */\n    public BubbleChart(@NamedArg(\"xAxis\") Axis<X> xAxis, @NamedArg(\"yAxis\") Axis<Y> yAxis, @NamedArg(\"data\") ObservableList<Series<X,Y>> data) {\n        super(xAxis, yAxis);\n        setLegend(legend);\n        if (!(xAxis instanceof ValueAxis && yAxis instanceof ValueAxis)) {\n            throw new IllegalArgumentException(\"Axis type incorrect, X and Y should both be NumberAxis\");\n        }\n        setData(data);\n    }"}
{"Number":"854","API Relative Path":"javafx.scene.chart.StackedAreaChart.java-StackedAreaChart(Axis-Axis-ObservableList)","Corresponding Source":"/**\n     * Construct a new Area Chart with the given axis and data.\n     * <p>\n     * Note: yAxis must be a ValueAxis, otherwise {@code IllegalArgumentException} is thrown.\n     *\n     * @param xAxis The x axis to use\n     * @param yAxis The y axis to use\n     * @param data The data to use, this is the actual list used so any changes to it will be reflected in the chart\n     *\n     * @throws java.lang.IllegalArgumentException if yAxis is not a ValueAxis\n     */\n    public StackedAreaChart(@NamedArg(\"xAxis\") Axis<X> xAxis, @NamedArg(\"yAxis\") Axis<Y> yAxis, @NamedArg(\"data\") ObservableList<Series<X,Y>> data) {\n        super(xAxis,yAxis);\n        if (!(yAxis instanceof ValueAxis)) {\n            throw new IllegalArgumentException(\"Axis type incorrect, yAxis must be of ValueAxis type.\");\n        }\n        setLegend(legend);\n        setData(data);\n    }"}
{"Number":"855","API Relative Path":"javafx.scene.chart.StackedBarChart.java-StackedBarChart(Axis-Axis-ObservableList)","Corresponding Source":"/**\n     * Construct a new StackedBarChart with the given axis and data. The two axis should be a ValueAxis/NumberAxis and a\n     * CategoryAxis, they can be in either order depending on if you want a horizontal or vertical bar chart.\n     *\n     * @param xAxis The x axis to use\n     * @param yAxis The y axis to use\n     * @param data The data to use, this is the actual list used so any changes to it will be reflected in the chart\n     */\n    public StackedBarChart(@NamedArg(\"xAxis\") Axis<X> xAxis, @NamedArg(\"yAxis\") Axis<Y> yAxis, @NamedArg(\"data\") ObservableList<Series<X, Y>> data) {\n        super(xAxis, yAxis);\n        getStyleClass().add(\"stacked-bar-chart\");\n        setLegend(legend);\n        if (!((xAxis instanceof ValueAxis && yAxis instanceof CategoryAxis)\n                || (yAxis instanceof ValueAxis && xAxis instanceof CategoryAxis))) {\n            throw new IllegalArgumentException(\"Axis type incorrect, one of X,Y should be CategoryAxis and the other NumberAxis\");\n        }\n        if (xAxis instanceof CategoryAxis) {\n            categoryAxis = (CategoryAxis) xAxis;\n            valueAxis = (ValueAxis) yAxis;\n            orientation = Orientation.VERTICAL;\n        } else {\n            categoryAxis = (CategoryAxis) yAxis;\n            valueAxis = (ValueAxis) xAxis;\n            orientation = Orientation.HORIZONTAL;\n        }\n        // update css\n        pseudoClassStateChanged(HORIZONTAL_PSEUDOCLASS_STATE, orientation == Orientation.HORIZONTAL);\n        pseudoClassStateChanged(VERTICAL_PSEUDOCLASS_STATE, orientation == Orientation.VERTICAL);\n        setData(data);\n        categoryAxis.getCategories().addListener(categoriesListener);\n    }"}
{"Number":"856","API Relative Path":"javafx.scene.control.cell.CheckBoxListCell.java-updateItem(T-boolean)","Corresponding Source":"/***************************************************************************\n     *                                                                         *\n     * Public API                                                              *\n     *                                                                         *\n     **************************************************************************/\n\n    /** {@inheritDoc} */\n    @Override public void updateItem(T item, boolean empty) {\n        super.updateItem(item, empty);\n\n        if (! empty) {\n            StringConverter<T> c = getConverter();\n            Callback<T, ObservableValue<Boolean>> callback = getSelectedStateCallback();\n            if (callback == null) {\n                throw new NullPointerException(\n                        \"The CheckBoxListCell selectedStateCallbackProperty can not be null\");\n            }\n\n            setGraphic(checkBox);\n            setText(c != null ? c.toString(item) : (item == null ? \"\" : item.toString()));\n\n            if (booleanProperty != null) {\n                checkBox.selectedProperty().unbindBidirectional((BooleanProperty)booleanProperty);\n            }\n            booleanProperty = callback.call(item);\n            if (booleanProperty != null) {\n                checkBox.selectedProperty().bindBidirectional((BooleanProperty)booleanProperty);\n            }\n        } else {\n            setGraphic(null);\n            setText(null);\n        }\n    }"}
{"Number":"857","API Relative Path":"javafx.scene.control.cell.CheckBoxTreeCell.java-updateItem(T-boolean)","Corresponding Source":"/***************************************************************************\n     *                                                                         *\n     * Public API                                                              *\n     *                                                                         *\n     **************************************************************************/\n\n    /** {@inheritDoc} */\n    @Override public void updateItem(T item, boolean empty) {\n        super.updateItem(item, empty);\n\n        if (empty) {\n            setText(null);\n            setGraphic(null);\n        } else {\n            StringConverter<TreeItem<T>> c = getConverter();\n\n            TreeItem<T> treeItem = getTreeItem();\n\n            // update the node content\n            setText(c != null ? c.toString(treeItem) : (treeItem == null ? \"\" : treeItem.toString()));\n            checkBox.setGraphic(treeItem == null ? null : treeItem.getGraphic());\n            setGraphic(checkBox);\n\n            // uninstall bindings\n            if (booleanProperty != null) {\n                checkBox.selectedProperty().unbindBidirectional((BooleanProperty)booleanProperty);\n            }\n            if (indeterminateProperty != null) {\n                checkBox.indeterminateProperty().unbindBidirectional(indeterminateProperty);\n            }\n\n            // install new bindings.\n            // We special case things when the TreeItem is a CheckBoxTreeItem\n            if (treeItem instanceof CheckBoxTreeItem) {\n                CheckBoxTreeItem<T> cbti = (CheckBoxTreeItem<T>) treeItem;\n                booleanProperty = cbti.selectedProperty();\n                checkBox.selectedProperty().bindBidirectional((BooleanProperty)booleanProperty);\n\n                indeterminateProperty = cbti.indeterminateProperty();\n                checkBox.indeterminateProperty().bindBidirectional(indeterminateProperty);\n            } else {\n                Callback<TreeItem<T>, ObservableValue<Boolean>> callback = getSelectedStateCallback();\n                if (callback == null) {\n                    throw new NullPointerException(\n                            \"The CheckBoxTreeCell selectedStateCallbackProperty can not be null\");\n                }\n\n                booleanProperty = callback.call(treeItem);\n                if (booleanProperty != null) {\n                    checkBox.selectedProperty().bindBidirectional((BooleanProperty)booleanProperty);\n                }\n            }\n        }\n    }"}
{"Number":"858","API Relative Path":"javafx.scene.control.ContextMenu.java-show(Node-double-double)","Corresponding Source":"private void doShow(Node anchor, double screenX, double screenY) {\n        Event.fireEvent(this, new Event(Menu.ON_SHOWING));\n        if(isImpl_showRelativeToWindow()) {\n            final Scene scene = (anchor == null) ? null : anchor.getScene();\n            final Window win = (scene == null) ? null : scene.getWindow();\n            if (win == null) return;\n            super.show(win, screenX, screenY);\n        } else {\n            super.show(anchor, screenX, screenY);\n        }\n        Event.fireEvent(this, new Event(Menu.ON_SHOWN));\n    }"}
{"Number":"859","API Relative Path":"javafx.scene.control.ContextMenu.java-show(Node-double-double)","Corresponding Source":"private void doShow(Node anchor, double screenX, double screenY) {\n        Event.fireEvent(this, new Event(Menu.ON_SHOWING));\n        if(isImpl_showRelativeToWindow()) {\n            final Scene scene = (anchor == null) ? null : anchor.getScene();\n            final Window win = (scene == null) ? null : scene.getWindow();\n            if (win == null) return;\n            super.show(win, screenX, screenY);\n        } else {\n            super.show(anchor, screenX, screenY);\n        }\n        Event.fireEvent(this, new Event(Menu.ON_SHOWN));\n    }"}
{"Number":"860","API Relative Path":"javafx.scene.control.ContextMenu.java-show(Node-double-double)","Corresponding Source":"private void doShow(Node anchor, double screenX, double screenY) {\n        Event.fireEvent(this, new Event(Menu.ON_SHOWING));\n        if(isImpl_showRelativeToWindow()) {\n            final Scene scene = (anchor == null) ? null : anchor.getScene();\n            final Window win = (scene == null) ? null : scene.getWindow();\n            if (win == null) return;\n            super.show(win, screenX, screenY);\n        } else {\n            super.show(anchor, screenX, screenY);\n        }\n        Event.fireEvent(this, new Event(Menu.ON_SHOWN));\n    }"}
{"Number":"861","API Relative Path":"javafx.scene.control.ContextMenu.java-show(Node-Side-double-double)","Corresponding Source":"/***************************************************************************\n     *                                                                         *\n     * Methods                                                                 *\n     *                                                                         *\n     **************************************************************************/\n\n    /**\n     * Shows the {@code ContextMenu} relative to the given anchor node, on the side\n     * specified by the {@code hpos} and {@code vpos} parameters, and offset\n     * by the given {@code dx} and {@code dy} values for the x-axis and y-axis, respectively.\n     * If there is not enough room, the menu is moved to the opposite side and\n     * the offset is not applied.\n     * <p>\n     * To clarify the purpose of the {@code hpos} and {@code vpos} parameters,\n     * consider that they are relative to the anchor node. As such, a {@code hpos}\n     * and {@code vpos} of {@code CENTER} would mean that the ContextMenu appears\n     * on top of the anchor, with the (0,0) position of the {@code ContextMenu}\n     * positioned at (0,0) of the anchor. A {@code hpos} of right would then shift\n     * the {@code ContextMenu} such that its top-left (0,0) position would be attached\n     * to the top-right position of the anchor.\n     * <p>\n     * This function is useful for finely tuning the position of a menu,\n     * relative to the parent node to ensure close alignment.\n     */\n    // TODO provide more detail\n     public void show(Node anchor, Side side, double dx, double dy) {\n        if (anchor == null) return;\n        if (getItems().size() == 0) return;\n\n        getScene().setNodeOrientation(anchor.getEffectiveNodeOrientation());\n        // FIXME because Side is not yet in javafx.geometry, we have to convert\n        // to the old HPos/VPos API here, as Utils can not refer to Side in the\n        // charting API.\n        HPos hpos = side == Side.LEFT ? HPos.LEFT : side == Side.RIGHT ? HPos.RIGHT : HPos.CENTER;\n        VPos vpos = side == Side.TOP ? VPos.TOP : side == Side.BOTTOM ? VPos.BOTTOM : VPos.CENTER;\n\n        // translate from anchor/hpos/vpos/dx/dy into screenX/screenY\n        Point2D point = Utils.pointRelativeTo(anchor,\n                prefWidth(-1), prefHeight(-1),\n                hpos, vpos, dx, dy, true);\n        doShow(anchor, point.getX(), point.getY());\n    }"}
{"Number":"862","API Relative Path":"javafx.scene.control.ContextMenu.java-show(Node-Side-double-double)","Corresponding Source":"/***************************************************************************\n     *                                                                         *\n     * Methods                                                                 *\n     *                                                                         *\n     **************************************************************************/\n\n    /**\n     * Shows the {@code ContextMenu} relative to the given anchor node, on the side\n     * specified by the {@code hpos} and {@code vpos} parameters, and offset\n     * by the given {@code dx} and {@code dy} values for the x-axis and y-axis, respectively.\n     * If there is not enough room, the menu is moved to the opposite side and\n     * the offset is not applied.\n     * <p>\n     * To clarify the purpose of the {@code hpos} and {@code vpos} parameters,\n     * consider that they are relative to the anchor node. As such, a {@code hpos}\n     * and {@code vpos} of {@code CENTER} would mean that the ContextMenu appears\n     * on top of the anchor, with the (0,0) position of the {@code ContextMenu}\n     * positioned at (0,0) of the anchor. A {@code hpos} of right would then shift\n     * the {@code ContextMenu} such that its top-left (0,0) position would be attached\n     * to the top-right position of the anchor.\n     * <p>\n     * This function is useful for finely tuning the position of a menu,\n     * relative to the parent node to ensure close alignment.\n     */\n    // TODO provide more detail\n     public void show(Node anchor, Side side, double dx, double dy) {\n        if (anchor == null) return;\n        if (getItems().size() == 0) return;\n\n        getScene().setNodeOrientation(anchor.getEffectiveNodeOrientation());\n        // FIXME because Side is not yet in javafx.geometry, we have to convert\n        // to the old HPos/VPos API here, as Utils can not refer to Side in the\n        // charting API.\n        HPos hpos = side == Side.LEFT ? HPos.LEFT : side == Side.RIGHT ? HPos.RIGHT : HPos.CENTER;\n        VPos vpos = side == Side.TOP ? VPos.TOP : side == Side.BOTTOM ? VPos.BOTTOM : VPos.CENTER;\n\n        // translate from anchor/hpos/vpos/dx/dy into screenX/screenY\n        Point2D point = Utils.pointRelativeTo(anchor,\n                prefWidth(-1), prefHeight(-1),\n                hpos, vpos, dx, dy, true);\n        doShow(anchor, point.getX(), point.getY());\n    }"}
{"Number":"863","API Relative Path":"javafx.scene.control.ContextMenu.java-show(Node-Side-double-double)","Corresponding Source":"/***************************************************************************\n     *                                                                         *\n     * Methods                                                                 *\n     *                                                                         *\n     **************************************************************************/\n\n    /**\n     * Shows the {@code ContextMenu} relative to the given anchor node, on the side\n     * specified by the {@code hpos} and {@code vpos} parameters, and offset\n     * by the given {@code dx} and {@code dy} values for the x-axis and y-axis, respectively.\n     * If there is not enough room, the menu is moved to the opposite side and\n     * the offset is not applied.\n     * <p>\n     * To clarify the purpose of the {@code hpos} and {@code vpos} parameters,\n     * consider that they are relative to the anchor node. As such, a {@code hpos}\n     * and {@code vpos} of {@code CENTER} would mean that the ContextMenu appears\n     * on top of the anchor, with the (0,0) position of the {@code ContextMenu}\n     * positioned at (0,0) of the anchor. A {@code hpos} of right would then shift\n     * the {@code ContextMenu} such that its top-left (0,0) position would be attached\n     * to the top-right position of the anchor.\n     * <p>\n     * This function is useful for finely tuning the position of a menu,\n     * relative to the parent node to ensure close alignment.\n     */\n    // TODO provide more detail\n     public void show(Node anchor, Side side, double dx, double dy) {\n        if (anchor == null) return;\n        if (getItems().size() == 0) return;\n\n        getScene().setNodeOrientation(anchor.getEffectiveNodeOrientation());\n        // FIXME because Side is not yet in javafx.geometry, we have to convert\n        // to the old HPos/VPos API here, as Utils can not refer to Side in the\n        // charting API.\n        HPos hpos = side == Side.LEFT ? HPos.LEFT : side == Side.RIGHT ? HPos.RIGHT : HPos.CENTER;\n        VPos vpos = side == Side.TOP ? VPos.TOP : side == Side.BOTTOM ? VPos.BOTTOM : VPos.CENTER;\n\n        // translate from anchor/hpos/vpos/dx/dy into screenX/screenY\n        Point2D point = Utils.pointRelativeTo(anchor,\n                prefWidth(-1), prefHeight(-1),\n                hpos, vpos, dx, dy, true);\n        doShow(anchor, point.getX(), point.getY());\n    }"}
{"Number":"864","API Relative Path":"javafx.scene.control.IndexRange.java-IndexRange(int-int)","Corresponding Source":"/**\n     * Creates an instance of IndexRange representing the range between\n     * <code>start<\/code> and <code>end<\/code>.\n     *\n     * @param start The start position of the range.\n     * @param end The end position of the range.\n     */\n    public IndexRange(@NamedArg(\"start\") int start, @NamedArg(\"end\") int end) {\n        if (end < start) {\n            throw new IllegalArgumentException();\n        }\n\n        this.start = start;\n        this.end = end;\n    }"}
{"Number":"865","API Relative Path":"javafx.scene.control.IndexRange.java-valueOf(String)","Corresponding Source":"/**\n     * Convenience method to parse in a String of the form '2,6', which will\n     * create an IndexRange instance with a start value of 2, and an end value\n     * of 6.\n     *\n     * @param value The string to be parsed, and converted to an IndexRange.\n     * @return An IndexRange instance representing the start and end values provided\n     *      in the value string.\n     */\n    public static IndexRange valueOf(String value) {\n        if (value == null) {\n            throw new IllegalArgumentException();\n        }\n\n        String[] values = value.split(VALUE_DELIMITER);\n        if (values.length != 2) {\n            throw new IllegalArgumentException();\n        }\n\n        // NOTE As of Java 6, Integer#parseInt() appears to require\n        // trimmed values\n        int start = Integer.parseInt(values[0].trim());\n        int end = Integer.parseInt(values[1].trim());\n\n        return IndexRange.normalize(start, end);\n    }"}
{"Number":"866","API Relative Path":"javafx.scene.control.SkinBase.java-SkinBase(C)","Corresponding Source":"/***************************************************************************\n     *                                                                         *\n     * Constructor                                                             *\n     *                                                                         *\n     **************************************************************************/\n\n    /**\n     * Constructor for all SkinBase instances.\n     *\n     * @param control The control for which this Skin should attach to.\n     */\n    protected SkinBase(final C control) {\n        if (control == null) {\n            throw new IllegalArgumentException(\"Cannot pass null for control\");\n        }\n\n        // Update the control and behavior\n        this.control = control;\n        this.children = control.getControlChildren();\n\n        // Default behavior for controls is to consume all mouse events\n        consumeMouseEvents(true);\n    }"}
{"Number":"867","API Relative Path":"javafx.scene.control.TableView.java-edit(int-TableColumn)","Corresponding Source":"/**\n     * Causes the cell at the given row/column view indexes to switch into\n     * its editing state, if it is not already in it, and assuming that the\n     * TableView and column are also editable.\n     *\n     * <p><strong>Note:<\/strong> This method will cancel editing if the given row\n     * value is less than zero and the given column is null.<\/p>\n     */\n    public void edit(int row, TableColumn<S,?> column) {\n        if (!isEditable() || (column != null && ! column.isEditable())) {\n            return;\n        }\n\n        if (row < 0 && column == null) {\n            setEditingCell(null);\n        } else {\n            setEditingCell(new TablePosition<>(this, row, column));\n        }\n    }"}
{"Number":"868","API Relative Path":"javafx.scene.control.TabPane.java-lookupAll(String)","Corresponding Source":"/** {@inheritDoc} */\n    public Set<Node> lookupAll(String selector) {\n\n        if (selector == null) return null;\n\n        final List<Node> results = new ArrayList<>();\n\n        results.addAll(super.lookupAll(selector));\n        for(Tab tab : tabs) {\n            results.addAll(tab.lookupAll(selector));\n        }\n\n        return new UnmodifiableListSet<Node>(results);\n    }"}
{"Number":"869","API Relative Path":"javafx.scene.control.TextInputControl.java-appendText(String)","Corresponding Source":"/**\n     * Appends a sequence of characters to the content.\n     *\n     * @param text a non null String\n     */\n    public void appendText(String text) {\n        insertText(getLength(), text);\n    }"}
{"Number":"870","API Relative Path":"javafx.scene.control.TextInputControl.java-deleteText(int-int)","Corresponding Source":"/**\n     * Removes a range of characters from the content.\n     *\n     * @param start The starting index in the range, inclusive. This must be &gt;= 0 and &lt; the end.\n     * @param end The ending index in the range, exclusive. This is one-past the last character to\n     *            delete (consistent with the String manipulation methods). This must be &gt; the start,\n     *            and &lt;= the length of the text.\n     */\n    public void deleteText(int start, int end) {\n        replaceText(start, end, \"\");\n    }"}
{"Number":"871","API Relative Path":"javafx.scene.control.TextInputControl.java-deleteText(int-int)","Corresponding Source":"/**\n     * Removes a range of characters from the content.\n     *\n     * @param start The starting index in the range, inclusive. This must be &gt;= 0 and &lt; the end.\n     * @param end The ending index in the range, exclusive. This is one-past the last character to\n     *            delete (consistent with the String manipulation methods). This must be &gt; the start,\n     *            and &lt;= the length of the text.\n     */\n    public void deleteText(int start, int end) {\n        replaceText(start, end, \"\");\n    }"}
{"Number":"872","API Relative Path":"javafx.scene.control.TextInputControl.java-getText(int-int)","Corresponding Source":"/***************************************************************************\n     *                                                                         *\n     * Methods                                                                 *\n     *                                                                         *\n     **************************************************************************/\n\n    /**\n     * Returns a subset of the text input's content.\n     *\n     * @param start must be a value between 0 and end - 1.\n     * @param end must be less than or equal to the length\n     */\n    public String getText(int start, int end) {\n        if (start > end) {\n            throw new IllegalArgumentException(\"The start must be <= the end\");\n        }\n\n        if (start < 0\n            || end > getLength()) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        return getContent().get(start, end);\n    }"}
{"Number":"873","API Relative Path":"javafx.scene.control.TextInputControl.java-getText(int-int)","Corresponding Source":"/***************************************************************************\n     *                                                                         *\n     * Methods                                                                 *\n     *                                                                         *\n     **************************************************************************/\n\n    /**\n     * Returns a subset of the text input's content.\n     *\n     * @param start must be a value between 0 and end - 1.\n     * @param end must be less than or equal to the length\n     */\n    public String getText(int start, int end) {\n        if (start > end) {\n            throw new IllegalArgumentException(\"The start must be <= the end\");\n        }\n\n        if (start < 0\n            || end > getLength()) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        return getContent().get(start, end);\n    }"}
{"Number":"874","API Relative Path":"javafx.scene.control.TextInputControl.java-insertText(int-String)","Corresponding Source":"/**\n     * Inserts a sequence of characters into the content.\n     *\n     * @param index The location to insert the text.\n     * @param text The text to insert.\n     */\n    public void insertText(int index, String text) {\n        replaceText(index, index, text);\n    }"}
{"Number":"875","API Relative Path":"javafx.scene.control.TextInputControl.java-insertText(int-String)","Corresponding Source":"/**\n     * Inserts a sequence of characters into the content.\n     *\n     * @param index The location to insert the text.\n     * @param text The text to insert.\n     */\n    public void insertText(int index, String text) {\n        replaceText(index, index, text);\n    }"}
{"Number":"876","API Relative Path":"javafx.scene.control.TextInputControl.java-insertText(int-String)","Corresponding Source":"/**\n     * Inserts a sequence of characters into the content.\n     *\n     * @param index The location to insert the text.\n     * @param text The text to insert.\n     */\n    public void insertText(int index, String text) {\n        replaceText(index, index, text);\n    }"}
{"Number":"877","API Relative Path":"javafx.scene.control.TextInputControl.java-replaceText(int-int-String)","Corresponding Source":"/**\n     * Replaces a range of characters with the given text.\n     *\n     * @param start The starting index in the range, inclusive. This must be &gt;= 0 and &lt; the end.\n     * @param end The ending index in the range, exclusive. This is one-past the last character to\n     *            delete (consistent with the String manipulation methods). This must be &gt; the start,\n     *            and &lt;= the length of the text.\n     * @param text The text that is to replace the range. This must not be null.\n     */\n    public void replaceText(final int start, final int end, final String text) {\n        if (start > end) {\n            throw new IllegalArgumentException();\n        }\n\n        if (text == null) {\n            throw new NullPointerException();\n        }\n\n        if (start < 0\n            || end > getLength()) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        if (!this.text.isBound()) {\n            final int oldLength = getLength();\n            TextFormatter<?> formatter = getTextFormatter();\n            TextFormatter.Change change = new TextFormatter.Change(this, getFormatterAccessor(), start, end, text);\n            if (formatter != null && formatter.getFilter() != null) {\n                change = formatter.getFilter().apply(change);\n                if (change == null) {\n                    return;\n                }\n            }\n\n            // Update the content\n            updateContent(change, oldLength == 0);\n\n        }\n    }"}
{"Number":"878","API Relative Path":"javafx.scene.control.TextInputControl.java-replaceText(int-int-String)","Corresponding Source":"/**\n     * Replaces a range of characters with the given text.\n     *\n     * @param start The starting index in the range, inclusive. This must be &gt;= 0 and &lt; the end.\n     * @param end The ending index in the range, exclusive. This is one-past the last character to\n     *            delete (consistent with the String manipulation methods). This must be &gt; the start,\n     *            and &lt;= the length of the text.\n     * @param text The text that is to replace the range. This must not be null.\n     */\n    public void replaceText(final int start, final int end, final String text) {\n        if (start > end) {\n            throw new IllegalArgumentException();\n        }\n\n        if (text == null) {\n            throw new NullPointerException();\n        }\n\n        if (start < 0\n            || end > getLength()) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        if (!this.text.isBound()) {\n            final int oldLength = getLength();\n            TextFormatter<?> formatter = getTextFormatter();\n            TextFormatter.Change change = new TextFormatter.Change(this, getFormatterAccessor(), start, end, text);\n            if (formatter != null && formatter.getFilter() != null) {\n                change = formatter.getFilter().apply(change);\n                if (change == null) {\n                    return;\n                }\n            }\n\n            // Update the content\n            updateContent(change, oldLength == 0);\n\n        }\n    }"}
{"Number":"879","API Relative Path":"javafx.scene.control.TextInputControl.java-replaceText(int-int-String)","Corresponding Source":"/**\n     * Replaces a range of characters with the given text.\n     *\n     * @param start The starting index in the range, inclusive. This must be &gt;= 0 and &lt; the end.\n     * @param end The ending index in the range, exclusive. This is one-past the last character to\n     *            delete (consistent with the String manipulation methods). This must be &gt; the start,\n     *            and &lt;= the length of the text.\n     * @param text The text that is to replace the range. This must not be null.\n     */\n    public void replaceText(final int start, final int end, final String text) {\n        if (start > end) {\n            throw new IllegalArgumentException();\n        }\n\n        if (text == null) {\n            throw new NullPointerException();\n        }\n\n        if (start < 0\n            || end > getLength()) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        if (!this.text.isBound()) {\n            final int oldLength = getLength();\n            TextFormatter<?> formatter = getTextFormatter();\n            TextFormatter.Change change = new TextFormatter.Change(this, getFormatterAccessor(), start, end, text);\n            if (formatter != null && formatter.getFilter() != null) {\n                change = formatter.getFilter().apply(change);\n                if (change == null) {\n                    return;\n                }\n            }\n\n            // Update the content\n            updateContent(change, oldLength == 0);\n\n        }\n    }"}
{"Number":"880","API Relative Path":"javafx.scene.control.TreeItem.java-nextSibling(TreeItem)","Corresponding Source":"/**\n     * Returns the next sibling after the given node. Ordering is based on the\n     * position of the given TreeItem relative to its siblings in the children\n     * list belonging to the parent of the TreeItem.\n     *\n     * @param afterNode The TreeItem for which the next sibling is being\n     *      sought.\n     * @return A TreeItem that is the next sibling of the given TreeItem,\n     *      or null if no such sibling can be found.\n     */\n    public TreeItem<T> nextSibling(final TreeItem<T> afterNode) {\n        if (getParent() == null || afterNode == null) {\n            return null;\n        }\n\n        List<TreeItem<T>> parentChildren = getParent().getChildren();\n        final int childCount = parentChildren.size();\n        int pos = -1;\n        for (int i = 0; i < childCount; i++) {\n            if (afterNode.equals(parentChildren.get(i))) {\n                pos = i + 1;\n                return pos >= childCount ? null : parentChildren.get(pos);\n            }\n        }\n        return null;\n    }"}
{"Number":"881","API Relative Path":"javafx.scene.control.TreeItem.java-previousSibling(TreeItem)","Corresponding Source":"/**\n     * Returns the previous sibling after the given node. Ordering is based on the\n     * position of the given TreeItem relative to its siblings in the children\n     * list belonging to the parent of the TreeItem.\n     *\n     * @param beforeNode The TreeItem for which the previous sibling is being\n     *      sought.\n     * @return A TreeItem that is the previous sibling of the given TreeItem,\n     *      or null if no such sibling can be found.\n     */\n    public TreeItem<T> previousSibling(final TreeItem<T> beforeNode) {\n        if (getParent() == null || beforeNode == null) {\n            return null;\n        }\n\n        List<TreeItem<T>> parentChildren = getParent().getChildren();\n        final int childCount = parentChildren.size();\n        int pos = -1;\n        for (int i = 0; i < childCount; i++) {\n            if (beforeNode.equals(parentChildren.get(i))) {\n                pos = i - 1;\n                return pos < 0 ? null : parentChildren.get(pos);\n            }\n        }\n        return null;\n    }"}
{"Number":"882","API Relative Path":"javafx.scene.control.TreeTableView.java-edit(int-TreeTableColumn)","Corresponding Source":"/**\n     * Causes the cell at the given row/column view indexes to switch into\n     * its editing state, if it is not already in it, and assuming that the\n     * TableView and column are also editable.\n     */\n    public void edit(int row, TreeTableColumn<S,?> column) {\n        if (!isEditable() || (column != null && ! column.isEditable())) {\n            return;\n        }\n\n        if (row < 0 && column == null) {\n            setEditingCell(null);\n        } else {\n            setEditingCell(new TreeTablePosition<>(this, row, column));\n        }\n    }"}
{"Number":"883","API Relative Path":"javafx.scene.CssStyleHelper.java-lookupFont(Styleable-String-StyleMap-CalculatedValue)","Corresponding Source":"/**\n     * Look up a font property. This is handled separately from lookup since\n     * font is inherited and has sub-properties. One should expect that the\n     * text font for the following would be 16px Arial. The lookup method would\n     * give 16px system since it would look <em>only<\/em> for font-size,\n     * font-family, etc <em>only<\/em> if the lookup on font failed.\n     * <pre>\n     * Text text = new Text(\"Hello World\");\n     * text.setStyle(\"-fx-font-size: 16px;\");\n     * Group group = new Group();\n     * group.setStyle(\"-fx-font: 12px Arial;\");\n     * group.getChildren().add(text);\n     * <\/pre>\n     */\n     /*package access for testing*/ CalculatedValue lookupFont(\n            final Styleable styleable,\n            final String property,\n            final StyleMap styleMap,\n            final CalculatedValue cachedFont)\n    {\n\n        StyleOrigin origin = null;\n\n        // How far from this node did we travel to find a font shorthand?\n        // Don't look past this distance for other font properties.\n        int distance = 0;\n\n        // Did we find a style?\n        boolean foundStyle = false;\n\n        String family = null;\n        double size = -1;\n        FontWeight weight = null;\n        FontPosture posture = null;\n\n        CalculatedValue cvFont = cachedFont;\n\n\n        Set<PseudoClass> states = styleable instanceof Node ? ((Node)styleable).pseudoClassStates : styleable.getPseudoClassStates();\n\n        // RT-20145 - if looking for font size and the node has a font,\n        // use the font property's value if it was set by the user and\n        // there is not an inline or author style.\n\n        if (cacheContainer.fontProp != null) {\n            StyleableProperty<Font> styleableProp = cacheContainer.fontProp.getStyleableProperty(styleable);\n            StyleOrigin fpOrigin = styleableProp.getStyleOrigin();\n            Font font = styleableProp.getValue();\n            if (font == null) font = Font.getDefault();\n            if (fpOrigin == StyleOrigin.USER) {\n                origin = fpOrigin;\n                family = getFontFamily(font);\n                size = font.getSize();\n                weight = getFontWeight(font);\n                posture = getFontPosture(font);\n                cvFont = new CalculatedValue(font, fpOrigin, false);\n            }\n        }\n\n        CalculatedValue parentCachedFont = getCachedFont(styleable.getStyleableParent());\n        if (parentCachedFont == null) parentCachedFont = new CalculatedValue(Font.getDefault(), null, false);\n\n        //\n        // Look up the font- properties\n        //\n        CascadingStyle fontShorthand = getStyle(styleable, property, styleMap, states);\n\n        // don't look past current node for font shorthand if user set the font\n        if (fontShorthand == null && origin != StyleOrigin.USER) {\n\n            Styleable parent = styleable != null ? styleable.getStyleableParent() : null;\n\n            while (parent != null) {\n\n                CssStyleHelper parentStyleHelper = parent instanceof Node ? ((Node)parent).styleHelper : null;\n                if (parentStyleHelper != null) {\n\n                    distance += 1;\n\n                    StyleMap parentStyleMap = parentStyleHelper.getStyleMap(parent);\n                    Set<PseudoClass> transitionStates = ((Node)parent).pseudoClassStates;\n                    CascadingStyle cascadingStyle = parentStyleHelper.getStyle(parent, property, parentStyleMap, transitionStates);\n\n                    if (cascadingStyle != null) {\n\n                        final ParsedValueImpl cssValue = cascadingStyle.getParsedValueImpl();\n\n                        if (\"inherit\".equals(cssValue.getValue()) == false) {\n                            fontShorthand = cascadingStyle;\n                            break;\n                        }\n                    }\n\n                }\n\n                parent = parent.getStyleableParent();\n\n            }\n\n        }\n\n        if (fontShorthand != null) {\n\n            //\n            // If we don't have an existing font, or if the origin of the\n            // existing font is less than that of the shorthand, then\n            // take the shorthand. If the origins compare equals, then take\n            // the shorthand since the fontProp value will not have been\n            // updated yet.\n            //\n            if (origin == null || origin.compareTo(fontShorthand.getOrigin()) <= 0) {\n\n                final CalculatedValue cv =\n                        calculateValue(fontShorthand, styleable, dummyFontProperty,\n                                styleMap, states, styleable, parentCachedFont);\n\n                // cv could be SKIP\n                if (cv.getValue() instanceof Font) {\n                    origin = cv.getOrigin();\n                    Font font = (Font)cv.getValue();\n                    family = getFontFamily(font);\n                    size = font.getSize();\n                    weight = getFontWeight(font);\n                    posture = getFontPosture(font);\n                    cvFont = cv;\n                    foundStyle = true;\n                }\n\n            }\n        }\n\n        CascadingStyle fontSize = getStyle(styleable, property.concat(\"-size\"), styleMap, states);\n        if (fontSize != null) {\n            // if we have a font shorthand and it is more specific than font-size, then don't use the font-size style\n            if (fontShorthand != null && fontShorthand.compareTo(fontSize) < 0) {\n                fontSize = null;\n            } else if (origin == StyleOrigin.USER) {\n                // If fontSize is an inline or author-stylesheet style, use it.\n                // Otherwise, fontSize is a user-agent stylesheet style and should not override the USER style.\n                if (StyleOrigin.USER.compareTo(fontSize.getOrigin()) > 0) {\n                    fontSize = null;\n                }\n            }\n        } else if (origin != StyleOrigin.USER) {\n            //\n            // If we don't have a font-size, see if there is an inherited font-size.\n            // If lookupInheritedFontProperty returns other than null, then we know that font-size is closer (more specific)\n            // than the font shorthand\n            //\n            fontSize = lookupInheritedFontProperty(styleable, property.concat(\"-size\"), styleMap, distance, fontShorthand);\n        }\n\n        if (fontSize != null) {\n\n            // The logic above ensures that, if fontSize is not null, then it is either\n            // 1) a style matching this node and is more specific than the font shorthand or\n            // 2) an inherited style that is more specific than the font shorthand\n            // and, therefore, we can use the fontSize style\n\n            final CalculatedValue cv =\n                    calculateValue(fontSize, styleable, dummyFontProperty,\n                            styleMap, states, styleable, parentCachedFont);\n\n            if (cv.getValue() instanceof Double) {\n                if (origin == null || origin.compareTo(fontSize.getOrigin()) <= 0) {\n\n                    origin = cv.getOrigin();\n                }\n                size = (Double) cv.getValue();\n\n                if (cvFont != null) {\n                    boolean isRelative = cvFont.isRelative() || cv.isRelative();\n                    Font font = deriveFont((Font) cvFont.getValue(), family, weight, posture, size);\n                    cvFont = new CalculatedValue(font, origin, isRelative);\n                } else {\n                    boolean isRelative = cv.isRelative();\n                    Font font = deriveFont(Font.getDefault(), family, weight, posture, size);\n                    cvFont = new CalculatedValue(font, origin, isRelative);\n                }\n                foundStyle = true;\n            }\n\n        }\n\n        // if cachedFont is null, then we're in this method to look up a font for the CacheContainer's fontSizeCache\n        // and we only care about font-size or the size from font shorthand.\n        if (cachedFont == null) {\n            return (cvFont != null) ? cvFont : SKIP;\n        }\n\n        CascadingStyle fontWeight = getStyle(styleable, property.concat(\"-weight\"), styleMap, states);\n        if (fontWeight != null) {\n            // if we have a font shorthand and it is more specific than font-weight, then don't use the font-weight style\n            if (fontShorthand != null && fontShorthand.compareTo(fontWeight) < 0) {\n                fontWeight = null;\n            }\n\n        } else if (origin != StyleOrigin.USER) {\n            //\n            // If we don't have a font-weight, see if there is an inherited font-weight.\n            // If lookupInheritedFontProperty returns other than null, then we know that font-weight is closer (more specific)\n            // than the font shorthand\n            //\n            fontWeight = lookupInheritedFontProperty(styleable, property.concat(\"-weight\"), styleMap, distance, fontShorthand);\n        }\n\n        if (fontWeight != null) {\n\n            // The logic above ensures that, if fontWeight is not null, then it is either\n            // 1) a style matching this node and is more specific than the font shorthand or\n            // 2) an inherited style that is more specific than the font shorthand\n            // and, therefore, we can use the fontWeight style\n\n            final CalculatedValue cv =\n                    calculateValue(fontWeight, styleable, dummyFontProperty,\n                            styleMap, states, styleable, null);\n\n            if (cv.getValue() instanceof FontWeight) {\n                if (origin == null || origin.compareTo(fontWeight.getOrigin()) <= 0) {\n                    origin = cv.getOrigin();\n                }\n                weight = (FontWeight)cv.getValue();\n                foundStyle = true;\n            }\n        }\n\n\n        CascadingStyle fontStyle = getStyle(styleable, property.concat(\"-style\"), styleMap, states);\n        if (fontStyle != null) {\n            // if we have a font shorthand and it is more specific than font-style, then don't use the font-style style\n            if (fontShorthand != null && fontShorthand.compareTo(fontStyle) < 0) {\n                fontStyle = null;\n            }\n\n        } else if (origin != StyleOrigin.USER) {\n            //\n            // If we don't have a font-style, see if there is an inherited font-style.\n            // If lookupInheritedFontProperty returns other than null, then we know that font-style is closer (more specific)\n            // than the font shorthand\n            //\n            fontStyle = lookupInheritedFontProperty(styleable, property.concat(\"-style\"), styleMap, distance, fontShorthand);\n        }\n\n        if (fontStyle != null) {\n\n            // The logic above ensures that, if fontStyle is not null, then it is either\n            // 1) a style matching this node and is more specific than the font shorthand or\n            // 2) an inherited style that is more specific than the font shorthand\n            // and, therefore, we can use the fontStyle style\n\n            final CalculatedValue cv =\n                    calculateValue(fontStyle, styleable, dummyFontProperty,\n                            styleMap, states, styleable, null);\n\n            if (cv.getValue() instanceof FontPosture) {\n                if (origin == null || origin.compareTo(fontStyle.getOrigin()) <= 0) {\n                    origin = cv.getOrigin();\n                }\n                posture = (FontPosture)cv.getValue();\n                foundStyle = true;\n            }\n\n        }\n\n        CascadingStyle fontFamily = getStyle(styleable, property.concat(\"-family\"), styleMap, states);\n        if (fontFamily != null) {\n            // if we have a font shorthand and it is more specific than font-family, then don't use the font-family style\n            if (fontShorthand != null && fontShorthand.compareTo(fontFamily) < 0) {\n                fontFamily = null;\n            }\n\n        } else if (origin != StyleOrigin.USER) {\n            //\n            // If we don't have a font-family, see if there is an inherited font-family.\n            // If lookupInheritedFontProperty returns other than null, then we know that font-family is closer (more specific)\n            // than the font shorthand\n            //\n            fontFamily = lookupInheritedFontProperty(styleable, property.concat(\"-family\"), styleMap, distance, fontShorthand);\n        }\n\n        if (fontFamily != null) {\n\n            // The logic above ensures that, if fontFamily is not null, then it is either\n            // 1) a style matching this node and is more specific than the font shorthand or\n            // 2) an inherited style that is more specific than the font shorthand\n            // and, therefore, we can use the fontFamily style\n\n            final CalculatedValue cv =\n                    calculateValue(fontFamily, styleable, dummyFontProperty,\n                            styleMap, states, styleable, null);\n\n            if (cv.getValue() instanceof String) {\n                if (origin == null || origin.compareTo(fontFamily.getOrigin()) <= 0) {\n                    origin = cv.getOrigin();\n                }\n                family = (String)cv.getValue();\n                foundStyle = true;\n            }\n\n        }\n\n        if (foundStyle) {\n\n            Font font = cvFont != null ? (Font)cvFont.getValue() : Font.getDefault();\n            Font derivedFont = deriveFont(font, family, weight, posture, size);\n            return new CalculatedValue(derivedFont,origin,false);\n\n        }\n\n        return SKIP;\n    }"}
{"Number":"884","API Relative Path":"javafx.scene.CssStyleHelper.java-transitionToState(Node)","Corresponding Source":"/**\n     * Called by the Node whenever it has transitioned from one set of\n     * pseudo-class states to another. This function will then lookup the\n     * new values for each of the styleable variables on the Node, and\n     * then either set the value directly or start an animation based on\n     * how things are specified in the CSS file. Currently animation support\n     * is disabled until the new parser comes online with support for\n     * animations and that support is detectable via the API.\n     */\n    void transitionToState(final Node node) {\n\n        if (cacheContainer == null) {\n            return;\n        }\n\n        //\n        // If styleMap is null, then StyleManager has blown it away and we need to reapply CSS.\n        //\n        final StyleMap styleMap = getStyleMap(node);\n        if (styleMap == null) {\n            cacheContainer = null;\n            node.impl_reapplyCSS();\n            return;\n        }\n\n        // if the style-map is empty, then we are only looking for inherited styles.\n        final boolean inheritOnly = styleMap.isEmpty();\n\n        //\n        // Styles that need lookup can be cached provided none of the styles\n        // are from Node.style.\n        //\n        final StyleCache sharedCache = StyleManager.getInstance().getSharedCache(node, node.getSubScene(), cacheContainer.styleCacheKey);\n\n        if (sharedCache == null) {\n            // Shared cache was blown away by StyleManager.\n            // Therefore, this CssStyleHelper is no good.\n            cacheContainer = null;\n            node.impl_reapplyCSS();\n            return;\n\n        }\n\n        final Set<PseudoClass>[] transitionStates = getTransitionStates(node);\n\n        final StyleCacheEntry.Key fontCacheKey = new StyleCacheEntry.Key(transitionStates, Font.getDefault());\n        CalculatedValue cachedFont = cacheContainer.fontSizeCache.get(fontCacheKey);\n\n        if (cachedFont == null) {\n\n            cachedFont = lookupFont(node, \"-fx-font\", styleMap, cachedFont);\n\n            if (cachedFont == SKIP) cachedFont = getCachedFont(node.getStyleableParent());\n            if (cachedFont == null) cachedFont = new CalculatedValue(Font.getDefault(), null, false);\n\n            cacheContainer.fontSizeCache.put(fontCacheKey,cachedFont);\n\n        }\n\n        final Font fontForRelativeSizes = (Font)cachedFont.getValue();\n\n        final StyleCacheEntry.Key cacheEntryKey = new StyleCacheEntry.Key(transitionStates, fontForRelativeSizes);\n        StyleCacheEntry cacheEntry = sharedCache.getStyleCacheEntry(cacheEntryKey);\n\n        // if the cacheEntry already exists, take the fastpath\n        final boolean fastpath = cacheEntry != null;\n\n        if (cacheEntry == null) {\n            cacheEntry = new StyleCacheEntry();\n            sharedCache.addStyleCacheEntry(cacheEntryKey, cacheEntry);\n        }\n\n        final List<CssMetaData<? extends Styleable,  ?>> styleables = node.getCssMetaData();\n\n        // Used in the for loop below, and a convenient place to stop when debugging.\n        final int max = styleables.size();\n\n        final boolean isForceSlowpath = cacheContainer.forceSlowpath;\n        cacheContainer.forceSlowpath = false;\n\n        // RT-20643\n        CssError.setCurrentScene(node.getScene());\n\n        // For each property that is settable, we need to do a lookup and\n        // transition to that value.\n        for(int n=0; n<max; n++) {\n\n            @SuppressWarnings(\"unchecked\") // this is a widening conversion\n            final CssMetaData<Styleable,Object> cssMetaData =\n                    (CssMetaData<Styleable,Object>)styleables.get(n);\n\n            // Don't bother looking up styles that don't inherit.\n            if (inheritOnly && cssMetaData.isInherits() == false) {\n                continue;\n            }\n\n            // Skip the lookup if we know there isn't a chance for this property\n            // to be set (usually due to a \"bind\").\n            if (!cssMetaData.isSettable(node)) continue;\n\n            final String property = cssMetaData.getProperty();\n\n            CalculatedValue calculatedValue = cacheEntry.get(property);\n\n            // If there is no calculatedValue and we're on the fast path,\n            // take the slow path if cssFlags is REAPPLY (RT-31691)\n            final boolean forceSlowpath =\n                    fastpath && calculatedValue == null && isForceSlowpath;\n\n            final boolean addToCache =\n                    (!fastpath && calculatedValue == null) || forceSlowpath;\n\n            if (fastpath && !forceSlowpath) {\n\n                // If the cache contains SKIP, then there was an\n                // exception thrown from applyStyle\n                if (calculatedValue == SKIP) {\n                    continue;\n                }\n\n            } else if (calculatedValue == null) {\n\n                // slowpath!\n                calculatedValue = lookup(node, cssMetaData, styleMap, transitionStates[0],\n                        node, cachedFont);\n\n                // lookup is not supposed to return null.\n                if (calculatedValue == null) {\n                    assert false : \"lookup returned null for \" + property;\n                    continue;\n                }\n\n            }\n\n            // StyleableProperty#applyStyle might throw an exception and it is called\n            // from two places in this try block.\n            try {\n\n                //\n                // RT-19089\n                // If the current value of the property was set by CSS\n                // and there is no style for the property, then reset this\n                // property to its initial value. If it was not set by CSS\n                // then leave the property alone.\n                //\n                if (calculatedValue == null || calculatedValue == SKIP) {\n\n                    // cssSetProperties keeps track of the StyleableProperty's that were set by CSS in the previous state.\n                    // If this property is not in cssSetProperties map, then the property was not set in the previous state.\n                    // This accomplishes two things. First, it lets us know if the property was set in the previous state\n                    // so it can be reset in this state if there is no value for it. Second, it calling\n                    // CssMetaData#getStyleableProperty which is rather expensive as it may cause expansion of lazy\n                    // properties.\n                    CalculatedValue initialValue = cacheContainer.cssSetProperties.get(cssMetaData);\n\n                    // if the current value was set by CSS and there\n                    // is no calculated value for the property, then\n                    // there was no style for the property in the current\n                    // state, so reset the property to its initial value.\n                    if (initialValue != null) {\n\n                        StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(node);\n                        if (styleableProperty.getStyleOrigin() != StyleOrigin.USER) {\n                            styleableProperty.applyStyle(initialValue.getOrigin(), initialValue.getValue());\n                        }\n                    }\n\n                    continue;\n\n                }\n\n                if (addToCache) {\n\n                    // If we're not on the fastpath, then add the calculated\n                    // value to cache.\n                    cacheEntry.put(property, calculatedValue);\n                }\n\n                StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(node);\n\n                // need to know who set the current value - CSS, the user, or init\n                final StyleOrigin originOfCurrentValue = styleableProperty.getStyleOrigin();\n\n\n                // RT-10522:\n                // If the user set the property and there is a style and\n                // the style came from the user agent stylesheet, then\n                // skip the value. A style from a user agent stylesheet should\n                // not override the user set style.\n                //\n                final StyleOrigin originOfCalculatedValue = calculatedValue.getOrigin();\n\n                // A calculated value should never have a null style origin since that would\n                // imply the style didn't come from a stylesheet or in-line style.\n                if (originOfCalculatedValue == null) {\n                    assert false : styleableProperty.toString();\n                    continue;\n                }\n\n                if (originOfCurrentValue == StyleOrigin.USER) {\n                    if (originOfCalculatedValue == StyleOrigin.USER_AGENT) {\n                        continue;\n                    }\n                }\n\n                final Object value = calculatedValue.getValue();\n                final Object currentValue = styleableProperty.getValue();\n\n                // RT-21185: Only apply the style if something has changed.\n                if ((originOfCurrentValue != originOfCalculatedValue)\n                        || (currentValue != null\n                        ? currentValue.equals(value) == false\n                        : value != null)) {\n\n                    if (LOGGER.isLoggable(Level.FINER)) {\n                        LOGGER.finer(property + \", call applyStyle: \" + styleableProperty + \", value =\" +\n                                String.valueOf(value) + \", originOfCalculatedValue=\" + originOfCalculatedValue);\n                    }\n\n                    styleableProperty.applyStyle(originOfCalculatedValue, value);\n\n                    if (cacheContainer.cssSetProperties.containsKey(cssMetaData) == false) {\n                        // track this property\n                        CalculatedValue initialValue = new CalculatedValue(currentValue, originOfCurrentValue, false);\n                        cacheContainer.cssSetProperties.put(cssMetaData, initialValue);\n                    }\n\n                }\n\n            } catch (Exception e) {\n\n                StyleableProperty styleableProperty = cssMetaData.getStyleableProperty(node);\n\n                final String msg = String.format(\"Failed to set css [%s] on [%s] due to '%s'\\n\",\n                        cssMetaData.getProperty(), styleableProperty, e.getMessage());\n\n                List<CssError> errors = null;\n                if ((errors = StyleManager.getErrors()) != null) {\n                    final CssError error = new CssError.PropertySetError(cssMetaData, node, msg);\n                    errors.add(error);\n                }\n\n                PlatformLogger logger = Logging.getCSSLogger();\n                if (logger.isLoggable(Level.WARNING)) {\n                    logger.warning(msg);\n                }\n\n                // RT-27155: if setting value raises exception, reset value\n                // the value to initial and thereafter skip setting the property\n                cacheEntry.put(property, SKIP);\n\n                CalculatedValue cachedValue = null;\n                if (cacheContainer != null && cacheContainer.cssSetProperties != null) {\n                    cachedValue = cacheContainer.cssSetProperties.get(cssMetaData);\n                }\n                Object value = (cachedValue != null) ? cachedValue.getValue() : cssMetaData.getInitialValue(node);\n                StyleOrigin origin = (cachedValue != null) ? cachedValue.getOrigin() : null;\n                try {\n                    styleableProperty.applyStyle(origin, value);\n                } catch (Exception ebad) {\n                    // This would be bad.\n                    if (logger.isLoggable(Level.SEVERE)) {\n                        logger.severe(String.format(\"Could not reset [%s] on [%s] due to %s\\n\" ,\n                                cssMetaData.getProperty(), styleableProperty, e.getMessage()));\n                    }\n                }\n\n            }\n\n        }\n\n        // RT-20643\n        CssError.setCurrentScene(null);\n\n    }"}
{"Number":"885","API Relative Path":"javafx.scene.Cursor.java-Cursor(String)","Corresponding Source":"// PENDING_DOC_REVIEW\n    /**\n     * Returns a cursor for the specified identifier. The identifier can be\n     * either a name of some standard cursor or a valid URL string. If the\n     * identifier names a standard cursor the corresponding cursor is returned.\n     * In the case of a URL string, the method returns a new {@code ImageCursor}\n     * created for that URL.\n     *\n     * @param identifier the cursor identifier\n     * @return the cursor for the identifier\n     * @throws IllegalArgumentException if the cursor identifier is not a\n     *      valid URL string nor any standard cursor name\n     */\n    public static Cursor cursor(final String identifier) {\n        if (identifier == null) {\n            throw new NullPointerException(\n                    \"The cursor identifier must not be null\");\n        }\n\n        if (isUrl(identifier)) {\n            return new ImageCursor(new Image(identifier));\n        }\n\n        String uName = identifier.toUpperCase(Locale.ROOT);\n        if (uName.equals(DEFAULT.name)) {\n            return DEFAULT;\n        } else if(uName.equals(CROSSHAIR.name)) {\n            return CROSSHAIR;\n        } else if (uName.equals(TEXT.name)) {\n            return TEXT;\n        } else if (uName.equals(WAIT.name)) {\n            return WAIT;\n        } else if (uName.equals(MOVE.name)) {\n            return MOVE;\n        } else if (uName.equals(SW_RESIZE.name)) {\n            return SW_RESIZE;\n        } else if (uName.equals(SE_RESIZE.name)) {\n            return SE_RESIZE;\n        } else if (uName.equals(NW_RESIZE.name)) {\n            return NW_RESIZE;\n        } else if (uName.equals(NE_RESIZE.name)) {\n            return NE_RESIZE;\n        } else if (uName.equals(N_RESIZE.name)) {\n            return N_RESIZE;\n        } else if (uName.equals(S_RESIZE.name)) {\n            return S_RESIZE;\n        } else if (uName.equals(W_RESIZE.name)) {\n            return W_RESIZE;\n        } else if (uName.equals(E_RESIZE.name)) {\n            return E_RESIZE;\n        } else if (uName.equals(OPEN_HAND.name)) {\n            return OPEN_HAND;\n        } else if (uName.equals(CLOSED_HAND.name)) {\n            return CLOSED_HAND;\n        } else if (uName.equals(HAND.name)) {\n            return HAND;\n        } else if (uName.equals(H_RESIZE.name)) {\n            return H_RESIZE;\n        } else if (uName.equals(V_RESIZE.name)) {\n            return V_RESIZE;\n        } else if (uName.equals(DISAPPEAR.name)) {\n            return DISAPPEAR;\n        } else if (uName.equals(NONE.name)) {\n            return NONE;\n        }\n\n        throw new IllegalArgumentException(\"Invalid cursor specification\");\n    }"}
{"Number":"886","API Relative Path":"javafx.scene.Cursor.java-Cursor(String)","Corresponding Source":"// PENDING_DOC_REVIEW\n    /**\n     * Returns a cursor for the specified identifier. The identifier can be\n     * either a name of some standard cursor or a valid URL string. If the\n     * identifier names a standard cursor the corresponding cursor is returned.\n     * In the case of a URL string, the method returns a new {@code ImageCursor}\n     * created for that URL.\n     *\n     * @param identifier the cursor identifier\n     * @return the cursor for the identifier\n     * @throws IllegalArgumentException if the cursor identifier is not a\n     *      valid URL string nor any standard cursor name\n     */\n    public static Cursor cursor(final String identifier) {\n        if (identifier == null) {\n            throw new NullPointerException(\n                    \"The cursor identifier must not be null\");\n        }\n\n        if (isUrl(identifier)) {\n            return new ImageCursor(new Image(identifier));\n        }\n\n        String uName = identifier.toUpperCase(Locale.ROOT);\n        if (uName.equals(DEFAULT.name)) {\n            return DEFAULT;\n        } else if(uName.equals(CROSSHAIR.name)) {\n            return CROSSHAIR;\n        } else if (uName.equals(TEXT.name)) {\n            return TEXT;\n        } else if (uName.equals(WAIT.name)) {\n            return WAIT;\n        } else if (uName.equals(MOVE.name)) {\n            return MOVE;\n        } else if (uName.equals(SW_RESIZE.name)) {\n            return SW_RESIZE;\n        } else if (uName.equals(SE_RESIZE.name)) {\n            return SE_RESIZE;\n        } else if (uName.equals(NW_RESIZE.name)) {\n            return NW_RESIZE;\n        } else if (uName.equals(NE_RESIZE.name)) {\n            return NE_RESIZE;\n        } else if (uName.equals(N_RESIZE.name)) {\n            return N_RESIZE;\n        } else if (uName.equals(S_RESIZE.name)) {\n            return S_RESIZE;\n        } else if (uName.equals(W_RESIZE.name)) {\n            return W_RESIZE;\n        } else if (uName.equals(E_RESIZE.name)) {\n            return E_RESIZE;\n        } else if (uName.equals(OPEN_HAND.name)) {\n            return OPEN_HAND;\n        } else if (uName.equals(CLOSED_HAND.name)) {\n            return CLOSED_HAND;\n        } else if (uName.equals(HAND.name)) {\n            return HAND;\n        } else if (uName.equals(H_RESIZE.name)) {\n            return H_RESIZE;\n        } else if (uName.equals(V_RESIZE.name)) {\n            return V_RESIZE;\n        } else if (uName.equals(DISAPPEAR.name)) {\n            return DISAPPEAR;\n        } else if (uName.equals(NONE.name)) {\n            return NONE;\n        }\n\n        throw new IllegalArgumentException(\"Invalid cursor specification\");\n    }"}
{"Number":"887","API Relative Path":"javafx.scene.effect.Blend.java-impl_getToolkitMode(BlendMode)","Corresponding Source":"/**\n     * Used by Group to convert the FX BlendMode enum value into a Decora value.\n     * @treatAsPrivate implementation detail\n     * @deprecated This is an internal API that is not intended for use and will be removed in the next version\n     */\n    @Deprecated\n    public static Mode impl_getToolkitMode(BlendMode mode) {\n        return toPGMode(mode);\n    }"}
{"Number":"888","API Relative Path":"javafx.scene.image.Image.java-Image(InputStream)","Corresponding Source":"/**\n     * Construct an {@code Image} with content loaded from the specified\n     * input stream.\n     *\n     * @param is the stream from which to load the image\n     * @throws NullPointerException if input stream is null\n     */\n    public Image(@NamedArg(\"is\") InputStream is) {\n        this(null, validateInputStream(is), 0, 0, false, false, false);\n        initialize(null);\n    }"}
{"Number":"889","API Relative Path":"javafx.scene.image.Image.java-Image(InputStream-double-double-boolean-boolean)","Corresponding Source":"private static ImageLoader loadImage(\n            InputStream stream, double width, double height,\n            boolean preserveRatio, boolean smooth) {\n        return Toolkit.getToolkit().loadImage(stream, (int) width, (int) height,\n                                              preserveRatio, smooth);\n\n    }"}
{"Number":"890","API Relative Path":"javafx.scene.image.Image.java-Image(int-int)","Corresponding Source":"/**\n     * Package private internal constructor used only by {@link WritableImage}.\n     * The dimensions must both be positive numbers <code>(&gt;&nbsp;0)<\/code>.\n     *\n     * @param width the width of the empty image\n     * @param height the height of the empty image\n     * @throws IllegalArgumentException if either dimension is negative or zero.\n     */\n    Image(int width, int height) {\n        this(null, null, width, height, false, false, false);\n        if (width <= 0 || height <= 0) {\n            throw new IllegalArgumentException(\"Image dimensions must be positive (w,h > 0)\");\n        }\n        initialize(Toolkit.getToolkit().createPlatformImage(width, height));\n    }"}
{"Number":"891","API Relative Path":"javafx.scene.ImageCursor.java-ImageCursor(Image-double-double)","Corresponding Source":"/**\n     * Constructs an {@code ImageCursor} from the specified image and hotspot\n     * coordinates.\n     *\n     * @param image the image\n     * @param hotspotX the X coordinate of the cursor's hot spot\n     * @param hotspotY the Y coordinate of the cursor's hot spot\n     */\n    public ImageCursor(@NamedArg(\"image\") final Image image,\n                       @NamedArg(\"hotspotX\") double hotspotX,\n                       @NamedArg(\"hotspotY\") double hotspotY) {\n        if ((image != null) && (image.getProgress() < 1)) {\n            DelayedInitialization.applyTo(\n                    this, image, hotspotX, hotspotY);\n        } else {\n            initialize(image, hotspotX, hotspotY);\n        }\n    }"}
{"Number":"892","API Relative Path":"javafx.scene.input.KeyCharacterCombination.java-KeyCharacterCombination(String-ModifierValue-ModifierValue-ModifierValue-ModifierValue-ModifierValue)","Corresponding Source":"/**\n     * Constructs a {@code KeyCharacterCombination} for the specified main key\n     * character and with an explicit specification of all modifier keys. Each\n     * modifier key can be set to {@code PRESSED}, {@code RELEASED} or\n     * {@code IGNORED}.\n     *\n     * @param character the main key character\n     * @param shift the value of the {@code shift} modifier key\n     * @param control the value of the {@code control} modifier key\n     * @param alt the value of the {@code alt} modifier key\n     * @param meta the value of the {@code meta} modifier key\n     * @param shortcut the value of the {@code shortcut} modifier key\n     */\n    public KeyCharacterCombination(final @NamedArg(\"character\") String character,\n                                   final @NamedArg(\"shift\") ModifierValue shift,\n                                   final @NamedArg(\"control\") ModifierValue control,\n                                   final @NamedArg(\"alt\") ModifierValue alt,\n                                   final @NamedArg(\"meta\") ModifierValue meta,\n                                   final @NamedArg(\"shortcut\") ModifierValue shortcut) {\n        super(shift, control, alt, meta, shortcut);\n\n        validateKeyCharacter(character);\n        this.character = character;\n    }"}
{"Number":"893","API Relative Path":"javafx.scene.input.KeyCharacterCombination.java-KeyCharacterCombination(String-ModifierValue-ModifierValue-ModifierValue-ModifierValue-ModifierValue)","Corresponding Source":"/**\n     * Constructs a {@code KeyCharacterCombination} for the specified main key\n     * character and with an explicit specification of all modifier keys. Each\n     * modifier key can be set to {@code PRESSED}, {@code RELEASED} or\n     * {@code IGNORED}.\n     *\n     * @param character the main key character\n     * @param shift the value of the {@code shift} modifier key\n     * @param control the value of the {@code control} modifier key\n     * @param alt the value of the {@code alt} modifier key\n     * @param meta the value of the {@code meta} modifier key\n     * @param shortcut the value of the {@code shortcut} modifier key\n     */\n    public KeyCharacterCombination(final @NamedArg(\"character\") String character,\n                                   final @NamedArg(\"shift\") ModifierValue shift,\n                                   final @NamedArg(\"control\") ModifierValue control,\n                                   final @NamedArg(\"alt\") ModifierValue alt,\n                                   final @NamedArg(\"meta\") ModifierValue meta,\n                                   final @NamedArg(\"shortcut\") ModifierValue shortcut) {\n        super(shift, control, alt, meta, shortcut);\n\n        validateKeyCharacter(character);\n        this.character = character;\n    }"}
{"Number":"894","API Relative Path":"javafx.scene.input.KeyCodeCombination.java-KeyCodeCombination(KeyCode-ModifierValue-ModifierValue-ModifierValue-ModifierValue-ModifierValue)","Corresponding Source":"/**\n     * Constructs a {@code KeyCodeCombination} for the specified main key and\n     * with an explicit specification of all modifier keys. Each modifier key\n     * can be set to {@code PRESSED}, {@code RELEASED} or {@code IGNORED}.\n     *\n     * @param code the key code of the main key\n     * @param shift the value of the {@code shift} modifier key\n     * @param control the value of the {@code control} modifier key\n     * @param alt the value of the {@code alt} modifier key\n     * @param meta the value of the {@code meta} modifier key\n     * @param shortcut the value of the {@code shortcut} modifier key\n     */\n    public KeyCodeCombination(final @NamedArg(\"code\") KeyCode code,\n                              final @NamedArg(\"shift\") ModifierValue shift,\n                              final @NamedArg(\"control\") ModifierValue control,\n                              final @NamedArg(\"alt\") ModifierValue alt,\n                              final @NamedArg(\"meta\") ModifierValue meta,\n                              final @NamedArg(\"shortcut\") ModifierValue shortcut) {\n        super(shift, control, alt, meta, shortcut);\n\n        validateKeyCode(code);\n        this.code = code;\n    }"}
{"Number":"895","API Relative Path":"javafx.scene.input.KeyCodeCombination.java-KeyCodeCombination(KeyCode-ModifierValue-ModifierValue-ModifierValue-ModifierValue-ModifierValue)","Corresponding Source":"/**\n     * Constructs a {@code KeyCodeCombination} for the specified main key and\n     * with an explicit specification of all modifier keys. Each modifier key\n     * can be set to {@code PRESSED}, {@code RELEASED} or {@code IGNORED}.\n     *\n     * @param code the key code of the main key\n     * @param shift the value of the {@code shift} modifier key\n     * @param control the value of the {@code control} modifier key\n     * @param alt the value of the {@code alt} modifier key\n     * @param meta the value of the {@code meta} modifier key\n     * @param shortcut the value of the {@code shortcut} modifier key\n     */\n    public KeyCodeCombination(final @NamedArg(\"code\") KeyCode code,\n                              final @NamedArg(\"shift\") ModifierValue shift,\n                              final @NamedArg(\"control\") ModifierValue control,\n                              final @NamedArg(\"alt\") ModifierValue alt,\n                              final @NamedArg(\"meta\") ModifierValue meta,\n                              final @NamedArg(\"shortcut\") ModifierValue shortcut) {\n        super(shift, control, alt, meta, shortcut);\n\n        validateKeyCode(code);\n        this.code = code;\n    }"}
{"Number":"896","API Relative Path":"javafx.scene.input.KeyCombination.java-KeyCombination(ModifierValue-ModifierValue-ModifierValue-ModifierValue-ModifierValue)","Corresponding Source":"/**\n     * Constructs a {@code KeyCombination} with an explicit specification\n     * of all modifier keys. Each modifier key can be set to {@code DOWN},\n     * {@code UP} or {@code ANY}.\n     *\n     * @param shift the value of the {@code shift} modifier key\n     * @param control the value of the {@code control} modifier key\n     * @param alt the value of the {@code alt} modifier key\n     * @param meta the value of the {@code meta} modifier key\n     * @param shortcut the value of the {@code shortcut} modifier key\n     */\n    protected KeyCombination(final ModifierValue shift,\n                             final ModifierValue control,\n                             final ModifierValue alt,\n                             final ModifierValue meta,\n                             final ModifierValue shortcut) {\n        if ((shift == null)\n                || (control == null)\n                || (alt == null)\n                || (meta == null)\n                || (shortcut == null)) {\n            throw new NullPointerException(\"Modifier value must not be null!\");\n        }\n\n        this.shift = shift;\n        this.control = control;\n        this.alt = alt;\n        this.meta = meta;\n        this.shortcut = shortcut;\n    }"}
{"Number":"897","API Relative Path":"javafx.scene.layout.BackgroundPosition.java-BackgroundPosition(Side-double-boolean-Side-double-boolean)","Corresponding Source":"/**\n     * Creates a new BackgroundPosition.\n     *\n     * @param horizontalSide            The horizontal side, must be either null, LEFT, or RIGHT. If null, LEFT\n     *                                  will be used. If TOP or BOTTOM is specified, an IllegalArgumentException\n     *                                  is thrown.\n     * @param horizontalPosition        The horizontal position value.\n     * @param horizontalAsPercentage    Whether to interpret the horizontal position as a decimal or percentage\n     * @param verticalSide              The vertical side, must be either null, TOP, or BOTTOM. If null, TOP\n     *                                  will be used. If LEFT or RIGHT is specified, an IllegalArgumentException\n     *                                  is thrown.\n     * @param verticalPosition          The vertical position value.\n     * @param verticalAsPercentage      Whether to interpret the vertical position as a decimal or percentage\n     */\n    public BackgroundPosition(@NamedArg(\"horizontalSide\") Side horizontalSide, @NamedArg(\"horizontalPosition\") double horizontalPosition, @NamedArg(\"horizontalAsPercentage\") boolean horizontalAsPercentage,\n                              @NamedArg(\"verticalSide\") Side verticalSide, @NamedArg(\"verticalPosition\") double verticalPosition, @NamedArg(\"verticalAsPercentage\") boolean verticalAsPercentage) {\n\n        if (horizontalSide == Side.TOP || horizontalSide == Side.BOTTOM) {\n            throw new IllegalArgumentException(\"The horizontalSide must be LEFT or RIGHT\");\n        }\n\n        if (verticalSide == Side.LEFT || verticalSide == Side.RIGHT) {\n            throw new IllegalArgumentException(\"The verticalSide must be TOP or BOTTOM\");\n        }\n\n        this.horizontalSide = horizontalSide == null ? Side.LEFT : horizontalSide;\n        this.verticalSide = verticalSide == null ? Side.TOP : verticalSide;\n        this.horizontalPosition = horizontalPosition;\n        this.verticalPosition = verticalPosition;\n        this.horizontalAsPercentage = horizontalAsPercentage;\n        this.verticalAsPercentage = verticalAsPercentage;\n\n        // Pre-compute the hash code. NOTE: all variables are prefixed with \"this\" so that we\n        // do not accidentally compute the hash based on the constructor arguments rather than\n        // based on the fields themselves!\n        int result;\n        long temp;\n        result = this.horizontalSide.hashCode();\n        result = 31 * result + this.verticalSide.hashCode();\n        temp = this.horizontalPosition != +0.0d ? Double.doubleToLongBits(this.horizontalPosition) : 0L;\n        result = 31 * result + (int) (temp ^ (temp >>> 32));\n        temp = this.verticalPosition != +0.0d ? Double.doubleToLongBits(this.verticalPosition) : 0L;\n        result = 31 * result + (int) (temp ^ (temp >>> 32));\n        result = 31 * result + (this.horizontalAsPercentage ? 1 : 0);\n        result = 31 * result + (this.verticalAsPercentage ? 1 : 0);\n        hash = result;\n    }"}
{"Number":"898","API Relative Path":"javafx.scene.layout.BackgroundPosition.java-BackgroundPosition(Side-double-boolean-Side-double-boolean)","Corresponding Source":"/**\n     * Creates a new BackgroundPosition.\n     *\n     * @param horizontalSide            The horizontal side, must be either null, LEFT, or RIGHT. If null, LEFT\n     *                                  will be used. If TOP or BOTTOM is specified, an IllegalArgumentException\n     *                                  is thrown.\n     * @param horizontalPosition        The horizontal position value.\n     * @param horizontalAsPercentage    Whether to interpret the horizontal position as a decimal or percentage\n     * @param verticalSide              The vertical side, must be either null, TOP, or BOTTOM. If null, TOP\n     *                                  will be used. If LEFT or RIGHT is specified, an IllegalArgumentException\n     *                                  is thrown.\n     * @param verticalPosition          The vertical position value.\n     * @param verticalAsPercentage      Whether to interpret the vertical position as a decimal or percentage\n     */\n    public BackgroundPosition(@NamedArg(\"horizontalSide\") Side horizontalSide, @NamedArg(\"horizontalPosition\") double horizontalPosition, @NamedArg(\"horizontalAsPercentage\") boolean horizontalAsPercentage,\n                              @NamedArg(\"verticalSide\") Side verticalSide, @NamedArg(\"verticalPosition\") double verticalPosition, @NamedArg(\"verticalAsPercentage\") boolean verticalAsPercentage) {\n\n        if (horizontalSide == Side.TOP || horizontalSide == Side.BOTTOM) {\n            throw new IllegalArgumentException(\"The horizontalSide must be LEFT or RIGHT\");\n        }\n\n        if (verticalSide == Side.LEFT || verticalSide == Side.RIGHT) {\n            throw new IllegalArgumentException(\"The verticalSide must be TOP or BOTTOM\");\n        }\n\n        this.horizontalSide = horizontalSide == null ? Side.LEFT : horizontalSide;\n        this.verticalSide = verticalSide == null ? Side.TOP : verticalSide;\n        this.horizontalPosition = horizontalPosition;\n        this.verticalPosition = verticalPosition;\n        this.horizontalAsPercentage = horizontalAsPercentage;\n        this.verticalAsPercentage = verticalAsPercentage;\n\n        // Pre-compute the hash code. NOTE: all variables are prefixed with \"this\" so that we\n        // do not accidentally compute the hash based on the constructor arguments rather than\n        // based on the fields themselves!\n        int result;\n        long temp;\n        result = this.horizontalSide.hashCode();\n        result = 31 * result + this.verticalSide.hashCode();\n        temp = this.horizontalPosition != +0.0d ? Double.doubleToLongBits(this.horizontalPosition) : 0L;\n        result = 31 * result + (int) (temp ^ (temp >>> 32));\n        temp = this.verticalPosition != +0.0d ? Double.doubleToLongBits(this.verticalPosition) : 0L;\n        result = 31 * result + (int) (temp ^ (temp >>> 32));\n        result = 31 * result + (this.horizontalAsPercentage ? 1 : 0);\n        result = 31 * result + (this.verticalAsPercentage ? 1 : 0);\n        hash = result;\n    }"}
{"Number":"899","API Relative Path":"javafx.scene.layout.BackgroundSize.java-BackgroundSize(double-double-boolean-boolean-boolean-boolean)","Corresponding Source":"/**\n     * Create a new BackgroundSize.\n     *\n     * @param width                 The width. Cannot be less than 0, except for the value of AUTO.\n     * @param height                The height. Cannot be less than 0, except for the value of AUTO.\n     * @param widthAsPercentage     Whether the width is to be interpreted as a percentage\n     * @param heightAsPercentage    Whether the height is to be interpreted as a percentage\n     * @param contain               Whether the image should be sized to fit within the Region maximally\n     * @param cover                 Whether the image should be sized to \"cover\" the Region\n     */\n    public BackgroundSize(@NamedArg(\"width\") double width, @NamedArg(\"height\") double height,\n                          @NamedArg(\"widthAsPercentage\") boolean widthAsPercentage, @NamedArg(\"heightAsPercentage\") boolean heightAsPercentage,\n                          @NamedArg(\"contain\") boolean contain, @NamedArg(\"cover\") boolean cover) {\n        // TODO Should deal with NaN and Infinity values as well\n        if (width < 0 && width != AUTO)\n            throw new IllegalArgumentException(\"Width cannot be < 0, except when AUTO\");\n        if (height < 0 && height != AUTO)\n            throw new IllegalArgumentException(\"Height cannot be < 0, except when AUTO\");\n\n        this.width = width;\n        this.height = height;\n        this.widthAsPercentage = widthAsPercentage;\n        this.heightAsPercentage = heightAsPercentage;\n        this.contain = contain;\n        this.cover = cover;\n\n        // Pre-compute the hash code. NOTE: all variables are prefixed with \"this\" so that we\n        // do not accidentally compute the hash based on the constructor arguments rather than\n        // based on the fields themselves!\n        int result;\n        long temp;\n        result = (this.widthAsPercentage ? 1 : 0);\n        result = 31 * result + (this.heightAsPercentage ? 1 : 0);\n        temp = this.width != +0.0d ? Double.doubleToLongBits(this.width) : 0L;\n        result = 31 * result + (int) (temp ^ (temp >>> 32));\n        temp = this.height != +0.0d ? Double.doubleToLongBits(this.height) : 0L;\n        result = 31 * result + (int) (temp ^ (temp >>> 32));\n        result = 31 * result + (this.cover ? 1 : 0);\n        result = 31 * result + (this.contain ? 1 : 0);\n        hash = result;\n    }"}
{"Number":"900","API Relative Path":"javafx.scene.layout.BackgroundSize.java-BackgroundSize(double-double-boolean-boolean-boolean-boolean)","Corresponding Source":"/**\n     * Create a new BackgroundSize.\n     *\n     * @param width                 The width. Cannot be less than 0, except for the value of AUTO.\n     * @param height                The height. Cannot be less than 0, except for the value of AUTO.\n     * @param widthAsPercentage     Whether the width is to be interpreted as a percentage\n     * @param heightAsPercentage    Whether the height is to be interpreted as a percentage\n     * @param contain               Whether the image should be sized to fit within the Region maximally\n     * @param cover                 Whether the image should be sized to \"cover\" the Region\n     */\n    public BackgroundSize(@NamedArg(\"width\") double width, @NamedArg(\"height\") double height,\n                          @NamedArg(\"widthAsPercentage\") boolean widthAsPercentage, @NamedArg(\"heightAsPercentage\") boolean heightAsPercentage,\n                          @NamedArg(\"contain\") boolean contain, @NamedArg(\"cover\") boolean cover) {\n        // TODO Should deal with NaN and Infinity values as well\n        if (width < 0 && width != AUTO)\n            throw new IllegalArgumentException(\"Width cannot be < 0, except when AUTO\");\n        if (height < 0 && height != AUTO)\n            throw new IllegalArgumentException(\"Height cannot be < 0, except when AUTO\");\n\n        this.width = width;\n        this.height = height;\n        this.widthAsPercentage = widthAsPercentage;\n        this.heightAsPercentage = heightAsPercentage;\n        this.contain = contain;\n        this.cover = cover;\n\n        // Pre-compute the hash code. NOTE: all variables are prefixed with \"this\" so that we\n        // do not accidentally compute the hash based on the constructor arguments rather than\n        // based on the fields themselves!\n        int result;\n        long temp;\n        result = (this.widthAsPercentage ? 1 : 0);\n        result = 31 * result + (this.heightAsPercentage ? 1 : 0);\n        temp = this.width != +0.0d ? Double.doubleToLongBits(this.width) : 0L;\n        result = 31 * result + (int) (temp ^ (temp >>> 32));\n        temp = this.height != +0.0d ? Double.doubleToLongBits(this.height) : 0L;\n        result = 31 * result + (int) (temp ^ (temp >>> 32));\n        result = 31 * result + (this.cover ? 1 : 0);\n        result = 31 * result + (this.contain ? 1 : 0);\n        hash = result;\n    }"}
{"Number":"901","API Relative Path":"javafx.scene.layout.BorderWidths.java-BorderWidths(double-double-double-double-boolean-boolean-boolean-boolean)","Corresponding Source":"/**\n     * Creates a new BorderWidths. None of the values for {@code top}, {@code right}, {@code bottom},\n     * or {@code left} can be non-negative.\n     *\n     * @param top    The thickness of the border on the top. Must be non-negative.\n     * @param right    The thickness of the border on the right. Must be non-negative.\n     * @param bottom    The thickness of the border on the bottom. Must be non-negative.\n     * @param left    The thickness of the border on the left. Must be non-negative.\n     * @param topAsPercentage    Whether the top should be treated as a percentage.\n     * @param rightAsPercentage    Whether the right should be treated as a percentage.\n     * @param bottomAsPercentage    Whether the bottom should be treated as a percentage.\n     * @param leftAsPercentage        Whether the left should be treated as a percentage.\n     */\n    public BorderWidths(\n            @NamedArg(\"top\") double top, @NamedArg(\"right\") double right, @NamedArg(\"bottom\") double bottom, @NamedArg(\"left\") double left, @NamedArg(\"topAsPercentage\") boolean topAsPercentage,\n            @NamedArg(\"rightAsPercentage\") boolean rightAsPercentage, @NamedArg(\"bottomAsPercentage\") boolean bottomAsPercentage, @NamedArg(\"leftAsPercentage\") boolean leftAsPercentage) {\n\n        // As per CSS 3 Spec (4.3), cannot be negative\n        if ((top != AUTO && top < 0) ||\n                (right != AUTO && right < 0) ||\n                (bottom != AUTO && bottom < 0) ||\n                (left != AUTO && left < 0)) {\n            throw new IllegalArgumentException(\"None of the widths can be < 0\");\n        }\n\n        this.top = top;\n        this.right = right;\n        this.bottom = bottom;\n        this.left = left;\n        this.topAsPercentage = topAsPercentage;\n        this.rightAsPercentage = rightAsPercentage;\n        this.bottomAsPercentage = bottomAsPercentage;\n        this.leftAsPercentage = leftAsPercentage;\n\n        // Pre-compute the hash code. NOTE: all variables are prefixed with \"this\" so that we\n        // do not accidentally compute the hash based on the constructor arguments rather than\n        // based on the fields themselves!\n        int result;\n        long temp;\n        temp = this.top != +0.0d ? Double.doubleToLongBits(this.top) : 0L;\n        result = (int) (temp ^ (temp >>> 32));\n        temp = this.right != +0.0d ? Double.doubleToLongBits(this.right) : 0L;\n        result = 31 * result + (int) (temp ^ (temp >>> 32));\n        temp = this.bottom != +0.0d ? Double.doubleToLongBits(this.bottom) : 0L;\n        result = 31 * result + (int) (temp ^ (temp >>> 32));\n        temp = this.left != +0.0d ? Double.doubleToLongBits(this.left) : 0L;\n        result = 31 * result + (int) (temp ^ (temp >>> 32));\n        result = 31 * result + (this.topAsPercentage ? 1 : 0);\n        result = 31 * result + (this.rightAsPercentage ? 1 : 0);\n        result = 31 * result + (this.bottomAsPercentage ? 1 : 0);\n        result = 31 * result + (this.leftAsPercentage ? 1 : 0);\n        hash = result;\n    }"}
{"Number":"902","API Relative Path":"javafx.scene.layout.CornerRadii.java-CornerRadii(double)","Corresponding Source":"/**\n     * Create a new CornerRadii with a single uniform radii value for all components of all\n     * corners. This constructor will create the CornerRadii such that none of the values are\n     * percentages.\n     *\n     * @param radius    The radii for each corner. Negative values are not allowed.\n     */\n    public CornerRadii(@NamedArg(\"radius\") double radius) {\n        // As per the CSS Spec 5.1\n        if (radius < 0) {\n            throw new IllegalArgumentException(\"The radii value may not be < 0\");\n        }\n        this.topLeftHorizontalRadius = this.topLeftVerticalRadius =\n                this.topRightVerticalRadius = this.topRightHorizontalRadius =\n                this.bottomRightHorizontalRadius = this.bottomRightVerticalRadius =\n                this.bottomLeftVerticalRadius = this.bottomLeftHorizontalRadius = radius;\n\n        this.topLeftHorizontalRadiusAsPercentage = this.topLeftVerticalRadiusAsPercentage =\n                this.topRightVerticalRadiusAsPercentage = this.topRightHorizontalRadiusAsPercentage =\n                this.bottomRightHorizontalRadiusAsPercentage = this.bottomRightVerticalRadiusAsPercentage =\n                this.bottomLeftVerticalRadiusAsPercentage = this.bottomLeftHorizontalRadiusAsPercentage = false;\n\n        hasPercentBasedRadii = false;\n        uniform = true;\n        this.hash = preComputeHash();\n    }"}
{"Number":"903","API Relative Path":"javafx.scene.layout.CornerRadii.java-CornerRadii(double-boolean)","Corresponding Source":"/**\n     * Create a new CornerRadii with the given radii for each corner. The value is\n     * interpreted either as being a percentage or not based on the {@code asPercent}\n     * argument.\n     *\n     * @param radius       The radii for each corner. Negative values are not allowed.\n     * @param asPercent    Whether the radii should be interpreted as a percentage.\n     */\n    public CornerRadii(@NamedArg(\"radius\") double radius, @NamedArg(\"asPercent\") boolean asPercent) {\n        if (radius < 0) {\n            throw new IllegalArgumentException(\"The radii value may not be < 0\");\n        }\n        this.topLeftHorizontalRadius = this.topLeftVerticalRadius =\n                this.topRightVerticalRadius = this.topRightHorizontalRadius =\n                this.bottomRightHorizontalRadius = this.bottomRightVerticalRadius =\n                this.bottomLeftVerticalRadius = this.bottomLeftHorizontalRadius = radius;\n\n        this.topLeftHorizontalRadiusAsPercentage = this.topLeftVerticalRadiusAsPercentage =\n                this.topRightVerticalRadiusAsPercentage = this.topRightHorizontalRadiusAsPercentage =\n                this.bottomRightHorizontalRadiusAsPercentage = this.bottomRightVerticalRadiusAsPercentage =\n                this.bottomLeftVerticalRadiusAsPercentage = this.bottomLeftHorizontalRadiusAsPercentage = asPercent;\n\n        uniform = true;\n        hasPercentBasedRadii = asPercent;\n        this.hash = preComputeHash();\n    }"}
{"Number":"904","API Relative Path":"javafx.scene.layout.CornerRadii.java-CornerRadii(double-double-double-double-boolean)","Corresponding Source":"/**\n     * Create a new CornerRadii with uniform yet independent radii for each corner. That is, each corner\n     * can be specified independently, but the horizontal and vertical components of each corner is uniform.\n     *\n     * @param topLeft        The radii of the top-left corner. Negative numbers are not allowed.\n     * @param topRight       The radii of the top-right corner. Negative numbers are not allowed.\n     * @param bottomRight    The radii of the bottom-right corner. Negative numbers are not allowed.\n     * @param bottomLeft     The radii of the bottom-left corner. Negative numbers are not allowed.\n     * @param asPercent      Whether all four radii should be considered as values or percentages\n     */\n    public CornerRadii(@NamedArg(\"topLeft\") double topLeft, @NamedArg(\"topRight\") double topRight, @NamedArg(\"bottomRight\") double bottomRight, @NamedArg(\"bottomLeft\") double bottomLeft, @NamedArg(\"asPercent\") boolean asPercent) {\n        if (topLeft < 0 || topRight < 0 || bottomRight < 0 || bottomLeft < 0) {\n            throw new IllegalArgumentException(\"No radii value may be < 0\");\n        }\n\n        this.topLeftHorizontalRadius = this.topLeftVerticalRadius = topLeft;\n        this.topRightVerticalRadius = this.topRightHorizontalRadius = topRight;\n        this.bottomRightHorizontalRadius = this.bottomRightVerticalRadius = bottomRight;\n        this.bottomLeftVerticalRadius = this.bottomLeftHorizontalRadius = bottomLeft;\n        this.topLeftHorizontalRadiusAsPercentage = this.topLeftVerticalRadiusAsPercentage =\n                this.topRightVerticalRadiusAsPercentage = this.topRightHorizontalRadiusAsPercentage =\n                this.bottomRightHorizontalRadiusAsPercentage = this.bottomRightVerticalRadiusAsPercentage =\n                this.bottomLeftVerticalRadiusAsPercentage = this.bottomLeftHorizontalRadiusAsPercentage = asPercent;\n\n        uniform = topLeft == topRight && topLeft == bottomLeft && topLeft == bottomRight;\n        hasPercentBasedRadii = asPercent;\n        this.hash = preComputeHash();\n    }"}
{"Number":"905","API Relative Path":"javafx.scene.layout.CornerRadii.java-CornerRadii(double-double-double-double-double-double-double-double-boolean-boolean-boolean-boolean-boolean-boolean-boolean-boolean)","Corresponding Source":"/**\n     * Creates a new CornerRadii, allowing for specification of each component of each corner\n     * radii and whether each component should be treated as a value or percentage.\n     *\n     * @param topLeftHorizontalRadius\n     * @param topLeftVerticalRadius\n     * @param topRightVerticalRadius\n     * @param topRightHorizontalRadius\n     * @param bottomRightHorizontalRadius\n     * @param bottomRightVerticalRadius\n     * @param bottomLeftVerticalRadius\n     * @param bottomLeftHorizontalRadius\n     * @param topLeftHorizontalRadiusAsPercent\n     * @param topLeftVerticalRadiusAsPercent\n     * @param topRightVerticalRadiusAsPercent\n     * @param topRightHorizontalRadiusAsPercent\n     * @param bottomRightHorizontalRadiusAsPercent\n     * @param bottomRightVerticalRadiusAsPercent\n     * @param bottomLeftVerticalRadiusAsPercent\n     * @param bottomLeftHorizontalRadiusAsPercent\n     */\n    public CornerRadii(\n            @NamedArg(\"topLeftHorizontalRadius\") double topLeftHorizontalRadius, @NamedArg(\"topLeftVerticalRadius\") double topLeftVerticalRadius, @NamedArg(\"topRightVerticalRadius\") double topRightVerticalRadius, @NamedArg(\"topRightHorizontalRadius\") double topRightHorizontalRadius,\n            @NamedArg(\"bottomRightHorizontalRadius\") double bottomRightHorizontalRadius, @NamedArg(\"bottomRightVerticalRadius\") double bottomRightVerticalRadius, @NamedArg(\"bottomLeftVerticalRadius\") double bottomLeftVerticalRadius, @NamedArg(\"bottomLeftHorizontalRadius\") double bottomLeftHorizontalRadius,\n            @NamedArg(\"topLeftHorizontalRadiusAsPercent\") boolean topLeftHorizontalRadiusAsPercent, @NamedArg(\"topLeftVerticalRadiusAsPercent\") boolean topLeftVerticalRadiusAsPercent, @NamedArg(\"topRightVerticalRadiusAsPercent\") boolean topRightVerticalRadiusAsPercent,\n            @NamedArg(\"topRightHorizontalRadiusAsPercent\") boolean topRightHorizontalRadiusAsPercent, @NamedArg(\"bottomRightHorizontalRadiusAsPercent\") boolean bottomRightHorizontalRadiusAsPercent, @NamedArg(\"bottomRightVerticalRadiusAsPercent\") boolean bottomRightVerticalRadiusAsPercent,\n            @NamedArg(\"bottomLeftVerticalRadiusAsPercent\") boolean bottomLeftVerticalRadiusAsPercent, @NamedArg(\"bottomLeftHorizontalRadiusAsPercent\") boolean bottomLeftHorizontalRadiusAsPercent)\n    {\n        if (topLeftHorizontalRadius < 0 || topLeftVerticalRadius < 0 ||\n                topRightVerticalRadius < 0 || topRightHorizontalRadius < 0 ||\n                bottomRightHorizontalRadius < 0 || bottomRightVerticalRadius < 0 ||\n                bottomLeftVerticalRadius < 0 || bottomLeftHorizontalRadius < 0) {\n            throw new IllegalArgumentException(\"No radii value may be < 0\");\n        }\n        this.topLeftHorizontalRadius = topLeftHorizontalRadius;\n        this.topLeftVerticalRadius = topLeftVerticalRadius;\n        this.topRightVerticalRadius = topRightVerticalRadius;\n        this.topRightHorizontalRadius = topRightHorizontalRadius;\n        this.bottomRightHorizontalRadius = bottomRightHorizontalRadius;\n        this.bottomRightVerticalRadius = bottomRightVerticalRadius;\n        this.bottomLeftVerticalRadius = bottomLeftVerticalRadius;\n        this.bottomLeftHorizontalRadius = bottomLeftHorizontalRadius;\n        this.topLeftHorizontalRadiusAsPercentage = topLeftHorizontalRadiusAsPercent;\n        this.topLeftVerticalRadiusAsPercentage = topLeftVerticalRadiusAsPercent;\n        this.topRightVerticalRadiusAsPercentage = topRightVerticalRadiusAsPercent;\n        this.topRightHorizontalRadiusAsPercentage = topRightHorizontalRadiusAsPercent;\n        this.bottomRightHorizontalRadiusAsPercentage = bottomRightHorizontalRadiusAsPercent;\n        this.bottomRightVerticalRadiusAsPercentage = bottomRightVerticalRadiusAsPercent;\n        this.bottomLeftVerticalRadiusAsPercentage = bottomLeftVerticalRadiusAsPercent;\n        this.bottomLeftHorizontalRadiusAsPercentage = bottomLeftHorizontalRadiusAsPercent;\n        this.hash = preComputeHash();\n        hasPercentBasedRadii = topLeftHorizontalRadiusAsPercent || topLeftVerticalRadiusAsPercent ||\n                topRightVerticalRadiusAsPercent || topRightHorizontalRadiusAsPercent ||\n                bottomRightHorizontalRadiusAsPercent || bottomRightVerticalRadiusAsPercent ||\n                bottomLeftVerticalRadiusAsPercent || bottomLeftHorizontalRadiusAsPercent;\n        uniform = topLeftHorizontalRadius == topRightHorizontalRadius &&\n                topLeftVerticalRadius == topRightVerticalRadius &&\n                topLeftHorizontalRadius == bottomRightHorizontalRadius &&\n                topLeftVerticalRadius == bottomRightVerticalRadius &&\n                topLeftHorizontalRadius == bottomLeftHorizontalRadius &&\n                topLeftVerticalRadius == bottomLeftVerticalRadius &&\n                topLeftHorizontalRadiusAsPercent == topRightHorizontalRadiusAsPercent &&\n                topLeftVerticalRadiusAsPercent == topRightVerticalRadiusAsPercent &&\n                topLeftHorizontalRadiusAsPercent == bottomRightHorizontalRadiusAsPercent &&\n                topLeftVerticalRadiusAsPercent == bottomRightVerticalRadiusAsPercent &&\n                topLeftHorizontalRadiusAsPercent == bottomLeftHorizontalRadiusAsPercent &&\n                topLeftVerticalRadiusAsPercent == bottomLeftVerticalRadiusAsPercent;\n    }"}
{"Number":"906","API Relative Path":"javafx.scene.layout.GridPane.java-add(Node-int-int)","Corresponding Source":"/**\n     * Adds a child to the gridpane at the specified column,row position.\n     * This convenience method will set the gridpane column and row constraints\n     * on the child.\n     * @param child the node being added to the gridpane\n     * @param columnIndex the column index position for the child within the gridpane, counting from 0\n     * @param rowIndex the row index position for the child within the gridpane, counting from 0\n     */\n    public void add(Node child, int columnIndex, int rowIndex) {\n        setConstraints(child, columnIndex, rowIndex);\n        getChildren().add(child);\n    }"}
{"Number":"907","API Relative Path":"javafx.scene.layout.GridPane.java-add(Node-int-int)","Corresponding Source":"/**\n     * Adds a child to the gridpane at the specified column,row position.\n     * This convenience method will set the gridpane column and row constraints\n     * on the child.\n     * @param child the node being added to the gridpane\n     * @param columnIndex the column index position for the child within the gridpane, counting from 0\n     * @param rowIndex the row index position for the child within the gridpane, counting from 0\n     */\n    public void add(Node child, int columnIndex, int rowIndex) {\n        setConstraints(child, columnIndex, rowIndex);\n        getChildren().add(child);\n    }"}
{"Number":"908","API Relative Path":"javafx.scene.layout.GridPane.java-add(Node-int-int-int-int)","Corresponding Source":"/**\n     * Adds a child to the gridpane at the specified column,row position and spans.\n     * This convenience method will set the gridpane column, row, and span constraints\n     * on the child.\n     * @param child the node being added to the gridpane\n     * @param columnIndex the column index position for the child within the gridpane, counting from 0\n     * @param rowIndex the row index position for the child within the gridpane, counting from 0\n     * @param colspan the number of columns the child's layout area should span\n     * @param rowspan the number of rows the child's layout area should span\n     */\n    public void add(Node child, int columnIndex, int rowIndex, int colspan, int rowspan) {\n        setConstraints(child, columnIndex, rowIndex, colspan, rowspan);\n        getChildren().add(child);\n    }"}
{"Number":"909","API Relative Path":"javafx.scene.layout.GridPane.java-add(Node-int-int-int-int)","Corresponding Source":"/**\n     * Adds a child to the gridpane at the specified column,row position and spans.\n     * This convenience method will set the gridpane column, row, and span constraints\n     * on the child.\n     * @param child the node being added to the gridpane\n     * @param columnIndex the column index position for the child within the gridpane, counting from 0\n     * @param rowIndex the row index position for the child within the gridpane, counting from 0\n     * @param colspan the number of columns the child's layout area should span\n     * @param rowspan the number of rows the child's layout area should span\n     */\n    public void add(Node child, int columnIndex, int rowIndex, int colspan, int rowspan) {\n        setConstraints(child, columnIndex, rowIndex, colspan, rowspan);\n        getChildren().add(child);\n    }"}
{"Number":"910","API Relative Path":"javafx.scene.layout.GridPane.java-add(Node-int-int-int-int)","Corresponding Source":"/**\n     * Adds a child to the gridpane at the specified column,row position and spans.\n     * This convenience method will set the gridpane column, row, and span constraints\n     * on the child.\n     * @param child the node being added to the gridpane\n     * @param columnIndex the column index position for the child within the gridpane, counting from 0\n     * @param rowIndex the row index position for the child within the gridpane, counting from 0\n     * @param colspan the number of columns the child's layout area should span\n     * @param rowspan the number of rows the child's layout area should span\n     */\n    public void add(Node child, int columnIndex, int rowIndex, int colspan, int rowspan) {\n        setConstraints(child, columnIndex, rowIndex, colspan, rowspan);\n        getChildren().add(child);\n    }"}
{"Number":"911","API Relative Path":"javafx.scene.layout.GridPane.java-add(Node-int-int-int-int)","Corresponding Source":"/**\n     * Adds a child to the gridpane at the specified column,row position and spans.\n     * This convenience method will set the gridpane column, row, and span constraints\n     * on the child.\n     * @param child the node being added to the gridpane\n     * @param columnIndex the column index position for the child within the gridpane, counting from 0\n     * @param rowIndex the row index position for the child within the gridpane, counting from 0\n     * @param colspan the number of columns the child's layout area should span\n     * @param rowspan the number of rows the child's layout area should span\n     */\n    public void add(Node child, int columnIndex, int rowIndex, int colspan, int rowspan) {\n        setConstraints(child, columnIndex, rowIndex, colspan, rowspan);\n        getChildren().add(child);\n    }"}
{"Number":"912","API Relative Path":"javafx.scene.layout.GridPane.java-setColumnIndex(Node-Integer)","Corresponding Source":"/**\n     * Sets the column index for the child when contained by a gridpane\n     * so that it will be positioned starting in that column of the gridpane.\n     * If a gridpane child has no column index set, it will be positioned in\n     * the first column.\n     * Setting the value to null will remove the constraint.\n     * @param child the child node of a gridpane\n     * @param value the column index of the child\n     */\n    public static void setColumnIndex(Node child, Integer value) {\n        if (value != null && value < 0) {\n            throw new IllegalArgumentException(\"columnIndex must be greater or equal to 0, but was \"+value);\n        }\n        setConstraint(child, COLUMN_INDEX_CONSTRAINT, value);\n    }"}
{"Number":"913","API Relative Path":"javafx.scene.layout.GridPane.java-setColumnSpan(Node-Integer)","Corresponding Source":"/**\n     * Sets the column span for the child when contained by a gridpane\n     * so that it will span that number of columns horizontally.   This may be\n     * set to REMAINING, which will cause the span to extend across all the remaining\n     * columns.\n     * <p>\n     * If a gridpane child has no column span set, it will default to spanning one column.\n     * Setting the value to null will remove the constraint.\n     * @param child the child node of a gridpane\n     * @param value the column span of the child\n     */\n    public static void setColumnSpan(Node child, Integer value) {\n        if (value != null && value < 1) {\n            throw new IllegalArgumentException(\"columnSpan must be greater or equal to 1, but was \"+value);\n        }\n        setConstraint(child, COLUMN_SPAN_CONSTRAINT, value);\n    }"}
{"Number":"914","API Relative Path":"javafx.scene.layout.GridPane.java-setConstraints(Node-int-int)","Corresponding Source":"/**\n     * Sets the column,row indeces for the child when contained in a gridpane.\n     * @param child the child node of a gridpane\n     * @param columnIndex the column index position for the child\n     * @param rowIndex the row index position for the child\n     */\n    public static void setConstraints(Node child, int columnIndex, int rowIndex) {\n        setRowIndex(child, rowIndex);\n        setColumnIndex(child, columnIndex);\n    }"}
{"Number":"915","API Relative Path":"javafx.scene.layout.GridPane.java-setConstraints(Node-int-int)","Corresponding Source":"/**\n     * Sets the column,row indeces for the child when contained in a gridpane.\n     * @param child the child node of a gridpane\n     * @param columnIndex the column index position for the child\n     * @param rowIndex the row index position for the child\n     */\n    public static void setConstraints(Node child, int columnIndex, int rowIndex) {\n        setRowIndex(child, rowIndex);\n        setColumnIndex(child, columnIndex);\n    }"}
{"Number":"916","API Relative Path":"javafx.scene.layout.GridPane.java-setConstraints(Node-int-int-int-int)","Corresponding Source":"/**\n     * Sets the column, row, column-span, and row-span value for the child when\n     * contained in a gridpane.\n     * @param child the child node of a gridpane\n     * @param columnIndex the column index position for the child\n     * @param rowIndex the row index position for the child\n     * @param columnspan the number of columns the child should span\n     * @param rowspan the number of rows the child should span\n     */\n    public static void setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan) {\n        setRowIndex(child, rowIndex);\n        setColumnIndex(child, columnIndex);\n        setRowSpan(child, rowspan);\n        setColumnSpan(child, columnspan);\n    }"}
{"Number":"917","API Relative Path":"javafx.scene.layout.GridPane.java-setConstraints(Node-int-int-int-int)","Corresponding Source":"/**\n     * Sets the column, row, column-span, and row-span value for the child when\n     * contained in a gridpane.\n     * @param child the child node of a gridpane\n     * @param columnIndex the column index position for the child\n     * @param rowIndex the row index position for the child\n     * @param columnspan the number of columns the child should span\n     * @param rowspan the number of rows the child should span\n     */\n    public static void setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan) {\n        setRowIndex(child, rowIndex);\n        setColumnIndex(child, columnIndex);\n        setRowSpan(child, rowspan);\n        setColumnSpan(child, columnspan);\n    }"}
{"Number":"918","API Relative Path":"javafx.scene.layout.GridPane.java-setConstraints(Node-int-int-int-int)","Corresponding Source":"/**\n     * Sets the column, row, column-span, and row-span value for the child when\n     * contained in a gridpane.\n     * @param child the child node of a gridpane\n     * @param columnIndex the column index position for the child\n     * @param rowIndex the row index position for the child\n     * @param columnspan the number of columns the child should span\n     * @param rowspan the number of rows the child should span\n     */\n    public static void setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan) {\n        setRowIndex(child, rowIndex);\n        setColumnIndex(child, columnIndex);\n        setRowSpan(child, rowspan);\n        setColumnSpan(child, columnspan);\n    }"}
{"Number":"919","API Relative Path":"javafx.scene.layout.GridPane.java-setConstraints(Node-int-int-int-int)","Corresponding Source":"/**\n     * Sets the column, row, column-span, and row-span value for the child when\n     * contained in a gridpane.\n     * @param child the child node of a gridpane\n     * @param columnIndex the column index position for the child\n     * @param rowIndex the row index position for the child\n     * @param columnspan the number of columns the child should span\n     * @param rowspan the number of rows the child should span\n     */\n    public static void setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan) {\n        setRowIndex(child, rowIndex);\n        setColumnIndex(child, columnIndex);\n        setRowSpan(child, rowspan);\n        setColumnSpan(child, columnspan);\n    }"}
{"Number":"920","API Relative Path":"javafx.scene.layout.GridPane.java-setConstraints(Node-int-int-int-int-HPos-VPos)","Corresponding Source":"/**\n     * Sets the grid position, spans, and alignment for the child when contained in a gridpane.\n     * @param child the child node of a gridpane\n     * @param columnIndex the column index position for the child\n     * @param rowIndex the row index position for the child\n     * @param columnspan the number of columns the child should span\n     * @param rowspan the number of rows the child should span\n     * @param halignment the horizontal alignment of the child\n     * @param valignment the vertical alignment of the child\n     */\n    public static void setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan,\n            HPos halignment, VPos valignment) {\n        setRowIndex(child, rowIndex);\n        setColumnIndex(child, columnIndex);\n        setRowSpan(child, rowspan);\n        setColumnSpan(child, columnspan);\n        setHalignment(child, halignment);\n        setValignment(child, valignment);\n    }"}
{"Number":"921","API Relative Path":"javafx.scene.layout.GridPane.java-setConstraints(Node-int-int-int-int-HPos-VPos)","Corresponding Source":"/**\n     * Sets the grid position, spans, and alignment for the child when contained in a gridpane.\n     * @param child the child node of a gridpane\n     * @param columnIndex the column index position for the child\n     * @param rowIndex the row index position for the child\n     * @param columnspan the number of columns the child should span\n     * @param rowspan the number of rows the child should span\n     * @param halignment the horizontal alignment of the child\n     * @param valignment the vertical alignment of the child\n     */\n    public static void setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan,\n            HPos halignment, VPos valignment) {\n        setRowIndex(child, rowIndex);\n        setColumnIndex(child, columnIndex);\n        setRowSpan(child, rowspan);\n        setColumnSpan(child, columnspan);\n        setHalignment(child, halignment);\n        setValignment(child, valignment);\n    }"}
{"Number":"922","API Relative Path":"javafx.scene.layout.GridPane.java-setConstraints(Node-int-int-int-int-HPos-VPos)","Corresponding Source":"/**\n     * Sets the grid position, spans, and alignment for the child when contained in a gridpane.\n     * @param child the child node of a gridpane\n     * @param columnIndex the column index position for the child\n     * @param rowIndex the row index position for the child\n     * @param columnspan the number of columns the child should span\n     * @param rowspan the number of rows the child should span\n     * @param halignment the horizontal alignment of the child\n     * @param valignment the vertical alignment of the child\n     */\n    public static void setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan,\n            HPos halignment, VPos valignment) {\n        setRowIndex(child, rowIndex);\n        setColumnIndex(child, columnIndex);\n        setRowSpan(child, rowspan);\n        setColumnSpan(child, columnspan);\n        setHalignment(child, halignment);\n        setValignment(child, valignment);\n    }"}
{"Number":"923","API Relative Path":"javafx.scene.layout.GridPane.java-setConstraints(Node-int-int-int-int-HPos-VPos)","Corresponding Source":"/**\n     * Sets the grid position, spans, and alignment for the child when contained in a gridpane.\n     * @param child the child node of a gridpane\n     * @param columnIndex the column index position for the child\n     * @param rowIndex the row index position for the child\n     * @param columnspan the number of columns the child should span\n     * @param rowspan the number of rows the child should span\n     * @param halignment the horizontal alignment of the child\n     * @param valignment the vertical alignment of the child\n     */\n    public static void setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan,\n            HPos halignment, VPos valignment) {\n        setRowIndex(child, rowIndex);\n        setColumnIndex(child, columnIndex);\n        setRowSpan(child, rowspan);\n        setColumnSpan(child, columnspan);\n        setHalignment(child, halignment);\n        setValignment(child, valignment);\n    }"}
{"Number":"924","API Relative Path":"javafx.scene.layout.GridPane.java-setConstraints(Node-int-int-int-int-HPos-VPos-Priority-Priority)","Corresponding Source":"/**\n     * Sets the grid position, spans, and alignment for the child when contained in a gridpane.\n     * @param child the child node of a gridpane\n     * @param columnIndex the column index position for the child\n     * @param rowIndex the row index position for the child\n     * @param columnspan the number of columns the child should span\n     * @param rowspan the number of rows the child should span\n     * @param halignment the horizontal alignment of the child\n     * @param valignment the vertical alignment of the child\n     * @param hgrow the horizontal grow priority of the child\n     * @param vgrow the vertical grow priority of the child\n     */\n    public static void setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan,\n            HPos halignment, VPos valignment, Priority hgrow, Priority vgrow) {\n        setRowIndex(child, rowIndex);\n        setColumnIndex(child, columnIndex);\n        setRowSpan(child, rowspan);\n        setColumnSpan(child, columnspan);\n        setHalignment(child, halignment);\n        setValignment(child, valignment);\n        setHgrow(child, hgrow);\n        setVgrow(child, vgrow);\n    }"}
{"Number":"925","API Relative Path":"javafx.scene.layout.GridPane.java-setConstraints(Node-int-int-int-int-HPos-VPos-Priority-Priority)","Corresponding Source":"/**\n     * Sets the grid position, spans, and alignment for the child when contained in a gridpane.\n     * @param child the child node of a gridpane\n     * @param columnIndex the column index position for the child\n     * @param rowIndex the row index position for the child\n     * @param columnspan the number of columns the child should span\n     * @param rowspan the number of rows the child should span\n     * @param halignment the horizontal alignment of the child\n     * @param valignment the vertical alignment of the child\n     * @param hgrow the horizontal grow priority of the child\n     * @param vgrow the vertical grow priority of the child\n     */\n    public static void setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan,\n            HPos halignment, VPos valignment, Priority hgrow, Priority vgrow) {\n        setRowIndex(child, rowIndex);\n        setColumnIndex(child, columnIndex);\n        setRowSpan(child, rowspan);\n        setColumnSpan(child, columnspan);\n        setHalignment(child, halignment);\n        setValignment(child, valignment);\n        setHgrow(child, hgrow);\n        setVgrow(child, vgrow);\n    }"}
{"Number":"926","API Relative Path":"javafx.scene.layout.GridPane.java-setConstraints(Node-int-int-int-int-HPos-VPos-Priority-Priority)","Corresponding Source":"/**\n     * Sets the grid position, spans, and alignment for the child when contained in a gridpane.\n     * @param child the child node of a gridpane\n     * @param columnIndex the column index position for the child\n     * @param rowIndex the row index position for the child\n     * @param columnspan the number of columns the child should span\n     * @param rowspan the number of rows the child should span\n     * @param halignment the horizontal alignment of the child\n     * @param valignment the vertical alignment of the child\n     * @param hgrow the horizontal grow priority of the child\n     * @param vgrow the vertical grow priority of the child\n     */\n    public static void setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan,\n            HPos halignment, VPos valignment, Priority hgrow, Priority vgrow) {\n        setRowIndex(child, rowIndex);\n        setColumnIndex(child, columnIndex);\n        setRowSpan(child, rowspan);\n        setColumnSpan(child, columnspan);\n        setHalignment(child, halignment);\n        setValignment(child, valignment);\n        setHgrow(child, hgrow);\n        setVgrow(child, vgrow);\n    }"}
{"Number":"927","API Relative Path":"javafx.scene.layout.GridPane.java-setConstraints(Node-int-int-int-int-HPos-VPos-Priority-Priority)","Corresponding Source":"/**\n     * Sets the grid position, spans, and alignment for the child when contained in a gridpane.\n     * @param child the child node of a gridpane\n     * @param columnIndex the column index position for the child\n     * @param rowIndex the row index position for the child\n     * @param columnspan the number of columns the child should span\n     * @param rowspan the number of rows the child should span\n     * @param halignment the horizontal alignment of the child\n     * @param valignment the vertical alignment of the child\n     * @param hgrow the horizontal grow priority of the child\n     * @param vgrow the vertical grow priority of the child\n     */\n    public static void setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan,\n            HPos halignment, VPos valignment, Priority hgrow, Priority vgrow) {\n        setRowIndex(child, rowIndex);\n        setColumnIndex(child, columnIndex);\n        setRowSpan(child, rowspan);\n        setColumnSpan(child, columnspan);\n        setHalignment(child, halignment);\n        setValignment(child, valignment);\n        setHgrow(child, hgrow);\n        setVgrow(child, vgrow);\n    }"}
{"Number":"928","API Relative Path":"javafx.scene.layout.GridPane.java-setConstraints(Node-int-int-int-int-HPos-VPos-Priority-Priority-Insets)","Corresponding Source":"/**\n     * Sets the grid position, spans, alignment, grow priorities, and margin for\n     * the child when contained in a gridpane.\n     * @param child the child node of a gridpane\n     * @param columnIndex the column index position for the child\n     * @param rowIndex the row index position for the child\n     * @param columnspan the number of columns the child should span\n     * @param rowspan the number of rows the child should span\n     * @param halignment the horizontal alignment of the child\n     * @param valignment the vertical alignment of the child\n     * @param hgrow the horizontal grow priority of the child\n     * @param vgrow the vertical grow priority of the child\n     * @param margin the margin of space around the child\n     */\n    public static void setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan,\n            HPos halignment, VPos valignment, Priority hgrow, Priority vgrow, Insets margin) {\n        setRowIndex(child, rowIndex);\n        setColumnIndex(child, columnIndex);\n        setRowSpan(child, rowspan);\n        setColumnSpan(child, columnspan);\n        setHalignment(child, halignment);\n        setValignment(child, valignment);\n        setHgrow(child, hgrow);\n        setVgrow(child, vgrow);\n        setMargin(child, margin);\n    }"}
{"Number":"929","API Relative Path":"javafx.scene.layout.GridPane.java-setConstraints(Node-int-int-int-int-HPos-VPos-Priority-Priority-Insets)","Corresponding Source":"/**\n     * Sets the grid position, spans, alignment, grow priorities, and margin for\n     * the child when contained in a gridpane.\n     * @param child the child node of a gridpane\n     * @param columnIndex the column index position for the child\n     * @param rowIndex the row index position for the child\n     * @param columnspan the number of columns the child should span\n     * @param rowspan the number of rows the child should span\n     * @param halignment the horizontal alignment of the child\n     * @param valignment the vertical alignment of the child\n     * @param hgrow the horizontal grow priority of the child\n     * @param vgrow the vertical grow priority of the child\n     * @param margin the margin of space around the child\n     */\n    public static void setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan,\n            HPos halignment, VPos valignment, Priority hgrow, Priority vgrow, Insets margin) {\n        setRowIndex(child, rowIndex);\n        setColumnIndex(child, columnIndex);\n        setRowSpan(child, rowspan);\n        setColumnSpan(child, columnspan);\n        setHalignment(child, halignment);\n        setValignment(child, valignment);\n        setHgrow(child, hgrow);\n        setVgrow(child, vgrow);\n        setMargin(child, margin);\n    }"}
{"Number":"930","API Relative Path":"javafx.scene.layout.GridPane.java-setConstraints(Node-int-int-int-int-HPos-VPos-Priority-Priority-Insets)","Corresponding Source":"/**\n     * Sets the grid position, spans, alignment, grow priorities, and margin for\n     * the child when contained in a gridpane.\n     * @param child the child node of a gridpane\n     * @param columnIndex the column index position for the child\n     * @param rowIndex the row index position for the child\n     * @param columnspan the number of columns the child should span\n     * @param rowspan the number of rows the child should span\n     * @param halignment the horizontal alignment of the child\n     * @param valignment the vertical alignment of the child\n     * @param hgrow the horizontal grow priority of the child\n     * @param vgrow the vertical grow priority of the child\n     * @param margin the margin of space around the child\n     */\n    public static void setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan,\n            HPos halignment, VPos valignment, Priority hgrow, Priority vgrow, Insets margin) {\n        setRowIndex(child, rowIndex);\n        setColumnIndex(child, columnIndex);\n        setRowSpan(child, rowspan);\n        setColumnSpan(child, columnspan);\n        setHalignment(child, halignment);\n        setValignment(child, valignment);\n        setHgrow(child, hgrow);\n        setVgrow(child, vgrow);\n        setMargin(child, margin);\n    }"}
{"Number":"931","API Relative Path":"javafx.scene.layout.GridPane.java-setConstraints(Node-int-int-int-int-HPos-VPos-Priority-Priority-Insets)","Corresponding Source":"/**\n     * Sets the grid position, spans, alignment, grow priorities, and margin for\n     * the child when contained in a gridpane.\n     * @param child the child node of a gridpane\n     * @param columnIndex the column index position for the child\n     * @param rowIndex the row index position for the child\n     * @param columnspan the number of columns the child should span\n     * @param rowspan the number of rows the child should span\n     * @param halignment the horizontal alignment of the child\n     * @param valignment the vertical alignment of the child\n     * @param hgrow the horizontal grow priority of the child\n     * @param vgrow the vertical grow priority of the child\n     * @param margin the margin of space around the child\n     */\n    public static void setConstraints(Node child, int columnIndex, int rowIndex, int columnspan, int rowspan,\n            HPos halignment, VPos valignment, Priority hgrow, Priority vgrow, Insets margin) {\n        setRowIndex(child, rowIndex);\n        setColumnIndex(child, columnIndex);\n        setRowSpan(child, rowspan);\n        setColumnSpan(child, columnspan);\n        setHalignment(child, halignment);\n        setValignment(child, valignment);\n        setHgrow(child, hgrow);\n        setVgrow(child, vgrow);\n        setMargin(child, margin);\n    }"}
{"Number":"932","API Relative Path":"javafx.scene.layout.GridPane.java-setRowIndex(Node-Integer)","Corresponding Source":"/**\n     * Sets the row index for the child when contained by a gridpane\n     * so that it will be positioned starting in that row of the gridpane.\n     * If a gridpane child has no row index set, it will be positioned in the\n     * first row.\n     * Setting the value to null will remove the constraint.\n     * @param child the child node of a gridpane\n     * @param value the row index of the child\n     */\n    public static void setRowIndex(Node child, Integer value) {\n        if (value != null && value < 0) {\n            throw new IllegalArgumentException(\"rowIndex must be greater or equal to 0, but was \"+value);\n        }\n        setConstraint(child, ROW_INDEX_CONSTRAINT, value);\n    }"}
{"Number":"933","API Relative Path":"javafx.scene.layout.GridPane.java-setRowSpan(Node-Integer)","Corresponding Source":"/**\n     * Sets the row span for the child when contained by a gridpane\n     * so that it will span that number of rows vertically.  This may be\n     * set to REMAINING, which will cause the span to extend across all the remaining\n     * rows.\n     * <p>\n     * If a gridpane child has no row span set, it will default to spanning one row.\n     * Setting the value to null will remove the constraint.\n     * @param child the child node of a gridpane\n     * @param value the row span of the child\n     */\n    public static void setRowSpan(Node child, Integer value) {\n        if (value != null && value < 1) {\n            throw new IllegalArgumentException(\"rowSpan must be greater or equal to 1, but was \"+value);\n        }\n        setConstraint(child, ROW_SPAN_CONSTRAINT, value);\n    }"}
{"Number":"934","API Relative Path":"javafx.scene.media.MediaErrorEvent.java-MediaErrorEvent(Object-EventTarget-MediaException)","Corresponding Source":"/**\n     * Construct a new <code>MediaErrorEvent<\/code> with the specified event\n     * source, target and error.\n     *\n     * @param source the event source which sent the event\n     * @param target the event target to associate with the event\n     * @param error the error which provoked the event\n     * @throws <code>IllegalArgumentException<\/code> if <code>error<\/code> is\n     * <code>null<\/code>.\n     */\n    MediaErrorEvent(Object source, EventTarget target, MediaException error) {\n        super(source, target, MEDIA_ERROR);\n\n        if(error == null) {\n            throw new IllegalArgumentException(\"error == null!\");\n        }\n\n        this.error = error;\n    }"}
{"Number":"935","API Relative Path":"javafx.scene.media.MediaPlayer.java-seek(Duration)","Corresponding Source":"/**\n     * Seeks the player to a new playback time. Invoking this method will have\n     * no effect while the player status is {@link Status#STOPPED} or media duration is {@link Duration#INDEFINITE}.\n     *\n     * <p>The behavior of <code>seek()<\/code> is constrained as follows where\n     * <i>start time<\/i> and <i>stop time<\/i> indicate the effective lower and\n     * upper bounds, respectively, of media playback:\n     * <table border=\"1\">\n     * <tr><th>seekTime<\/th><th>seek position<\/th><\/tr>\n     * <tr><td><code>null<\/code><\/td><td>no change<\/td><\/tr>\n     * <tr><td>{@link Duration#UNKNOWN}<\/td><td>no change<\/td><\/tr>\n     * <tr><td>{@link Duration#INDEFINITE}<\/td><td>stop time<\/td><\/tr>\n     * <tr><td>seekTime&nbsp;&lt;&nbsp;start time<\/td><td>start time<\/td><\/tr>\n     * <tr><td>seekTime&nbsp;&gt;&nbsp;stop time<\/td><td>stop time<\/td><\/tr>\n     * <tr><td>start time&nbsp;&le;&nbsp;seekTime&nbsp;&le;&nbsp;stop time<\/td><td>seekTime<\/td><\/tr>\n     * <\/table>\n     * <\/p>\n     *\n     * @param seekTime the requested playback time\n     */\n    public void seek(Duration seekTime) {\n        synchronized (disposeLock) {\n            if (getStatus() == Status.DISPOSED) {\n                return;\n            }\n\n            // Seek only if the player is ready and the seekTime is valid.\n            if (playerReady && seekTime != null && !seekTime.isUnknown()) {\n                if (jfxPlayer.getDuration() == Double.POSITIVE_INFINITY) {\n                    return;\n                }\n\n                // Determine the seek position in seconds.\n                double seekSeconds;\n\n                // Duration.INDEFINITE means seek to end.\n                if (seekTime.isIndefinite()) {\n                    // Determine the effective duration.\n                    Duration duration = media.getDuration();\n                    if (duration == null\n                            || duration.isUnknown()\n                            || duration.isIndefinite()) {\n                        duration = Duration.millis(Double.MAX_VALUE);\n                    }\n\n                    // Convert the duration to seconds.\n                    seekSeconds = duration.toMillis() / 1000.0;\n                } else {\n                    // Convert the parameter to seconds.\n                    seekSeconds = seekTime.toMillis() / 1000.0;\n\n                    // Clamp the seconds if needed.\n                    double[] startStop = calculateStartStopTimes(getStartTime(), getStopTime());\n                    if (seekSeconds < startStop[0]) {\n                        seekSeconds = startStop[0];\n                    } else if (seekSeconds > startStop[1]) {\n                        seekSeconds = startStop[1];\n                    }\n                }\n\n                if (!isUpdateTimeEnabled) {\n                    // Change time update flag to true amd current rate to rate\n                    // if status is PLAYING and current time is in range.\n                    Status playerStatus = getStatus();\n                    if ((playerStatus == MediaPlayer.Status.PLAYING\n                            || playerStatus == MediaPlayer.Status.PAUSED)\n                            && getStartTime().toSeconds() <= seekSeconds\n                            && seekSeconds <= getStopTime().toSeconds()) {\n                        isEOS = false;\n                        isUpdateTimeEnabled = true;\n                        setCurrentRate(getRate());\n                    }\n                }\n\n                // Perform the seek.\n                jfxPlayer.seek(seekSeconds);\n            }\n        }\n    }"}
{"Number":"936","API Relative Path":"javafx.scene.Node.java-lookup(String)","Corresponding Source":"/**\n     * Finds this {@code Node}, or the first sub-node, based on the given CSS selector.\n     * If this node is a {@code Parent}, then this function will traverse down\n     * into the branch until it finds a match. If more than one sub-node matches the\n     * specified selector, this function returns the first of them.\n     * <p>\n     *     For example, if a Node is given the id of \"myId\", then the lookup method can\n     *     be used to find this node as follows: <code>scene.lookup(\"#myId\");<\/code>.\n     * <\/p>\n     *\n     * @param selector The css selector of the node to find\n     * @return The first node, starting from this {@code Node}, which matches\n     *         the CSS {@code selector}, null if none is found.\n     */\n    public Node lookup(String selector) {\n        if (selector == null) return null;\n        Selector s = Selector.createSelector(selector);\n        return s != null && s.applies(this) ? this : null;\n    }"}
{"Number":"937","API Relative Path":"javafx.scene.Node.java-lookup(String)","Corresponding Source":"/**\n     * Finds this {@code Node}, or the first sub-node, based on the given CSS selector.\n     * If this node is a {@code Parent}, then this function will traverse down\n     * into the branch until it finds a match. If more than one sub-node matches the\n     * specified selector, this function returns the first of them.\n     * <p>\n     *     For example, if a Node is given the id of \"myId\", then the lookup method can\n     *     be used to find this node as follows: <code>scene.lookup(\"#myId\");<\/code>.\n     * <\/p>\n     *\n     * @param selector The css selector of the node to find\n     * @return The first node, starting from this {@code Node}, which matches\n     *         the CSS {@code selector}, null if none is found.\n     */\n    public Node lookup(String selector) {\n        if (selector == null) return null;\n        Selector s = Selector.createSelector(selector);\n        return s != null && s.applies(this) ? this : null;\n    }"}
{"Number":"938","API Relative Path":"javafx.scene.Node.java-lookupAll(String)","Corresponding Source":"/**\n     * Finds all {@code Node}s, including this one and any children, which match\n     * the given CSS selector. If no matches are found, an empty unmodifiable set is\n     * returned. The set is explicitly unordered.\n     *\n     * @param selector The css selector of the nodes to find\n     * @return All nodes, starting from and including this {@code Node}, which match\n     *         the CSS {@code selector}. The returned set is always unordered and\n     *         unmodifiable, and never null.\n     */\n    public Set<Node> lookupAll(String selector) {\n        final Selector s = Selector.createSelector(selector);\n        final Set<Node> empty = Collections.emptySet();\n        if (s == null) return empty;\n        List<Node> results = lookupAll(s, null);\n        return results == null ? empty : new UnmodifiableListSet<Node>(results);\n    }"}
{"Number":"939","API Relative Path":"javafx.scene.paint.Color.java-color(double-double-double)","Corresponding Source":"/**\n     * Creates an opaque sRGB color with the specified red, green and blue values\n     * in the range {@code 0.0-1.0}.\n     *\n     * @param red the red component, in the range {@code 0.0-1.0}\n     * @param green the green component, in the range {@code 0.0-1.0}\n     * @param blue the blue component, in the range {@code 0.0-1.0}\n     * @return the {@code Color}\n     * @throws IllegalArgumentException if any value is out of range\n     */\n    public static Color color(double red, double green, double blue) {\n        return new Color(red, green, blue, 1);\n    }"}
{"Number":"940","API Relative Path":"javafx.scene.paint.Color.java-color(double-double-double)","Corresponding Source":"/**\n     * Creates an opaque sRGB color with the specified red, green and blue values\n     * in the range {@code 0.0-1.0}.\n     *\n     * @param red the red component, in the range {@code 0.0-1.0}\n     * @param green the green component, in the range {@code 0.0-1.0}\n     * @param blue the blue component, in the range {@code 0.0-1.0}\n     * @return the {@code Color}\n     * @throws IllegalArgumentException if any value is out of range\n     */\n    public static Color color(double red, double green, double blue) {\n        return new Color(red, green, blue, 1);\n    }"}
{"Number":"941","API Relative Path":"javafx.scene.paint.Color.java-color(double-double-double)","Corresponding Source":"/**\n     * Creates an opaque sRGB color with the specified red, green and blue values\n     * in the range {@code 0.0-1.0}.\n     *\n     * @param red the red component, in the range {@code 0.0-1.0}\n     * @param green the green component, in the range {@code 0.0-1.0}\n     * @param blue the blue component, in the range {@code 0.0-1.0}\n     * @return the {@code Color}\n     * @throws IllegalArgumentException if any value is out of range\n     */\n    public static Color color(double red, double green, double blue) {\n        return new Color(red, green, blue, 1);\n    }"}
{"Number":"942","API Relative Path":"javafx.scene.paint.Color.java-color(double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of color\n     * @param red red component ranging from {@code 0} to {@code 1}\n     * @param green green component ranging from {@code 0} to {@code 1}\n     * @param blue blue component ranging from {@code 0} to {@code 1}\n     * @param opacity opacity ranging from {@code 0} to {@code 1}\n     */\n    public Color(@NamedArg(\"red\") double red, @NamedArg(\"green\") double green, @NamedArg(\"blue\") double blue, @NamedArg(value=\"opacity\", defaultValue=\"1\") double opacity) {\n        if (red < 0 || red > 1) {\n            throw new IllegalArgumentException(\"Color's red value (\" + red + \") must be in the range 0.0-1.0\");\n        }\n        if (green < 0 || green > 1) {\n            throw new IllegalArgumentException(\"Color's green value (\" + green + \") must be in the range 0.0-1.0\");\n        }\n        if (blue < 0 || blue > 1) {\n            throw new IllegalArgumentException(\"Color's blue value (\" + blue + \") must be in the range 0.0-1.0\");\n        }\n        if (opacity < 0 || opacity > 1) {\n            throw new IllegalArgumentException(\"Color's opacity value (\" + opacity + \") must be in the range 0.0-1.0\");\n        }\n\n        this.red = (float) red;\n        this.green = (float) green;\n        this.blue = (float) blue;\n        this.opacity = (float) opacity;\n    }"}
{"Number":"943","API Relative Path":"javafx.scene.paint.Color.java-color(double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of color\n     * @param red red component ranging from {@code 0} to {@code 1}\n     * @param green green component ranging from {@code 0} to {@code 1}\n     * @param blue blue component ranging from {@code 0} to {@code 1}\n     * @param opacity opacity ranging from {@code 0} to {@code 1}\n     */\n    public Color(@NamedArg(\"red\") double red, @NamedArg(\"green\") double green, @NamedArg(\"blue\") double blue, @NamedArg(value=\"opacity\", defaultValue=\"1\") double opacity) {\n        if (red < 0 || red > 1) {\n            throw new IllegalArgumentException(\"Color's red value (\" + red + \") must be in the range 0.0-1.0\");\n        }\n        if (green < 0 || green > 1) {\n            throw new IllegalArgumentException(\"Color's green value (\" + green + \") must be in the range 0.0-1.0\");\n        }\n        if (blue < 0 || blue > 1) {\n            throw new IllegalArgumentException(\"Color's blue value (\" + blue + \") must be in the range 0.0-1.0\");\n        }\n        if (opacity < 0 || opacity > 1) {\n            throw new IllegalArgumentException(\"Color's opacity value (\" + opacity + \") must be in the range 0.0-1.0\");\n        }\n\n        this.red = (float) red;\n        this.green = (float) green;\n        this.blue = (float) blue;\n        this.opacity = (float) opacity;\n    }"}
{"Number":"944","API Relative Path":"javafx.scene.paint.Color.java-color(double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of color\n     * @param red red component ranging from {@code 0} to {@code 1}\n     * @param green green component ranging from {@code 0} to {@code 1}\n     * @param blue blue component ranging from {@code 0} to {@code 1}\n     * @param opacity opacity ranging from {@code 0} to {@code 1}\n     */\n    public Color(@NamedArg(\"red\") double red, @NamedArg(\"green\") double green, @NamedArg(\"blue\") double blue, @NamedArg(value=\"opacity\", defaultValue=\"1\") double opacity) {\n        if (red < 0 || red > 1) {\n            throw new IllegalArgumentException(\"Color's red value (\" + red + \") must be in the range 0.0-1.0\");\n        }\n        if (green < 0 || green > 1) {\n            throw new IllegalArgumentException(\"Color's green value (\" + green + \") must be in the range 0.0-1.0\");\n        }\n        if (blue < 0 || blue > 1) {\n            throw new IllegalArgumentException(\"Color's blue value (\" + blue + \") must be in the range 0.0-1.0\");\n        }\n        if (opacity < 0 || opacity > 1) {\n            throw new IllegalArgumentException(\"Color's opacity value (\" + opacity + \") must be in the range 0.0-1.0\");\n        }\n\n        this.red = (float) red;\n        this.green = (float) green;\n        this.blue = (float) blue;\n        this.opacity = (float) opacity;\n    }"}
{"Number":"945","API Relative Path":"javafx.scene.paint.Color.java-color(double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of color\n     * @param red red component ranging from {@code 0} to {@code 1}\n     * @param green green component ranging from {@code 0} to {@code 1}\n     * @param blue blue component ranging from {@code 0} to {@code 1}\n     * @param opacity opacity ranging from {@code 0} to {@code 1}\n     */\n    public Color(@NamedArg(\"red\") double red, @NamedArg(\"green\") double green, @NamedArg(\"blue\") double blue, @NamedArg(value=\"opacity\", defaultValue=\"1\") double opacity) {\n        if (red < 0 || red > 1) {\n            throw new IllegalArgumentException(\"Color's red value (\" + red + \") must be in the range 0.0-1.0\");\n        }\n        if (green < 0 || green > 1) {\n            throw new IllegalArgumentException(\"Color's green value (\" + green + \") must be in the range 0.0-1.0\");\n        }\n        if (blue < 0 || blue > 1) {\n            throw new IllegalArgumentException(\"Color's blue value (\" + blue + \") must be in the range 0.0-1.0\");\n        }\n        if (opacity < 0 || opacity > 1) {\n            throw new IllegalArgumentException(\"Color's opacity value (\" + opacity + \") must be in the range 0.0-1.0\");\n        }\n\n        this.red = (float) red;\n        this.green = (float) green;\n        this.blue = (float) blue;\n        this.opacity = (float) opacity;\n    }"}
{"Number":"946","API Relative Path":"javafx.scene.paint.Color.java-gray(double-double)","Corresponding Source":"/**\n     * Creates a grey color.\n     * @param gray color on gray scale in the range\n     *             {@code 0.0} (black) - {@code 1.0} (white).\n     * @param opacity the opacity component, in the range {@code 0.0-1.0}\n     * @return the {@code Color}\n     * @throws IllegalArgumentException if any value is out of range\n     */\n    public static Color gray(double gray, double opacity) {\n        return new Color(gray, gray, gray, opacity);\n    }"}
{"Number":"947","API Relative Path":"javafx.scene.paint.Color.java-gray(double-double)","Corresponding Source":"/**\n     * Creates a grey color.\n     * @param gray color on gray scale in the range\n     *             {@code 0.0} (black) - {@code 1.0} (white).\n     * @param opacity the opacity component, in the range {@code 0.0-1.0}\n     * @return the {@code Color}\n     * @throws IllegalArgumentException if any value is out of range\n     */\n    public static Color gray(double gray, double opacity) {\n        return new Color(gray, gray, gray, opacity);\n    }"}
{"Number":"948","API Relative Path":"javafx.scene.paint.Color.java-grayRgb(int)","Corresponding Source":"/**\n     * This is a shortcut for {@code rgb(gray, gray, gray)}.\n     */\n    public static Color grayRgb(int gray) {\n        return rgb(gray, gray, gray);\n    }"}
{"Number":"949","API Relative Path":"javafx.scene.paint.Color.java-grayRgb(int-double)","Corresponding Source":"/**\n     * This is a shortcut for {@code rgb(gray, gray, gray, opacity)}.\n     */\n    public static Color grayRgb(int gray, double opacity) {\n        return rgb(gray, gray, gray, opacity);\n    }"}
{"Number":"950","API Relative Path":"javafx.scene.paint.Color.java-grayRgb(int-double)","Corresponding Source":"/**\n     * This is a shortcut for {@code rgb(gray, gray, gray, opacity)}.\n     */\n    public static Color grayRgb(int gray, double opacity) {\n        return rgb(gray, gray, gray, opacity);\n    }"}
{"Number":"951","API Relative Path":"javafx.scene.paint.Color.java-hsb(double-double-double-double)","Corresponding Source":"/**\n     * Creates a {@code Color} based on the specified values in the HSB color model,\n     * and a given opacity.\n     *\n     * @param hue the hue, in degrees\n     * @param saturation the saturation, {@code 0.0 to 1.0}\n     * @param brightness the brightness, {@code 0.0 to 1.0}\n     * @param opacity the opacity, {@code 0.0 to 1.0}\n     * @return the {@code Color}\n     * @throws IllegalArgumentException if {@code saturation}, {@code brightness} or\n     *         {@code opacity} are out of range\n     */\n    public static Color hsb(double hue, double saturation, double brightness, double opacity) {\n        checkSB(saturation, brightness);\n        double[] rgb = Utils.HSBtoRGB(hue, saturation, brightness);\n        Color result = new Color(rgb[0], rgb[1], rgb[2], opacity);\n        return result;\n    }"}
{"Number":"952","API Relative Path":"javafx.scene.paint.Color.java-hsb(double-double-double-double)","Corresponding Source":"/**\n     * Creates a {@code Color} based on the specified values in the HSB color model,\n     * and a given opacity.\n     *\n     * @param hue the hue, in degrees\n     * @param saturation the saturation, {@code 0.0 to 1.0}\n     * @param brightness the brightness, {@code 0.0 to 1.0}\n     * @param opacity the opacity, {@code 0.0 to 1.0}\n     * @return the {@code Color}\n     * @throws IllegalArgumentException if {@code saturation}, {@code brightness} or\n     *         {@code opacity} are out of range\n     */\n    public static Color hsb(double hue, double saturation, double brightness, double opacity) {\n        checkSB(saturation, brightness);\n        double[] rgb = Utils.HSBtoRGB(hue, saturation, brightness);\n        Color result = new Color(rgb[0], rgb[1], rgb[2], opacity);\n        return result;\n    }"}
{"Number":"953","API Relative Path":"javafx.scene.paint.Color.java-hsb(double-double-double-double)","Corresponding Source":"/**\n     * Creates a {@code Color} based on the specified values in the HSB color model,\n     * and a given opacity.\n     *\n     * @param hue the hue, in degrees\n     * @param saturation the saturation, {@code 0.0 to 1.0}\n     * @param brightness the brightness, {@code 0.0 to 1.0}\n     * @param opacity the opacity, {@code 0.0 to 1.0}\n     * @return the {@code Color}\n     * @throws IllegalArgumentException if {@code saturation}, {@code brightness} or\n     *         {@code opacity} are out of range\n     */\n    public static Color hsb(double hue, double saturation, double brightness, double opacity) {\n        checkSB(saturation, brightness);\n        double[] rgb = Utils.HSBtoRGB(hue, saturation, brightness);\n        Color result = new Color(rgb[0], rgb[1], rgb[2], opacity);\n        return result;\n    }"}
{"Number":"954","API Relative Path":"javafx.scene.paint.Color.java-rgb(int-int-int)","Corresponding Source":"private static void checkRGB(int red, int green, int blue) {\n        if (red < 0 || red > 255) {\n            throw new IllegalArgumentException(\"Color.rgb's red parameter (\" + red + \") expects color values 0-255\");\n        }\n        if (green < 0 || green > 255) {\n            throw new IllegalArgumentException(\"Color.rgb's green parameter (\" + green + \") expects color values 0-255\");\n        }\n        if (blue < 0 || blue > 255) {\n            throw new IllegalArgumentException(\"Color.rgb's blue parameter (\" + blue + \") expects color values 0-255\");\n        }\n    }"}
{"Number":"955","API Relative Path":"javafx.scene.paint.Color.java-rgb(int-int-int)","Corresponding Source":"private static void checkRGB(int red, int green, int blue) {\n        if (red < 0 || red > 255) {\n            throw new IllegalArgumentException(\"Color.rgb's red parameter (\" + red + \") expects color values 0-255\");\n        }\n        if (green < 0 || green > 255) {\n            throw new IllegalArgumentException(\"Color.rgb's green parameter (\" + green + \") expects color values 0-255\");\n        }\n        if (blue < 0 || blue > 255) {\n            throw new IllegalArgumentException(\"Color.rgb's blue parameter (\" + blue + \") expects color values 0-255\");\n        }\n    }"}
{"Number":"956","API Relative Path":"javafx.scene.paint.Color.java-rgb(int-int-int)","Corresponding Source":"private static void checkRGB(int red, int green, int blue) {\n        if (red < 0 || red > 255) {\n            throw new IllegalArgumentException(\"Color.rgb's red parameter (\" + red + \") expects color values 0-255\");\n        }\n        if (green < 0 || green > 255) {\n            throw new IllegalArgumentException(\"Color.rgb's green parameter (\" + green + \") expects color values 0-255\");\n        }\n        if (blue < 0 || blue > 255) {\n            throw new IllegalArgumentException(\"Color.rgb's blue parameter (\" + blue + \") expects color values 0-255\");\n        }\n    }"}
{"Number":"957","API Relative Path":"javafx.scene.paint.Color.java-rgb(int-int-int-double)","Corresponding Source":"/**\n     * Creates an sRGB color with the specified RGB values in the range {@code 0-255},\n     * and a given opacity.\n     *\n     * @param red the red component, in the range {@code 0-255}\n     * @param green the green component, in the range {@code 0-255}\n     * @param blue the blue component, in the range {@code 0-255}\n     * @param opacity the opacity component, in the range {@code 0.0-1.0}\n     * @return the {@code Color}\n     * @throws IllegalArgumentException if any value is out of range\n     */\n    public static Color rgb(int red, int green, int blue, double opacity) {\n        checkRGB(red, green, blue);\n        return new Color(\n            red / 255.0,\n            green / 255.0,\n            blue / 255.0,\n            opacity);\n    }"}
{"Number":"958","API Relative Path":"javafx.scene.paint.Color.java-rgb(int-int-int-double)","Corresponding Source":"/**\n     * Creates an sRGB color with the specified RGB values in the range {@code 0-255},\n     * and a given opacity.\n     *\n     * @param red the red component, in the range {@code 0-255}\n     * @param green the green component, in the range {@code 0-255}\n     * @param blue the blue component, in the range {@code 0-255}\n     * @param opacity the opacity component, in the range {@code 0.0-1.0}\n     * @return the {@code Color}\n     * @throws IllegalArgumentException if any value is out of range\n     */\n    public static Color rgb(int red, int green, int blue, double opacity) {\n        checkRGB(red, green, blue);\n        return new Color(\n            red / 255.0,\n            green / 255.0,\n            blue / 255.0,\n            opacity);\n    }"}
{"Number":"959","API Relative Path":"javafx.scene.paint.Color.java-rgb(int-int-int-double)","Corresponding Source":"/**\n     * Creates an sRGB color with the specified RGB values in the range {@code 0-255},\n     * and a given opacity.\n     *\n     * @param red the red component, in the range {@code 0-255}\n     * @param green the green component, in the range {@code 0-255}\n     * @param blue the blue component, in the range {@code 0-255}\n     * @param opacity the opacity component, in the range {@code 0.0-1.0}\n     * @return the {@code Color}\n     * @throws IllegalArgumentException if any value is out of range\n     */\n    public static Color rgb(int red, int green, int blue, double opacity) {\n        checkRGB(red, green, blue);\n        return new Color(\n            red / 255.0,\n            green / 255.0,\n            blue / 255.0,\n            opacity);\n    }"}
{"Number":"960","API Relative Path":"javafx.scene.paint.Color.java-rgb(int-int-int-double)","Corresponding Source":"/**\n     * Creates an sRGB color with the specified RGB values in the range {@code 0-255},\n     * and a given opacity.\n     *\n     * @param red the red component, in the range {@code 0-255}\n     * @param green the green component, in the range {@code 0-255}\n     * @param blue the blue component, in the range {@code 0-255}\n     * @param opacity the opacity component, in the range {@code 0.0-1.0}\n     * @return the {@code Color}\n     * @throws IllegalArgumentException if any value is out of range\n     */\n    public static Color rgb(int red, int green, int blue, double opacity) {\n        checkRGB(red, green, blue);\n        return new Color(\n            red / 255.0,\n            green / 255.0,\n            blue / 255.0,\n            opacity);\n    }"}
{"Number":"961","API Relative Path":"javafx.scene.paint.Color.java-web(String-double)","Corresponding Source":"/**\n     * Creates an RGB color specified with an HTML or CSS attribute string.\n     *\n     * <p>\n     * This method supports the following formats:\n     * <ul>\n     * <li>Any standard HTML color name\n     * <li>An HTML long or short format hex string with an optional hex alpha\n     * channel.\n     * Hexadecimal values may be preceded by either {@code \"0x\"} or {@code \"#\"}\n     * and can either be 2 digits in the range {@code 00} to {@code 0xFF} or a\n     * single digit in the range {@code 0} to {@code F}.\n     * <li>An {@code rgb(r,g,b)} or {@code rgba(r,g,b,a)} format string.\n     * Each of the {@code r}, {@code g}, or {@code b} values can be an integer\n     * from 0 to 255 or a floating point percentage value from 0.0 to 100.0\n     * followed by the percent ({@code %}) character.\n     * The alpha component, if present, is a\n     * floating point value from 0.0 to 1.0.  Spaces are allowed before or\n     * after the numbers and between the percentage number and its percent\n     * sign ({@code %}).\n     * <li>An {@code hsl(h,s,l)} or {@code hsla(h,s,l,a)} format string.\n     * The {@code h} value is a floating point number from 0.0 to 360.0\n     * representing the hue angle on a color wheel in degrees with\n     * {@code 0.0} or {@code 360.0} representing red, {@code 120.0}\n     * representing green, and {@code 240.0} representing blue.  The\n     * {@code s} value is the saturation of the desired color represented\n     * as a floating point percentage from gray ({@code 0.0}) to\n     * the fully saturated color ({@code 100.0}) and the {@code l} value\n     * is the desired lightness or brightness of the desired color represented\n     * as a floating point percentage from black ({@code 0.0}) to the full\n     * brightness of the color ({@code 100.0}).\n     * The alpha component, if present, is a floating\n     * point value from 0.0 to 1.0.  Spaces are allowed before or\n     * after the numbers and between the percentage number and its percent\n     * sign ({@code %}).\n     * <\/ul>\n     *\n     * <p>For formats without an alpha component and for named colors, opacity\n     * is set according to the {@code opacity} argument. For colors specified\n     * with an alpha component, the resulting opacity is a combination of the\n     * parsed alpha component and the {@code opacity} argument, so a\n     * transparent color becomes more transparent by specifying opacity.<\/p>\n     *\n     * <p>Examples:<\/p>\n     * <div class=\"classUseContainer\">\n     * <table class=\"overviewSummary\" border=\"0\" cellpadding=\"3\" cellspacing=\"0\">\n     * <tr>\n     * <th class=\"colFirst\">Web Format String<\/th>\n     * <th class=\"colLast\">Equivalent constructor or factory call<\/th>\n     * <\/tr>\n     * <tr class=\"rowColor\">\n     * <td class=\"colFirst\"><code>Color.web(\"orange\", 0.5);<\/code><\/td>\n     * <td class=\"colLast\"><code>new Color(1.0, 0xA5/255.0, 0.0, 0.5)<\/code><\/td>\n     * <\/tr>\n     * <tr class=\"altColor\">\n     * <td class=\"colFirst\"><code>Color.web(\"0xff66cc33\", 0.5);<\/code><\/td>\n     * <td class=\"colLast\"><code>new Color(1.0, 0.4, 0.8, 0.1)<\/code><\/td>\n     * <\/tr>\n     * <tr class=\"rowColor\">\n     * <td class=\"colFirst\"><code>Color.web(\"0xff66cc\", 0.5);<\/code><\/td>\n     * <td class=\"colLast\"><code>new Color(1.0, 0.4, 0.8, 0.5)<\/code><\/td>\n     * <\/tr>\n     * <tr class=\"altColor\">\n     * <td class=\"colFirst\"><code>Color.web(\"#ff66cc\", 0.5);<\/code><\/td>\n     * <td class=\"colLast\"><code>new Color(1.0, 0.4, 0.8, 0.5)<\/code><\/td>\n     * <\/tr>\n     * <tr class=\"rowColor\">\n     * <td class=\"colFirst\"><code>Color.web(\"#f68\", 0.5);<\/code><\/td>\n     * <td class=\"colLast\"><code>new Color(1.0, 0.4, 0.8, 0.5)<\/code><\/td>\n     * <\/tr>\n     * <tr class=\"altColor\">\n     * <td class=\"colFirst\"><code>Color.web(\"rgb(255,102,204)\", 0.5);<\/code><\/td>\n     * <td class=\"colLast\"><code>new Color(1.0, 0.4, 0.8, 0.5)<\/code><\/td>\n     * <\/tr>\n     * <tr class=\"rowColor\">\n     * <td class=\"colFirst\"><code>Color.web(\"rgb(100%,50%,50%)\", 0.5);<\/code><\/td>\n     * <td class=\"colLast\"><code>new Color(1.0, 0.5, 0.5, 0.5)<\/code><\/td>\n     * <\/tr>\n     * <tr class=\"altColor\">\n     * <td class=\"colFirst\"><code>Color.web(\"rgb(255,50%,50%,0.25)\", 0.5);<\/code><\/td>\n     * <td class=\"colLast\"><code>new Color(1.0, 0.5, 0.5, 0.125)<\/code><\/td>\n     * <\/tr>\n     * <tr class=\"rowColor\">\n     * <td class=\"colFirst\"><code>Color.web(\"hsl(240,100%,100%)\", 0.5);<\/code><\/td>\n     * <td class=\"colLast\"><code>Color.hsb(240.0, 1.0, 1.0, 0.5)<\/code><\/td>\n     * <\/tr>\n     * <tr class=\"altColor\">\n     * <td style=\"border-bottom:1px solid\" class=\"colFirst\">\n     *     <code>Color.web(\"hsla(120,0%,0%,0.25)\", 0.5);<\/code>\n     * <\/td>\n     * <td style=\"border-bottom:1px solid\" class=\"colLast\">\n     *     <code>Color.hsb(120.0, 0.0, 0.0, 0.125)<\/code>\n     * <\/td>\n     * <\/tr>\n     * <\/table>\n     * <\/div>\n     *\n     * @param colorString the name or numeric representation of the color\n     *                    in one of the supported formats\n     * @param opacity the opacity component in range from 0.0 (transparent)\n     *                to 1.0 (opaque)\n     * @throws NullPointerException if {@code colorString} is {@code null}\n     * @throws IllegalArgumentException if {@code colorString} specifies\n     *      an unsupported color name or contains an illegal numeric value\n     */\n    public static Color web(String colorString, double opacity) {\n        if (colorString == null) {\n            throw new NullPointerException(\n                    \"The color components or name must be specified\");\n        }\n        if (colorString.isEmpty()) {\n            throw new IllegalArgumentException(\"Invalid color specification\");\n        }\n\n        String color = colorString.toLowerCase(Locale.ROOT);\n\n        if (color.startsWith(\"#\")) {\n            color = color.substring(1);\n        } else if (color.startsWith(\"0x\")) {\n            color = color.substring(2);\n        } else if (color.startsWith(\"rgb\")) {\n            if (color.startsWith(\"(\", 3)) {\n                return parseRGBColor(color, 4, false, opacity);\n            } else if (color.startsWith(\"a(\", 3)) {\n                return parseRGBColor(color, 5, true, opacity);\n            }\n        } else if (color.startsWith(\"hsl\")) {\n            if (color.startsWith(\"(\", 3)) {\n                return parseHSLColor(color, 4, false, opacity);\n            } else if (color.startsWith(\"a(\", 3)) {\n                return parseHSLColor(color, 5, true, opacity);\n            }\n        } else {\n            Color col = NamedColors.get(color);\n            if (col != null) {\n                if (opacity == 1.0) {\n                    return col;\n                } else {\n                    return Color.color(col.red, col.green, col.blue, opacity);\n                }\n            }\n        }\n\n        int len = color.length();\n\n        try {\n            int r;\n            int g;\n            int b;\n            int a;\n\n            if (len == 3) {\n                r = Integer.parseInt(color.substring(0, 1), 16);\n                g = Integer.parseInt(color.substring(1, 2), 16);\n                b = Integer.parseInt(color.substring(2, 3), 16);\n                return Color.color(r / 15.0, g / 15.0, b / 15.0, opacity);\n            } else if (len == 4) {\n                r = Integer.parseInt(color.substring(0, 1), 16);\n                g = Integer.parseInt(color.substring(1, 2), 16);\n                b = Integer.parseInt(color.substring(2, 3), 16);\n                a = Integer.parseInt(color.substring(3, 4), 16);\n                return Color.color(r / 15.0, g / 15.0, b / 15.0,\n                        opacity * a / 15.0);\n            } else if (len == 6) {\n                r = Integer.parseInt(color.substring(0, 2), 16);\n                g = Integer.parseInt(color.substring(2, 4), 16);\n                b = Integer.parseInt(color.substring(4, 6), 16);\n                return Color.rgb(r, g, b, opacity);\n            } else if (len == 8) {\n                r = Integer.parseInt(color.substring(0, 2), 16);\n                g = Integer.parseInt(color.substring(2, 4), 16);\n                b = Integer.parseInt(color.substring(4, 6), 16);\n                a = Integer.parseInt(color.substring(6, 8), 16);\n                return Color.rgb(r, g, b, opacity * a / 255.0);\n            }\n        } catch (NumberFormatException nfe) {}\n\n        throw new IllegalArgumentException(\"Invalid color specification\");\n    }"}
{"Number":"962","API Relative Path":"javafx.scene.Scene.java-impl_setAllowPGAccess(boolean)","Corresponding Source":"/**\n         * @treatAsPrivate implementation detail\n         * @deprecated This is an internal API that is not intended for use and will be removed in the next version\n         */\n        @Deprecated\n        public static void impl_setAllowPGAccess(boolean flag) {\n            if (Utils.assertionEnabled()) {\n                if (flag) {\n                    pgAccessCount++;\n                    allowPGAccess = true;\n                }\n                else {\n                    if (pgAccessCount <= 0) {\n                        throw new java.lang.AssertionError(\"*** pgAccessCount underflow\");\n                    }\n                    if (--pgAccessCount == 0) {\n                        allowPGAccess = false;\n                    }\n                }\n            }\n        }"}
{"Number":"963","API Relative Path":"javafx.scene.shape.Arc.java-Arc(double-double-double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of Arc.\n     * @param centerX the X coordinate of the center point of the arc\n     * @param centerY the Y coordinate of the center point of the arc\n     * @param radiusX the overall width (horizontal radius) of the full ellipse\n     * of which this arc is a partial section\n     * @param radiusY the overall height (vertical radius) of the full ellipse\n     * of which this arc is a partial section\n     * @param startAngle the starting angle of the arc in degrees\n     * @param length the angular extent of the arc in degrees\n     */\n    public Arc(double centerX, double centerY, double radiusX, double radiusY, double startAngle, double length) {\n        setCenterX(centerX);\n        setCenterY(centerY);\n        setRadiusX(radiusX);\n        setRadiusY(radiusY);\n        setStartAngle(startAngle);\n        setLength(length);\n    }"}
{"Number":"964","API Relative Path":"javafx.scene.shape.Arc.java-Arc(double-double-double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of Arc.\n     * @param centerX the X coordinate of the center point of the arc\n     * @param centerY the Y coordinate of the center point of the arc\n     * @param radiusX the overall width (horizontal radius) of the full ellipse\n     * of which this arc is a partial section\n     * @param radiusY the overall height (vertical radius) of the full ellipse\n     * of which this arc is a partial section\n     * @param startAngle the starting angle of the arc in degrees\n     * @param length the angular extent of the arc in degrees\n     */\n    public Arc(double centerX, double centerY, double radiusX, double radiusY, double startAngle, double length) {\n        setCenterX(centerX);\n        setCenterY(centerY);\n        setRadiusX(radiusX);\n        setRadiusY(radiusY);\n        setStartAngle(startAngle);\n        setLength(length);\n    }"}
{"Number":"965","API Relative Path":"javafx.scene.shape.Arc.java-Arc(double-double-double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of Arc.\n     * @param centerX the X coordinate of the center point of the arc\n     * @param centerY the Y coordinate of the center point of the arc\n     * @param radiusX the overall width (horizontal radius) of the full ellipse\n     * of which this arc is a partial section\n     * @param radiusY the overall height (vertical radius) of the full ellipse\n     * of which this arc is a partial section\n     * @param startAngle the starting angle of the arc in degrees\n     * @param length the angular extent of the arc in degrees\n     */\n    public Arc(double centerX, double centerY, double radiusX, double radiusY, double startAngle, double length) {\n        setCenterX(centerX);\n        setCenterY(centerY);\n        setRadiusX(radiusX);\n        setRadiusY(radiusY);\n        setStartAngle(startAngle);\n        setLength(length);\n    }"}
{"Number":"966","API Relative Path":"javafx.scene.shape.ArcTo.java-ArcTo(double-double-double-double-double-boolean-boolean)","Corresponding Source":"/**\n     * Creates a new instance of ArcTo.\n     * @param radiusX horizontal radius of the arc\n     * @param radiusY vertical radius of the arc\n     * @param xAxisRotation the x-axis rotation in degrees\n     * @param x horizontal position of the arc end point\n     * @param y vertical position of the arc end point\n     * @param largeArcFlag large arg flag: determines which arc to use (large/small)\n     * @param sweepFlag sweep flag: determines which arc to use (direction)\n     */\n    public ArcTo(double radiusX, double radiusY, double xAxisRotation,\n        double x, double y, boolean largeArcFlag, boolean sweepFlag)\n    {\n        setRadiusX(radiusX);\n        setRadiusY(radiusY);\n        setXAxisRotation(xAxisRotation);\n        setX(x);\n        setY(y);\n        setLargeArcFlag(largeArcFlag);\n        setSweepFlag(sweepFlag);\n    }"}
{"Number":"967","API Relative Path":"javafx.scene.shape.ArcTo.java-ArcTo(double-double-double-double-double-boolean-boolean)","Corresponding Source":"/**\n     * Creates a new instance of ArcTo.\n     * @param radiusX horizontal radius of the arc\n     * @param radiusY vertical radius of the arc\n     * @param xAxisRotation the x-axis rotation in degrees\n     * @param x horizontal position of the arc end point\n     * @param y vertical position of the arc end point\n     * @param largeArcFlag large arg flag: determines which arc to use (large/small)\n     * @param sweepFlag sweep flag: determines which arc to use (direction)\n     */\n    public ArcTo(double radiusX, double radiusY, double xAxisRotation,\n        double x, double y, boolean largeArcFlag, boolean sweepFlag)\n    {\n        setRadiusX(radiusX);\n        setRadiusY(radiusY);\n        setXAxisRotation(xAxisRotation);\n        setX(x);\n        setY(y);\n        setLargeArcFlag(largeArcFlag);\n        setSweepFlag(sweepFlag);\n    }"}
{"Number":"968","API Relative Path":"javafx.scene.shape.ArcTo.java-ArcTo(double-double-double-double-double-boolean-boolean)","Corresponding Source":"/**\n     * Creates a new instance of ArcTo.\n     * @param radiusX horizontal radius of the arc\n     * @param radiusY vertical radius of the arc\n     * @param xAxisRotation the x-axis rotation in degrees\n     * @param x horizontal position of the arc end point\n     * @param y vertical position of the arc end point\n     * @param largeArcFlag large arg flag: determines which arc to use (large/small)\n     * @param sweepFlag sweep flag: determines which arc to use (direction)\n     */\n    public ArcTo(double radiusX, double radiusY, double xAxisRotation,\n        double x, double y, boolean largeArcFlag, boolean sweepFlag)\n    {\n        setRadiusX(radiusX);\n        setRadiusY(radiusY);\n        setXAxisRotation(xAxisRotation);\n        setX(x);\n        setY(y);\n        setLargeArcFlag(largeArcFlag);\n        setSweepFlag(sweepFlag);\n    }"}
{"Number":"969","API Relative Path":"javafx.scene.shape.ArcTo.java-ArcTo(double-double-double-double-double-boolean-boolean)","Corresponding Source":"/**\n     * Creates a new instance of ArcTo.\n     * @param radiusX horizontal radius of the arc\n     * @param radiusY vertical radius of the arc\n     * @param xAxisRotation the x-axis rotation in degrees\n     * @param x horizontal position of the arc end point\n     * @param y vertical position of the arc end point\n     * @param largeArcFlag large arg flag: determines which arc to use (large/small)\n     * @param sweepFlag sweep flag: determines which arc to use (direction)\n     */\n    public ArcTo(double radiusX, double radiusY, double xAxisRotation,\n        double x, double y, boolean largeArcFlag, boolean sweepFlag)\n    {\n        setRadiusX(radiusX);\n        setRadiusY(radiusY);\n        setXAxisRotation(xAxisRotation);\n        setX(x);\n        setY(y);\n        setLargeArcFlag(largeArcFlag);\n        setSweepFlag(sweepFlag);\n    }"}
{"Number":"970","API Relative Path":"javafx.scene.shape.ArcTo.java-ArcTo(double-double-double-double-double-boolean-boolean)","Corresponding Source":"/**\n     * Creates a new instance of ArcTo.\n     * @param radiusX horizontal radius of the arc\n     * @param radiusY vertical radius of the arc\n     * @param xAxisRotation the x-axis rotation in degrees\n     * @param x horizontal position of the arc end point\n     * @param y vertical position of the arc end point\n     * @param largeArcFlag large arg flag: determines which arc to use (large/small)\n     * @param sweepFlag sweep flag: determines which arc to use (direction)\n     */\n    public ArcTo(double radiusX, double radiusY, double xAxisRotation,\n        double x, double y, boolean largeArcFlag, boolean sweepFlag)\n    {\n        setRadiusX(radiusX);\n        setRadiusY(radiusY);\n        setXAxisRotation(xAxisRotation);\n        setX(x);\n        setY(y);\n        setLargeArcFlag(largeArcFlag);\n        setSweepFlag(sweepFlag);\n    }"}
{"Number":"971","API Relative Path":"javafx.scene.shape.Circle.java-Circle(double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of Circle with a specified position and radius.\n     * @param centerX the horizontal position of the center of the circle in pixels\n     * @param centerY the vertical position of the center of the circle in pixels\n     * @param radius the radius of the circle in pixels\n     */\n    public Circle(double centerX, double centerY, double radius) {\n        setCenterX(centerX);\n        setCenterY(centerY);\n        setRadius(radius);\n    }"}
{"Number":"972","API Relative Path":"javafx.scene.shape.Circle.java-Circle(double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of Circle with a specified position and radius.\n     * @param centerX the horizontal position of the center of the circle in pixels\n     * @param centerY the vertical position of the center of the circle in pixels\n     * @param radius the radius of the circle in pixels\n     */\n    public Circle(double centerX, double centerY, double radius) {\n        setCenterX(centerX);\n        setCenterY(centerY);\n        setRadius(radius);\n    }"}
{"Number":"973","API Relative Path":"javafx.scene.shape.Circle.java-Circle(double-double-double-Paint)","Corresponding Source":"/**\n     * Creates a new instance of Circle with a specified position, radius and fill.\n     * @param centerX the horizontal position of the center of the circle in pixels\n     * @param centerY the vertical position of the center of the circle in pixels\n     * @param radius the radius of the circle in pixels\n     * @param fill determines how to fill the interior of the Circle\n     */\n    public Circle(double centerX, double centerY, double radius, Paint fill) {\n        setCenterX(centerX);\n        setCenterY(centerY);\n        setRadius(radius);\n        setFill(fill);\n    }"}
{"Number":"974","API Relative Path":"javafx.scene.shape.Circle.java-Circle(double-double-double-Paint)","Corresponding Source":"/**\n     * Creates a new instance of Circle with a specified position, radius and fill.\n     * @param centerX the horizontal position of the center of the circle in pixels\n     * @param centerY the vertical position of the center of the circle in pixels\n     * @param radius the radius of the circle in pixels\n     * @param fill determines how to fill the interior of the Circle\n     */\n    public Circle(double centerX, double centerY, double radius, Paint fill) {\n        setCenterX(centerX);\n        setCenterY(centerY);\n        setRadius(radius);\n        setFill(fill);\n    }"}
{"Number":"975","API Relative Path":"javafx.scene.shape.CubicCurve.java-CubicCurve(double-double-double-double-double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of CubicCurve.\n     * @param startX the X coordinate of the start point\n     * @param startY the Y coordinate of the start point\n     * @param controlX1 the X coordinate of the first control point\n     * @param controlY1 the Y coordinate of the first control point\n     * @param controlX2 the X coordinate of the second control point\n     * @param controlY2 the Y coordinate of the second control point\n     * @param endX the X coordinate of the end point\n     * @param endY the Y coordinate of the end point\n     * @since JavaFX 2.1\n     */\n    public CubicCurve(double startX, double startY, double controlX1,\n            double controlY1, double controlX2, double controlY2,\n            double endX, double endY) {\n        setStartX(startX);\n        setStartY(startY);\n        setControlX1(controlX1);\n        setControlY1(controlY1);\n        setControlX2(controlX2);\n        setControlY2(controlY2);\n        setEndX(endX);\n        setEndY(endY);\n    }"}
{"Number":"976","API Relative Path":"javafx.scene.shape.CubicCurve.java-CubicCurve(double-double-double-double-double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of CubicCurve.\n     * @param startX the X coordinate of the start point\n     * @param startY the Y coordinate of the start point\n     * @param controlX1 the X coordinate of the first control point\n     * @param controlY1 the Y coordinate of the first control point\n     * @param controlX2 the X coordinate of the second control point\n     * @param controlY2 the Y coordinate of the second control point\n     * @param endX the X coordinate of the end point\n     * @param endY the Y coordinate of the end point\n     * @since JavaFX 2.1\n     */\n    public CubicCurve(double startX, double startY, double controlX1,\n            double controlY1, double controlX2, double controlY2,\n            double endX, double endY) {\n        setStartX(startX);\n        setStartY(startY);\n        setControlX1(controlX1);\n        setControlY1(controlY1);\n        setControlX2(controlX2);\n        setControlY2(controlY2);\n        setEndX(endX);\n        setEndY(endY);\n    }"}
{"Number":"977","API Relative Path":"javafx.scene.shape.CubicCurve.java-CubicCurve(double-double-double-double-double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of CubicCurve.\n     * @param startX the X coordinate of the start point\n     * @param startY the Y coordinate of the start point\n     * @param controlX1 the X coordinate of the first control point\n     * @param controlY1 the Y coordinate of the first control point\n     * @param controlX2 the X coordinate of the second control point\n     * @param controlY2 the Y coordinate of the second control point\n     * @param endX the X coordinate of the end point\n     * @param endY the Y coordinate of the end point\n     * @since JavaFX 2.1\n     */\n    public CubicCurve(double startX, double startY, double controlX1,\n            double controlY1, double controlX2, double controlY2,\n            double endX, double endY) {\n        setStartX(startX);\n        setStartY(startY);\n        setControlX1(controlX1);\n        setControlY1(controlY1);\n        setControlX2(controlX2);\n        setControlY2(controlY2);\n        setEndX(endX);\n        setEndY(endY);\n    }"}
{"Number":"978","API Relative Path":"javafx.scene.shape.CubicCurve.java-CubicCurve(double-double-double-double-double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of CubicCurve.\n     * @param startX the X coordinate of the start point\n     * @param startY the Y coordinate of the start point\n     * @param controlX1 the X coordinate of the first control point\n     * @param controlY1 the Y coordinate of the first control point\n     * @param controlX2 the X coordinate of the second control point\n     * @param controlY2 the Y coordinate of the second control point\n     * @param endX the X coordinate of the end point\n     * @param endY the Y coordinate of the end point\n     * @since JavaFX 2.1\n     */\n    public CubicCurve(double startX, double startY, double controlX1,\n            double controlY1, double controlX2, double controlY2,\n            double endX, double endY) {\n        setStartX(startX);\n        setStartY(startY);\n        setControlX1(controlX1);\n        setControlY1(controlY1);\n        setControlX2(controlX2);\n        setControlY2(controlY2);\n        setEndX(endX);\n        setEndY(endY);\n    }"}
{"Number":"979","API Relative Path":"javafx.scene.shape.CubicCurve.java-CubicCurve(double-double-double-double-double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of CubicCurve.\n     * @param startX the X coordinate of the start point\n     * @param startY the Y coordinate of the start point\n     * @param controlX1 the X coordinate of the first control point\n     * @param controlY1 the Y coordinate of the first control point\n     * @param controlX2 the X coordinate of the second control point\n     * @param controlY2 the Y coordinate of the second control point\n     * @param endX the X coordinate of the end point\n     * @param endY the Y coordinate of the end point\n     * @since JavaFX 2.1\n     */\n    public CubicCurve(double startX, double startY, double controlX1,\n            double controlY1, double controlX2, double controlY2,\n            double endX, double endY) {\n        setStartX(startX);\n        setStartY(startY);\n        setControlX1(controlX1);\n        setControlY1(controlY1);\n        setControlX2(controlX2);\n        setControlY2(controlY2);\n        setEndX(endX);\n        setEndY(endY);\n    }"}
{"Number":"980","API Relative Path":"javafx.scene.shape.CubicCurve.java-CubicCurve(double-double-double-double-double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of CubicCurve.\n     * @param startX the X coordinate of the start point\n     * @param startY the Y coordinate of the start point\n     * @param controlX1 the X coordinate of the first control point\n     * @param controlY1 the Y coordinate of the first control point\n     * @param controlX2 the X coordinate of the second control point\n     * @param controlY2 the Y coordinate of the second control point\n     * @param endX the X coordinate of the end point\n     * @param endY the Y coordinate of the end point\n     * @since JavaFX 2.1\n     */\n    public CubicCurve(double startX, double startY, double controlX1,\n            double controlY1, double controlX2, double controlY2,\n            double endX, double endY) {\n        setStartX(startX);\n        setStartY(startY);\n        setControlX1(controlX1);\n        setControlY1(controlY1);\n        setControlX2(controlX2);\n        setControlY2(controlY2);\n        setEndX(endX);\n        setEndY(endY);\n    }"}
{"Number":"981","API Relative Path":"javafx.scene.shape.CubicCurve.java-CubicCurve(double-double-double-double-double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of CubicCurve.\n     * @param startX the X coordinate of the start point\n     * @param startY the Y coordinate of the start point\n     * @param controlX1 the X coordinate of the first control point\n     * @param controlY1 the Y coordinate of the first control point\n     * @param controlX2 the X coordinate of the second control point\n     * @param controlY2 the Y coordinate of the second control point\n     * @param endX the X coordinate of the end point\n     * @param endY the Y coordinate of the end point\n     * @since JavaFX 2.1\n     */\n    public CubicCurve(double startX, double startY, double controlX1,\n            double controlY1, double controlX2, double controlY2,\n            double endX, double endY) {\n        setStartX(startX);\n        setStartY(startY);\n        setControlX1(controlX1);\n        setControlY1(controlY1);\n        setControlX2(controlX2);\n        setControlY2(controlY2);\n        setEndX(endX);\n        setEndY(endY);\n    }"}
{"Number":"982","API Relative Path":"javafx.scene.shape.CubicCurve.java-CubicCurve(double-double-double-double-double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of CubicCurve.\n     * @param startX the X coordinate of the start point\n     * @param startY the Y coordinate of the start point\n     * @param controlX1 the X coordinate of the first control point\n     * @param controlY1 the Y coordinate of the first control point\n     * @param controlX2 the X coordinate of the second control point\n     * @param controlY2 the Y coordinate of the second control point\n     * @param endX the X coordinate of the end point\n     * @param endY the Y coordinate of the end point\n     * @since JavaFX 2.1\n     */\n    public CubicCurve(double startX, double startY, double controlX1,\n            double controlY1, double controlX2, double controlY2,\n            double endX, double endY) {\n        setStartX(startX);\n        setStartY(startY);\n        setControlX1(controlX1);\n        setControlY1(controlY1);\n        setControlX2(controlX2);\n        setControlY2(controlY2);\n        setEndX(endX);\n        setEndY(endY);\n    }"}
{"Number":"983","API Relative Path":"javafx.scene.shape.CubicCurveTo.java-CubicCurveTo(double-double-double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of CubicCurveTo.\n     * @param controlX1 the X coordinate of the first B&eacute;zier control point\n     * @param controlY1 the Y coordinate of the first B&eacute;zier control point\n     * @param controlX2 the X coordinate of the second B&eacute;zier control point\n     * @param controlY2 the Y coordinate of the second B&eacute;zier control point\n     * @param x the X coordinate of the final end point\n     * @param y the Y coordinate of the final end point\n     */\n    public CubicCurveTo(double controlX1, double controlY1, double controlX2,\n        double controlY2, double x, double y)\n    {\n        setControlX1(controlX1);\n        setControlY1(controlY1);\n        setControlX2(controlX2);\n        setControlY2(controlY2);\n        setX(x);\n        setY(y);\n    }"}
{"Number":"984","API Relative Path":"javafx.scene.shape.CubicCurveTo.java-CubicCurveTo(double-double-double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of CubicCurveTo.\n     * @param controlX1 the X coordinate of the first B&eacute;zier control point\n     * @param controlY1 the Y coordinate of the first B&eacute;zier control point\n     * @param controlX2 the X coordinate of the second B&eacute;zier control point\n     * @param controlY2 the Y coordinate of the second B&eacute;zier control point\n     * @param x the X coordinate of the final end point\n     * @param y the Y coordinate of the final end point\n     */\n    public CubicCurveTo(double controlX1, double controlY1, double controlX2,\n        double controlY2, double x, double y)\n    {\n        setControlX1(controlX1);\n        setControlY1(controlY1);\n        setControlX2(controlX2);\n        setControlY2(controlY2);\n        setX(x);\n        setY(y);\n    }"}
{"Number":"985","API Relative Path":"javafx.scene.shape.CubicCurveTo.java-CubicCurveTo(double-double-double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of CubicCurveTo.\n     * @param controlX1 the X coordinate of the first B&eacute;zier control point\n     * @param controlY1 the Y coordinate of the first B&eacute;zier control point\n     * @param controlX2 the X coordinate of the second B&eacute;zier control point\n     * @param controlY2 the Y coordinate of the second B&eacute;zier control point\n     * @param x the X coordinate of the final end point\n     * @param y the Y coordinate of the final end point\n     */\n    public CubicCurveTo(double controlX1, double controlY1, double controlX2,\n        double controlY2, double x, double y)\n    {\n        setControlX1(controlX1);\n        setControlY1(controlY1);\n        setControlX2(controlX2);\n        setControlY2(controlY2);\n        setX(x);\n        setY(y);\n    }"}
{"Number":"986","API Relative Path":"javafx.scene.shape.CubicCurveTo.java-CubicCurveTo(double-double-double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of CubicCurveTo.\n     * @param controlX1 the X coordinate of the first B&eacute;zier control point\n     * @param controlY1 the Y coordinate of the first B&eacute;zier control point\n     * @param controlX2 the X coordinate of the second B&eacute;zier control point\n     * @param controlY2 the Y coordinate of the second B&eacute;zier control point\n     * @param x the X coordinate of the final end point\n     * @param y the Y coordinate of the final end point\n     */\n    public CubicCurveTo(double controlX1, double controlY1, double controlX2,\n        double controlY2, double x, double y)\n    {\n        setControlX1(controlX1);\n        setControlY1(controlY1);\n        setControlX2(controlX2);\n        setControlY2(controlY2);\n        setX(x);\n        setY(y);\n    }"}
{"Number":"987","API Relative Path":"javafx.scene.shape.CubicCurveTo.java-CubicCurveTo(double-double-double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of CubicCurveTo.\n     * @param controlX1 the X coordinate of the first B&eacute;zier control point\n     * @param controlY1 the Y coordinate of the first B&eacute;zier control point\n     * @param controlX2 the X coordinate of the second B&eacute;zier control point\n     * @param controlY2 the Y coordinate of the second B&eacute;zier control point\n     * @param x the X coordinate of the final end point\n     * @param y the Y coordinate of the final end point\n     */\n    public CubicCurveTo(double controlX1, double controlY1, double controlX2,\n        double controlY2, double x, double y)\n    {\n        setControlX1(controlX1);\n        setControlY1(controlY1);\n        setControlX2(controlX2);\n        setControlY2(controlY2);\n        setX(x);\n        setY(y);\n    }"}
{"Number":"988","API Relative Path":"javafx.scene.shape.CubicCurveTo.java-CubicCurveTo(double-double-double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of CubicCurveTo.\n     * @param controlX1 the X coordinate of the first B&eacute;zier control point\n     * @param controlY1 the Y coordinate of the first B&eacute;zier control point\n     * @param controlX2 the X coordinate of the second B&eacute;zier control point\n     * @param controlY2 the Y coordinate of the second B&eacute;zier control point\n     * @param x the X coordinate of the final end point\n     * @param y the Y coordinate of the final end point\n     */\n    public CubicCurveTo(double controlX1, double controlY1, double controlX2,\n        double controlY2, double x, double y)\n    {\n        setControlX1(controlX1);\n        setControlY1(controlY1);\n        setControlX2(controlX2);\n        setControlY2(controlY2);\n        setX(x);\n        setY(y);\n    }"}
{"Number":"989","API Relative Path":"javafx.scene.shape.Ellipse.java-Ellipse(double-double-double-double)","Corresponding Source":"/**\n     * Creates an instance of Ellipse of the given position and size.\n     * @param centerX the horizontal position of the center of the ellipse in pixels\n     * @param centerY the vertical position of the center of the ellipse in pixels\n     * @param radiusX the horizontal radius of the ellipse in pixels\n     * @param radiusY the vertical radius of the ellipse in pixels\n     */\n    public Ellipse(double centerX, double centerY, double radiusX, double radiusY) {\n        this(radiusX, radiusY);\n        setCenterX(centerX);\n        setCenterY(centerY);\n    }"}
{"Number":"990","API Relative Path":"javafx.scene.shape.Ellipse.java-Ellipse(double-double-double-double)","Corresponding Source":"/**\n     * Creates an instance of Ellipse of the given position and size.\n     * @param centerX the horizontal position of the center of the ellipse in pixels\n     * @param centerY the vertical position of the center of the ellipse in pixels\n     * @param radiusX the horizontal radius of the ellipse in pixels\n     * @param radiusY the vertical radius of the ellipse in pixels\n     */\n    public Ellipse(double centerX, double centerY, double radiusX, double radiusY) {\n        this(radiusX, radiusY);\n        setCenterX(centerX);\n        setCenterY(centerY);\n    }"}
{"Number":"991","API Relative Path":"javafx.scene.shape.LineTo.java-LineTo(double-double)","Corresponding Source":"/**\n     * Creates a new isntance of LineTo.\n     * @param x the horizontal coordinate of the line end point\n     * @param y the vertical coordinate of the line end point\n     */\n    public LineTo(double x, double y) {\n        setX(x);\n        setY(y);\n    }"}
{"Number":"992","API Relative Path":"javafx.scene.shape.LineTo.java-LineTo(double-double)","Corresponding Source":"/**\n     * Creates a new isntance of LineTo.\n     * @param x the horizontal coordinate of the line end point\n     * @param y the vertical coordinate of the line end point\n     */\n    public LineTo(double x, double y) {\n        setX(x);\n        setY(y);\n    }"}
{"Number":"993","API Relative Path":"javafx.scene.shape.MoveTo.java-MoveTo(double-double)","Corresponding Source":"/**\n     * Creates a new instance of MoveTo.\n     * @param x the horizontal coordinate to move to\n     * @param y the vertical coordinate to move to\n     */\n    public MoveTo(double x, double y) {\n        setX(x);\n        setY(y);\n    }"}
{"Number":"994","API Relative Path":"javafx.scene.shape.MoveTo.java-MoveTo(double-double)","Corresponding Source":"/**\n     * Creates a new instance of MoveTo.\n     * @param x the horizontal coordinate to move to\n     * @param y the vertical coordinate to move to\n     */\n    public MoveTo(double x, double y) {\n        setX(x);\n        setY(y);\n    }"}
{"Number":"995","API Relative Path":"javafx.scene.shape.Path.java-Path(Collection)","Corresponding Source":"/**\n     * Creates new instance of Path\n     * @param elements The collection of the elements of the Path\n     * @since JavaFX 2.2\n     */\n    public Path(Collection<? extends PathElement> elements) {\n        if (elements != null) {\n            this.elements.addAll(elements);\n        }\n    }"}
{"Number":"996","API Relative Path":"javafx.scene.shape.Path.java-Path(PathElement)","Corresponding Source":"/**\n     * Creates a new instance of Path\n     * @param elements Elements of the Path\n     * @since JavaFX 2.1\n     */\n    public Path(PathElement... elements) {\n        if (elements != null) {\n            this.elements.addAll(elements);\n        }\n    }"}
{"Number":"997","API Relative Path":"javafx.scene.shape.Polygon.java-Polygon(double)","Corresponding Source":"/**\n     * Creates a new instance of Polygon.\n     * @param points the coordinates of the polygon vertices\n     */\n    public Polygon(double... points) {\n        if (points != null) {\n            for (double p : points) {\n                this.getPoints().add(p);\n            }\n        }\n    }"}
{"Number":"998","API Relative Path":"javafx.scene.shape.Polyline.java-Polyline(double)","Corresponding Source":"/**\n     * Creates a new instance of Polyline.\n     * @param points the coordinates of the polyline segments\n     */\n    public Polyline(double... points) {\n        if (points != null) {\n            for (double p : points) {\n                this.getPoints().add(p);\n            }\n        }\n    }"}
{"Number":"999","API Relative Path":"javafx.scene.shape.QuadCurve.java-QuadCurve(double-double-double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of QuadCurve.\n     * @param startX the X coordinate of the start point\n     * @param startY the Y coordinate of the start point\n     * @param controlX the X coordinate of the control point\n     * @param controlY the Y coordinate of the control point\n     * @param endX the X coordinate of the end point\n     * @param endY the Y coordinate of the end point\n     */\n    public QuadCurve(double startX, double startY, double controlX, double controlY, double endX, double endY) {\n        setStartX(startX);\n        setStartY(startY);\n        setControlX(controlX);\n        setControlY(controlY);\n        setEndX(endX);\n        setEndY(endY);\n    }"}
{"Number":"1000","API Relative Path":"javafx.scene.shape.QuadCurve.java-QuadCurve(double-double-double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of QuadCurve.\n     * @param startX the X coordinate of the start point\n     * @param startY the Y coordinate of the start point\n     * @param controlX the X coordinate of the control point\n     * @param controlY the Y coordinate of the control point\n     * @param endX the X coordinate of the end point\n     * @param endY the Y coordinate of the end point\n     */\n    public QuadCurve(double startX, double startY, double controlX, double controlY, double endX, double endY) {\n        setStartX(startX);\n        setStartY(startY);\n        setControlX(controlX);\n        setControlY(controlY);\n        setEndX(endX);\n        setEndY(endY);\n    }"}
{"Number":"1001","API Relative Path":"javafx.scene.shape.QuadCurve.java-QuadCurve(double-double-double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of QuadCurve.\n     * @param startX the X coordinate of the start point\n     * @param startY the Y coordinate of the start point\n     * @param controlX the X coordinate of the control point\n     * @param controlY the Y coordinate of the control point\n     * @param endX the X coordinate of the end point\n     * @param endY the Y coordinate of the end point\n     */\n    public QuadCurve(double startX, double startY, double controlX, double controlY, double endX, double endY) {\n        setStartX(startX);\n        setStartY(startY);\n        setControlX(controlX);\n        setControlY(controlY);\n        setEndX(endX);\n        setEndY(endY);\n    }"}
{"Number":"1002","API Relative Path":"javafx.scene.shape.QuadCurve.java-QuadCurve(double-double-double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of QuadCurve.\n     * @param startX the X coordinate of the start point\n     * @param startY the Y coordinate of the start point\n     * @param controlX the X coordinate of the control point\n     * @param controlY the Y coordinate of the control point\n     * @param endX the X coordinate of the end point\n     * @param endY the Y coordinate of the end point\n     */\n    public QuadCurve(double startX, double startY, double controlX, double controlY, double endX, double endY) {\n        setStartX(startX);\n        setStartY(startY);\n        setControlX(controlX);\n        setControlY(controlY);\n        setEndX(endX);\n        setEndY(endY);\n    }"}
{"Number":"1003","API Relative Path":"javafx.scene.shape.QuadCurveTo.java-QuadCurveTo(double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of QuadCurveTo.\n     * @param controlX the X coordinate of the quadratic control point\n     * @param controlY the Y coordinate of the quadratic control point\n     * @param x the X coordinate of the final end point\n     * @param y the Y coordinate of the final end point\n     */\n    public QuadCurveTo(double controlX, double controlY, double x, double y) {\n        setControlX(controlX);\n        setControlY(controlY);\n        setX(x);\n        setY(y);\n    }"}
{"Number":"1004","API Relative Path":"javafx.scene.shape.QuadCurveTo.java-QuadCurveTo(double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of QuadCurveTo.\n     * @param controlX the X coordinate of the quadratic control point\n     * @param controlY the Y coordinate of the quadratic control point\n     * @param x the X coordinate of the final end point\n     * @param y the Y coordinate of the final end point\n     */\n    public QuadCurveTo(double controlX, double controlY, double x, double y) {\n        setControlX(controlX);\n        setControlY(controlY);\n        setX(x);\n        setY(y);\n    }"}
{"Number":"1005","API Relative Path":"javafx.scene.shape.Rectangle.java-Rectangle(double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of Rectangle with the given position and size.\n     * @param x horizontal position of the rectangle\n     * @param y vertical position of the rectangle\n     * @param width width of the rectangle\n     * @param height height of the rectangle\n     */\n    public Rectangle(double x, double y, double width, double height) {\n        this(width, height);\n        setX(x);\n        setY(y);\n    }"}
{"Number":"1006","API Relative Path":"javafx.scene.shape.Rectangle.java-Rectangle(double-double-double-double)","Corresponding Source":"/**\n     * Creates a new instance of Rectangle with the given position and size.\n     * @param x horizontal position of the rectangle\n     * @param y vertical position of the rectangle\n     * @param width width of the rectangle\n     * @param height height of the rectangle\n     */\n    public Rectangle(double x, double y, double width, double height) {\n        this(width, height);\n        setX(x);\n        setY(y);\n    }"}
{"Number":"1007","API Relative Path":"javafx.scene.text.Text.java-impl_hitTestChar(Point2D)","Corresponding Source":"/**\n     * Maps local point to index in the content.\n     *\n     * @treatAsPrivate implementation detail\n     * @deprecated This is an internal API that is not intended\n     * for use and will be removed in the next version\n     */\n    @Deprecated\n    public final HitInfo impl_hitTestChar(Point2D point) {\n        if (point == null) return null;\n        TextLayout layout = getTextLayout();\n        double x = point.getX() - getX();\n        double y = point.getY() - getY() + getYRendering();\n        return layout.getHitInfo((float)x, (float)y);\n    }"}
{"Number":"1008","API Relative Path":"javafx.scene.transform.Affine.java-setElement(MatrixType-int-int-double)","Corresponding Source":"/**\n     * Sets the specified element of the transformation matrix.\n     * @param type type of matrix to work with\n     * @param row zero-based row number\n     * @param column zero-based column number\n     * @param value new value of the specified transformation matrix element\n     * @throws IndexOutOfBoundsException if the indices are not within\n     *         the specified matrix type\n     * @throws IllegalArgumentException if setting the value would break\n     *         transform's affinity (for convenience the method allows to set\n     *         the elements of the last line of a 2D 3x3 matrix to\n     *         {@code [0, 0, 1]} and the elements of the last line\n     *         of a 3D 4x4 matrix to {@code [0, 0, 0, 1]}).\n     * @throws NullPointerException if the specified {@code type} is null\n     * @since JavaFX 8.0\n     */\n    public void setElement(MatrixType type, int row, int column, double value) {\n        if (row < 0 || row >= type.rows() ||\n                column < 0 || column >= type.columns()) {\n            throw new IndexOutOfBoundsException(\"Index outside of affine \"\n                    + \"matrix \" + type + \": [\" + row + \", \" + column + \"]\");\n        }\n        switch(type) {\n            default:\n                stateError();\n                // cannot reach\n            case MT_2D_2x3:\n                // fall-through\n            case MT_2D_3x3:\n                if (!isType2D()) {\n                    throw new IllegalArgumentException(\"Cannot access 2D matrix \"\n                            + \"of a 3D transform\");\n                }\n                switch(row) {\n                    case 0:\n                        switch(column) {\n                            case 0: setMxx(value); return;\n                            case 1: setMxy(value); return;\n                            case 2: setTx(value); return;\n                        }\n                    case 1:\n                        switch(column) {\n                            case 0: setMyx(value); return;\n                            case 1: setMyy(value); return;\n                            case 2: setTy(value); return;\n                        }\n                    case 2:\n                        switch(column) {\n                            case 0: if (value == 0.0) return; else break;\n                            case 1: if (value == 0.0) return; else break;\n                            case 2: if (value == 1.0) return; else break;\n                        }\n                }\n                break;\n            case MT_3D_3x4:\n                // fall-through\n            case MT_3D_4x4:\n                switch(row) {\n                    case 0:\n                        switch(column) {\n                            case 0: setMxx(value); return;\n                            case 1: setMxy(value); return;\n                            case 2: setMxz(value); return;\n                            case 3: setTx(value); return;\n                        }\n                    case 1:\n                        switch(column) {\n                            case 0: setMyx(value); return;\n                            case 1: setMyy(value); return;\n                            case 2: setMyz(value); return;\n                            case 3: setTy(value); return;\n                        }\n                    case 2:\n                        switch(column) {\n                            case 0: setMzx(value); return;\n                            case 1: setMzy(value); return;\n                            case 2: setMzz(value); return;\n                            case 3: setTz(value); return;\n                        }\n                    case 3:\n                        switch(column) {\n                            case 0: if (value == 0.0) return; else break;\n                            case 1: if (value == 0.0) return; else break;\n                            case 2: if (value == 0.0) return; else break;\n                            case 3: if (value == 1.0) return; else break;\n                        }\n                }\n                break;\n        }\n        // reaches here when last line is set to something else than 0 .. 0 1\n        throw new IllegalArgumentException(\"Cannot set affine matrix \" + type +\n                \" element \" + \"[\" + row + \", \" + column + \"] to \" + value);\n    }"}
{"Number":"1009","API Relative Path":"javafx.scene.transform.Transform.java-column(MatrixType-int-double[])","Corresponding Source":"/**\n     * Returns an array containing a column of the transformation matrix.\n     * If the column of the requested matrix type fits in the specified array,\n     * it is returned therein. Otherwise, a new array is created.\n     * @param type matrix type whose column is to be filled in the array\n     * @param column zero-based index of the column\n     * @param array array into which the elements of the column are to be\n     *              stored, if it is non-null and big enough; otherwise,\n     *              a new array is created for this purpose.\n     * @return an array containing the requested column of the requested matrix\n     *         type representing this transform\n     * @throws IllegalArgumentException if a 2D matrix type is requested for\n     *         a 3D transform\n     * @throws IndexOutOfBoundsException if the {@code column} index\n     *         is not within the number of columns of the specified matrix type\n     * @throws NullPointerException if the specified {@code type} is null\n     * @since JavaFX 8.0\n     */\n    public double[] column(MatrixType type, int column, double[] array) {\n\n        checkRequestedMAT(type);\n\n        if (column < 0 || column >= type.columns()) {\n            throw new IndexOutOfBoundsException(\n                    \"Cannot get row \" + column + \" from \" + type);\n        }\n\n        if (array == null || array.length < type.rows()) {\n            array = new double[type.rows()];\n        }\n\n        switch(type) {\n            case MT_2D_2x3:\n                switch (column) {\n                    case 0:\n                        array[0] = getMxx();\n                        array[1] = getMyx();\n                        break;\n                    case 1:\n                        array[0] = getMxy();\n                        array[1] = getMyy();\n                        break;\n                    case 2:\n                        array[0] = getTx();\n                        array[1] = getTy();\n                        break;\n                }\n                break;\n            case MT_2D_3x3:\n                switch (column) {\n                    case 0:\n                        array[0] = getMxx();\n                        array[1] = getMyx();\n                        array[2] = 0.0;\n                        break;\n                    case 1:\n                        array[0] = getMxy();\n                        array[1] = getMyy();\n                        array[2] = 0.0;\n                        break;\n                    case 2:\n                        array[0] = getTx();\n                        array[1] = getTy();\n                        array[2] = 1.0;\n                        break;\n                }\n                break;\n            case MT_3D_3x4:\n                switch (column) {\n                    case 0:\n                        array[0] = getMxx();\n                        array[1] = getMyx();\n                        array[2] = getMzx();\n                        break;\n                    case 1:\n                        array[0] = getMxy();\n                        array[1] = getMyy();\n                        array[2] = getMzy();\n                        break;\n                    case 2:\n                        array[0] = getMxz();\n                        array[1] = getMyz();\n                        array[2] = getMzz();\n                        break;\n                    case 3:\n                        array[0] = getTx();\n                        array[1] = getTy();\n                        array[2] = getTz();\n                        break;\n                }\n                break;\n            case MT_3D_4x4:\n                switch (column) {\n                    case 0:\n                        array[0] = getMxx();\n                        array[1] = getMyx();\n                        array[2] = getMzx();\n                        array[3] = 0.0;\n                        break;\n                    case 1:\n                        array[0] = getMxy();\n                        array[1] = getMyy();\n                        array[2] = getMzy();\n                        array[3] = 0.0;\n                        break;\n                    case 2:\n                        array[0] = getMxz();\n                        array[1] = getMyz();\n                        array[2] = getMzz();\n                        array[3] = 0.0;\n                        break;\n                    case 3:\n                        array[0] = getTx();\n                        array[1] = getTy();\n                        array[2] = getTz();\n                        array[3] = 1.0;\n                        break;\n                }\n                break;\n            default:\n                throw new InternalError(\"Unsupported column \" + column + \" of \"\n                        + type);\n        }\n        return array;\n    }"}
{"Number":"1010","API Relative Path":"javafx.scene.transform.Transform.java-getElement(MatrixType-int-int)","Corresponding Source":"/**\n     * Gets the specified element of the transformation matrix.\n     * @param type type of matrix to get the value from\n     * @param row zero-based row number\n     * @param column zero-based column number\n     * @return value of the specified transformation matrix element\n     * @throws IllegalArgumentException if a 2D matrix type is requested for\n     *         a 3D transform\n     * @throws IndexOutOfBoundsException if the indices are not within\n     *         the specified matrix type\n     * @throws NullPointerException if the specified {@code type} is null\n     * @since JavaFX 8.0\n     */\n    public double getElement(MatrixType type, int row, int column) {\n        if (row < 0 || row >= type.rows() || column < 0 || column >= type.columns()) {\n            throw new IndexOutOfBoundsException(\"Index outside of affine \"\n                    + \"matrix \" + type + \": [\" + row + \", \" + column + \"]\");\n        }\n        switch(type) {\n            case MT_2D_2x3:\n                // fall-through\n            case MT_2D_3x3:\n                if (!isType2D()) {\n                    throw new IllegalArgumentException(\"Cannot access 2D matrix \"\n                            + \"of a 3D transform\");\n                }\n                switch(row) {\n                    case 0:\n                        switch(column) {\n                            case 0: return getMxx();\n                            case 1: return getMxy();\n                            case 2: return getTx();\n                        }\n                    case 1:\n                        switch(column) {\n                            case 0: return getMyx();\n                            case 1: return getMyy();\n                            case 2: return getTy();\n                        }\n                    case 2:\n                        switch(column) {\n                            case 0: return 0.0;\n                            case 1: return 0.0;\n                            case 2: return 1.0;\n                        }\n                }\n                break;\n            case MT_3D_3x4:\n                // fall-through\n            case MT_3D_4x4:\n                switch(row) {\n                    case 0:\n                        switch(column) {\n                            case 0: return getMxx();\n                            case 1: return getMxy();\n                            case 2: return getMxz();\n                            case 3: return getTx();\n                        }\n                    case 1:\n                        switch(column) {\n                            case 0: return getMyx();\n                            case 1: return getMyy();\n                            case 2: return getMyz();\n                            case 3: return getTy();\n                        }\n                    case 2:\n                        switch(column) {\n                            case 0: return getMzx();\n                            case 1: return getMzy();\n                            case 2: return getMzz();\n                            case 3: return getTz();\n                        }\n                    case 3:\n                        switch(column) {\n                            case 0: return 0.0;\n                            case 1: return 0.0;\n                            case 2: return 0.0;\n                            case 3: return 1.0;\n                        }\n                }\n                break;\n        }\n        // cannot reach here\n        throw new InternalError(\"Unsupported matrix type \" + type);\n    }"}
{"Number":"1011","API Relative Path":"javafx.scene.transform.Transform.java-inverseTransform2DPoints(double[]-int-double[]-int-int)","Corresponding Source":"/**\n     * Transforms an array of coordinates by the inverse of this transform.\n     * The two coordinate array sections can be exactly the same or\n     * can be overlapping sections of the same array without affecting the\n     * validity of the results.\n     * This method ensures that no source coordinates are overwritten by a\n     * previous operation before they can be transformed.\n     * The coordinates are stored in the arrays starting at the specified\n     * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]<\/code>.\n     * This method can be used only for 2D transforms.\n     * @param srcPts the array containing the source point coordinates.\n     * Each point is stored as a pair of x,&nbsp;y coordinates.\n     * @param srcOff the offset to the first point to be transformed\n     * in the source array\n     * @param dstPts the array into which the transformed point coordinates\n     * are returned.  Each point is stored as a pair of x,&nbsp;y\n     * coordinates.\n     * @param dstOff the offset to the location of the first\n     * transformed point that is stored in the destination array\n     * @param numPts the number of points to be transformed\n     * @throws IllegalStateException if this is a 3D transform\n     * @throws NonInvertibleTransformException if this transform\n     *         cannot be inverted\n     * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null\n     * @since JavaFX 8.0\n     */\n    public void inverseTransform2DPoints(double[] srcPts, int srcOff,\n                          double[] dstPts, int dstOff,\n                          int numPts) throws NonInvertibleTransformException{\n\n        if (srcPts == null || dstPts == null) {\n            throw new NullPointerException();\n        }\n\n        if (!isType2D()) {\n            throw new IllegalStateException(\"Cannot transform 2D points \"\n                    + \"with a 3D transform\");\n        }\n\n        // deal with overlapping arrays\n        srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 2);\n\n        // do the transformations\n        inverseTransform2DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);\n    }"}
{"Number":"1012","API Relative Path":"javafx.scene.transform.Transform.java-inverseTransform3DPoints(double[]-int-double[]-int-int)","Corresponding Source":"/**\n     * Transforms an array of floating point coordinates by the inverse\n     * of this transform.\n     * The three coordinate array sections can be exactly the same or\n     * can be overlapping sections of the same array without affecting the\n     * validity of the results.\n     * This method ensures that no source coordinates are overwritten by a\n     * previous operation before they can be transformed.\n     * The coordinates are stored in the arrays starting at the specified\n     * offset in the order <code>[x0, y0, z0, x1, y1, z1, ..., xn, yn, zn]<\/code>.\n     * @param srcPts the array containing the source point coordinates.\n     * Each point is stored as a triplet of x,&nbsp;y,&nbsp;z coordinates.\n     * @param srcOff the offset to the first point to be transformed\n     * in the source array\n     * @param dstPts the array into which the transformed point coordinates\n     * are returned.  Each point is stored as a triplet of x,&nbsp;y,&nbsp;z\n     * coordinates.\n     * @param dstOff the offset to the location of the first\n     * transformed point that is stored in the destination array\n     * @param numPts the number of points to be transformed\n     * @throws NonInvertibleTransformException if this transform\n     *         cannot be inverted\n     * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null\n     * @since JavaFX 8.0\n     */\n    public void inverseTransform3DPoints(double[] srcPts, int srcOff,\n                          double[] dstPts, int dstOff,\n                          int numPts) throws NonInvertibleTransformException {\n\n        if (srcPts == null || dstPts == null) {\n            throw new NullPointerException();\n        }\n\n        // deal with overlapping arrays\n        srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 3);\n\n        // do the transformations\n        inverseTransform3DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);\n    }"}
{"Number":"1013","API Relative Path":"javafx.scene.transform.Transform.java-row(MatrixType-int-double[])","Corresponding Source":"/**\n     * Returns an array containing a row of the transformation matrix.\n     * If the row of the requested matrix type fits in the specified array,\n     * it is returned therein. Otherwise, a new array is created.\n     * @param type matrix type whose row is to be filled in the array\n     * @param row zero-based index of the row\n     * @param array array into which the elements of the row are to be\n     *              stored, if it is non-null and big enough; otherwise,\n     *              a new array is created for this purpose.\n     * @return an array containing the requested row of the requested matrix\n     *         type representing this transform\n     * @throws IllegalArgumentException if a 2D matrix type is requested for\n     *         a 3D transform\n     * @throws IndexOutOfBoundsException if the {@code row} index is not within\n     *         the number of rows of the specified matrix type\n     * @throws NullPointerException if the specified {@code type} is null\n     * @since JavaFX 8.0\n     */\n    public double[] row(MatrixType type, int row, double[] array) {\n\n        checkRequestedMAT(type);\n\n        if (row < 0 || row >= type.rows()) {\n            throw new IndexOutOfBoundsException(\n                    \"Cannot get row \" + row + \" from \" + type);\n        }\n\n        if (array == null || array.length < type.columns()) {\n            array = new double[type.columns()];\n        }\n\n        switch(type) {\n            case MT_2D_2x3:\n            case MT_2D_3x3:\n                switch (row) {\n                    case 0:\n                        array[0] = getMxx();\n                        array[1] = getMxy();\n                        array[2] = getTx();\n                        break;\n                    case 1:\n                        array[0] = getMyx();\n                        array[1] = getMyy();\n                        array[2] = getTy();\n                        break;\n                    case 2:\n                        array[0] = 0.0;\n                        array[1] = 0.0;\n                        array[2] = 1.0;\n                        break;\n                }\n                break;\n            case MT_3D_3x4:\n            case MT_3D_4x4:\n                switch (row) {\n                    case 0:\n                        array[0] = getMxx();\n                        array[1] = getMxy();\n                        array[2] = getMxz();\n                        array[3] = getTx();\n                        break;\n                    case 1:\n                        array[0] = getMyx();\n                        array[1] = getMyy();\n                        array[2] = getMyz();\n                        array[3] = getTy();\n                        break;\n                    case 2:\n                        array[0] = getMzx();\n                        array[1] = getMzy();\n                        array[2] = getMzz();\n                        array[3] = getTz();\n                        break;\n                    case 3:\n                        array[0] = 0.0;\n                        array[1] = 0.0;\n                        array[2] = 0.0;\n                        array[3] = 1.0;\n                        break;\n                }\n                break;\n            default:\n                throw new InternalError(\"Unsupported row \" + row + \" of \" + type);\n        }\n        return array;\n    }"}
{"Number":"1014","API Relative Path":"javafx.scene.transform.Transform.java-transform2DPoints(double[]-int-double[]-int-int)","Corresponding Source":"/**\n     * Transforms an array of coordinates by the inverse of this transform.\n     * The two coordinate array sections can be exactly the same or\n     * can be overlapping sections of the same array without affecting the\n     * validity of the results.\n     * This method ensures that no source coordinates are overwritten by a\n     * previous operation before they can be transformed.\n     * The coordinates are stored in the arrays starting at the specified\n     * offset in the order <code>[x0, y0, x1, y1, ..., xn, yn]<\/code>.\n     * This method can be used only for 2D transforms.\n     * @param srcPts the array containing the source point coordinates.\n     * Each point is stored as a pair of x,&nbsp;y coordinates.\n     * @param srcOff the offset to the first point to be transformed\n     * in the source array\n     * @param dstPts the array into which the transformed point coordinates\n     * are returned.  Each point is stored as a pair of x,&nbsp;y\n     * coordinates.\n     * @param dstOff the offset to the location of the first\n     * transformed point that is stored in the destination array\n     * @param numPts the number of points to be transformed\n     * @throws IllegalStateException if this is a 3D transform\n     * @throws NonInvertibleTransformException if this transform\n     *         cannot be inverted\n     * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null\n     * @since JavaFX 8.0\n     */\n    public void inverseTransform2DPoints(double[] srcPts, int srcOff,\n                          double[] dstPts, int dstOff,\n                          int numPts) throws NonInvertibleTransformException{\n\n        if (srcPts == null || dstPts == null) {\n            throw new NullPointerException();\n        }\n\n        if (!isType2D()) {\n            throw new IllegalStateException(\"Cannot transform 2D points \"\n                    + \"with a 3D transform\");\n        }\n\n        // deal with overlapping arrays\n        srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 2);\n\n        // do the transformations\n        inverseTransform2DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);\n    }"}
{"Number":"1015","API Relative Path":"javafx.scene.transform.Transform.java-transform3DPoints(double[]-int-double[]-int-int)","Corresponding Source":"/**\n     * Transforms an array of floating point coordinates by the inverse\n     * of this transform.\n     * The three coordinate array sections can be exactly the same or\n     * can be overlapping sections of the same array without affecting the\n     * validity of the results.\n     * This method ensures that no source coordinates are overwritten by a\n     * previous operation before they can be transformed.\n     * The coordinates are stored in the arrays starting at the specified\n     * offset in the order <code>[x0, y0, z0, x1, y1, z1, ..., xn, yn, zn]<\/code>.\n     * @param srcPts the array containing the source point coordinates.\n     * Each point is stored as a triplet of x,&nbsp;y,&nbsp;z coordinates.\n     * @param srcOff the offset to the first point to be transformed\n     * in the source array\n     * @param dstPts the array into which the transformed point coordinates\n     * are returned.  Each point is stored as a triplet of x,&nbsp;y,&nbsp;z\n     * coordinates.\n     * @param dstOff the offset to the location of the first\n     * transformed point that is stored in the destination array\n     * @param numPts the number of points to be transformed\n     * @throws NonInvertibleTransformException if this transform\n     *         cannot be inverted\n     * @throws NullPointerException if {@code srcPts} or (@code dstPts} is null\n     * @since JavaFX 8.0\n     */\n    public void inverseTransform3DPoints(double[] srcPts, int srcOff,\n                          double[] dstPts, int dstOff,\n                          int numPts) throws NonInvertibleTransformException {\n\n        if (srcPts == null || dstPts == null) {\n            throw new NullPointerException();\n        }\n\n        // deal with overlapping arrays\n        srcOff = getFixedSrcOffset(srcPts, srcOff, dstPts, dstOff, numPts, 3);\n\n        // do the transformations\n        inverseTransform3DPointsImpl(srcPts, srcOff, dstPts, dstOff, numPts);\n    }"}
{"Number":"1016","API Relative Path":"javafx.util.converter.BigDecimalStringConverter.java-fromString(String)","Corresponding Source":"/** {@inheritDoc} */\n    @Override public BigDecimal fromString(String value) {\n        // If the specified value is null or zero-length, return null\n        if (value == null) {\n            return null;\n        }\n\n        value = value.trim();\n\n        if (value.length() < 1) {\n            return null;\n        }\n\n        return new BigDecimal(value);\n    }"}
{"Number":"1017","API Relative Path":"javafx.util.converter.BigIntegerStringConverter.java-fromString(String)","Corresponding Source":"/** {@inheritDoc} */\n    @Override public BigInteger fromString(String value) {\n        // If the specified value is null or zero-length, return null\n        if (value == null) {\n            return null;\n        }\n\n        value = value.trim();\n\n        if (value.length() < 1) {\n            return null;\n        }\n\n        return new BigInteger(value);\n    }"}
{"Number":"1018","API Relative Path":"javafx.util.converter.BooleanStringConverter.java-fromString(String)","Corresponding Source":"/** {@inheritDoc} */\n    @Override public Boolean fromString(String value) {\n        // If the specified value is null or zero-length, return null\n        if (value == null) {\n            return null;\n        }\n\n        value = value.trim();\n\n        if (value.length() < 1) {\n            return null;\n        }\n\n        return Boolean.valueOf(value);\n    }"}
{"Number":"1019","API Relative Path":"javafx.util.converter.ByteStringConverter.java-fromString(String)","Corresponding Source":"/** {@inheritDoc} */\n    @Override public Byte fromString(String value) {\n        // If the specified value is null or zero-length, return null\n        if (value == null) {\n            return null;\n        }\n\n        value = value.trim();\n\n        if (value.length() < 1) {\n            return null;\n        }\n\n        return Byte.valueOf(value);\n    }"}
{"Number":"1020","API Relative Path":"javafx.util.converter.CharacterStringConverter.java-fromString(String)","Corresponding Source":"/** {@inheritDoc} */\n    @Override public Character fromString(String value) {\n        // If the specified value is null or zero-length, return null\n        if (value == null) {\n            return null;\n        }\n\n        value = value.trim();\n\n        if (value.length() < 1) {\n            return null;\n        }\n\n        return Character.valueOf(value.charAt(0));\n    }"}
{"Number":"1021","API Relative Path":"javafx.util.converter.DoubleStringConverter.java-fromString(String)","Corresponding Source":"/** {@inheritDoc} */\n    @Override public Double fromString(String value) {\n        // If the specified value is null or zero-length, return null\n        if (value == null) {\n            return null;\n        }\n\n        value = value.trim();\n\n        if (value.length() < 1) {\n            return null;\n        }\n\n        return Double.valueOf(value);\n    }"}
{"Number":"1022","API Relative Path":"javafx.util.converter.FloatStringConverter.java-fromString(String)","Corresponding Source":"/** {@inheritDoc} */\n    @Override public Float fromString(String value) {\n        // If the specified value is null or zero-length, return null\n        if (value == null) {\n            return null;\n        }\n\n        value = value.trim();\n\n        if (value.length() < 1) {\n            return null;\n        }\n\n        return Float.valueOf(value);\n    }"}
{"Number":"1023","API Relative Path":"javafx.util.converter.FormatStringConverter.java-fromString(String)","Corresponding Source":"// ------------------------------------------------------- Converter Methods\n\n    /** {@inheritDoc} */\n    @Override public T fromString(String value) {\n        // If the specified value is null or zero-length, return null\n        if (value == null) {\n            return null;\n        }\n\n        value = value.trim();\n\n        if (value.length() < 1) {\n            return null;\n        }\n\n        // Create and configure the parser to be used\n        Format _format = getFormat();\n\n        // Perform the requested parsing, and attempt to conver the output\n        // back to T\n        final ParsePosition pos = new ParsePosition(0);\n        T result = (T) _format.parseObject(value, pos);\n        if (pos.getIndex() != value.length()) {\n            throw new RuntimeException(\"Parsed string not according to the format\");\n        }\n        return result;\n    }"}
{"Number":"1024","API Relative Path":"javafx.util.converter.IntegerStringConverter.java-fromString(String)","Corresponding Source":"/** {@inheritDoc} */\n    @Override public Integer fromString(String value) {\n        // If the specified value is null or zero-length, return null\n        if (value == null) {\n            return null;\n        }\n\n        value = value.trim();\n\n        if (value.length() < 1) {\n            return null;\n        }\n\n        return Integer.valueOf(value);\n    }"}
{"Number":"1025","API Relative Path":"javafx.util.converter.LongStringConverter.java-fromString(String)","Corresponding Source":"/** {@inheritDoc} */\n    @Override public Long fromString(String value) {\n        // If the specified value is null or zero-length, return null\n        if (value == null) {\n            return null;\n        }\n\n        value = value.trim();\n\n        if (value.length() < 1) {\n            return null;\n        }\n\n        return Long.valueOf(value);\n    }"}
{"Number":"1026","API Relative Path":"javafx.util.converter.ShortStringConverter.java-fromString(String)","Corresponding Source":"/** {@inheritDoc} */\n    @Override public Short fromString(String text) {\n        // If the specified value is null or zero-length, return null\n        if (text == null) {\n            return null;\n        }\n\n        text = text.trim();\n\n        if (text.length() < 1) {\n            return null;\n        }\n\n        return Short.valueOf(text);\n    }"}
{"Number":"1027","API Relative Path":"javax.swing.AbstractAction.java-firePropertyChange(String-Object-Object)","Corresponding Source":"/**\n     * Supports reporting bound property changes.  This method can be called\n     * when a bound property has changed and it will send the appropriate\n     * <code>PropertyChangeEvent<\/code> to any registered\n     * <code>PropertyChangeListeners<\/code>.\n     */\n    protected void firePropertyChange(String propertyName, Object oldValue, Object newValue) {\n        if (changeSupport == null ||\n            (oldValue != null && newValue != null && oldValue.equals(newValue))) {\n            return;\n        }\n        changeSupport.firePropertyChange(propertyName, oldValue, newValue);\n    }"}
{"Number":"1028","API Relative Path":"javax.swing.AbstractAction.java-putValue(String-Object)","Corresponding Source":"/**\n     * Sets the <code>Value<\/code> associated with the specified key.\n     *\n     * @param key  the <code>String<\/code> that identifies the stored object\n     * @param newValue the <code>Object<\/code> to store using this key\n     * @see Action#putValue\n     */\n    public void putValue(String key, Object newValue) {\n        Object oldValue = null;\n        if (key == \"enabled\") {\n            // Treat putValue(\"enabled\") the same way as a call to setEnabled.\n            // If we don't do this it means the two may get out of sync, and a\n            // bogus property change notification would be sent.\n            //\n            // To avoid dependencies between putValue & setEnabled this\n            // directly changes enabled. If we instead called setEnabled\n            // to change enabled, it would be possible for stack\n            // overflow in the case where a developer implemented setEnabled\n            // in terms of putValue.\n            if (newValue == null || !(newValue instanceof Boolean)) {\n                newValue = false;\n            }\n            oldValue = enabled;\n            enabled = (Boolean)newValue;\n        } else {\n            if (arrayTable == null) {\n                arrayTable = new ArrayTable();\n            }\n            if (arrayTable.containsKey(key))\n                oldValue = arrayTable.get(key);\n            // Remove the entry for key if newValue is null\n            // else put in the newValue for key.\n            if (newValue == null) {\n                arrayTable.remove(key);\n            } else {\n                arrayTable.put(key,newValue);\n            }\n        }\n        firePropertyChange(key, oldValue, newValue);\n    }"}
{"Number":"1029","API Relative Path":"javax.swing.AbstractButton.java-addActionListener(ActionListener)","Corresponding Source":"/**\n     * Adds an <code>ActionListener<\/code> to the button.\n     * @param l the <code>ActionListener<\/code> to be added\n     */\n    public void addActionListener(ActionListener l) {\n        listenerList.add(ActionListener.class, l);\n    }"}
{"Number":"1030","API Relative Path":"javax.swing.AbstractButton.java-addChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Adds a <code>ChangeListener<\/code> to the button.\n     * @param l the listener to be added\n     */\n    public void addChangeListener(ChangeListener l) {\n        listenerList.add(ChangeListener.class, l);\n    }"}
{"Number":"1031","API Relative Path":"javax.swing.AbstractButton.java-addItemListener(ItemListener)","Corresponding Source":"/**\n     * Adds an <code>ItemListener<\/code> to the <code>checkbox<\/code>.\n     * @param l  the <code>ItemListener<\/code> to be added\n     */\n    public void addItemListener(ItemListener l) {\n        listenerList.add(ItemListener.class, l);\n    }"}
{"Number":"1032","API Relative Path":"javax.swing.AbstractButton.java-checkHorizontalKey(int-String)","Corresponding Source":"/**\n     * Verify that the {@code key} argument is a legal value for the\n     * {@code horizontalAlignment} and {@code horizontalTextPosition}\n     * properties. Valid values are:\n     * <ul>\n     *   <li>{@code SwingConstants.RIGHT}\n     *   <li>{@code SwingConstants.LEFT}\n     *   <li>{@code SwingConstants.CENTER}\n     *   <li>{@code SwingConstants.LEADING}\n     *   <li>{@code SwingConstants.TRAILING}\n     * <\/ul>\n     *\n     * @param key the property value to check\n     * @param exception the message to use in the\n     *        {@code IllegalArgumentException} that is thrown for an invalid\n     *        value\n     * @return the {@code key} argument\n     * @exception IllegalArgumentException if key is not one of the legal\n     *            values listed above\n     * @see #setHorizontalTextPosition\n     * @see #setHorizontalAlignment\n     */\n    protected int checkHorizontalKey(int key, String exception) {\n        if ((key == LEFT) ||\n            (key == CENTER) ||\n            (key == RIGHT) ||\n            (key == LEADING) ||\n            (key == TRAILING)) {\n            return key;\n        } else {\n            throw new IllegalArgumentException(exception);\n        }\n    }"}
{"Number":"1033","API Relative Path":"javax.swing.AbstractButton.java-checkVerticalKey(int-String)","Corresponding Source":"/**\n     * Verify that the {@code key} argument is a legal value for the\n     * vertical properties. Valid values are:\n     * <ul>\n     *   <li>{@code SwingConstants.CENTER}\n     *   <li>{@code SwingConstants.TOP}\n     *   <li>{@code SwingConstants.BOTTOM}\n     * <\/ul>\n     *\n     * @param key the property value to check\n     * @param exception the message to use in the\n     *        {@code IllegalArgumentException} that is thrown for an invalid\n     *        value\n     * @return the {@code key} argument\n     * @exception IllegalArgumentException if key is not one of the legal\n     *            values listed above\n     */\n    protected int checkVerticalKey(int key, String exception) {\n        if ((key == TOP) || (key == CENTER) || (key == BOTTOM)) {\n            return key;\n        } else {\n            throw new IllegalArgumentException(exception);\n        }\n    }"}
{"Number":"1034","API Relative Path":"javax.swing.AbstractButton.java-removeActionListener(ActionListener)","Corresponding Source":"/**\n     * Removes an <code>ActionListener<\/code> from the button.\n     * If the listener is the currently set <code>Action<\/code>\n     * for the button, then the <code>Action<\/code>\n     * is set to <code>null<\/code>.\n     *\n     * @param l the listener to be removed\n     */\n    public void removeActionListener(ActionListener l) {\n        if ((l != null) && (getAction() == l)) {\n            setAction(null);\n        } else {\n            listenerList.remove(ActionListener.class, l);\n        }\n    }"}
{"Number":"1035","API Relative Path":"javax.swing.AbstractButton.java-removeChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Removes a ChangeListener from the button.\n     * @param l the listener to be removed\n     */\n    public void removeChangeListener(ChangeListener l) {\n        listenerList.remove(ChangeListener.class, l);\n    }"}
{"Number":"1036","API Relative Path":"javax.swing.AbstractButton.java-removeItemListener(ItemListener)","Corresponding Source":"/**\n     * Removes an <code>ItemListener<\/code> from the button.\n     * @param l the <code>ItemListener<\/code> to be removed\n     */\n    public void removeItemListener(ItemListener l) {\n        listenerList.remove(ItemListener.class, l);\n    }"}
{"Number":"1037","API Relative Path":"javax.swing.AbstractButton.java-setAction(Action)","Corresponding Source":"/**\n     * Sets the <code>Action<\/code>.\n     * The new <code>Action<\/code> replaces any previously set\n     * <code>Action<\/code> but does not affect <code>ActionListeners<\/code>\n     * independently added with <code>addActionListener<\/code>.\n     * If the <code>Action<\/code> is already a registered\n     * <code>ActionListener<\/code> for the button, it is not re-registered.\n     * <p>\n     * Setting the <code>Action<\/code> results in immediately changing\n     * all the properties described in <a href=\"Action.html#buttonActions\">\n     * Swing Components Supporting <code>Action<\/code><\/a>.\n     * Subsequently, the button's properties are automatically updated\n     * as the <code>Action<\/code>'s properties change.\n     * <p>\n     * This method uses three other methods to set\n     * and help track the <code>Action<\/code>'s property values.\n     * It uses the <code>configurePropertiesFromAction<\/code> method\n     * to immediately change the button's properties.\n     * To track changes in the <code>Action<\/code>'s property values,\n     * this method registers the <code>PropertyChangeListener<\/code>\n     * returned by <code>createActionPropertyChangeListener<\/code>. The\n     * default {@code PropertyChangeListener} invokes the\n     * {@code actionPropertyChanged} method when a property in the\n     * {@code Action} changes.\n     *\n     * @param a the <code>Action<\/code> for the <code>AbstractButton<\/code>,\n     *          or <code>null<\/code>\n     * @since 1.3\n     * @see Action\n     * @see #getAction\n     * @see #configurePropertiesFromAction\n     * @see #createActionPropertyChangeListener\n     * @see #actionPropertyChanged\n     * @beaninfo\n     *        bound: true\n     *    attribute: visualUpdate true\n     *  description: the Action instance connected with this ActionEvent source\n     */\n    public void setAction(Action a) {\n        Action oldValue = getAction();\n        if (action==null || !action.equals(a)) {\n            action = a;\n            if (oldValue!=null) {\n                removeActionListener(oldValue);\n                oldValue.removePropertyChangeListener(actionPropertyChangeListener);\n                actionPropertyChangeListener = null;\n            }\n            configurePropertiesFromAction(action);\n            if (action!=null) {\n                // Don't add if it is already a listener\n                if (!isListener(ActionListener.class, action)) {\n                    addActionListener(action);\n                }\n                // Reverse linkage:\n                actionPropertyChangeListener = createActionPropertyChangeListener(action);\n                action.addPropertyChangeListener(actionPropertyChangeListener);\n            }\n            firePropertyChange(\"action\", oldValue, action);\n        }\n    }"}
{"Number":"1038","API Relative Path":"javax.swing.AbstractButton.java-setDisplayedMnemonicIndex(int)","Corresponding Source":"/**\n     * Provides a hint to the look and feel as to which character in the\n     * text should be decorated to represent the mnemonic. Not all look and\n     * feels may support this. A value of -1 indicates either there is no\n     * mnemonic, the mnemonic character is not contained in the string, or\n     * the developer does not wish the mnemonic to be displayed.\n     * <p>\n     * The value of this is updated as the properties relating to the\n     * mnemonic change (such as the mnemonic itself, the text...).\n     * You should only ever have to call this if\n     * you do not wish the default character to be underlined. For example, if\n     * the text was 'Save As', with a mnemonic of 'a', and you wanted the 'A'\n     * to be decorated, as 'Save <u>A<\/u>s', you would have to invoke\n     * <code>setDisplayedMnemonicIndex(5)<\/code> after invoking\n     * <code>setMnemonic(KeyEvent.VK_A)<\/code>.\n     *\n     * @since 1.4\n     * @param index Index into the String to underline\n     * @exception IllegalArgumentException will be thrown if <code>index<\/code>\n     *            is &gt;= length of the text, or &lt; -1\n     * @see #getDisplayedMnemonicIndex\n     *\n     * @beaninfo\n     *        bound: true\n     *    attribute: visualUpdate true\n     *  description: the index into the String to draw the keyboard character\n     *               mnemonic at\n     */\n    public void setDisplayedMnemonicIndex(int index)\n                                          throws IllegalArgumentException {\n        int oldValue = mnemonicIndex;\n        if (index == -1) {\n            mnemonicIndex = -1;\n        } else {\n            String text = getText();\n            int textLength = (text == null) ? 0 : text.length();\n            if (index < -1 || index >= textLength) {  // index out of range\n                throw new IllegalArgumentException(\"index == \" + index);\n            }\n        }\n        mnemonicIndex = index;\n        firePropertyChange(\"displayedMnemonicIndex\", oldValue, index);\n        if (index != oldValue) {\n            revalidate();\n            repaint();\n        }\n    }"}
{"Number":"1039","API Relative Path":"javax.swing.AbstractButton.java-setHorizontalAlignment(int)","Corresponding Source":"/**\n     * Sets the horizontal alignment of the icon and text.\n     * {@code AbstractButton}'s default is {@code SwingConstants.CENTER},\n     * but subclasses such as {@code JCheckBox} may use a different default.\n     *\n     * @param alignment the alignment value, one of the following values:\n     * <ul>\n     *   <li>{@code SwingConstants.RIGHT}\n     *   <li>{@code SwingConstants.LEFT}\n     *   <li>{@code SwingConstants.CENTER}\n     *   <li>{@code SwingConstants.LEADING}\n     *   <li>{@code SwingConstants.TRAILING}\n     * <\/ul>\n     * @throws IllegalArgumentException if the alignment is not one of the\n     *         valid values\n     * @beaninfo\n     *        bound: true\n     *         enum: LEFT     SwingConstants.LEFT\n     *               CENTER   SwingConstants.CENTER\n     *               RIGHT    SwingConstants.RIGHT\n     *               LEADING  SwingConstants.LEADING\n     *               TRAILING SwingConstants.TRAILING\n     *    attribute: visualUpdate true\n     *  description: The horizontal alignment of the icon and text.\n     */\n    public void setHorizontalAlignment(int alignment) {\n        if (alignment == horizontalAlignment) return;\n        int oldValue = horizontalAlignment;\n        horizontalAlignment = checkHorizontalKey(alignment,\n                                                 \"horizontalAlignment\");\n        firePropertyChange(HORIZONTAL_ALIGNMENT_CHANGED_PROPERTY,\n                           oldValue, horizontalAlignment);\n        repaint();\n    }"}
{"Number":"1040","API Relative Path":"javax.swing.AbstractButton.java-setHorizontalTextPosition(int)","Corresponding Source":"/**\n     * Sets the horizontal position of the text relative to the icon.\n     * @param textPosition one of the following values:\n     * <ul>\n     * <li>{@code SwingConstants.RIGHT}\n     * <li>{@code SwingConstants.LEFT}\n     * <li>{@code SwingConstants.CENTER}\n     * <li>{@code SwingConstants.LEADING}\n     * <li>{@code SwingConstants.TRAILING} (the default)\n     * <\/ul>\n     * @exception IllegalArgumentException if <code>textPosition<\/code>\n     *          is not one of the legal values listed above\n     * @beaninfo\n     *        bound: true\n     *         enum: LEFT     SwingConstants.LEFT\n     *               CENTER   SwingConstants.CENTER\n     *               RIGHT    SwingConstants.RIGHT\n     *               LEADING  SwingConstants.LEADING\n     *               TRAILING SwingConstants.TRAILING\n     *    attribute: visualUpdate true\n     *  description: The horizontal position of the text relative to the icon.\n     */\n    public void setHorizontalTextPosition(int textPosition) {\n        if (textPosition == horizontalTextPosition) return;\n        int oldValue = horizontalTextPosition;\n        horizontalTextPosition = checkHorizontalKey(textPosition,\n                                                    \"horizontalTextPosition\");\n        firePropertyChange(HORIZONTAL_TEXT_POSITION_CHANGED_PROPERTY,\n                           oldValue,\n                           horizontalTextPosition);\n        revalidate();\n        repaint();\n    }"}
{"Number":"1041","API Relative Path":"javax.swing.AbstractButton.java-setVerticalAlignment(int)","Corresponding Source":"/**\n     * Sets the vertical alignment of the icon and text.\n     * @param alignment one of the following values:\n     * <ul>\n     * <li>{@code SwingConstants.CENTER} (the default)\n     * <li>{@code SwingConstants.TOP}\n     * <li>{@code SwingConstants.BOTTOM}\n     * <\/ul>\n     * @throws IllegalArgumentException if the alignment is not one of the legal\n     *         values listed above\n     * @beaninfo\n     *        bound: true\n     *         enum: TOP    SwingConstants.TOP\n     *               CENTER SwingConstants.CENTER\n     *               BOTTOM  SwingConstants.BOTTOM\n     *    attribute: visualUpdate true\n     *  description: The vertical alignment of the icon and text.\n     */\n    public void setVerticalAlignment(int alignment) {\n        if (alignment == verticalAlignment) return;\n        int oldValue = verticalAlignment;\n        verticalAlignment = checkVerticalKey(alignment, \"verticalAlignment\");\n        firePropertyChange(VERTICAL_ALIGNMENT_CHANGED_PROPERTY, oldValue, verticalAlignment);         repaint();\n    }"}
{"Number":"1042","API Relative Path":"javax.swing.AbstractButton.java-setVerticalTextPosition(int)","Corresponding Source":"/**\n     * Sets the vertical position of the text relative to the icon.\n     * @param textPosition  one of the following values:\n     * <ul>\n     * <li>{@code SwingConstants.CENTER} (the default)\n     * <li>{@code SwingConstants.TOP}\n     * <li>{@code SwingConstants.BOTTOM}\n     * <\/ul>\n     * @beaninfo\n     *        bound: true\n     *         enum: TOP    SwingConstants.TOP\n     *               CENTER SwingConstants.CENTER\n     *               BOTTOM SwingConstants.BOTTOM\n     *    attribute: visualUpdate true\n     *  description: The vertical position of the text relative to the icon.\n     */\n    public void setVerticalTextPosition(int textPosition) {\n        if (textPosition == verticalTextPosition) return;\n        int oldValue = verticalTextPosition;\n        verticalTextPosition = checkVerticalKey(textPosition, \"verticalTextPosition\");\n        firePropertyChange(VERTICAL_TEXT_POSITION_CHANGED_PROPERTY, oldValue, verticalTextPosition);\n        revalidate();\n        repaint();\n    }"}
{"Number":"1043","API Relative Path":"javax.swing.AbstractCellEditor.java-addCellEditorListener(CellEditorListener)","Corresponding Source":"/**\n     * Adds a <code>CellEditorListener<\/code> to the listener list.\n     * @param l  the new listener to be added\n     */\n    public void addCellEditorListener(CellEditorListener l) {\n        listenerList.add(CellEditorListener.class, l);\n    }"}
{"Number":"1044","API Relative Path":"javax.swing.AbstractCellEditor.java-removeCellEditorListener(CellEditorListener)","Corresponding Source":"/**\n     * Removes a <code>CellEditorListener<\/code> from the listener list.\n     * @param l  the listener to be removed\n     */\n    public void removeCellEditorListener(CellEditorListener l) {\n        listenerList.remove(CellEditorListener.class, l);\n    }"}
{"Number":"1045","API Relative Path":"javax.swing.AbstractListModel.java-addListDataListener(ListDataListener)","Corresponding Source":"/**\n     * Adds a listener to the list that's notified each time a change\n     * to the data model occurs.\n     *\n     * @param l the <code>ListDataListener<\/code> to be added\n     */\n    public void addListDataListener(ListDataListener l) {\n        listenerList.add(ListDataListener.class, l);\n    }"}
{"Number":"1046","API Relative Path":"javax.swing.AbstractListModel.java-removeListDataListener(ListDataListener)","Corresponding Source":"/**\n     * Removes a listener from the list that's notified each time a\n     * change to the data model occurs.\n     *\n     * @param l the <code>ListDataListener<\/code> to be removed\n     */\n    public void removeListDataListener(ListDataListener l) {\n        listenerList.remove(ListDataListener.class, l);\n    }"}
{"Number":"1047","API Relative Path":"javax.swing.AbstractSpinnerModel.java-addChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Adds a ChangeListener to the model's listener list.  The\n     * ChangeListeners must be notified when the models value changes.\n     *\n     * @param l the ChangeListener to add\n     * @see #removeChangeListener\n     * @see SpinnerModel#addChangeListener\n     */\n    public void addChangeListener(ChangeListener l) {\n        listenerList.add(ChangeListener.class, l);\n    }"}
{"Number":"1048","API Relative Path":"javax.swing.AbstractSpinnerModel.java-removeChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Removes a ChangeListener from the model's listener list.\n     *\n     * @param l the ChangeListener to remove\n     * @see #addChangeListener\n     * @see SpinnerModel#removeChangeListener\n     */\n    public void removeChangeListener(ChangeListener l) {\n        listenerList.remove(ChangeListener.class, l);\n    }"}
{"Number":"1049","API Relative Path":"javax.swing.ActionMap.java-put(Object-Action)","Corresponding Source":"/**\n     * Adds a binding for <code>key<\/code> to <code>action<\/code>.\n     * If <code>action<\/code> is null, this removes the current binding\n     * for <code>key<\/code>.\n     * <p>In most instances, <code>key<\/code> will be\n     * <code>action.getValue(NAME)<\/code>.\n     */\n    public void put(Object key, Action action) {\n        if (key == null) {\n            return;\n        }\n        if (action == null) {\n            remove(key);\n        }\n        else {\n            if (arrayTable == null) {\n                arrayTable = new ArrayTable();\n            }\n            arrayTable.put(key, action);\n        }\n    }"}
{"Number":"1050","API Relative Path":"javax.swing.border.AbstractBorder.java-getBaselineResizeBehavior(Component)","Corresponding Source":"/**\n     * Returns an enum indicating how the baseline of a component\n     * changes as the size changes.  This method is primarily meant for\n     * layout managers and GUI builders.\n     * <p>\n     * The default implementation returns\n     * <code>BaselineResizeBehavior.OTHER<\/code>, subclasses that support\n     * baseline should override appropriately.  Subclasses should\n     * never return <code>null<\/code>; if the baseline can not be\n     * calculated return <code>BaselineResizeBehavior.OTHER<\/code>.  Callers\n     * should first ask for the baseline using\n     * <code>getBaseline<\/code> and if a value &gt;= 0 is returned use\n     * this method.  It is acceptable for this method to return a\n     * value other than <code>BaselineResizeBehavior.OTHER<\/code> even if\n     * <code>getBaseline<\/code> returns a value less than 0.\n     *\n     * @param c <code>Component<\/code> to return baseline resize behavior for\n     * @return an enum indicating how the baseline changes as the border is\n     *         resized\n     * @see java.awt.Component#getBaseline(int,int)\n     * @see java.awt.Component#getBaselineResizeBehavior()\n     * @since 1.6\n     */\n    public Component.BaselineResizeBehavior getBaselineResizeBehavior(\n            Component c) {\n        if (c == null) {\n            throw new NullPointerException(\"Component must be non-null\");\n        }\n        return Component.BaselineResizeBehavior.OTHER;\n    }"}
{"Number":"1051","API Relative Path":"javax.swing.border.TitledBorder.java-getBaseline(Component-int-int)","Corresponding Source":"/**\n     * Returns the baseline.\n     *\n     * @throws NullPointerException {@inheritDoc}\n     * @throws IllegalArgumentException {@inheritDoc}\n     * @see javax.swing.JComponent#getBaseline(int, int)\n     * @since 1.6\n     */\n    public int getBaseline(Component c, int width, int height) {\n        if (c == null) {\n            throw new NullPointerException(\"Must supply non-null component\");\n        }\n        if (width < 0) {\n            throw new IllegalArgumentException(\"Width must be >= 0\");\n        }\n        if (height < 0) {\n            throw new IllegalArgumentException(\"Height must be >= 0\");\n        }\n        Border border = getBorder();\n        String title = getTitle();\n        if ((title != null) && !title.isEmpty()) {\n            int edge = (border instanceof TitledBorder) ? 0 : EDGE_SPACING;\n            JLabel label = getLabel(c);\n            Dimension size = label.getPreferredSize();\n            Insets insets = getBorderInsets(border, c, new Insets(0, 0, 0, 0));\n\n            int baseline = label.getBaseline(size.width, size.height);\n            switch (getPosition()) {\n                case ABOVE_TOP:\n                    return baseline;\n                case TOP:\n                    insets.top = edge + (insets.top - size.height) / 2;\n                    return (insets.top < edge)\n                            ? baseline\n                            : baseline + insets.top;\n                case BELOW_TOP:\n                    return baseline + insets.top + edge;\n                case ABOVE_BOTTOM:\n                    return baseline + height - size.height - insets.bottom - edge;\n                case BOTTOM:\n                    insets.bottom = edge + (insets.bottom - size.height) / 2;\n                    return (insets.bottom < edge)\n                            ? baseline + height - size.height\n                            : baseline + height - size.height + insets.bottom;\n                case BELOW_BOTTOM:\n                    return baseline + height - size.height;\n            }\n        }\n        return -1;\n    }"}
{"Number":"1052","API Relative Path":"javax.swing.border.TitledBorder.java-getBaseline(Component-int-int)","Corresponding Source":"/**\n     * Returns the baseline.\n     *\n     * @throws NullPointerException {@inheritDoc}\n     * @throws IllegalArgumentException {@inheritDoc}\n     * @see javax.swing.JComponent#getBaseline(int, int)\n     * @since 1.6\n     */\n    public int getBaseline(Component c, int width, int height) {\n        if (c == null) {\n            throw new NullPointerException(\"Must supply non-null component\");\n        }\n        if (width < 0) {\n            throw new IllegalArgumentException(\"Width must be >= 0\");\n        }\n        if (height < 0) {\n            throw new IllegalArgumentException(\"Height must be >= 0\");\n        }\n        Border border = getBorder();\n        String title = getTitle();\n        if ((title != null) && !title.isEmpty()) {\n            int edge = (border instanceof TitledBorder) ? 0 : EDGE_SPACING;\n            JLabel label = getLabel(c);\n            Dimension size = label.getPreferredSize();\n            Insets insets = getBorderInsets(border, c, new Insets(0, 0, 0, 0));\n\n            int baseline = label.getBaseline(size.width, size.height);\n            switch (getPosition()) {\n                case ABOVE_TOP:\n                    return baseline;\n                case TOP:\n                    insets.top = edge + (insets.top - size.height) / 2;\n                    return (insets.top < edge)\n                            ? baseline\n                            : baseline + insets.top;\n                case BELOW_TOP:\n                    return baseline + insets.top + edge;\n                case ABOVE_BOTTOM:\n                    return baseline + height - size.height - insets.bottom - edge;\n                case BOTTOM:\n                    insets.bottom = edge + (insets.bottom - size.height) / 2;\n                    return (insets.bottom < edge)\n                            ? baseline + height - size.height\n                            : baseline + height - size.height + insets.bottom;\n                case BELOW_BOTTOM:\n                    return baseline + height - size.height;\n            }\n        }\n        return -1;\n    }"}
{"Number":"1053","API Relative Path":"javax.swing.border.TitledBorder.java-getBaseline(Component-int-int)","Corresponding Source":"/**\n     * Returns the baseline.\n     *\n     * @throws NullPointerException {@inheritDoc}\n     * @throws IllegalArgumentException {@inheritDoc}\n     * @see javax.swing.JComponent#getBaseline(int, int)\n     * @since 1.6\n     */\n    public int getBaseline(Component c, int width, int height) {\n        if (c == null) {\n            throw new NullPointerException(\"Must supply non-null component\");\n        }\n        if (width < 0) {\n            throw new IllegalArgumentException(\"Width must be >= 0\");\n        }\n        if (height < 0) {\n            throw new IllegalArgumentException(\"Height must be >= 0\");\n        }\n        Border border = getBorder();\n        String title = getTitle();\n        if ((title != null) && !title.isEmpty()) {\n            int edge = (border instanceof TitledBorder) ? 0 : EDGE_SPACING;\n            JLabel label = getLabel(c);\n            Dimension size = label.getPreferredSize();\n            Insets insets = getBorderInsets(border, c, new Insets(0, 0, 0, 0));\n\n            int baseline = label.getBaseline(size.width, size.height);\n            switch (getPosition()) {\n                case ABOVE_TOP:\n                    return baseline;\n                case TOP:\n                    insets.top = edge + (insets.top - size.height) / 2;\n                    return (insets.top < edge)\n                            ? baseline\n                            : baseline + insets.top;\n                case BELOW_TOP:\n                    return baseline + insets.top + edge;\n                case ABOVE_BOTTOM:\n                    return baseline + height - size.height - insets.bottom - edge;\n                case BOTTOM:\n                    insets.bottom = edge + (insets.bottom - size.height) / 2;\n                    return (insets.bottom < edge)\n                            ? baseline + height - size.height\n                            : baseline + height - size.height + insets.bottom;\n                case BELOW_BOTTOM:\n                    return baseline + height - size.height;\n            }\n        }\n        return -1;\n    }"}
{"Number":"1054","API Relative Path":"javax.swing.Box.java-Box(int)","Corresponding Source":"/**\n     * Creates a <code>Box<\/code> that displays its components\n     * along the the specified axis.\n     *\n     * @param axis  can be {@link BoxLayout#X_AXIS},\n     *              {@link BoxLayout#Y_AXIS},\n     *              {@link BoxLayout#LINE_AXIS} or\n     *              {@link BoxLayout#PAGE_AXIS}.\n     * @throws AWTError if the <code>axis<\/code> is invalid\n     * @see #createHorizontalBox\n     * @see #createVerticalBox\n     */\n    public Box(int axis) {\n        super();\n        super.setLayout(new BoxLayout(this, axis));\n    }"}
{"Number":"1055","API Relative Path":"javax.swing.BoxLayout.java-BoxLayout(Container-int)","Corresponding Source":"/**\n     * Creates a layout manager that will lay out components along the\n     * given axis.\n     *\n     * @param target  the container that needs to be laid out\n     * @param axis  the axis to lay out components along. Can be one of:\n     *              <code>BoxLayout.X_AXIS<\/code>,\n     *              <code>BoxLayout.Y_AXIS<\/code>,\n     *              <code>BoxLayout.LINE_AXIS<\/code> or\n     *              <code>BoxLayout.PAGE_AXIS<\/code>\n     *\n     * @exception AWTError  if the value of <code>axis<\/code> is invalid\n     */\n    @ConstructorProperties({\"target\", \"axis\"})\n    public BoxLayout(Container target, int axis) {\n        if (axis != X_AXIS && axis != Y_AXIS &&\n            axis != LINE_AXIS && axis != PAGE_AXIS) {\n            throw new AWTError(\"Invalid axis\");\n        }\n        this.axis = axis;\n        this.target = target;\n    }"}
{"Number":"1056","API Relative Path":"javax.swing.BoxLayout.java-getLayoutAlignmentX(Container)","Corresponding Source":"/**\n     * Returns the alignment along the X axis for the container.\n     * If the box is horizontal, the default\n     * alignment will be returned. Otherwise, the alignment needed\n     * to place the children along the X axis will be returned.\n     *\n     * @param target  the container\n     * @return the alignment &gt;= 0.0f &amp;&amp; &lt;= 1.0f\n     * @exception AWTError  if the target isn't the container specified to the\n     *                      BoxLayout constructor\n     */\n    public synchronized float getLayoutAlignmentX(Container target) {\n        checkContainer(target);\n        checkRequests();\n        return xTotal.alignment;\n    }"}
{"Number":"1057","API Relative Path":"javax.swing.BoxLayout.java-getLayoutAlignmentY(Container)","Corresponding Source":"/**\n     * Returns the alignment along the Y axis for the container.\n     * If the box is vertical, the default\n     * alignment will be returned. Otherwise, the alignment needed\n     * to place the children along the Y axis will be returned.\n     *\n     * @param target  the container\n     * @return the alignment &gt;= 0.0f &amp;&amp; &lt;= 1.0f\n     * @exception AWTError  if the target isn't the container specified to the\n     *                      BoxLayout constructor\n     */\n    public synchronized float getLayoutAlignmentY(Container target) {\n        checkContainer(target);\n        checkRequests();\n        return yTotal.alignment;\n    }"}
{"Number":"1058","API Relative Path":"javax.swing.BoxLayout.java-invalidateLayout(Container)","Corresponding Source":"/**\n     * Indicates that a child has changed its layout related information,\n     * and thus any cached calculations should be flushed.\n     * <p>\n     * This method is called by AWT when the invalidate method is called\n     * on the Container.  Since the invalidate method may be called\n     * asynchronously to the event thread, this method may be called\n     * asynchronously.\n     *\n     * @param target  the affected container\n     *\n     * @exception AWTError  if the target isn't the container specified to the\n     *                      BoxLayout constructor\n     */\n    public synchronized void invalidateLayout(Container target) {\n        checkContainer(target);\n        xChildren = null;\n        yChildren = null;\n        xTotal = null;\n        yTotal = null;\n    }"}
{"Number":"1059","API Relative Path":"javax.swing.BoxLayout.java-layoutContainer(Container)","Corresponding Source":"/**\n     * Called by the AWT <!-- XXX CHECK! --> when the specified container\n     * needs to be laid out.\n     *\n     * @param target  the container to lay out\n     *\n     * @exception AWTError  if the target isn't the container specified to the\n     *                      BoxLayout constructor\n     */\n    public void layoutContainer(Container target) {\n        checkContainer(target);\n        int nChildren = target.getComponentCount();\n        int[] xOffsets = new int[nChildren];\n        int[] xSpans = new int[nChildren];\n        int[] yOffsets = new int[nChildren];\n        int[] ySpans = new int[nChildren];\n\n        Dimension alloc = target.getSize();\n        Insets in = target.getInsets();\n        alloc.width -= in.left + in.right;\n        alloc.height -= in.top + in.bottom;\n\n        // Resolve axis to an absolute value (either X_AXIS or Y_AXIS)\n        ComponentOrientation o = target.getComponentOrientation();\n        int absoluteAxis = resolveAxis( axis, o );\n        boolean ltr = (absoluteAxis != axis) ? o.isLeftToRight() : true;\n\n\n        // determine the child placements\n        synchronized(this) {\n            checkRequests();\n\n            if (absoluteAxis == X_AXIS) {\n                SizeRequirements.calculateTiledPositions(alloc.width, xTotal,\n                                                         xChildren, xOffsets,\n                                                         xSpans, ltr);\n                SizeRequirements.calculateAlignedPositions(alloc.height, yTotal,\n                                                           yChildren, yOffsets,\n                                                           ySpans);\n            } else {\n                SizeRequirements.calculateAlignedPositions(alloc.width, xTotal,\n                                                           xChildren, xOffsets,\n                                                           xSpans, ltr);\n                SizeRequirements.calculateTiledPositions(alloc.height, yTotal,\n                                                         yChildren, yOffsets,\n                                                         ySpans);\n            }\n        }\n\n        // flush changes to the container\n        for (int i = 0; i < nChildren; i++) {\n            Component c = target.getComponent(i);\n            c.setBounds((int) Math.min((long) in.left + (long) xOffsets[i], Integer.MAX_VALUE),\n                        (int) Math.min((long) in.top + (long) yOffsets[i], Integer.MAX_VALUE),\n                        xSpans[i], ySpans[i]);\n\n        }\n        if (dbg != null) {\n            for (int i = 0; i < nChildren; i++) {\n                Component c = target.getComponent(i);\n                dbg.println(c.toString());\n                dbg.println(\"X: \" + xChildren[i]);\n                dbg.println(\"Y: \" + yChildren[i]);\n            }\n        }\n\n    }"}
{"Number":"1060","API Relative Path":"javax.swing.BoxLayout.java-maximumLayoutSize(Container)","Corresponding Source":"/**\n     * Returns the maximum dimensions the target container can use\n     * to lay out the components it contains.\n     *\n     * @param target  the container that needs to be laid out\n     * @return the dimensions &gt;= 0 &amp;&amp; &lt;= Integer.MAX_VALUE\n     * @exception AWTError  if the target isn't the container specified to the\n     *                      BoxLayout constructor\n     * @see #preferredLayoutSize\n     * @see #minimumLayoutSize\n     */\n    public Dimension maximumLayoutSize(Container target) {\n        Dimension size;\n        synchronized(this) {\n            checkContainer(target);\n            checkRequests();\n            size = new Dimension(xTotal.maximum, yTotal.maximum);\n        }\n\n        Insets insets = target.getInsets();\n        size.width = (int) Math.min((long) size.width + (long) insets.left + (long) insets.right, Integer.MAX_VALUE);\n        size.height = (int) Math.min((long) size.height + (long) insets.top + (long) insets.bottom, Integer.MAX_VALUE);\n        return size;\n    }"}
{"Number":"1061","API Relative Path":"javax.swing.BoxLayout.java-minimumLayoutSize(Container)","Corresponding Source":"/**\n     * Returns the minimum dimensions needed to lay out the components\n     * contained in the specified target container.\n     *\n     * @param target  the container that needs to be laid out\n     * @return the dimensions &gt;= 0 &amp;&amp; &lt;= Integer.MAX_VALUE\n     * @exception AWTError  if the target isn't the container specified to the\n     *                      BoxLayout constructor\n     * @see #preferredLayoutSize\n     * @see #maximumLayoutSize\n     */\n    public Dimension minimumLayoutSize(Container target) {\n        Dimension size;\n        synchronized(this) {\n            checkContainer(target);\n            checkRequests();\n            size = new Dimension(xTotal.minimum, yTotal.minimum);\n        }\n\n        Insets insets = target.getInsets();\n        size.width = (int) Math.min((long) size.width + (long) insets.left + (long) insets.right, Integer.MAX_VALUE);\n        size.height = (int) Math.min((long) size.height + (long) insets.top + (long) insets.bottom, Integer.MAX_VALUE);\n        return size;\n    }"}
{"Number":"1062","API Relative Path":"javax.swing.BoxLayout.java-preferredLayoutSize(Container)","Corresponding Source":"/**\n     * Returns the preferred dimensions for this layout, given the components\n     * in the specified target container.\n     *\n     * @param target  the container that needs to be laid out\n     * @return the dimensions &gt;= 0 &amp;&amp; &lt;= Integer.MAX_VALUE\n     * @exception AWTError  if the target isn't the container specified to the\n     *                      BoxLayout constructor\n     * @see Container\n     * @see #minimumLayoutSize\n     * @see #maximumLayoutSize\n     */\n    public Dimension preferredLayoutSize(Container target) {\n        Dimension size;\n        synchronized(this) {\n            checkContainer(target);\n            checkRequests();\n            size = new Dimension(xTotal.preferred, yTotal.preferred);\n        }\n\n        Insets insets = target.getInsets();\n        size.width = (int) Math.min((long) size.width + (long) insets.left + (long) insets.right, Integer.MAX_VALUE);\n        size.height = (int) Math.min((long) size.height + (long) insets.top + (long) insets.bottom, Integer.MAX_VALUE);\n        return size;\n    }"}
{"Number":"1063","API Relative Path":"javax.swing.ButtonGroup.java-add(AbstractButton)","Corresponding Source":"/**\n     * Adds the button to the group.\n     * @param b the button to be added\n     */\n    public void add(AbstractButton b) {\n        if(b == null) {\n            return;\n        }\n        buttons.addElement(b);\n\n        if (b.isSelected()) {\n            if (selection == null) {\n                selection = b.getModel();\n            } else {\n                b.setSelected(false);\n            }\n        }\n\n        b.getModel().setGroup(this);\n    }"}
{"Number":"1064","API Relative Path":"javax.swing.ButtonGroup.java-remove(AbstractButton)","Corresponding Source":"/**\n     * Removes the button from the group.\n     * @param b the button to be removed\n     */\n    public void remove(AbstractButton b) {\n        if(b == null) {\n            return;\n        }\n        buttons.removeElement(b);\n        if(b.getModel() == selection) {\n            selection = null;\n        }\n        b.getModel().setGroup(null);\n    }"}
{"Number":"1065","API Relative Path":"javax.swing.ButtonGroup.java-setSelected(ButtonModel-boolean)","Corresponding Source":"/**\n     * Sets the selected value for the <code>ButtonModel<\/code>.\n     * Only one button in the group may be selected at a time.\n     * @param m the <code>ButtonModel<\/code>\n     * @param b <code>true<\/code> if this button is to be\n     *   selected, otherwise <code>false<\/code>\n     */\n    public void setSelected(ButtonModel m, boolean b) {\n        if (b && m != null && m != selection) {\n            ButtonModel oldSelection = selection;\n            selection = m;\n            if (oldSelection != null) {\n                oldSelection.setSelected(false);\n            }\n            m.setSelected(true);\n        }\n    }"}
{"Number":"1066","API Relative Path":"javax.swing.CellRendererPane.java-paintComponent(Graphics-Component-Container-int-int-int-int-boolean)","Corresponding Source":"/**\n     * Paint a cell renderer component c on graphics object g.  Before the component\n     * is drawn it's reparented to this (if that's necessary), it's bounds\n     * are set to w,h and the graphics object is (effectively) translated to x,y.\n     * If it's a JComponent, double buffering is temporarily turned off. After\n     * the component is painted it's bounds are reset to -w, -h, 0, 0 so that, if\n     * it's the last renderer component painted, it will not start consuming input.\n     * The Container p is the component we're actually drawing on, typically it's\n     * equal to this.getParent(). If shouldValidate is true the component c will be\n     * validated before painted.\n     */\n    public void paintComponent(Graphics g, Component c, Container p, int x, int y, int w, int h, boolean shouldValidate) {\n        if (c == null) {\n            if (p != null) {\n                Color oldColor = g.getColor();\n                g.setColor(p.getBackground());\n                g.fillRect(x, y, w, h);\n                g.setColor(oldColor);\n            }\n            return;\n        }\n\n        if (c.getParent() != this) {\n            this.add(c);\n        }\n\n        c.setBounds(x, y, w, h);\n\n        if(shouldValidate) {\n            c.validate();\n        }\n\n        boolean wasDoubleBuffered = false;\n        if ((c instanceof JComponent) && ((JComponent)c).isDoubleBuffered()) {\n            wasDoubleBuffered = true;\n            ((JComponent)c).setDoubleBuffered(false);\n        }\n\n        Graphics cg = g.create(x, y, w, h);\n        try {\n            c.paint(cg);\n        }\n        finally {\n            cg.dispose();\n        }\n\n        if (wasDoubleBuffered && (c instanceof JComponent)) {\n            ((JComponent)c).setDoubleBuffered(true);\n        }\n\n        c.setBounds(-w, -h, 0, 0);\n    }"}
{"Number":"1067","API Relative Path":"javax.swing.CellRendererPane.java-paintComponent(Graphics-Component-Container-int-int-int-int-boolean)","Corresponding Source":"/**\n     * Paint a cell renderer component c on graphics object g.  Before the component\n     * is drawn it's reparented to this (if that's necessary), it's bounds\n     * are set to w,h and the graphics object is (effectively) translated to x,y.\n     * If it's a JComponent, double buffering is temporarily turned off. After\n     * the component is painted it's bounds are reset to -w, -h, 0, 0 so that, if\n     * it's the last renderer component painted, it will not start consuming input.\n     * The Container p is the component we're actually drawing on, typically it's\n     * equal to this.getParent(). If shouldValidate is true the component c will be\n     * validated before painted.\n     */\n    public void paintComponent(Graphics g, Component c, Container p, int x, int y, int w, int h, boolean shouldValidate) {\n        if (c == null) {\n            if (p != null) {\n                Color oldColor = g.getColor();\n                g.setColor(p.getBackground());\n                g.fillRect(x, y, w, h);\n                g.setColor(oldColor);\n            }\n            return;\n        }\n\n        if (c.getParent() != this) {\n            this.add(c);\n        }\n\n        c.setBounds(x, y, w, h);\n\n        if(shouldValidate) {\n            c.validate();\n        }\n\n        boolean wasDoubleBuffered = false;\n        if ((c instanceof JComponent) && ((JComponent)c).isDoubleBuffered()) {\n            wasDoubleBuffered = true;\n            ((JComponent)c).setDoubleBuffered(false);\n        }\n\n        Graphics cg = g.create(x, y, w, h);\n        try {\n            c.paint(cg);\n        }\n        finally {\n            cg.dispose();\n        }\n\n        if (wasDoubleBuffered && (c instanceof JComponent)) {\n            ((JComponent)c).setDoubleBuffered(true);\n        }\n\n        c.setBounds(-w, -h, 0, 0);\n    }"}
{"Number":"1068","API Relative Path":"javax.swing.CellRendererPane.java-paintComponent(Graphics-Component-Container-int-int-int-int-boolean)","Corresponding Source":"/**\n     * Paint a cell renderer component c on graphics object g.  Before the component\n     * is drawn it's reparented to this (if that's necessary), it's bounds\n     * are set to w,h and the graphics object is (effectively) translated to x,y.\n     * If it's a JComponent, double buffering is temporarily turned off. After\n     * the component is painted it's bounds are reset to -w, -h, 0, 0 so that, if\n     * it's the last renderer component painted, it will not start consuming input.\n     * The Container p is the component we're actually drawing on, typically it's\n     * equal to this.getParent(). If shouldValidate is true the component c will be\n     * validated before painted.\n     */\n    public void paintComponent(Graphics g, Component c, Container p, int x, int y, int w, int h, boolean shouldValidate) {\n        if (c == null) {\n            if (p != null) {\n                Color oldColor = g.getColor();\n                g.setColor(p.getBackground());\n                g.fillRect(x, y, w, h);\n                g.setColor(oldColor);\n            }\n            return;\n        }\n\n        if (c.getParent() != this) {\n            this.add(c);\n        }\n\n        c.setBounds(x, y, w, h);\n\n        if(shouldValidate) {\n            c.validate();\n        }\n\n        boolean wasDoubleBuffered = false;\n        if ((c instanceof JComponent) && ((JComponent)c).isDoubleBuffered()) {\n            wasDoubleBuffered = true;\n            ((JComponent)c).setDoubleBuffered(false);\n        }\n\n        Graphics cg = g.create(x, y, w, h);\n        try {\n            c.paint(cg);\n        }\n        finally {\n            cg.dispose();\n        }\n\n        if (wasDoubleBuffered && (c instanceof JComponent)) {\n            ((JComponent)c).setDoubleBuffered(true);\n        }\n\n        c.setBounds(-w, -h, 0, 0);\n    }"}
{"Number":"1069","API Relative Path":"javax.swing.colorchooser.DefaultColorSelectionModel.java-addChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Adds a <code>ChangeListener<\/code> to the model.\n     *\n     * @param l the <code>ChangeListener<\/code> to be added\n     */\n    public void addChangeListener(ChangeListener l) {\n        listenerList.add(ChangeListener.class, l);\n    }"}
{"Number":"1070","API Relative Path":"javax.swing.colorchooser.DefaultColorSelectionModel.java-removeChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Removes a <code>ChangeListener<\/code> from the model.\n     * @param l the <code>ChangeListener<\/code> to be removed\n     */\n    public void removeChangeListener(ChangeListener l) {\n        listenerList.remove(ChangeListener.class, l);\n    }"}
{"Number":"1071","API Relative Path":"javax.swing.colorchooser.DefaultColorSelectionModel.java-setSelectedColor(Color)","Corresponding Source":"/**\n     * Sets the selected color to <code>color<\/code>.\n     * Note that setting the color to <code>null<\/code>\n     * is undefined and may have unpredictable results.\n     * This method fires a state changed event if it sets the\n     * current color to a new non-<code>null<\/code> color;\n     * if the new color is the same as the current color,\n     * no event is fired.\n     *\n     * @param color the new <code>Color<\/code>\n     */\n    public void setSelectedColor(Color color) {\n        if (color != null && !selectedColor.equals(color)) {\n            selectedColor = color;\n            fireStateChanged();\n        }\n    }"}
{"Number":"1072","API Relative Path":"javax.swing.ComponentInputMap.java-ComponentInputMap(JComponent)","Corresponding Source":"/**\n     * Creates a <code>ComponentInputMap<\/code> associated with the\n     * specified component.\n     *\n     * @param component  a non-null <code>JComponent<\/code>\n     * @throws IllegalArgumentException  if <code>component<\/code> is null\n     */\n    public ComponentInputMap(JComponent component) {\n        this.component = component;\n        if (component == null) {\n            throw new IllegalArgumentException(\"ComponentInputMaps must be associated with a non-null JComponent\");\n        }\n    }"}
{"Number":"1073","API Relative Path":"javax.swing.ComponentInputMap.java-setParent(InputMap)","Corresponding Source":"/**\n     * Sets the parent, which must be a <code>ComponentInputMap<\/code>\n     * associated with the same component as this\n     * <code>ComponentInputMap<\/code>.\n     *\n     * @param map  a <code>ComponentInputMap<\/code>\n     *\n     * @throws IllegalArgumentException  if <code>map<\/code>\n     *         is not a <code>ComponentInputMap<\/code>\n     *         or is not associated with the same component\n     */\n    public void setParent(InputMap map) {\n        if (getParent() == map) {\n            return;\n        }\n        if (map != null && (!(map instanceof ComponentInputMap) ||\n                 ((ComponentInputMap)map).getComponent() != getComponent())) {\n            throw new IllegalArgumentException(\"ComponentInputMaps must have a parent ComponentInputMap associated with the same component\");\n        }\n        super.setParent(map);\n        getComponent().componentInputMapChanged(this);\n    }"}
{"Number":"1074","API Relative Path":"javax.swing.DefaultBoundedRangeModel.java-addChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Adds a <code>ChangeListener<\/code>.  The change listeners are run each\n     * time any one of the Bounded Range model properties changes.\n     *\n     * @param l the ChangeListener to add\n     * @see #removeChangeListener\n     * @see BoundedRangeModel#addChangeListener\n     */\n    public void addChangeListener(ChangeListener l) {\n        listenerList.add(ChangeListener.class, l);\n    }"}
{"Number":"1075","API Relative Path":"javax.swing.DefaultBoundedRangeModel.java-DefaultBoundedRangeModel(int-int-int-int)","Corresponding Source":"/**\n     * Initializes value, extent, minimum and maximum. Adjusting is false.\n     * Throws an <code>IllegalArgumentException<\/code> if the following\n     * constraints aren't satisfied:\n     * <pre>\n     * min &lt;= value &lt;= value+extent &lt;= max\n     * <\/pre>\n     */\n    public DefaultBoundedRangeModel(int value, int extent, int min, int max)\n    {\n        if ((max >= min) &&\n            (value >= min) &&\n            ((value + extent) >= value) &&\n            ((value + extent) <= max)) {\n            this.value = value;\n            this.extent = extent;\n            this.min = min;\n            this.max = max;\n        }\n        else {\n            throw new IllegalArgumentException(\"invalid range properties\");\n        }\n    }"}
{"Number":"1076","API Relative Path":"javax.swing.DefaultBoundedRangeModel.java-removeChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Removes a <code>ChangeListener<\/code>.\n     *\n     * @param l the <code>ChangeListener<\/code> to remove\n     * @see #addChangeListener\n     * @see BoundedRangeModel#removeChangeListener\n     */\n    public void removeChangeListener(ChangeListener l) {\n        listenerList.remove(ChangeListener.class, l);\n    }"}
{"Number":"1077","API Relative Path":"javax.swing.DefaultButtonModel.java-addActionListener(ActionListener)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    public void addActionListener(ActionListener l) {\n        listenerList.add(ActionListener.class, l);\n    }"}
{"Number":"1078","API Relative Path":"javax.swing.DefaultButtonModel.java-addChangeListener(ChangeListener)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    public void addChangeListener(ChangeListener l) {\n        listenerList.add(ChangeListener.class, l);\n    }"}
{"Number":"1079","API Relative Path":"javax.swing.DefaultButtonModel.java-addItemListener(ItemListener)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    public void addItemListener(ItemListener l) {\n        listenerList.add(ItemListener.class, l);\n    }"}
{"Number":"1080","API Relative Path":"javax.swing.DefaultButtonModel.java-removeActionListener(ActionListener)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    public void removeActionListener(ActionListener l) {\n        listenerList.remove(ActionListener.class, l);\n    }"}
{"Number":"1081","API Relative Path":"javax.swing.DefaultButtonModel.java-removeChangeListener(ChangeListener)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    public void removeChangeListener(ChangeListener l) {\n        listenerList.remove(ChangeListener.class, l);\n    }"}
{"Number":"1082","API Relative Path":"javax.swing.DefaultButtonModel.java-removeItemListener(ItemListener)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    public void removeItemListener(ItemListener l) {\n        listenerList.remove(ItemListener.class, l);\n    }"}
{"Number":"1083","API Relative Path":"javax.swing.DefaultDesktopManager.java-deiconifyFrame(JInternalFrame)","Corresponding Source":"/**\n     * Removes the desktopIcon from its parent and adds its frame\n     * to the parent.\n     * @param f the <code>JInternalFrame<\/code> to be de-iconified\n     */\n    public void deiconifyFrame(JInternalFrame f) {\n        JInternalFrame.JDesktopIcon desktopIcon = f.getDesktopIcon();\n        Container c = desktopIcon.getParent();\n        JDesktopPane d = f.getDesktopPane();\n        if (c != null && d != null) {\n            c.add(f);\n            // If the frame is to be restored to a maximized state make\n            // sure it still fills the whole desktop.\n            if (f.isMaximum()) {\n                Rectangle desktopBounds = c.getBounds();\n                if (f.getWidth() != desktopBounds.width ||\n                        f.getHeight() != desktopBounds.height) {\n                    setBoundsForFrame(f, 0, 0,\n                        desktopBounds.width, desktopBounds.height);\n                }\n            }\n            removeIconFor(f);\n            if (f.isSelected()) {\n                f.moveToFront();\n                f.restoreSubcomponentFocus();\n            }\n            else {\n                try {\n                    f.setSelected(true);\n                } catch (PropertyVetoException e2) {}\n\n            }\n        }\n    }"}
{"Number":"1084","API Relative Path":"javax.swing.DefaultDesktopManager.java-deiconifyFrame(JInternalFrame)","Corresponding Source":"/**\n     * Removes the desktopIcon from its parent and adds its frame\n     * to the parent.\n     * @param f the <code>JInternalFrame<\/code> to be de-iconified\n     */\n    public void deiconifyFrame(JInternalFrame f) {\n        JInternalFrame.JDesktopIcon desktopIcon = f.getDesktopIcon();\n        Container c = desktopIcon.getParent();\n        JDesktopPane d = f.getDesktopPane();\n        if (c != null && d != null) {\n            c.add(f);\n            // If the frame is to be restored to a maximized state make\n            // sure it still fills the whole desktop.\n            if (f.isMaximum()) {\n                Rectangle desktopBounds = c.getBounds();\n                if (f.getWidth() != desktopBounds.width ||\n                        f.getHeight() != desktopBounds.height) {\n                    setBoundsForFrame(f, 0, 0,\n                        desktopBounds.width, desktopBounds.height);\n                }\n            }\n            removeIconFor(f);\n            if (f.isSelected()) {\n                f.moveToFront();\n                f.restoreSubcomponentFocus();\n            }\n            else {\n                try {\n                    f.setSelected(true);\n                } catch (PropertyVetoException e2) {}\n\n            }\n        }\n    }"}
{"Number":"1085","API Relative Path":"javax.swing.DefaultDesktopManager.java-openFrame(JInternalFrame)","Corresponding Source":"/** Normally this method will not be called. If it is, it\n      * try to determine the appropriate parent from the desktopIcon of the frame.\n      * Will remove the desktopIcon from its parent if it successfully adds the frame.\n      */\n    public void openFrame(JInternalFrame f) {\n        if(f.getDesktopIcon().getParent() != null) {\n            f.getDesktopIcon().getParent().add(f);\n            removeIconFor(f);\n        }\n    }"}
{"Number":"1086","API Relative Path":"javax.swing.DefaultDesktopManager.java-openFrame(JInternalFrame)","Corresponding Source":"/** Normally this method will not be called. If it is, it\n      * try to determine the appropriate parent from the desktopIcon of the frame.\n      * Will remove the desktopIcon from its parent if it successfully adds the frame.\n      */\n    public void openFrame(JInternalFrame f) {\n        if(f.getDesktopIcon().getParent() != null) {\n            f.getDesktopIcon().getParent().add(f);\n            removeIconFor(f);\n        }\n    }"}
{"Number":"1087","API Relative Path":"javax.swing.DefaultDesktopManager.java-setWasIcon(JInternalFrame-Boolean)","Corresponding Source":"/**\n     * Sets that the component has been iconized and the bounds of the\n     * <code>desktopIcon<\/code> are valid.\n     */\n    protected void setWasIcon(JInternalFrame f, Boolean value)  {\n        if (value != null) {\n            f.putClientProperty(HAS_BEEN_ICONIFIED_PROPERTY, value);\n        }\n    }"}
{"Number":"1088","API Relative Path":"javax.swing.DefaultDesktopManager.java-setWasIcon(JInternalFrame-Boolean)","Corresponding Source":"/**\n     * Sets that the component has been iconized and the bounds of the\n     * <code>desktopIcon<\/code> are valid.\n     */\n    protected void setWasIcon(JInternalFrame f, Boolean value)  {\n        if (value != null) {\n            f.putClientProperty(HAS_BEEN_ICONIFIED_PROPERTY, value);\n        }\n    }"}
{"Number":"1089","API Relative Path":"javax.swing.DefaultListModel.java-removeRange(int-int)","Corresponding Source":"/**\n     * Deletes the components at the specified range of indexes.\n     * The removal is inclusive, so specifying a range of (1,5)\n     * removes the component at index 1 and the component at index 5,\n     * as well as all components in between.\n     * <p>\n     * Throws an <code>ArrayIndexOutOfBoundsException<\/code>\n     * if the index was invalid.\n     * Throws an <code>IllegalArgumentException<\/code> if\n     * <code>fromIndex &gt; toIndex<\/code>.\n     *\n     * @param      fromIndex the index of the lower end of the range\n     * @param      toIndex   the index of the upper end of the range\n     * @see        #remove(int)\n     */\n    public void removeRange(int fromIndex, int toIndex) {\n        if (fromIndex > toIndex) {\n            throw new IllegalArgumentException(\"fromIndex must be <= toIndex\");\n        }\n        for(int i = toIndex; i >= fromIndex; i--) {\n            delegate.removeElementAt(i);\n        }\n        fireIntervalRemoved(this, fromIndex, toIndex);\n    }"}
{"Number":"1090","API Relative Path":"javax.swing.DefaultListSelectionModel.java-addListSelectionListener(ListSelectionListener)","Corresponding Source":"/** {@inheritDoc} */\n    public void addListSelectionListener(ListSelectionListener l) {\n        listenerList.add(ListSelectionListener.class, l);\n    }"}
{"Number":"1091","API Relative Path":"javax.swing.DefaultListSelectionModel.java-removeListSelectionListener(ListSelectionListener)","Corresponding Source":"/** {@inheritDoc} */\n    public void removeListSelectionListener(ListSelectionListener l) {\n        listenerList.remove(ListSelectionListener.class, l);\n    }"}
{"Number":"1092","API Relative Path":"javax.swing.DefaultRowSorter.java-convertRowIndexToModel(int)","Corresponding Source":"/**\n     * {@inheritDoc}\n     *\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public int convertRowIndexToModel(int index) {\n        if (viewToModel == null) {\n            if (index < 0 || index >= getModelWrapper().getRowCount()) {\n                throw new IndexOutOfBoundsException(\"Invalid index\");\n            }\n            return index;\n        }\n        return viewToModel[index].modelIndex;\n    }"}
{"Number":"1093","API Relative Path":"javax.swing.DefaultRowSorter.java-convertRowIndexToView(int)","Corresponding Source":"/**\n     * {@inheritDoc}\n     *\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public int convertRowIndexToView(int index) {\n        if (modelToView == null) {\n            if (index < 0 || index >= getModelWrapper().getRowCount()) {\n                throw new IndexOutOfBoundsException(\"Invalid index\");\n            }\n            return index;\n        }\n        return modelToView[index];\n    }"}
{"Number":"1094","API Relative Path":"javax.swing.DefaultRowSorter.java-getComparator(int)","Corresponding Source":"/**\n     * Returns the <code>Comparator<\/code> for the specified\n     * column.  This will return <code>null<\/code> if a <code>Comparator<\/code>\n     * has not been specified for the column.\n     *\n     * @param column the column to fetch the <code>Comparator<\/code> for, in\n     *        terms of the underlying model\n     * @return the <code>Comparator<\/code> for the specified column\n     * @throws IndexOutOfBoundsException if column is outside\n     *         the range of the underlying model\n     */\n    public Comparator<?> getComparator(int column) {\n        checkColumn(column);\n        if (comparators != null) {\n            return comparators[column];\n        }\n        return null;\n    }"}
{"Number":"1095","API Relative Path":"javax.swing.DefaultRowSorter.java-isSortable(int)","Corresponding Source":"/**\n     * Returns true if the specified column is sortable; otherwise, false.\n     *\n     * @param column the column to check sorting for, in terms of the\n     *        underlying model\n     * @return true if the column is sortable\n     * @throws IndexOutOfBoundsException if column is outside\n     *         the range of the underlying model\n     */\n    public boolean isSortable(int column) {\n        checkColumn(column);\n        return (isSortable == null) ? true : isSortable[column];\n    }"}
{"Number":"1096","API Relative Path":"javax.swing.DefaultRowSorter.java-rowsDeleted(int-int)","Corresponding Source":"/**\n     * {@inheritDoc}\n     *\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public void rowsDeleted(int firstRow, int endRow) {\n        checkAgainstModel(firstRow, endRow);\n        if (firstRow >= modelRowCount || endRow >= modelRowCount) {\n            throw new IndexOutOfBoundsException(\"Invalid range\");\n        }\n        modelRowCount = getModelWrapper().getRowCount();\n        if (shouldOptimizeChange(firstRow, endRow)) {\n            rowsDeleted0(firstRow, endRow);\n        }\n    }"}
{"Number":"1097","API Relative Path":"javax.swing.DefaultRowSorter.java-rowsDeleted(int-int)","Corresponding Source":"/**\n     * {@inheritDoc}\n     *\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public void rowsDeleted(int firstRow, int endRow) {\n        checkAgainstModel(firstRow, endRow);\n        if (firstRow >= modelRowCount || endRow >= modelRowCount) {\n            throw new IndexOutOfBoundsException(\"Invalid range\");\n        }\n        modelRowCount = getModelWrapper().getRowCount();\n        if (shouldOptimizeChange(firstRow, endRow)) {\n            rowsDeleted0(firstRow, endRow);\n        }\n    }"}
{"Number":"1098","API Relative Path":"javax.swing.DefaultRowSorter.java-rowsInserted(int-int)","Corresponding Source":"/**\n     * {@inheritDoc}\n     *\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public void rowsInserted(int firstRow, int endRow) {\n        checkAgainstModel(firstRow, endRow);\n        int newModelRowCount = getModelWrapper().getRowCount();\n        if (endRow >= newModelRowCount) {\n            throw new IndexOutOfBoundsException(\"Invalid range\");\n        }\n        modelRowCount = newModelRowCount;\n        if (shouldOptimizeChange(firstRow, endRow)) {\n            rowsInserted0(firstRow, endRow);\n        }\n    }"}
{"Number":"1099","API Relative Path":"javax.swing.DefaultRowSorter.java-rowsInserted(int-int)","Corresponding Source":"/**\n     * {@inheritDoc}\n     *\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public void rowsInserted(int firstRow, int endRow) {\n        checkAgainstModel(firstRow, endRow);\n        int newModelRowCount = getModelWrapper().getRowCount();\n        if (endRow >= newModelRowCount) {\n            throw new IndexOutOfBoundsException(\"Invalid range\");\n        }\n        modelRowCount = newModelRowCount;\n        if (shouldOptimizeChange(firstRow, endRow)) {\n            rowsInserted0(firstRow, endRow);\n        }\n    }"}
{"Number":"1100","API Relative Path":"javax.swing.DefaultRowSorter.java-rowsUpdated(int-int)","Corresponding Source":"/**\n     * {@inheritDoc}\n     *\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public void rowsUpdated(int firstRow, int endRow) {\n        checkAgainstModel(firstRow, endRow);\n        if (firstRow >= modelRowCount || endRow >= modelRowCount) {\n            throw new IndexOutOfBoundsException(\"Invalid range\");\n        }\n        if (getSortsOnUpdates()) {\n            if (shouldOptimizeChange(firstRow, endRow)) {\n                rowsUpdated0(firstRow, endRow);\n            }\n        }\n        else {\n            sorted = false;\n        }\n    }"}
{"Number":"1101","API Relative Path":"javax.swing.DefaultRowSorter.java-rowsUpdated(int-int)","Corresponding Source":"/**\n     * {@inheritDoc}\n     *\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public void rowsUpdated(int firstRow, int endRow) {\n        checkAgainstModel(firstRow, endRow);\n        if (firstRow >= modelRowCount || endRow >= modelRowCount) {\n            throw new IndexOutOfBoundsException(\"Invalid range\");\n        }\n        if (getSortsOnUpdates()) {\n            if (shouldOptimizeChange(firstRow, endRow)) {\n                rowsUpdated0(firstRow, endRow);\n            }\n        }\n        else {\n            sorted = false;\n        }\n    }"}
{"Number":"1102","API Relative Path":"javax.swing.DefaultRowSorter.java-rowsUpdated(int-int-int)","Corresponding Source":"/**\n     * {@inheritDoc}\n     *\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public void rowsUpdated(int firstRow, int endRow, int column) {\n        checkColumn(column);\n        rowsUpdated(firstRow, endRow);\n    }"}
{"Number":"1103","API Relative Path":"javax.swing.DefaultRowSorter.java-setComparator(int-Comparator)","Corresponding Source":"/**\n     * Sets the <code>Comparator<\/code> to use when sorting the specified\n     * column.  This does not trigger a sort.  If you want to sort after\n     * setting the comparator you need to explicitly invoke <code>sort<\/code>.\n     *\n     * @param column the index of the column the <code>Comparator<\/code> is\n     *        to be used for, in terms of the underlying model\n     * @param comparator the <code>Comparator<\/code> to use\n     * @throws IndexOutOfBoundsException if <code>column<\/code> is outside\n     *         the range of the underlying model\n     */\n    public void setComparator(int column, Comparator<?> comparator) {\n        checkColumn(column);\n        if (comparators == null) {\n            comparators = new Comparator[getModelWrapper().getColumnCount()];\n        }\n        comparators[column] = comparator;\n    }"}
{"Number":"1104","API Relative Path":"javax.swing.DefaultRowSorter.java-setSortable(int-boolean)","Corresponding Source":"/**\n     * Sets whether or not the specified column is sortable.  The specified\n     * value is only checked when <code>toggleSortOrder<\/code> is invoked.\n     * It is still possible to sort on a column that has been marked as\n     * unsortable by directly setting the sort keys.  The default is\n     * true.\n     *\n     * @param column the column to enable or disable sorting on, in terms\n     *        of the underlying model\n     * @param sortable whether or not the specified column is sortable\n     * @throws IndexOutOfBoundsException if <code>column<\/code> is outside\n     *         the range of the model\n     * @see #toggleSortOrder\n     * @see #setSortKeys\n     */\n    public void setSortable(int column, boolean sortable) {\n        checkColumn(column);\n        if (isSortable == null) {\n            isSortable = new boolean[getModelWrapper().getColumnCount()];\n            for (int i = isSortable.length - 1; i >= 0; i--) {\n                isSortable[i] = true;\n            }\n        }\n        isSortable[column] = sortable;\n    }"}
{"Number":"1105","API Relative Path":"javax.swing.DefaultRowSorter.java-toggleSortOrder(int)","Corresponding Source":"/**\n     * Reverses the sort order from ascending to descending (or\n     * descending to ascending) if the specified column is already the\n     * primary sorted column; otherwise, makes the specified column\n     * the primary sorted column, with an ascending sort order.  If\n     * the specified column is not sortable, this method has no\n     * effect.\n     *\n     * @param column index of the column to make the primary sorted column,\n     *        in terms of the underlying model\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     * @see #setSortable(int,boolean)\n     * @see #setMaxSortKeys(int)\n     */\n    public void toggleSortOrder(int column) {\n        checkColumn(column);\n        if (isSortable(column)) {\n            List<SortKey> keys = new ArrayList<SortKey>(getSortKeys());\n            SortKey sortKey;\n            int sortIndex;\n            for (sortIndex = keys.size() - 1; sortIndex >= 0; sortIndex--) {\n                if (keys.get(sortIndex).getColumn() == column) {\n                    break;\n                }\n            }\n            if (sortIndex == -1) {\n                // Key doesn't exist\n                sortKey = new SortKey(column, SortOrder.ASCENDING);\n                keys.add(0, sortKey);\n            }\n            else if (sortIndex == 0) {\n                // It's the primary sorting key, toggle it\n                keys.set(0, toggle(keys.get(0)));\n            }\n            else {\n                // It's not the first, but was sorted on, remove old\n                // entry, insert as first with ascending.\n                keys.remove(sortIndex);\n                keys.add(0, new SortKey(column, SortOrder.ASCENDING));\n            }\n            if (keys.size() > getMaxSortKeys()) {\n                keys = keys.subList(0, getMaxSortKeys());\n            }\n            setSortKeys(keys);\n        }\n    }"}
{"Number":"1106","API Relative Path":"javax.swing.DefaultRowSorter.java-useToString(int)","Corresponding Source":"/**\n     * Returns whether or not to convert the value to a string before\n     * doing comparisons when sorting.  If true\n     * <code>ModelWrapper.getStringValueAt<\/code> will be used, otherwise\n     * <code>ModelWrapper.getValueAt<\/code> will be used.  It is up to\n     * subclasses, such as <code>TableRowSorter<\/code>, to honor this value\n     * in their <code>ModelWrapper<\/code> implementation.\n     *\n     * @param column the index of the column to test, in terms of the\n     *        underlying model\n     * @throws IndexOutOfBoundsException if <code>column<\/code> is not valid\n     */\n    protected boolean useToString(int column) {\n        return (getComparator(column) == null);\n    }"}
{"Number":"1107","API Relative Path":"javax.swing.DefaultSingleSelectionModel.java-addChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Adds a <code>ChangeListener<\/code> to the button.\n     */\n    public void addChangeListener(ChangeListener l) {\n        listenerList.add(ChangeListener.class, l);\n    }"}
{"Number":"1108","API Relative Path":"javax.swing.DefaultSingleSelectionModel.java-removeChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Removes a <code>ChangeListener<\/code> from the button.\n     */\n    public void removeChangeListener(ChangeListener l) {\n        listenerList.remove(ChangeListener.class, l);\n    }"}
{"Number":"1109","API Relative Path":"javax.swing.event.EventListenerList.java-add(Class-T)","Corresponding Source":"/**\n     * Adds the listener as a listener of the specified type.\n     * @param t the type of the listener to be added\n     * @param l the listener to be added\n     */\n    public synchronized <T extends EventListener> void add(Class<T> t, T l) {\n        if (l==null) {\n            // In an ideal world, we would do an assertion here\n            // to help developers know they are probably doing\n            // something wrong\n            return;\n        }\n        if (!t.isInstance(l)) {\n            throw new IllegalArgumentException(\"Listener \" + l +\n                                         \" is not of type \" + t);\n        }\n        if (listenerList == NULL_ARRAY) {\n            // if this is the first listener added,\n            // initialize the lists\n            listenerList = new Object[] { t, l };\n        } else {\n            // Otherwise copy the array and add the new listener\n            int i = listenerList.length;\n            Object[] tmp = new Object[i+2];\n            System.arraycopy(listenerList, 0, tmp, 0, i);\n\n            tmp[i] = t;\n            tmp[i+1] = l;\n\n            listenerList = tmp;\n        }\n    }"}
{"Number":"1110","API Relative Path":"javax.swing.event.EventListenerList.java-remove(Class-T)","Corresponding Source":"/**\n     * Removes the listener as a listener of the specified type.\n     * @param t the type of the listener to be removed\n     * @param l the listener to be removed\n     */\n    public synchronized <T extends EventListener> void remove(Class<T> t, T l) {\n        if (l ==null) {\n            // In an ideal world, we would do an assertion here\n            // to help developers know they are probably doing\n            // something wrong\n            return;\n        }\n        if (!t.isInstance(l)) {\n            throw new IllegalArgumentException(\"Listener \" + l +\n                                         \" is not of type \" + t);\n        }\n        // Is l on the list?\n        int index = -1;\n        for (int i = listenerList.length-2; i>=0; i-=2) {\n            if ((listenerList[i]==t) && (listenerList[i+1].equals(l) == true)) {\n                index = i;\n                break;\n            }\n        }\n\n        // If so,  remove it\n        if (index != -1) {\n            Object[] tmp = new Object[listenerList.length-2];\n            // Copy the list up to index\n            System.arraycopy(listenerList, 0, tmp, 0, index);\n            // Copy from two past the index, up to\n            // the end of tmp (which is two elements\n            // shorter than the old list)\n            if (index < tmp.length)\n                System.arraycopy(listenerList, index+2, tmp, index,\n                                 tmp.length - index);\n            // set the listener array to the new array or null\n            listenerList = (tmp.length == 0) ? NULL_ARRAY : tmp;\n            }\n    }"}
{"Number":"1111","API Relative Path":"javax.swing.event.TreeModelEvent.java-TreeModelEvent(Object-Object[])","Corresponding Source":"/**\n     * Used to create an event when the node structure has changed in some way,\n     * identifying the path to the root of a modified subtree as an array of\n     * Objects. A structure change event might involve nodes swapping position,\n     * for example, or it might encapsulate multiple inserts and deletes in the\n     * subtree stemming from the node, where the changes may have taken place at\n     * different levels of the subtree.\n     * <blockquote>\n     *   <b>Note:<\/b><br>\n     *   JTree collapses all nodes under the specified node, so that only its\n     *   immediate children are visible.\n     * <\/blockquote>\n     *\n     * @param source the Object responsible for generating the event (typically\n     *               the creator of the event object passes <code>this<\/code>\n     *               for its value)\n     * @param path   an array of Object identifying the path to the root of the\n     *               modified subtree, where the first element of the array is\n     *               the object stored at the root node and the last element\n     *               is the object stored at the changed node\n     * @see TreePath\n     */\n    public TreeModelEvent(Object source, Object[] path)\n    {\n        this(source, (path == null) ? null : new TreePath(path));\n    }"}
{"Number":"1112","API Relative Path":"javax.swing.event.TreeModelEvent.java-TreeModelEvent(Object-Object[]-int[]-Object[])","Corresponding Source":"/**\n     * Used to create an event when nodes have been changed, inserted, or\n     * removed, identifying the path to the parent of the modified items as\n     * an array of Objects. All of the modified objects are siblings which are\n     * direct descendents (not grandchildren) of the specified parent.\n     * The positions at which the inserts, deletes, or changes occurred are\n     * specified by an array of <code>int<\/code>. The indexes in that array\n     * must be in order, from lowest to highest.\n     * <p>\n     * For changes, the indexes in the model correspond exactly to the indexes\n     * of items currently displayed in the UI. As a result, it is not really\n     * critical if the indexes are not in their exact order. But after multiple\n     * inserts or deletes, the items currently in the UI no longer correspond\n     * to the items in the model. It is therefore critical to specify the\n     * indexes properly for inserts and deletes.\n     * <p>\n     * For inserts, the indexes represent the <i>final<\/i> state of the tree,\n     * after the inserts have occurred. Since the indexes must be specified in\n     * order, the most natural processing methodology is to do the inserts\n     * starting at the lowest index and working towards the highest. Accumulate\n     * a Vector of <code>Integer<\/code> objects that specify the\n     * insert-locations as you go, then convert the Vector to an\n     * array of <code>int<\/code> to create the event. When the postition-index\n     * equals zero, the node is inserted at the beginning of the list. When the\n     * position index equals the size of the list, the node is \"inserted\" at\n     * (appended to) the end of the list.\n     * <p>\n     * For deletes, the indexes represent the <i>initial<\/i> state of the tree,\n     * before the deletes have occurred. Since the indexes must be specified in\n     * order, the most natural processing methodology is to use a delete-counter.\n     * Start by initializing the counter to zero and start work through the\n     * list from lowest to highest. Every time you do a delete, add the current\n     * value of the delete-counter to the index-position where the delete occurred,\n     * and append the result to a Vector of delete-locations, using\n     * <code>addElement()<\/code>. Then increment the delete-counter. The index\n     * positions stored in the Vector therefore reflect the effects of all previous\n     * deletes, so they represent each object's position in the initial tree.\n     * (You could also start at the highest index and working back towards the\n     * lowest, accumulating a Vector of delete-locations as you go using the\n     * <code>insertElementAt(Integer, 0)<\/code>.) However you produce the Vector\n     * of initial-positions, you then need to convert the Vector of <code>Integer<\/code>\n     * objects to an array of <code>int<\/code> to create the event.\n     * <p>\n     * <b>Notes:<\/b><ul style=\"list-style-type:none\">\n     * <li>Like the <code>insertNodeInto<\/code> method in the\n     *    <code>DefaultTreeModel<\/code> class, <code>insertElementAt<\/code>\n     *    appends to the <code>Vector<\/code> when the index matches the size\n     *    of the vector. So you can use <code>insertElementAt(Integer, 0)<\/code>\n     *    even when the vector is empty.<\/li>\n     * <li>To create a node changed event for the root node, specify the parent\n     *     and the child indices as <code>null<\/code>.<\/li>\n     * <\/ul>\n     *\n     * @param source the Object responsible for generating the event (typically\n     *               the creator of the event object passes <code>this<\/code>\n     *               for its value)\n     * @param path   an array of Object identifying the path to the\n     *               parent of the modified item(s), where the first element\n     *               of the array is the Object stored at the root node and\n     *               the last element is the Object stored at the parent node\n     * @param childIndices an array of <code>int<\/code> that specifies the\n     *               index values of the removed items. The indices must be\n     *               in sorted order, from lowest to highest\n     * @param children an array of Object containing the inserted, removed, or\n     *                 changed objects\n     * @see TreePath\n     */\n    public TreeModelEvent(Object source, Object[] path, int[] childIndices,\n                          Object[] children)\n    {\n        this(source, (path == null) ? null : new TreePath(path), childIndices, children);\n    }"}
{"Number":"1113","API Relative Path":"javax.swing.event.TreeSelectionEvent.java-isAddedPath(int)","Corresponding Source":"/**\n     * Returns whether the path at {@code getPaths()[index]} was added\n     * to the selection.  A return value of {@code true} indicates the\n     * path was added to the selection. A return value of {@code false}\n     * indicates the path is no longer selected.\n     *\n     * @param index the index of the path to test\n     * @return {@code true} if the path was added to the selection,\n     *         {@code false} otherwise\n     * @throws IllegalArgumentException if index is outside the range of\n     *         {@code getPaths}\n     * @see #getPaths\n     *\n     * @since 1.3\n     */\n    public boolean isAddedPath(int index) {\n        if (paths == null || index < 0 || index >= paths.length) {\n            throw new IllegalArgumentException(\"index is beyond range of added paths identified by TreeSelectionEvent\");\n        }\n        return areNew[index];\n    }"}
{"Number":"1114","API Relative Path":"javax.swing.filechooser.FileSystemView.java-getParentDirectory(File)","Corresponding Source":"/**\n     * Returns the parent directory of <code>dir<\/code>.\n     * @param dir the <code>File<\/code> being queried\n     * @return the parent directory of <code>dir<\/code>, or\n     *   <code>null<\/code> if <code>dir<\/code> is <code>null<\/code>\n     */\n    public File getParentDirectory(File dir) {\n        if (dir == null || !dir.exists()) {\n            return null;\n        }\n\n        ShellFolder sf;\n\n        try {\n            sf = getShellFolder(dir);\n        } catch (FileNotFoundException e) {\n            return null;\n        }\n\n        File psf = sf.getParentFile();\n\n        if (psf == null) {\n            return null;\n        }\n\n        if (isFileSystem(psf)) {\n            File f = psf;\n            if (!f.exists()) {\n                // This could be a node under \"Network Neighborhood\".\n                File ppsf = psf.getParentFile();\n                if (ppsf == null || !isFileSystem(ppsf)) {\n                    // We're mostly after the exists() override for windows below.\n                    f = createFileSystemRoot(f);\n                }\n            }\n            return f;\n        } else {\n            return psf;\n        }\n    }"}
{"Number":"1115","API Relative Path":"javax.swing.filechooser.FileSystemView.java-getSystemDisplayName(File)","Corresponding Source":"/**\n     * Name of a file, directory, or folder as it would be displayed in\n     * a system file browser. Example from Windows: the \"M:\\\" directory\n     * displays as \"CD-ROM (M:)\"\n     *\n     * The default implementation gets information from the ShellFolder class.\n     *\n     * @param f a <code>File<\/code> object\n     * @return the file name as it would be displayed by a native file chooser\n     * @see JFileChooser#getName\n     * @since 1.4\n     */\n    public String getSystemDisplayName(File f) {\n        if (f == null) {\n            return null;\n        }\n\n        String name = f.getName();\n\n        if (!name.equals(\"..\") && !name.equals(\".\") &&\n                (useSystemExtensionHiding || !isFileSystem(f) || isFileSystemRoot(f)) &&\n                (f instanceof ShellFolder || f.exists())) {\n\n            try {\n                name = getShellFolder(f).getDisplayName();\n            } catch (FileNotFoundException e) {\n                return null;\n            }\n\n            if (name == null || name.length() == 0) {\n                name = f.getPath(); // e.g. \"/\"\n            }\n        }\n\n        return name;\n    }"}
{"Number":"1116","API Relative Path":"javax.swing.filechooser.FileSystemView.java-getSystemIcon(File)","Corresponding Source":"/**\n     * Icon for a file, directory, or folder as it would be displayed in\n     * a system file browser. Example from Windows: the \"M:\\\" directory\n     * displays a CD-ROM icon.\n     *\n     * The default implementation gets information from the ShellFolder class.\n     *\n     * @param f a <code>File<\/code> object\n     * @return an icon as it would be displayed by a native file chooser\n     * @see JFileChooser#getIcon\n     * @since 1.4\n     */\n    public Icon getSystemIcon(File f) {\n        if (f == null) {\n            return null;\n        }\n\n        ShellFolder sf;\n\n        try {\n            sf = getShellFolder(f);\n        } catch (FileNotFoundException e) {\n            return null;\n        }\n\n        Image img = sf.getIcon(false);\n\n        if (img != null) {\n            return new ImageIcon(img, sf.getFolderType());\n        } else {\n            return UIManager.getIcon(f.isDirectory() ? \"FileView.directoryIcon\" : \"FileView.fileIcon\");\n        }\n    }"}
{"Number":"1117","API Relative Path":"javax.swing.GroupLayout.java-getLayoutAlignmentX(Container)","Corresponding Source":"/**\n     * Returns the alignment along the x axis.  This specifies how\n     * the component would like to be aligned relative to other\n     * components.  The value should be a number between 0 and 1\n     * where 0 represents alignment along the origin, 1 is aligned\n     * the furthest away from the origin, 0.5 is centered, etc.\n     *\n     * @param parent the {@code Container} hosting this {@code LayoutManager}\n     * @throws IllegalArgumentException if {@code parent} is not\n     *         the same {@code Container} that this was created with\n     * @return the alignment; this implementation returns {@code .5}\n     */\n    public float getLayoutAlignmentX(Container parent) {\n        checkParent(parent);\n        return .5f;\n    }"}
{"Number":"1118","API Relative Path":"javax.swing.GroupLayout.java-getLayoutAlignmentY(Container)","Corresponding Source":"/**\n     * Returns the alignment along the y axis.  This specifies how\n     * the component would like to be aligned relative to other\n     * components.  The value should be a number between 0 and 1\n     * where 0 represents alignment along the origin, 1 is aligned\n     * the furthest away from the origin, 0.5 is centered, etc.\n     *\n     * @param parent the {@code Container} hosting this {@code LayoutManager}\n     * @throws IllegalArgumentException if {@code parent} is not\n     *         the same {@code Container} that this was created with\n     * @return alignment; this implementation returns {@code .5}\n     */\n    public float getLayoutAlignmentY(Container parent) {\n        checkParent(parent);\n        return .5f;\n    }"}
{"Number":"1119","API Relative Path":"javax.swing.GroupLayout.java-invalidateLayout(Container)","Corresponding Source":"/**\n     * Invalidates the layout, indicating that if the layout manager\n     * has cached information it should be discarded.\n     *\n     * @param parent the {@code Container} hosting this LayoutManager\n     * @throws IllegalArgumentException if {@code parent} is not\n     *         the same {@code Container} that this was created with\n     */\n    public void invalidateLayout(Container parent) {\n        checkParent(parent);\n        // invalidateLayout is called from Container.invalidate, which\n        // does NOT grab the treelock.  All other methods do.  To make sure\n        // there aren't any possible threading problems we grab the tree lock\n        // here.\n        synchronized(parent.getTreeLock()) {\n            isValid = false;\n        }\n    }"}
{"Number":"1120","API Relative Path":"javax.swing.GroupLayout.java-linkSize(int-Component)","Corresponding Source":"/**\n     * Forces the specified components to have the same size along the\n     * specified axis regardless of their preferred, minimum or\n     * maximum sizes. Components that are linked are given the maximum\n     * of the preferred size of each of the linked components. For\n     * example, if you link two components along the horizontal axis\n     * and the preferred width is 10 and 20, both components are given\n     * a width of 20.\n     * <p>\n     * This can be used multiple times to force any number of\n     * components to share the same size.\n     * <p>\n     * Linked {@code Component}s are not be resizable.\n     *\n     * @param components the {@code Component}s that are to have the same size\n     * @param axis the axis to link the size along; one of\n     *             {@code SwingConstants.HORIZONTAL} or\n     *             {@code SwingConstans.VERTICAL}\n     * @throws IllegalArgumentException if {@code components} is\n     *         {@code null}, or contains {@code null}; or {@code axis}\n     *          is not {@code SwingConstants.HORIZONTAL} or\n     *          {@code SwingConstants.VERTICAL}\n     */\n    public void linkSize(int axis, Component... components) {\n        if (components == null) {\n            throw new IllegalArgumentException(\"Components must be non-null\");\n        }\n        for (int counter = components.length - 1; counter >= 0; counter--) {\n            Component c = components[counter];\n            if (components[counter] == null) {\n                throw new IllegalArgumentException(\n                        \"Components must be non-null\");\n            }\n            // Force the component to be added\n            getComponentInfo(c);\n        }\n        int glAxis;\n        if (axis == SwingConstants.HORIZONTAL) {\n            glAxis = HORIZONTAL;\n        } else if (axis == SwingConstants.VERTICAL) {\n            glAxis = VERTICAL;\n        } else {\n            throw new IllegalArgumentException(\"Axis must be one of \" +\n                    \"SwingConstants.HORIZONTAL or SwingConstants.VERTICAL\");\n        }\n        LinkInfo master = getComponentInfo(\n                components[components.length - 1]).getLinkInfo(glAxis);\n        for (int counter = components.length - 2; counter >= 0; counter--) {\n            master.add(getComponentInfo(components[counter]));\n        }\n        invalidateHost();\n    }"}
{"Number":"1121","API Relative Path":"javax.swing.GroupLayout.java-maximumLayoutSize(Container)","Corresponding Source":"/**\n     * Returns the maximum size for the specified container.\n     *\n     * @param parent the container to return the size for\n     * @return the maximum size for {@code parent}\n     * @throws IllegalArgumentException if {@code parent} is not\n     *         the same {@code Container} that this was created with\n     * @throws IllegalStateException if any of the components added to\n     *         this layout are not in both a horizontal and vertical group\n     * @see java.awt.Container#getMaximumSize\n     */\n    public Dimension maximumLayoutSize(Container parent) {\n        checkParent(parent);\n        prepare(MAX_SIZE);\n        return adjustSize(horizontalGroup.getMaximumSize(HORIZONTAL),\n                verticalGroup.getMaximumSize(VERTICAL));\n    }"}
{"Number":"1122","API Relative Path":"javax.swing.GroupLayout.java-minimumLayoutSize(Container)","Corresponding Source":"/**\n     * Returns the minimum size for the specified container.\n     *\n     * @param parent the container to return the size for\n     * @return the minimum size for {@code parent}\n     * @throws IllegalArgumentException if {@code parent} is not\n     *         the same {@code Container} that this was created with\n     * @throws IllegalStateException if any of the components added to\n     *         this layout are not in both a horizontal and vertical group\n     * @see java.awt.Container#getMinimumSize\n     */\n    public Dimension minimumLayoutSize(Container parent) {\n        checkParent(parent);\n        prepare(MIN_SIZE);\n        return adjustSize(horizontalGroup.getMinimumSize(HORIZONTAL),\n                verticalGroup.getMinimumSize(VERTICAL));\n    }"}
{"Number":"1123","API Relative Path":"javax.swing.GroupLayout.java-preferredLayoutSize(Container)","Corresponding Source":"/**\n     * Returns the preferred size for the specified container.\n     *\n     * @param parent the container to return the preferred size for\n     * @return the preferred size for {@code parent}\n     * @throws IllegalArgumentException if {@code parent} is not\n     *         the same {@code Container} this was created with\n     * @throws IllegalStateException if any of the components added to\n     *         this layout are not in both a horizontal and vertical group\n     * @see java.awt.Container#getPreferredSize\n     */\n    public Dimension preferredLayoutSize(Container parent) {\n        checkParent(parent);\n        prepare(PREF_SIZE);\n        return adjustSize(horizontalGroup.getPreferredSize(HORIZONTAL),\n                verticalGroup.getPreferredSize(VERTICAL));\n    }"}
{"Number":"1124","API Relative Path":"javax.swing.GroupLayout.java-replace(Component-Component)","Corresponding Source":"/**\n     * Replaces an existing component with a new one.\n     *\n     * @param existingComponent the component that should be removed\n     *        and replaced with {@code newComponent}\n     * @param newComponent the component to put in\n     *        {@code existingComponent}'s place\n     * @throws IllegalArgumentException if either of the components are\n     *         {@code null} or {@code existingComponent} is not being managed\n     *         by this layout manager\n     */\n    public void replace(Component existingComponent, Component newComponent) {\n        if (existingComponent == null || newComponent == null) {\n            throw new IllegalArgumentException(\"Components must be non-null\");\n        }\n        // Make sure all the components have been registered, otherwise we may\n        // not update the correct Springs.\n        if (springsChanged) {\n            registerComponents(horizontalGroup, HORIZONTAL);\n            registerComponents(verticalGroup, VERTICAL);\n        }\n        ComponentInfo info = componentInfos.remove(existingComponent);\n        if (info == null) {\n            throw new IllegalArgumentException(\"Component must already exist\");\n        }\n        host.remove(existingComponent);\n        if (newComponent.getParent() != host) {\n            host.add(newComponent);\n        }\n        info.setComponent(newComponent);\n        componentInfos.put(newComponent, info);\n        invalidateHost();\n    }"}
{"Number":"1125","API Relative Path":"javax.swing.GroupLayout.java-replace(Component-Component)","Corresponding Source":"/**\n     * Replaces an existing component with a new one.\n     *\n     * @param existingComponent the component that should be removed\n     *        and replaced with {@code newComponent}\n     * @param newComponent the component to put in\n     *        {@code existingComponent}'s place\n     * @throws IllegalArgumentException if either of the components are\n     *         {@code null} or {@code existingComponent} is not being managed\n     *         by this layout manager\n     */\n    public void replace(Component existingComponent, Component newComponent) {\n        if (existingComponent == null || newComponent == null) {\n            throw new IllegalArgumentException(\"Components must be non-null\");\n        }\n        // Make sure all the components have been registered, otherwise we may\n        // not update the correct Springs.\n        if (springsChanged) {\n            registerComponents(horizontalGroup, HORIZONTAL);\n            registerComponents(verticalGroup, VERTICAL);\n        }\n        ComponentInfo info = componentInfos.remove(existingComponent);\n        if (info == null) {\n            throw new IllegalArgumentException(\"Component must already exist\");\n        }\n        host.remove(existingComponent);\n        if (newComponent.getParent() != host) {\n            host.add(newComponent);\n        }\n        info.setComponent(newComponent);\n        componentInfos.put(newComponent, info);\n        invalidateHost();\n    }"}
{"Number":"1126","API Relative Path":"javax.swing.GroupLayout.java-replace(Component-Component)","Corresponding Source":"/**\n     * Replaces an existing component with a new one.\n     *\n     * @param existingComponent the component that should be removed\n     *        and replaced with {@code newComponent}\n     * @param newComponent the component to put in\n     *        {@code existingComponent}'s place\n     * @throws IllegalArgumentException if either of the components are\n     *         {@code null} or {@code existingComponent} is not being managed\n     *         by this layout manager\n     */\n    public void replace(Component existingComponent, Component newComponent) {\n        if (existingComponent == null || newComponent == null) {\n            throw new IllegalArgumentException(\"Components must be non-null\");\n        }\n        // Make sure all the components have been registered, otherwise we may\n        // not update the correct Springs.\n        if (springsChanged) {\n            registerComponents(horizontalGroup, HORIZONTAL);\n            registerComponents(verticalGroup, VERTICAL);\n        }\n        ComponentInfo info = componentInfos.remove(existingComponent);\n        if (info == null) {\n            throw new IllegalArgumentException(\"Component must already exist\");\n        }\n        host.remove(existingComponent);\n        if (newComponent.getParent() != host) {\n            host.add(newComponent);\n        }\n        info.setComponent(newComponent);\n        componentInfos.put(newComponent, info);\n        invalidateHost();\n    }"}
{"Number":"1127","API Relative Path":"javax.swing.InputMap.java-put(KeyStroke-Object)","Corresponding Source":"/**\n     * Adds a binding for <code>keyStroke<\/code> to <code>actionMapKey<\/code>.\n     * If <code>actionMapKey<\/code> is null, this removes the current binding\n     * for <code>keyStroke<\/code>.\n     */\n    public void put(KeyStroke keyStroke, Object actionMapKey) {\n        if (keyStroke == null) {\n            return;\n        }\n        if (actionMapKey == null) {\n            remove(keyStroke);\n        }\n        else {\n            if (arrayTable == null) {\n                arrayTable = new ArrayTable();\n            }\n            arrayTable.put(keyStroke, actionMapKey);\n        }\n    }"}
{"Number":"1128","API Relative Path":"javax.swing.JApplet.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified child <code>Component<\/code>.\n     * This method is overridden to conditionally forward calls to the\n     * <code>contentPane<\/code>.\n     * By default, children are added to the <code>contentPane<\/code> instead\n     * of the frame, refer to {@link javax.swing.RootPaneContainer} for\n     * details.\n     *\n     * @param comp the component to be enhanced\n     * @param constraints the constraints to be respected\n     * @param index the index\n     * @exception IllegalArgumentException if <code>index<\/code> is invalid\n     * @exception IllegalArgumentException if adding the container's parent\n     *                  to itself\n     * @exception IllegalArgumentException if adding a window to a container\n     *\n     * @see #setRootPaneCheckingEnabled\n     * @see javax.swing.RootPaneContainer\n     */\n    protected void addImpl(Component comp, Object constraints, int index)\n    {\n        if(isRootPaneCheckingEnabled()) {\n            getContentPane().add(comp, constraints, index);\n        }\n        else {\n            super.addImpl(comp, constraints, index);\n        }\n    }"}
{"Number":"1129","API Relative Path":"javax.swing.JApplet.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified child <code>Component<\/code>.\n     * This method is overridden to conditionally forward calls to the\n     * <code>contentPane<\/code>.\n     * By default, children are added to the <code>contentPane<\/code> instead\n     * of the frame, refer to {@link javax.swing.RootPaneContainer} for\n     * details.\n     *\n     * @param comp the component to be enhanced\n     * @param constraints the constraints to be respected\n     * @param index the index\n     * @exception IllegalArgumentException if <code>index<\/code> is invalid\n     * @exception IllegalArgumentException if adding the container's parent\n     *                  to itself\n     * @exception IllegalArgumentException if adding a window to a container\n     *\n     * @see #setRootPaneCheckingEnabled\n     * @see javax.swing.RootPaneContainer\n     */\n    protected void addImpl(Component comp, Object constraints, int index)\n    {\n        if(isRootPaneCheckingEnabled()) {\n            getContentPane().add(comp, constraints, index);\n        }\n        else {\n            super.addImpl(comp, constraints, index);\n        }\n    }"}
{"Number":"1130","API Relative Path":"javax.swing.JApplet.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified child <code>Component<\/code>.\n     * This method is overridden to conditionally forward calls to the\n     * <code>contentPane<\/code>.\n     * By default, children are added to the <code>contentPane<\/code> instead\n     * of the frame, refer to {@link javax.swing.RootPaneContainer} for\n     * details.\n     *\n     * @param comp the component to be enhanced\n     * @param constraints the constraints to be respected\n     * @param index the index\n     * @exception IllegalArgumentException if <code>index<\/code> is invalid\n     * @exception IllegalArgumentException if adding the container's parent\n     *                  to itself\n     * @exception IllegalArgumentException if adding a window to a container\n     *\n     * @see #setRootPaneCheckingEnabled\n     * @see javax.swing.RootPaneContainer\n     */\n    protected void addImpl(Component comp, Object constraints, int index)\n    {\n        if(isRootPaneCheckingEnabled()) {\n            getContentPane().add(comp, constraints, index);\n        }\n        else {\n            super.addImpl(comp, constraints, index);\n        }\n    }"}
{"Number":"1131","API Relative Path":"javax.swing.JButton.java-JButton(Action)","Corresponding Source":"/**\n     * Creates a button where properties are taken from the\n     * <code>Action<\/code> supplied.\n     *\n     * @param a the <code>Action<\/code> used to specify the new button\n     *\n     * @since 1.3\n     */\n    public JButton(Action a) {\n        this();\n        setAction(a);\n    }"}
{"Number":"1132","API Relative Path":"javax.swing.JCheckBox.java-JCheckBox(Action)","Corresponding Source":"/**\n     * Creates a check box where properties are taken from the\n     * Action supplied.\n     *\n     * @since 1.3\n     */\n    public JCheckBox(Action a) {\n        this();\n        setAction(a);\n    }"}
{"Number":"1133","API Relative Path":"javax.swing.JCheckBoxMenuItem.java-JCheckBoxMenuItem(Action)","Corresponding Source":"/**\n     * Creates a menu item whose properties are taken from the\n     * Action supplied.\n     *\n     * @since 1.3\n     */\n    public JCheckBoxMenuItem(Action a) {\n        this();\n        setAction(a);\n    }"}
{"Number":"1134","API Relative Path":"javax.swing.JComboBox.java-addActionListener(ActionListener)","Corresponding Source":"/**\n     * Adds an <code>ActionListener<\/code>.\n     * <p>\n     * The <code>ActionListener<\/code> will receive an <code>ActionEvent<\/code>\n     * when a selection has been made. If the combo box is editable, then\n     * an <code>ActionEvent<\/code> will be fired when editing has stopped.\n     *\n     * @param l  the <code>ActionListener<\/code> that is to be notified\n     * @see #setSelectedItem\n     */\n    public void addActionListener(ActionListener l) {\n        listenerList.add(ActionListener.class,l);\n    }"}
{"Number":"1135","API Relative Path":"javax.swing.JComboBox.java-addItemListener(ItemListener)","Corresponding Source":"/** Selection **/\n\n    /**\n     * Adds an <code>ItemListener<\/code>.\n     * <p>\n     * <code>aListener<\/code> will receive one or two <code>ItemEvent<\/code>s when\n     * the selected item changes.\n     *\n     * @param aListener the <code>ItemListener<\/code> that is to be notified\n     * @see #setSelectedItem\n     */\n    public void addItemListener(ItemListener aListener) {\n        listenerList.add(ItemListener.class,aListener);\n    }"}
{"Number":"1136","API Relative Path":"javax.swing.JComboBox.java-addPopupMenuListener(PopupMenuListener)","Corresponding Source":"/**\n     * Adds a <code>PopupMenu<\/code> listener which will listen to notification\n     * messages from the popup portion of the combo box.\n     * <p>\n     * For all standard look and feels shipped with Java, the popup list\n     * portion of combo box is implemented as a <code>JPopupMenu<\/code>.\n     * A custom look and feel may not implement it this way and will\n     * therefore not receive the notification.\n     *\n     * @param l  the <code>PopupMenuListener<\/code> to add\n     * @since 1.4\n     */\n    public void addPopupMenuListener(PopupMenuListener l) {\n        listenerList.add(PopupMenuListener.class,l);\n    }"}
{"Number":"1137","API Relative Path":"javax.swing.JComboBox.java-removeActionListener(ActionListener)","Corresponding Source":"/** Removes an <code>ActionListener<\/code>.\n     *\n     * @param l  the <code>ActionListener<\/code> to remove\n     */\n    public void removeActionListener(ActionListener l) {\n        if ((l != null) && (getAction() == l)) {\n            setAction(null);\n        } else {\n            listenerList.remove(ActionListener.class, l);\n        }\n    }"}
{"Number":"1138","API Relative Path":"javax.swing.JComboBox.java-removeItemListener(ItemListener)","Corresponding Source":"/** Removes an <code>ItemListener<\/code>.\n     *\n     * @param aListener  the <code>ItemListener<\/code> to remove\n     */\n    public void removeItemListener(ItemListener aListener) {\n        listenerList.remove(ItemListener.class,aListener);\n    }"}
{"Number":"1139","API Relative Path":"javax.swing.JComboBox.java-removePopupMenuListener(PopupMenuListener)","Corresponding Source":"/**\n     * Removes a <code>PopupMenuListener<\/code>.\n     *\n     * @param l  the <code>PopupMenuListener<\/code> to remove\n     * @see #addPopupMenuListener\n     * @since 1.4\n     */\n    public void removePopupMenuListener(PopupMenuListener l) {\n        listenerList.remove(PopupMenuListener.class,l);\n    }"}
{"Number":"1140","API Relative Path":"javax.swing.JComboBox.java-setAction(Action)","Corresponding Source":"/**\n     * Sets the <code>Action<\/code> for the <code>ActionEvent<\/code> source.\n     * The new <code>Action<\/code> replaces any previously set\n     * <code>Action<\/code> but does not affect <code>ActionListeners<\/code>\n     * independently added with <code>addActionListener<\/code>.\n     * If the <code>Action<\/code> is already a registered\n     * <code>ActionListener<\/code> for the <code>ActionEvent<\/code> source,\n     * it is not re-registered.\n     * <p>\n     * Setting the <code>Action<\/code> results in immediately changing\n     * all the properties described in <a href=\"Action.html#buttonActions\">\n     * Swing Components Supporting <code>Action<\/code><\/a>.\n     * Subsequently, the combobox's properties are automatically updated\n     * as the <code>Action<\/code>'s properties change.\n     * <p>\n     * This method uses three other methods to set\n     * and help track the <code>Action<\/code>'s property values.\n     * It uses the <code>configurePropertiesFromAction<\/code> method\n     * to immediately change the combobox's properties.\n     * To track changes in the <code>Action<\/code>'s property values,\n     * this method registers the <code>PropertyChangeListener<\/code>\n     * returned by <code>createActionPropertyChangeListener<\/code>. The\n     * default {@code PropertyChangeListener} invokes the\n     * {@code actionPropertyChanged} method when a property in the\n     * {@code Action} changes.\n     *\n     * @param a the <code>Action<\/code> for the <code>JComboBox<\/code>,\n     *                  or <code>null<\/code>.\n     * @since 1.3\n     * @see Action\n     * @see #getAction\n     * @see #configurePropertiesFromAction\n     * @see #createActionPropertyChangeListener\n     * @see #actionPropertyChanged\n     * @beaninfo\n     *        bound: true\n     *    attribute: visualUpdate true\n     *  description: the Action instance connected with this ActionEvent source\n     */\n    public void setAction(Action a) {\n        Action oldValue = getAction();\n        if (action==null || !action.equals(a)) {\n            action = a;\n            if (oldValue!=null) {\n                removeActionListener(oldValue);\n                oldValue.removePropertyChangeListener(actionPropertyChangeListener);\n                actionPropertyChangeListener = null;\n            }\n            configurePropertiesFromAction(action);\n            if (action!=null) {\n                // Don't add if it is already a listener\n                if (!isListener(ActionListener.class, action)) {\n                    addActionListener(action);\n                }\n                // Reverse linkage:\n                actionPropertyChangeListener = createActionPropertyChangeListener(action);\n                action.addPropertyChangeListener(actionPropertyChangeListener);\n            }\n            firePropertyChange(\"action\", oldValue, action);\n        }\n    }"}
{"Number":"1141","API Relative Path":"javax.swing.JComponent.java-putClientProperty(Object-Object)","Corresponding Source":"/**\n     * Adds an arbitrary key/value \"client property\" to this component.\n     * <p>\n     * The <code>get/putClientProperty<\/code> methods provide access to\n     * a small per-instance hashtable. Callers can use get/putClientProperty\n     * to annotate components that were created by another module.\n     * For example, a\n     * layout manager might store per child constraints this way. For example:\n     * <pre>\n     * componentA.putClientProperty(\"to the left of\", componentB);\n     * <\/pre>\n     * If value is <code>null<\/code> this method will remove the property.\n     * Changes to client properties are reported with\n     * <code>PropertyChange<\/code> events.\n     * The name of the property (for the sake of PropertyChange\n     * events) is <code>key.toString()<\/code>.\n     * <p>\n     * The <code>clientProperty<\/code> dictionary is not intended to\n     * support large\n     * scale extensions to JComponent nor should be it considered an\n     * alternative to subclassing when designing a new component.\n     *\n     * @param key the new client property key\n     * @param value the new client property value; if <code>null<\/code>\n     *          this method will remove the property\n     * @see #getClientProperty\n     * @see #addPropertyChangeListener\n     */\n    public final void putClientProperty(Object key, Object value) {\n        if (key == SwingUtilities2.AA_TEXT_PROPERTY_KEY) {\n            aaTextInfo = value;\n            return;\n        }\n        if (value == null && clientProperties == null) {\n            // Both the value and ArrayTable are null, implying we don't\n            // have to do anything.\n            return;\n        }\n        ArrayTable clientProperties = getClientProperties();\n        Object oldValue;\n        synchronized(clientProperties) {\n            oldValue = clientProperties.get(key);\n            if (value != null) {\n                clientProperties.put(key, value);\n            } else if (oldValue != null) {\n                clientProperties.remove(key);\n            } else {\n                // old == new == null\n                return;\n            }\n        }\n        clientPropertyChanged(key, oldValue, value);\n        firePropertyChange(key.toString(), oldValue, value);\n    }"}
{"Number":"1142","API Relative Path":"javax.swing.JComponent.java-registerKeyboardAction(ActionListener-String-KeyStroke-int)","Corresponding Source":"/**\n     * This method is now obsolete, please use a combination of\n     * <code>getActionMap()<\/code> and <code>getInputMap()<\/code> for\n     * similar behavior. For example, to bind the <code>KeyStroke<\/code>\n     * <code>aKeyStroke<\/code> to the <code>Action<\/code> <code>anAction<\/code>\n     * now use:\n     * <pre>\n     *   component.getInputMap().put(aKeyStroke, aCommand);\n     *   component.getActionMap().put(aCommmand, anAction);\n     * <\/pre>\n     * The above assumes you want the binding to be applicable for\n     * <code>WHEN_FOCUSED<\/code>. To register bindings for other focus\n     * states use the <code>getInputMap<\/code> method that takes an integer.\n     * <p>\n     * Register a new keyboard action.\n     * <code>anAction<\/code> will be invoked if a key event matching\n     * <code>aKeyStroke<\/code> occurs and <code>aCondition<\/code> is verified.\n     * The <code>KeyStroke<\/code> object defines a\n     * particular combination of a keyboard key and one or more modifiers\n     * (alt, shift, ctrl, meta).\n     * <p>\n     * The <code>aCommand<\/code> will be set in the delivered event if\n     * specified.\n     * <p>\n     * The <code>aCondition<\/code> can be one of:\n     * <blockquote>\n     * <DL>\n     * <DT>WHEN_FOCUSED\n     * <DD>The action will be invoked only when the keystroke occurs\n     *     while the component has the focus.\n     * <DT>WHEN_IN_FOCUSED_WINDOW\n     * <DD>The action will be invoked when the keystroke occurs while\n     *     the component has the focus or if the component is in the\n     *     window that has the focus. Note that the component need not\n     *     be an immediate descendent of the window -- it can be\n     *     anywhere in the window's containment hierarchy. In other\n     *     words, whenever <em>any<\/em> component in the window has the focus,\n     *     the action registered with this component is invoked.\n     * <DT>WHEN_ANCESTOR_OF_FOCUSED_COMPONENT\n     * <DD>The action will be invoked when the keystroke occurs while the\n     *     component has the focus or if the component is an ancestor of\n     *     the component that has the focus.\n     * <\/DL>\n     * <\/blockquote>\n     * <p>\n     * The combination of keystrokes and conditions lets you define high\n     * level (semantic) action events for a specified keystroke+modifier\n     * combination (using the KeyStroke class) and direct to a parent or\n     * child of a component that has the focus, or to the component itself.\n     * In other words, in any hierarchical structure of components, an\n     * arbitrary key-combination can be immediately directed to the\n     * appropriate component in the hierarchy, and cause a specific method\n     * to be invoked (usually by way of adapter objects).\n     * <p>\n     * If an action has already been registered for the receiving\n     * container, with the same charCode and the same modifiers,\n     * <code>anAction<\/code> will replace the action.\n     *\n     * @param anAction  the <code>Action<\/code> to be registered\n     * @param aCommand  the command to be set in the delivered event\n     * @param aKeyStroke the <code>KeyStroke<\/code> to bind to the action\n     * @param aCondition the condition that needs to be met, see above\n     * @see KeyStroke\n     */\n    public void registerKeyboardAction(ActionListener anAction,String aCommand,KeyStroke aKeyStroke,int aCondition) {\n\n        InputMap inputMap = getInputMap(aCondition, true);\n\n        if (inputMap != null) {\n            ActionMap actionMap = getActionMap(true);\n            ActionStandin action = new ActionStandin(anAction, aCommand);\n            inputMap.put(aKeyStroke, action);\n            if (actionMap != null) {\n                actionMap.put(action, action);\n            }\n        }\n    }"}
{"Number":"1143","API Relative Path":"javax.swing.JComponent.java-registerKeyboardAction(ActionListener-String-KeyStroke-int)","Corresponding Source":"/**\n     * This method is now obsolete, please use a combination of\n     * <code>getActionMap()<\/code> and <code>getInputMap()<\/code> for\n     * similar behavior. For example, to bind the <code>KeyStroke<\/code>\n     * <code>aKeyStroke<\/code> to the <code>Action<\/code> <code>anAction<\/code>\n     * now use:\n     * <pre>\n     *   component.getInputMap().put(aKeyStroke, aCommand);\n     *   component.getActionMap().put(aCommmand, anAction);\n     * <\/pre>\n     * The above assumes you want the binding to be applicable for\n     * <code>WHEN_FOCUSED<\/code>. To register bindings for other focus\n     * states use the <code>getInputMap<\/code> method that takes an integer.\n     * <p>\n     * Register a new keyboard action.\n     * <code>anAction<\/code> will be invoked if a key event matching\n     * <code>aKeyStroke<\/code> occurs and <code>aCondition<\/code> is verified.\n     * The <code>KeyStroke<\/code> object defines a\n     * particular combination of a keyboard key and one or more modifiers\n     * (alt, shift, ctrl, meta).\n     * <p>\n     * The <code>aCommand<\/code> will be set in the delivered event if\n     * specified.\n     * <p>\n     * The <code>aCondition<\/code> can be one of:\n     * <blockquote>\n     * <DL>\n     * <DT>WHEN_FOCUSED\n     * <DD>The action will be invoked only when the keystroke occurs\n     *     while the component has the focus.\n     * <DT>WHEN_IN_FOCUSED_WINDOW\n     * <DD>The action will be invoked when the keystroke occurs while\n     *     the component has the focus or if the component is in the\n     *     window that has the focus. Note that the component need not\n     *     be an immediate descendent of the window -- it can be\n     *     anywhere in the window's containment hierarchy. In other\n     *     words, whenever <em>any<\/em> component in the window has the focus,\n     *     the action registered with this component is invoked.\n     * <DT>WHEN_ANCESTOR_OF_FOCUSED_COMPONENT\n     * <DD>The action will be invoked when the keystroke occurs while the\n     *     component has the focus or if the component is an ancestor of\n     *     the component that has the focus.\n     * <\/DL>\n     * <\/blockquote>\n     * <p>\n     * The combination of keystrokes and conditions lets you define high\n     * level (semantic) action events for a specified keystroke+modifier\n     * combination (using the KeyStroke class) and direct to a parent or\n     * child of a component that has the focus, or to the component itself.\n     * In other words, in any hierarchical structure of components, an\n     * arbitrary key-combination can be immediately directed to the\n     * appropriate component in the hierarchy, and cause a specific method\n     * to be invoked (usually by way of adapter objects).\n     * <p>\n     * If an action has already been registered for the receiving\n     * container, with the same charCode and the same modifiers,\n     * <code>anAction<\/code> will replace the action.\n     *\n     * @param anAction  the <code>Action<\/code> to be registered\n     * @param aCommand  the command to be set in the delivered event\n     * @param aKeyStroke the <code>KeyStroke<\/code> to bind to the action\n     * @param aCondition the condition that needs to be met, see above\n     * @see KeyStroke\n     */\n    public void registerKeyboardAction(ActionListener anAction,String aCommand,KeyStroke aKeyStroke,int aCondition) {\n\n        InputMap inputMap = getInputMap(aCondition, true);\n\n        if (inputMap != null) {\n            ActionMap actionMap = getActionMap(true);\n            ActionStandin action = new ActionStandin(anAction, aCommand);\n            inputMap.put(aKeyStroke, action);\n            if (actionMap != null) {\n                actionMap.put(action, action);\n            }\n        }\n    }"}
{"Number":"1144","API Relative Path":"javax.swing.JComponent.java-setInputVerifier(InputVerifier)","Corresponding Source":"/**\n     * Sets the input verifier for this component.\n     *\n     * @param inputVerifier the new input verifier\n     * @since 1.3\n     * @see InputVerifier\n     * @beaninfo\n     *       bound: true\n     * description: The component's input verifier.\n     */\n    public void setInputVerifier(InputVerifier inputVerifier) {\n        InputVerifier oldInputVerifier = (InputVerifier)getClientProperty(\n                                         JComponent_INPUT_VERIFIER);\n        putClientProperty(JComponent_INPUT_VERIFIER, inputVerifier);\n        firePropertyChange(\"inputVerifier\", oldInputVerifier, inputVerifier);\n    }"}
{"Number":"1145","API Relative Path":"javax.swing.JComponent.java-setNextFocusableComponent(Component)","Corresponding Source":"/**\n     * In release 1.4, the focus subsystem was rearchitected.\n     * For more information, see\n     * <a href=\"http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html\">\n     * How to Use the Focus Subsystem<\/a>,\n     * a section in <em>The Java Tutorial<\/em>.\n     * <p>\n     * Overrides the default <code>FocusTraversalPolicy<\/code> for this\n     * <code>JComponent<\/code>'s focus traversal cycle by unconditionally\n     * setting the specified <code>Component<\/code> as the next\n     * <code>Component<\/code> in the cycle, and this <code>JComponent<\/code>\n     * as the specified <code>Component<\/code>'s previous\n     * <code>Component<\/code> in the cycle.\n     *\n     * @param aComponent the <code>Component<\/code> that should follow this\n     *        <code>JComponent<\/code> in the focus traversal cycle\n     *\n     * @see #getNextFocusableComponent\n     * @see java.awt.FocusTraversalPolicy\n     * @deprecated As of 1.4, replaced by <code>FocusTraversalPolicy<\/code>\n     */\n    @Deprecated\n    public void setNextFocusableComponent(Component aComponent) {\n        boolean displayable = isDisplayable();\n        if (displayable) {\n            deregisterNextFocusableComponent();\n        }\n        putClientProperty(NEXT_FOCUS, aComponent);\n        if (displayable) {\n            registerNextFocusableComponent(aComponent);\n        }\n    }"}
{"Number":"1146","API Relative Path":"javax.swing.JComponent.java-setNextFocusableComponent(Component)","Corresponding Source":"/**\n     * In release 1.4, the focus subsystem was rearchitected.\n     * For more information, see\n     * <a href=\"http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html\">\n     * How to Use the Focus Subsystem<\/a>,\n     * a section in <em>The Java Tutorial<\/em>.\n     * <p>\n     * Overrides the default <code>FocusTraversalPolicy<\/code> for this\n     * <code>JComponent<\/code>'s focus traversal cycle by unconditionally\n     * setting the specified <code>Component<\/code> as the next\n     * <code>Component<\/code> in the cycle, and this <code>JComponent<\/code>\n     * as the specified <code>Component<\/code>'s previous\n     * <code>Component<\/code> in the cycle.\n     *\n     * @param aComponent the <code>Component<\/code> that should follow this\n     *        <code>JComponent<\/code> in the focus traversal cycle\n     *\n     * @see #getNextFocusableComponent\n     * @see java.awt.FocusTraversalPolicy\n     * @deprecated As of 1.4, replaced by <code>FocusTraversalPolicy<\/code>\n     */\n    @Deprecated\n    public void setNextFocusableComponent(Component aComponent) {\n        boolean displayable = isDisplayable();\n        if (displayable) {\n            deregisterNextFocusableComponent();\n        }\n        putClientProperty(NEXT_FOCUS, aComponent);\n        if (displayable) {\n            registerNextFocusableComponent(aComponent);\n        }\n    }"}
{"Number":"1147","API Relative Path":"javax.swing.JComponent.java-setTransferHandler(TransferHandler)","Corresponding Source":"/**\n     * Sets the {@code TransferHandler}, which provides support for transfer\n     * of data into and out of this component via cut/copy/paste and drag\n     * and drop. This may be {@code null} if the component does not support\n     * data transfer operations.\n     * <p>\n     * If the new {@code TransferHandler} is not {@code null}, this method\n     * also installs a <b>new<\/b> {@code DropTarget} on the component to\n     * activate drop handling through the {@code TransferHandler} and activate\n     * any built-in support (such as calculating and displaying potential drop\n     * locations). If you do not wish for this component to respond in any way\n     * to drops, you can disable drop support entirely either by removing the\n     * drop target ({@code setDropTarget(null)}) or by de-activating it\n     * ({@code getDropTaget().setActive(false)}).\n     * <p>\n     * If the new {@code TransferHandler} is {@code null}, this method removes\n     * the drop target.\n     * <p>\n     * Under two circumstances, this method does not modify the drop target:\n     * First, if the existing drop target on this component was explicitly\n     * set by the developer to a {@code non-null} value. Second, if the\n     * system property {@code suppressSwingDropSupport} is {@code true}. The\n     * default value for the system property is {@code false}.\n     * <p>\n     * Please see\n     * <a href=\"http://docs.oracle.com/javase/tutorial/uiswing/dnd/index.html\">\n     * How to Use Drag and Drop and Data Transfer<\/a>,\n     * a section in <em>The Java Tutorial<\/em>, for more information.\n     *\n     * @param newHandler the new {@code TransferHandler}\n     *\n     * @see TransferHandler\n     * @see #getTransferHandler\n     * @since 1.4\n     * @beaninfo\n     *        bound: true\n     *       hidden: true\n     *  description: Mechanism for transfer of data to and from the component\n     */\n    public void setTransferHandler(TransferHandler newHandler) {\n        TransferHandler oldHandler = (TransferHandler)getClientProperty(\n                                      JComponent_TRANSFER_HANDLER);\n        putClientProperty(JComponent_TRANSFER_HANDLER, newHandler);\n\n        SwingUtilities.installSwingDropTargetAsNecessary(this, newHandler);\n        firePropertyChange(\"transferHandler\", oldHandler, newHandler);\n    }"}
{"Number":"1148","API Relative Path":"javax.swing.JDialog.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified child {@code Component}.\n     * This method is overridden to conditionally forward calls to the\n     * {@code contentPane}.\n     * By default, children are added to the {@code contentPane} instead\n     * of the frame, refer to {@link javax.swing.RootPaneContainer} for\n     * details.\n     *\n     * @param comp the component to be enhanced\n     * @param constraints the constraints to be respected\n     * @param index the index\n     * @throws IllegalArgumentException if {@code index} is invalid\n     * @throws IllegalArgumentException if adding the container's parent\n     *                  to itself\n     * @throws IllegalArgumentException if adding a window to a container\n     *\n     * @see #setRootPaneCheckingEnabled\n     * @see javax.swing.RootPaneContainer\n     */\n    protected void addImpl(Component comp, Object constraints, int index)\n    {\n        if(isRootPaneCheckingEnabled()) {\n            getContentPane().add(comp, constraints, index);\n        }\n        else {\n            super.addImpl(comp, constraints, index);\n        }\n    }"}
{"Number":"1149","API Relative Path":"javax.swing.JDialog.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified child {@code Component}.\n     * This method is overridden to conditionally forward calls to the\n     * {@code contentPane}.\n     * By default, children are added to the {@code contentPane} instead\n     * of the frame, refer to {@link javax.swing.RootPaneContainer} for\n     * details.\n     *\n     * @param comp the component to be enhanced\n     * @param constraints the constraints to be respected\n     * @param index the index\n     * @throws IllegalArgumentException if {@code index} is invalid\n     * @throws IllegalArgumentException if adding the container's parent\n     *                  to itself\n     * @throws IllegalArgumentException if adding a window to a container\n     *\n     * @see #setRootPaneCheckingEnabled\n     * @see javax.swing.RootPaneContainer\n     */\n    protected void addImpl(Component comp, Object constraints, int index)\n    {\n        if(isRootPaneCheckingEnabled()) {\n            getContentPane().add(comp, constraints, index);\n        }\n        else {\n            super.addImpl(comp, constraints, index);\n        }\n    }"}
{"Number":"1150","API Relative Path":"javax.swing.JDialog.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified child {@code Component}.\n     * This method is overridden to conditionally forward calls to the\n     * {@code contentPane}.\n     * By default, children are added to the {@code contentPane} instead\n     * of the frame, refer to {@link javax.swing.RootPaneContainer} for\n     * details.\n     *\n     * @param comp the component to be enhanced\n     * @param constraints the constraints to be respected\n     * @param index the index\n     * @throws IllegalArgumentException if {@code index} is invalid\n     * @throws IllegalArgumentException if adding the container's parent\n     *                  to itself\n     * @throws IllegalArgumentException if adding a window to a container\n     *\n     * @see #setRootPaneCheckingEnabled\n     * @see javax.swing.RootPaneContainer\n     */\n    protected void addImpl(Component comp, Object constraints, int index)\n    {\n        if(isRootPaneCheckingEnabled()) {\n            getContentPane().add(comp, constraints, index);\n        }\n        else {\n            super.addImpl(comp, constraints, index);\n        }\n    }"}
{"Number":"1151","API Relative Path":"javax.swing.JDialog.java-setDefaultCloseOperation(int)","Corresponding Source":"/**\n     * Sets the operation that will happen by default when\n     * the user initiates a \"close\" on this dialog.\n     * You must specify one of the following choices:\n     * <br><br>\n     * <ul>\n     * <li>{@code DO_NOTHING_ON_CLOSE}\n     * (defined in {@code WindowConstants}):\n     * Don't do anything; require the\n     * program to handle the operation in the {@code windowClosing}\n     * method of a registered {@code WindowListener} object.\n     *\n     * <li>{@code HIDE_ON_CLOSE}\n     * (defined in {@code WindowConstants}):\n     * Automatically hide the dialog after\n     * invoking any registered {@code WindowListener}\n     * objects.\n     *\n     * <li>{@code DISPOSE_ON_CLOSE}\n     * (defined in {@code WindowConstants}):\n     * Automatically hide and dispose the\n     * dialog after invoking any registered {@code WindowListener}\n     * objects.\n     * <\/ul>\n     * <p>\n     * The value is set to {@code HIDE_ON_CLOSE} by default. Changes\n     * to the value of this property cause the firing of a property\n     * change event, with property name \"defaultCloseOperation\".\n     * <p>\n     * <b>Note<\/b>: When the last displayable window within the\n     * Java virtual machine (VM) is disposed of, the VM may\n     * terminate.  See <a href=\"../../java/awt/doc-files/AWTThreadIssues.html\">\n     * AWT Threading Issues<\/a> for more information.\n     *\n     * @param operation the operation which should be performed when the\n     *        user closes the dialog\n     * @throws IllegalArgumentException if defaultCloseOperation value\n     *         isn't one of the above valid values\n     * @see #addWindowListener\n     * @see #getDefaultCloseOperation\n     * @see WindowConstants\n     *\n     * @beaninfo\n     *   preferred: true\n     *       bound: true\n     *        enum: DO_NOTHING_ON_CLOSE WindowConstants.DO_NOTHING_ON_CLOSE\n     *              HIDE_ON_CLOSE       WindowConstants.HIDE_ON_CLOSE\n     *              DISPOSE_ON_CLOSE    WindowConstants.DISPOSE_ON_CLOSE\n     * description: The dialog's default close operation.\n     */\n    public void setDefaultCloseOperation(int operation) {\n        if (operation != DO_NOTHING_ON_CLOSE &&\n            operation != HIDE_ON_CLOSE &&\n            operation != DISPOSE_ON_CLOSE) {\n            throw new IllegalArgumentException(\"defaultCloseOperation must be one of: DO_NOTHING_ON_CLOSE, HIDE_ON_CLOSE, or DISPOSE_ON_CLOSE\");\n        }\n\n        int oldValue = this.defaultCloseOperation;\n        this.defaultCloseOperation = operation;\n        firePropertyChange(\"defaultCloseOperation\", oldValue, operation);\n    }"}
{"Number":"1152","API Relative Path":"javax.swing.JEditorPane.java-addHyperlinkListener(HyperlinkListener)","Corresponding Source":"/**\n     * Adds a hyperlink listener for notification of any changes, for example\n     * when a link is selected and entered.\n     *\n     * @param listener the listener\n     */\n    public synchronized void addHyperlinkListener(HyperlinkListener listener) {\n        listenerList.add(HyperlinkListener.class, listener);\n    }"}
{"Number":"1153","API Relative Path":"javax.swing.JEditorPane.java-removeHyperlinkListener(HyperlinkListener)","Corresponding Source":"/**\n     * Removes a hyperlink listener.\n     *\n     * @param listener the listener\n     */\n    public synchronized void removeHyperlinkListener(HyperlinkListener listener) {\n        listenerList.remove(HyperlinkListener.class, listener);\n    }"}
{"Number":"1154","API Relative Path":"javax.swing.JEditorPane.java-setPage(String)","Corresponding Source":"/**\n     * Sets the current URL being displayed.\n     *\n     * @param url the URL for display\n     * @exception IOException for a <code>null<\/code> or invalid URL\n     *          specification\n     */\n    public void setPage(String url) throws IOException {\n        if (url == null) {\n            throw new IOException(\"invalid url\");\n        }\n        URL page = new URL(url);\n        setPage(page);\n    }"}
{"Number":"1155","API Relative Path":"javax.swing.JEditorPane.java-setPage(URL)","Corresponding Source":"/**\n     * Sets the current URL being displayed.  The content type of the\n     * pane is set, and if the editor kit for the pane is\n     * non-<code>null<\/code>, then\n     * a new default document is created and the URL is read into it.\n     * If the URL contains and reference location, the location will\n     * be scrolled to by calling the <code>scrollToReference<\/code>\n     * method. If the desired URL is the one currently being displayed,\n     * the document will not be reloaded. To force a document\n     * reload it is necessary to clear the stream description property\n     * of the document. The following code shows how this can be done:\n     *\n     * <pre>\n     *   Document doc = jEditorPane.getDocument();\n     *   doc.putProperty(Document.StreamDescriptionProperty, null);\n     * <\/pre>\n     *\n     * If the desired URL is not the one currently being\n     * displayed, the <code>getStream<\/code> method is called to\n     * give subclasses control over the stream provided.\n     * <p>\n     * This may load either synchronously or asynchronously\n     * depending upon the document returned by the <code>EditorKit<\/code>.\n     * If the <code>Document<\/code> is of type\n     * <code>AbstractDocument<\/code> and has a value returned by\n     * <code>AbstractDocument.getAsynchronousLoadPriority<\/code>\n     * that is greater than or equal to zero, the page will be\n     * loaded on a separate thread using that priority.\n     * <p>\n     * If the document is loaded synchronously, it will be\n     * filled in with the stream prior to being installed into\n     * the editor with a call to <code>setDocument<\/code>, which\n     * is bound and will fire a property change event.  If an\n     * <code>IOException<\/code> is thrown the partially loaded\n     * document will\n     * be discarded and neither the document or page property\n     * change events will be fired.  If the document is\n     * successfully loaded and installed, a view will be\n     * built for it by the UI which will then be scrolled if\n     * necessary, and then the page property change event\n     * will be fired.\n     * <p>\n     * If the document is loaded asynchronously, the document\n     * will be installed into the editor immediately using a\n     * call to <code>setDocument<\/code> which will fire a\n     * document property change event, then a thread will be\n     * created which will begin doing the actual loading.\n     * In this case, the page property change event will not be\n     * fired by the call to this method directly, but rather will be\n     * fired when the thread doing the loading has finished.\n     * It will also be fired on the event-dispatch thread.\n     * Since the calling thread can not throw an <code>IOException<\/code>\n     * in the event of failure on the other thread, the page\n     * property change event will be fired when the other\n     * thread is done whether the load was successful or not.\n     *\n     * @param page the URL of the page\n     * @exception IOException for a <code>null<\/code> or invalid\n     *          page specification, or exception from the stream being read\n     * @see #getPage\n     * @beaninfo\n     *  description: the URL used to set content\n     *        bound: true\n     *       expert: true\n     */\n    public void setPage(URL page) throws IOException {\n        if (page == null) {\n            throw new IOException(\"invalid url\");\n        }\n        URL loaded = getPage();\n\n\n        // reset scrollbar\n        if (!page.equals(loaded) && page.getRef() == null) {\n            scrollRectToVisible(new Rectangle(0,0,1,1));\n        }\n        boolean reloaded = false;\n        Object postData = getPostData();\n        if ((loaded == null) || !loaded.sameFile(page) || (postData != null)) {\n            // different url or POST method, load the new content\n\n            int p = getAsynchronousLoadPriority(getDocument());\n            if (p < 0) {\n                // open stream synchronously\n                InputStream in = getStream(page);\n                if (kit != null) {\n                    Document doc = initializeModel(kit, page);\n\n                    // At this point, one could either load up the model with no\n                    // view notifications slowing it down (i.e. best synchronous\n                    // behavior) or set the model and start to feed it on a separate\n                    // thread (best asynchronous behavior).\n                    p = getAsynchronousLoadPriority(doc);\n                    if (p >= 0) {\n                        // load asynchronously\n                        setDocument(doc);\n                        synchronized(this) {\n                            pageLoader = new PageLoader(doc, in, loaded, page);\n                            pageLoader.execute();\n                        }\n                        return;\n                    }\n                    read(in, doc);\n                    setDocument(doc);\n                    reloaded = true;\n                }\n            } else {\n                // we may need to cancel background loading\n                if (pageLoader != null) {\n                    pageLoader.cancel(true);\n                }\n\n                // Do everything in a background thread.\n                // Model initialization is deferred to that thread, too.\n                pageLoader = new PageLoader(null, null, loaded, page);\n                pageLoader.execute();\n                return;\n            }\n        }\n        final String reference = page.getRef();\n        if (reference != null) {\n            if (!reloaded) {\n                scrollToReference(reference);\n            }\n            else {\n                // Have to scroll after painted.\n                SwingUtilities.invokeLater(new Runnable() {\n                    public void run() {\n                        scrollToReference(reference);\n                    }\n                });\n            }\n            getDocument().putProperty(Document.StreamDescriptionProperty, page);\n        }\n        firePropertyChange(\"page\", loaded, page);\n    }"}
{"Number":"1156","API Relative Path":"javax.swing.JFileChooser.java-addActionListener(ActionListener)","Corresponding Source":"/**\n     * Adds an <code>ActionListener<\/code> to the file chooser.\n     *\n     * @param l  the listener to be added\n     *\n     * @see #approveSelection\n     * @see #cancelSelection\n     */\n    public void addActionListener(ActionListener l) {\n        listenerList.add(ActionListener.class, l);\n    }"}
{"Number":"1157","API Relative Path":"javax.swing.JFileChooser.java-addChoosableFileFilter(FileFilter)","Corresponding Source":"/**\n     * Adds a filter to the list of user choosable file filters.\n     * For information on setting the file selection mode, see\n     * {@link #setFileSelectionMode setFileSelectionMode}.\n     *\n     * @param filter the <code>FileFilter<\/code> to add to the choosable file\n     *               filter list\n     *\n     * @beaninfo\n     *   preferred: true\n     *       bound: true\n     * description: Adds a filter to the list of user choosable file filters.\n     *\n     * @see #getChoosableFileFilters\n     * @see #removeChoosableFileFilter\n     * @see #resetChoosableFileFilters\n     * @see #setFileSelectionMode\n     */\n    public void addChoosableFileFilter(FileFilter filter) {\n        if(filter != null && !filters.contains(filter)) {\n            FileFilter[] oldValue = getChoosableFileFilters();\n            filters.addElement(filter);\n            firePropertyChange(CHOOSABLE_FILE_FILTER_CHANGED_PROPERTY, oldValue, getChoosableFileFilters());\n            if (fileFilter == null && filters.size() == 1) {\n                setFileFilter(filter);\n            }\n        }\n    }"}
{"Number":"1158","API Relative Path":"javax.swing.JFileChooser.java-JFileChooser(File-FileSystemView)","Corresponding Source":"/**\n     * Constructs a <code>JFileChooser<\/code> using the given current directory\n     * and <code>FileSystemView<\/code>.\n     */\n    public JFileChooser(File currentDirectory, FileSystemView fsv) {\n        setup(fsv);\n        setCurrentDirectory(currentDirectory);\n    }"}
{"Number":"1159","API Relative Path":"javax.swing.JFileChooser.java-removeActionListener(ActionListener)","Corresponding Source":"/**\n     * Removes an <code>ActionListener<\/code> from the file chooser.\n     *\n     * @param l  the listener to be removed\n     *\n     * @see #addActionListener\n     */\n    public void removeActionListener(ActionListener l) {\n        listenerList.remove(ActionListener.class, l);\n    }"}
{"Number":"1160","API Relative Path":"javax.swing.JFileChooser.java-setCurrentDirectory(File)","Corresponding Source":"/**\n     * Sets the current directory. Passing in <code>null<\/code> sets the\n     * file chooser to point to the user's default directory.\n     * This default depends on the operating system. It is\n     * typically the \"My Documents\" folder on Windows, and the user's\n     * home directory on Unix.\n     *\n     * If the file passed in as <code>currentDirectory<\/code> is not a\n     * directory, the parent of the file will be used as the currentDirectory.\n     * If the parent is not traversable, then it will walk up the parent tree\n     * until it finds a traversable directory, or hits the root of the\n     * file system.\n     *\n     * @beaninfo\n     *   preferred: true\n     *       bound: true\n     * description: The directory that the JFileChooser is showing files of.\n     *\n     * @param dir the current directory to point to\n     * @see #getCurrentDirectory\n     */\n    public void setCurrentDirectory(File dir) {\n        File oldValue = currentDirectory;\n\n        if (dir != null && !dir.exists()) {\n            dir = currentDirectory;\n        }\n        if (dir == null) {\n            dir = getFileSystemView().getDefaultDirectory();\n        }\n        if (currentDirectory != null) {\n            /* Verify the toString of object */\n            if (this.currentDirectory.equals(dir)) {\n                return;\n            }\n        }\n\n        File prev = null;\n        while (!isTraversable(dir) && prev != dir) {\n            prev = dir;\n            dir = getFileSystemView().getParentDirectory(dir);\n        }\n        currentDirectory = dir;\n\n        firePropertyChange(DIRECTORY_CHANGED_PROPERTY, oldValue, currentDirectory);\n    }"}
{"Number":"1161","API Relative Path":"javax.swing.JFileChooser.java-setDialogType(int)","Corresponding Source":"/**\n     * Sets the type of this dialog. Use <code>OPEN_DIALOG<\/code> when you\n     * want to bring up a file chooser that the user can use to open a file.\n     * Likewise, use <code>SAVE_DIALOG<\/code> for letting the user choose\n     * a file for saving.\n     * Use <code>CUSTOM_DIALOG<\/code> when you want to use the file\n     * chooser in a context other than \"Open\" or \"Save\".\n     * For instance, you might want to bring up a file chooser that allows\n     * the user to choose a file to execute. Note that you normally would not\n     * need to set the <code>JFileChooser<\/code> to use\n     * <code>CUSTOM_DIALOG<\/code>\n     * since a call to <code>setApproveButtonText<\/code> does this for you.\n     * The default dialog type is <code>JFileChooser.OPEN_DIALOG<\/code>.\n     *\n     * @param dialogType the type of dialog to be displayed:\n     * <ul>\n     * <li>JFileChooser.OPEN_DIALOG\n     * <li>JFileChooser.SAVE_DIALOG\n     * <li>JFileChooser.CUSTOM_DIALOG\n     * <\/ul>\n     *\n     * @exception IllegalArgumentException if <code>dialogType<\/code> is\n     *                          not legal\n     * @beaninfo\n     *   preferred: true\n     *       bound: true\n     * description: The type (open, save, custom) of the JFileChooser.\n     *        enum:\n     *              OPEN_DIALOG JFileChooser.OPEN_DIALOG\n     *              SAVE_DIALOG JFileChooser.SAVE_DIALOG\n     *              CUSTOM_DIALOG JFileChooser.CUSTOM_DIALOG\n     *\n     * @see #getDialogType\n     * @see #setApproveButtonText\n     */\n    // PENDING(jeff) - fire button text change property\n    public void setDialogType(int dialogType) {\n        if(this.dialogType == dialogType) {\n            return;\n        }\n        if(!(dialogType == OPEN_DIALOG || dialogType == SAVE_DIALOG || dialogType == CUSTOM_DIALOG)) {\n            throw new IllegalArgumentException(\"Incorrect Dialog Type: \" + dialogType);\n        }\n        int oldValue = this.dialogType;\n        this.dialogType = dialogType;\n        if(dialogType == OPEN_DIALOG || dialogType == SAVE_DIALOG) {\n            setApproveButtonText(null);\n        }\n        firePropertyChange(DIALOG_TYPE_CHANGED_PROPERTY, oldValue, dialogType);\n    }"}
{"Number":"1162","API Relative Path":"javax.swing.JFileChooser.java-setFileSelectionMode(int)","Corresponding Source":"/**\n     * Sets the <code>JFileChooser<\/code> to allow the user to just\n     * select files, just select\n     * directories, or select both files and directories.  The default is\n     * <code>JFilesChooser.FILES_ONLY<\/code>.\n     *\n     * @param mode the type of files to be displayed:\n     * <ul>\n     * <li>JFileChooser.FILES_ONLY\n     * <li>JFileChooser.DIRECTORIES_ONLY\n     * <li>JFileChooser.FILES_AND_DIRECTORIES\n     * <\/ul>\n     *\n     * @exception IllegalArgumentException  if <code>mode<\/code> is an\n     *                          illegal file selection mode\n     * @beaninfo\n     *   preferred: true\n     *       bound: true\n     * description: Sets the types of files that the JFileChooser can choose.\n     *        enum: FILES_ONLY JFileChooser.FILES_ONLY\n     *              DIRECTORIES_ONLY JFileChooser.DIRECTORIES_ONLY\n     *              FILES_AND_DIRECTORIES JFileChooser.FILES_AND_DIRECTORIES\n     *\n     *\n     * @see #getFileSelectionMode\n     */\n    public void setFileSelectionMode(int mode) {\n        if(fileSelectionMode == mode) {\n            return;\n        }\n\n        if ((mode == FILES_ONLY) || (mode == DIRECTORIES_ONLY) || (mode == FILES_AND_DIRECTORIES)) {\n           int oldValue = fileSelectionMode;\n           fileSelectionMode = mode;\n           firePropertyChange(FILE_SELECTION_MODE_CHANGED_PROPERTY, oldValue, fileSelectionMode);\n        } else {\n           throw new IllegalArgumentException(\"Incorrect Mode for file selection: \" + mode);\n        }\n    }"}
{"Number":"1163","API Relative Path":"javax.swing.JFormattedTextField.java-setFocusLostBehavior(int)","Corresponding Source":"/**\n     * Sets the behavior when focus is lost. This will be one of\n     * <code>JFormattedTextField.COMMIT_OR_REVERT<\/code>,\n     * <code>JFormattedTextField.REVERT<\/code>,\n     * <code>JFormattedTextField.COMMIT<\/code> or\n     * <code>JFormattedTextField.PERSIST<\/code>\n     * Note that some <code>AbstractFormatter<\/code>s may push changes as\n     * they occur, so that the value of this will have no effect.\n     * <p>\n     * This will throw an <code>IllegalArgumentException<\/code> if the object\n     * passed in is not one of the afore mentioned values.\n     * <p>\n     * The default value of this property is\n     * <code>JFormattedTextField.COMMIT_OR_REVERT<\/code>.\n     *\n     * @param behavior Identifies behavior when focus is lost\n     * @throws IllegalArgumentException if behavior is not one of the known\n     *         values\n     * @beaninfo\n     *  enum: COMMIT         JFormattedTextField.COMMIT\n     *        COMMIT_OR_REVERT JFormattedTextField.COMMIT_OR_REVERT\n     *        REVERT         JFormattedTextField.REVERT\n     *        PERSIST        JFormattedTextField.PERSIST\n     *  description: Behavior when component loses focus\n     */\n    public void setFocusLostBehavior(int behavior) {\n        if (behavior != COMMIT && behavior != COMMIT_OR_REVERT &&\n            behavior != PERSIST && behavior != REVERT) {\n            throw new IllegalArgumentException(\"setFocusLostBehavior must be one of: JFormattedTextField.COMMIT, JFormattedTextField.COMMIT_OR_REVERT, JFormattedTextField.PERSIST or JFormattedTextField.REVERT\");\n        }\n        focusLostBehavior = behavior;\n    }"}
{"Number":"1164","API Relative Path":"javax.swing.JFrame.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified child <code>Component<\/code>.\n     * This method is overridden to conditionally forward calls to the\n     * <code>contentPane<\/code>.\n     * By default, children are added to the <code>contentPane<\/code> instead\n     * of the frame, refer to {@link javax.swing.RootPaneContainer} for\n     * details.\n     *\n     * @param comp the component to be enhanced\n     * @param constraints the constraints to be respected\n     * @param index the index\n     * @exception IllegalArgumentException if <code>index<\/code> is invalid\n     * @exception IllegalArgumentException if adding the container's parent\n     *                  to itself\n     * @exception IllegalArgumentException if adding a window to a container\n     *\n     * @see #setRootPaneCheckingEnabled\n     * @see javax.swing.RootPaneContainer\n     */\n    protected void addImpl(Component comp, Object constraints, int index)\n    {\n        if(isRootPaneCheckingEnabled()) {\n            getContentPane().add(comp, constraints, index);\n        }\n        else {\n            super.addImpl(comp, constraints, index);\n        }\n    }"}
{"Number":"1165","API Relative Path":"javax.swing.JFrame.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified child <code>Component<\/code>.\n     * This method is overridden to conditionally forward calls to the\n     * <code>contentPane<\/code>.\n     * By default, children are added to the <code>contentPane<\/code> instead\n     * of the frame, refer to {@link javax.swing.RootPaneContainer} for\n     * details.\n     *\n     * @param comp the component to be enhanced\n     * @param constraints the constraints to be respected\n     * @param index the index\n     * @exception IllegalArgumentException if <code>index<\/code> is invalid\n     * @exception IllegalArgumentException if adding the container's parent\n     *                  to itself\n     * @exception IllegalArgumentException if adding a window to a container\n     *\n     * @see #setRootPaneCheckingEnabled\n     * @see javax.swing.RootPaneContainer\n     */\n    protected void addImpl(Component comp, Object constraints, int index)\n    {\n        if(isRootPaneCheckingEnabled()) {\n            getContentPane().add(comp, constraints, index);\n        }\n        else {\n            super.addImpl(comp, constraints, index);\n        }\n    }"}
{"Number":"1166","API Relative Path":"javax.swing.JFrame.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified child <code>Component<\/code>.\n     * This method is overridden to conditionally forward calls to the\n     * <code>contentPane<\/code>.\n     * By default, children are added to the <code>contentPane<\/code> instead\n     * of the frame, refer to {@link javax.swing.RootPaneContainer} for\n     * details.\n     *\n     * @param comp the component to be enhanced\n     * @param constraints the constraints to be respected\n     * @param index the index\n     * @exception IllegalArgumentException if <code>index<\/code> is invalid\n     * @exception IllegalArgumentException if adding the container's parent\n     *                  to itself\n     * @exception IllegalArgumentException if adding a window to a container\n     *\n     * @see #setRootPaneCheckingEnabled\n     * @see javax.swing.RootPaneContainer\n     */\n    protected void addImpl(Component comp, Object constraints, int index)\n    {\n        if(isRootPaneCheckingEnabled()) {\n            getContentPane().add(comp, constraints, index);\n        }\n        else {\n            super.addImpl(comp, constraints, index);\n        }\n    }"}
{"Number":"1167","API Relative Path":"javax.swing.JFrame.java-setDefaultCloseOperation(int)","Corresponding Source":"//    public void setMenuBar(MenuBar menu) {\n//        throw new IllegalComponentStateException(\"Please use setJMenuBar() with JFrame.\");\n//    }\n\n    /**\n     * Sets the operation that will happen by default when\n     * the user initiates a \"close\" on this frame.\n     * You must specify one of the following choices:\n     * <br><br>\n     * <ul>\n     * <li><code>DO_NOTHING_ON_CLOSE<\/code>\n     * (defined in <code>WindowConstants<\/code>):\n     * Don't do anything; require the\n     * program to handle the operation in the <code>windowClosing<\/code>\n     * method of a registered <code>WindowListener<\/code> object.\n     *\n     * <li><code>HIDE_ON_CLOSE<\/code>\n     * (defined in <code>WindowConstants<\/code>):\n     * Automatically hide the frame after\n     * invoking any registered <code>WindowListener<\/code>\n     * objects.\n     *\n     * <li><code>DISPOSE_ON_CLOSE<\/code>\n     * (defined in <code>WindowConstants<\/code>):\n     * Automatically hide and dispose the\n     * frame after invoking any registered <code>WindowListener<\/code>\n     * objects.\n     *\n     * <li><code>EXIT_ON_CLOSE<\/code>\n     * (defined in <code>JFrame<\/code>):\n     * Exit the application using the <code>System<\/code>\n     * <code>exit<\/code> method.  Use this only in applications.\n     * <\/ul>\n     * <p>\n     * The value is set to <code>HIDE_ON_CLOSE<\/code> by default. Changes\n     * to the value of this property cause the firing of a property\n     * change event, with property name \"defaultCloseOperation\".\n     * <p>\n     * <b>Note<\/b>: When the last displayable window within the\n     * Java virtual machine (VM) is disposed of, the VM may\n     * terminate.  See <a href=\"../../java/awt/doc-files/AWTThreadIssues.html\">\n     * AWT Threading Issues<\/a> for more information.\n     *\n     * @param operation the operation which should be performed when the\n     *        user closes the frame\n     * @exception IllegalArgumentException if defaultCloseOperation value\n     *             isn't one of the above valid values\n     * @see #addWindowListener\n     * @see #getDefaultCloseOperation\n     * @see WindowConstants\n     * @throws  SecurityException\n     *        if <code>EXIT_ON_CLOSE<\/code> has been specified and the\n     *        <code>SecurityManager<\/code> will\n     *        not allow the caller to invoke <code>System.exit<\/code>\n     * @see        java.lang.Runtime#exit(int)\n     *\n     * @beaninfo\n     *   preferred: true\n     *       bound: true\n     *        enum: DO_NOTHING_ON_CLOSE WindowConstants.DO_NOTHING_ON_CLOSE\n     *              HIDE_ON_CLOSE       WindowConstants.HIDE_ON_CLOSE\n     *              DISPOSE_ON_CLOSE    WindowConstants.DISPOSE_ON_CLOSE\n     *              EXIT_ON_CLOSE       WindowConstants.EXIT_ON_CLOSE\n     * description: The frame's default close operation.\n     */\n    public void setDefaultCloseOperation(int operation) {\n        if (operation != DO_NOTHING_ON_CLOSE &&\n            operation != HIDE_ON_CLOSE &&\n            operation != DISPOSE_ON_CLOSE &&\n            operation != EXIT_ON_CLOSE) {\n            throw new IllegalArgumentException(\"defaultCloseOperation must be one of: DO_NOTHING_ON_CLOSE, HIDE_ON_CLOSE, DISPOSE_ON_CLOSE, or EXIT_ON_CLOSE\");\n        }\n\n        if (operation == EXIT_ON_CLOSE) {\n            SecurityManager security = System.getSecurityManager();\n            if (security != null) {\n                security.checkExit(0);\n            }\n        }\n        if (this.defaultCloseOperation != operation) {\n            int oldValue = this.defaultCloseOperation;\n            this.defaultCloseOperation = operation;\n            firePropertyChange(\"defaultCloseOperation\", oldValue, operation);\n        }\n    }"}
{"Number":"1168","API Relative Path":"javax.swing.JInternalFrame.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified child <code>Component<\/code>.\n     * This method is overridden to conditionally forward calls to the\n     * <code>contentPane<\/code>.\n     * By default, children are added to the <code>contentPane<\/code> instead\n     * of the frame, refer to {@link javax.swing.RootPaneContainer} for\n     * details.\n     *\n     * @param comp the component to be enhanced\n     * @param constraints the constraints to be respected\n     * @param index the index\n     * @exception IllegalArgumentException if <code>index<\/code> is invalid\n     * @exception IllegalArgumentException if adding the container's parent\n     *                  to itself\n     * @exception IllegalArgumentException if adding a window to a container\n     *\n     * @see #setRootPaneCheckingEnabled\n     * @see javax.swing.RootPaneContainer\n     */\n    protected void addImpl(Component comp, Object constraints, int index) {\n        if(isRootPaneCheckingEnabled()) {\n            getContentPane().add(comp, constraints, index);\n        }\n        else {\n            super.addImpl(comp, constraints, index);\n        }\n    }"}
{"Number":"1169","API Relative Path":"javax.swing.JInternalFrame.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified child <code>Component<\/code>.\n     * This method is overridden to conditionally forward calls to the\n     * <code>contentPane<\/code>.\n     * By default, children are added to the <code>contentPane<\/code> instead\n     * of the frame, refer to {@link javax.swing.RootPaneContainer} for\n     * details.\n     *\n     * @param comp the component to be enhanced\n     * @param constraints the constraints to be respected\n     * @param index the index\n     * @exception IllegalArgumentException if <code>index<\/code> is invalid\n     * @exception IllegalArgumentException if adding the container's parent\n     *                  to itself\n     * @exception IllegalArgumentException if adding a window to a container\n     *\n     * @see #setRootPaneCheckingEnabled\n     * @see javax.swing.RootPaneContainer\n     */\n    protected void addImpl(Component comp, Object constraints, int index) {\n        if(isRootPaneCheckingEnabled()) {\n            getContentPane().add(comp, constraints, index);\n        }\n        else {\n            super.addImpl(comp, constraints, index);\n        }\n    }"}
{"Number":"1170","API Relative Path":"javax.swing.JInternalFrame.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified child <code>Component<\/code>.\n     * This method is overridden to conditionally forward calls to the\n     * <code>contentPane<\/code>.\n     * By default, children are added to the <code>contentPane<\/code> instead\n     * of the frame, refer to {@link javax.swing.RootPaneContainer} for\n     * details.\n     *\n     * @param comp the component to be enhanced\n     * @param constraints the constraints to be respected\n     * @param index the index\n     * @exception IllegalArgumentException if <code>index<\/code> is invalid\n     * @exception IllegalArgumentException if adding the container's parent\n     *                  to itself\n     * @exception IllegalArgumentException if adding a window to a container\n     *\n     * @see #setRootPaneCheckingEnabled\n     * @see javax.swing.RootPaneContainer\n     */\n    protected void addImpl(Component comp, Object constraints, int index) {\n        if(isRootPaneCheckingEnabled()) {\n            getContentPane().add(comp, constraints, index);\n        }\n        else {\n            super.addImpl(comp, constraints, index);\n        }\n    }"}
{"Number":"1171","API Relative Path":"javax.swing.JInternalFrame.java-addInternalFrameListener(InternalFrameListener)","Corresponding Source":"///////////////////////////\n// Frame/Window equivalents\n///////////////////////////\n\n    /**\n     * Adds the specified listener to receive internal\n     * frame events from this internal frame.\n     *\n     * @param l the internal frame listener\n     */\n    public void addInternalFrameListener(InternalFrameListener l) {  // remind: sync ??\n      listenerList.add(InternalFrameListener.class, l);\n      // remind: needed?\n      enableEvents(0);   // turn on the newEventsOnly flag in Component.\n    }"}
{"Number":"1172","API Relative Path":"javax.swing.JInternalFrame.java-removeInternalFrameListener(InternalFrameListener)","Corresponding Source":"/**\n     * Removes the specified internal frame listener so that it no longer\n     * receives internal frame events from this internal frame.\n     *\n     * @param l the internal frame listener\n     */\n    public void removeInternalFrameListener(InternalFrameListener l) {  // remind: sync??\n      listenerList.remove(InternalFrameListener.class, l);\n    }"}
{"Number":"1173","API Relative Path":"javax.swing.JInternalFrame.java-setCursor(Cursor)","Corresponding Source":"/**\n     * {@inheritDoc}\n     * @since 1.6\n     */\n    public void setCursor(Cursor cursor) {\n        if (cursor == null) {\n            lastCursor = null;\n            super.setCursor(cursor);\n            return;\n        }\n        int type = cursor.getType();\n        if (!(type == Cursor.SW_RESIZE_CURSOR  ||\n              type == Cursor.SE_RESIZE_CURSOR  ||\n              type == Cursor.NW_RESIZE_CURSOR  ||\n              type == Cursor.NE_RESIZE_CURSOR  ||\n              type == Cursor.N_RESIZE_CURSOR   ||\n              type == Cursor.S_RESIZE_CURSOR   ||\n              type == Cursor.W_RESIZE_CURSOR   ||\n              type == Cursor.E_RESIZE_CURSOR)) {\n            lastCursor = cursor;\n        }\n        super.setCursor(cursor);\n    }"}
{"Number":"1174","API Relative Path":"javax.swing.JLabel.java-JLabel(String-Icon-int)","Corresponding Source":"/**\n     * Creates a <code>JLabel<\/code> instance with the specified\n     * text, image, and horizontal alignment.\n     * The label is centered vertically in its display area.\n     * The text is on the trailing edge of the image.\n     *\n     * @param text  The text to be displayed by the label.\n     * @param icon  The image to be displayed by the label.\n     * @param horizontalAlignment  One of the following constants\n     *           defined in <code>SwingConstants<\/code>:\n     *           <code>LEFT<\/code>,\n     *           <code>CENTER<\/code>,\n     *           <code>RIGHT<\/code>,\n     *           <code>LEADING<\/code> or\n     *           <code>TRAILING<\/code>.\n     */\n    public JLabel(String text, Icon icon, int horizontalAlignment) {\n        setText(text);\n        setIcon(icon);\n        setHorizontalAlignment(horizontalAlignment);\n        updateUI();\n        setAlignmentX(LEFT_ALIGNMENT);\n    }"}
{"Number":"1175","API Relative Path":"javax.swing.JLabel.java-setDisplayedMnemonicIndex(int)","Corresponding Source":"/**\n     * Provides a hint to the look and feel as to which character in the\n     * text should be decorated to represent the mnemonic. Not all look and\n     * feels may support this. A value of -1 indicates either there is no\n     * mnemonic, the mnemonic character is not contained in the string, or\n     * the developer does not wish the mnemonic to be displayed.\n     * <p>\n     * The value of this is updated as the properties relating to the\n     * mnemonic change (such as the mnemonic itself, the text...).\n     * You should only ever have to call this if\n     * you do not wish the default character to be underlined. For example, if\n     * the text was 'Save As', with a mnemonic of 'a', and you wanted the 'A'\n     * to be decorated, as 'Save <u>A<\/u>s', you would have to invoke\n     * <code>setDisplayedMnemonicIndex(5)<\/code> after invoking\n     * <code>setDisplayedMnemonic(KeyEvent.VK_A)<\/code>.\n     *\n     * @since 1.4\n     * @param index Index into the String to underline\n     * @exception IllegalArgumentException will be thrown if <code>index<\/code>\n     *            is &gt;= length of the text, or &lt; -1\n     *\n     * @beaninfo\n     *        bound: true\n     *    attribute: visualUpdate true\n     *  description: the index into the String to draw the keyboard character\n     *               mnemonic at\n     */\n    public void setDisplayedMnemonicIndex(int index)\n                                             throws IllegalArgumentException {\n        int oldValue = mnemonicIndex;\n        if (index == -1) {\n            mnemonicIndex = -1;\n        } else {\n            String text = getText();\n            int textLength = (text == null) ? 0 : text.length();\n            if (index < -1 || index >= textLength) {  // index out of range\n                throw new IllegalArgumentException(\"index == \" + index);\n            }\n        }\n        mnemonicIndex = index;\n        firePropertyChange(\"displayedMnemonicIndex\", oldValue, index);\n        if (index != oldValue) {\n            revalidate();\n            repaint();\n        }\n    }"}
{"Number":"1176","API Relative Path":"javax.swing.JLabel.java-setHorizontalAlignment(int)","Corresponding Source":"/**\n     * Sets the alignment of the label's contents along the X axis.\n     * <p>\n     * This is a JavaBeans bound property.\n     *\n     * @param alignment  One of the following constants\n     *           defined in <code>SwingConstants<\/code>:\n     *           <code>LEFT<\/code>,\n     *           <code>CENTER<\/code> (the default for image-only labels),\n     *           <code>RIGHT<\/code>,\n     *           <code>LEADING<\/code> (the default for text-only labels) or\n     *           <code>TRAILING<\/code>.\n     *\n     * @see SwingConstants\n     * @see #getHorizontalAlignment\n     * @beaninfo\n     *        bound: true\n     *         enum: LEFT     SwingConstants.LEFT\n     *               CENTER   SwingConstants.CENTER\n     *               RIGHT    SwingConstants.RIGHT\n     *               LEADING  SwingConstants.LEADING\n     *               TRAILING SwingConstants.TRAILING\n     *    attribute: visualUpdate true\n     *  description: The alignment of the label's content along the X axis.\n     */\n    public void setHorizontalAlignment(int alignment) {\n        if (alignment == horizontalAlignment) return;\n        int oldValue = horizontalAlignment;\n        horizontalAlignment = checkHorizontalKey(alignment,\n                                                 \"horizontalAlignment\");\n        firePropertyChange(\"horizontalAlignment\",\n                           oldValue, horizontalAlignment);\n        repaint();\n    }"}
{"Number":"1177","API Relative Path":"javax.swing.JLabel.java-setHorizontalTextPosition(int)","Corresponding Source":"/**\n     * Sets the horizontal position of the label's text,\n     * relative to its image.\n     *\n     * @param textPosition  One of the following constants\n     *           defined in <code>SwingConstants<\/code>:\n     *           <code>LEFT<\/code>,\n     *           <code>CENTER<\/code>,\n     *           <code>RIGHT<\/code>,\n     *           <code>LEADING<\/code>, or\n     *           <code>TRAILING<\/code> (the default).\n     * @exception IllegalArgumentException\n     *\n     * @see SwingConstants\n     * @beaninfo\n     *       expert: true\n     *        bound: true\n     *         enum: LEFT     SwingConstants.LEFT\n     *               CENTER   SwingConstants.CENTER\n     *               RIGHT    SwingConstants.RIGHT\n     *               LEADING  SwingConstants.LEADING\n     *               TRAILING SwingConstants.TRAILING\n     *    attribute: visualUpdate true\n     *  description: The horizontal position of the label's text,\n     *               relative to its image.\n     */\n    public void setHorizontalTextPosition(int textPosition) {\n        int old = horizontalTextPosition;\n        this.horizontalTextPosition = checkHorizontalKey(textPosition,\n                                                \"horizontalTextPosition\");\n        firePropertyChange(\"horizontalTextPosition\",\n                           old, horizontalTextPosition);\n        revalidate();\n        repaint();\n    }"}
{"Number":"1178","API Relative Path":"javax.swing.JLabel.java-setVerticalAlignment(int)","Corresponding Source":"/**\n     * Sets the alignment of the label's contents along the Y axis.\n     * <p>\n     * The default value of this property is CENTER.\n     *\n     * @param alignment One of the following constants\n     *           defined in <code>SwingConstants<\/code>:\n     *           <code>TOP<\/code>,\n     *           <code>CENTER<\/code> (the default), or\n     *           <code>BOTTOM<\/code>.\n     *\n     * @see SwingConstants\n     * @see #getVerticalAlignment\n     * @beaninfo\n     *        bound: true\n     *         enum: TOP    SwingConstants.TOP\n     *               CENTER SwingConstants.CENTER\n     *               BOTTOM SwingConstants.BOTTOM\n     *    attribute: visualUpdate true\n     *  description: The alignment of the label's contents along the Y axis.\n     */\n    public void setVerticalAlignment(int alignment) {\n        if (alignment == verticalAlignment) return;\n        int oldValue = verticalAlignment;\n        verticalAlignment = checkVerticalKey(alignment, \"verticalAlignment\");\n        firePropertyChange(\"verticalAlignment\", oldValue, verticalAlignment);\n        repaint();\n    }"}
{"Number":"1179","API Relative Path":"javax.swing.JLabel.java-setVerticalTextPosition(int)","Corresponding Source":"/**\n     * Sets the vertical position of the label's text,\n     * relative to its image.\n     * <p>\n     * The default value of this property is CENTER.\n     * <p>\n     * This is a JavaBeans bound property.\n     *\n     * @param textPosition  One of the following constants\n     *           defined in <code>SwingConstants<\/code>:\n     *           <code>TOP<\/code>,\n     *           <code>CENTER<\/code> (the default), or\n     *           <code>BOTTOM<\/code>.\n     *\n     * @see SwingConstants\n     * @see #getVerticalTextPosition\n     * @beaninfo\n     *        bound: true\n     *         enum: TOP    SwingConstants.TOP\n     *               CENTER SwingConstants.CENTER\n     *               BOTTOM SwingConstants.BOTTOM\n     *       expert: true\n     *    attribute: visualUpdate true\n     *  description: The vertical position of the text relative to it's image.\n     */\n    public void setVerticalTextPosition(int textPosition) {\n        if (textPosition == verticalTextPosition) return;\n        int old = verticalTextPosition;\n        verticalTextPosition = checkVerticalKey(textPosition,\n                                                \"verticalTextPosition\");\n        firePropertyChange(\"verticalTextPosition\", old, verticalTextPosition);\n        revalidate();\n        repaint();\n    }"}
{"Number":"1180","API Relative Path":"javax.swing.JLayer.java-setBorder(Border)","Corresponding Source":"/**\n     * A non-{@code null} border, or non-zero insets, isn't supported, to prevent the geometry\n     * of this component from becoming complex enough to inhibit\n     * subclassing of {@code LayerUI} class.  To create a {@code JLayer} with a border,\n     * add it to a {@code JPanel} that has a border.\n     * <p>Note:  If {@code border} is non-{@code null}, this\n     * method will throw an exception as borders are not supported on\n     * a {@code JLayer}.\n     *\n     * @param border the {@code Border} to set\n     * @exception IllegalArgumentException this method is not supported\n     */\n    public void setBorder(Border border) {\n        if (border != null) {\n            throw new IllegalArgumentException(\"JLayer.setBorder() not supported\");\n        }\n    }"}
{"Number":"1181","API Relative Path":"javax.swing.JLayer.java-setBorder(Border)","Corresponding Source":"/**\n     * A non-{@code null} border, or non-zero insets, isn't supported, to prevent the geometry\n     * of this component from becoming complex enough to inhibit\n     * subclassing of {@code LayerUI} class.  To create a {@code JLayer} with a border,\n     * add it to a {@code JPanel} that has a border.\n     * <p>Note:  If {@code border} is non-{@code null}, this\n     * method will throw an exception as borders are not supported on\n     * a {@code JLayer}.\n     *\n     * @param border the {@code Border} to set\n     * @exception IllegalArgumentException this method is not supported\n     */\n    public void setBorder(Border border) {\n        if (border != null) {\n            throw new IllegalArgumentException(\"JLayer.setBorder() not supported\");\n        }\n    }"}
{"Number":"1182","API Relative Path":"javax.swing.JLayer.java-setGlassPane(JPanel)","Corresponding Source":"/**\n     * Sets the {@code JLayer}'s glassPane component, which can be {@code null}.\n     * <br>This is a bound property.\n     *\n     * @param glassPane the glassPane component of this {@code JLayer}\n     *\n     * @see #getGlassPane()\n     */\n    public void setGlassPane(JPanel glassPane) {\n        Component oldGlassPane = getGlassPane();\n        boolean isGlassPaneVisible = false;\n        if (oldGlassPane != null) {\n            isGlassPaneVisible = oldGlassPane.isVisible();\n            super.remove(oldGlassPane);\n        }\n        if (glassPane != null) {\n            AWTAccessor.getComponentAccessor().setMixingCutoutShape(glassPane,\n                    new Rectangle());\n            glassPane.setVisible(isGlassPaneVisible);\n            super.addImpl(glassPane, null, 0);\n        }\n        this.glassPane = glassPane;\n        firePropertyChange(\"glassPane\", oldGlassPane, glassPane);\n        revalidate();\n        repaint();\n    }"}
{"Number":"1183","API Relative Path":"javax.swing.JLayer.java-setGlassPane(JPanel)","Corresponding Source":"/**\n     * Sets the {@code JLayer}'s glassPane component, which can be {@code null}.\n     * <br>This is a bound property.\n     *\n     * @param glassPane the glassPane component of this {@code JLayer}\n     *\n     * @see #getGlassPane()\n     */\n    public void setGlassPane(JPanel glassPane) {\n        Component oldGlassPane = getGlassPane();\n        boolean isGlassPaneVisible = false;\n        if (oldGlassPane != null) {\n            isGlassPaneVisible = oldGlassPane.isVisible();\n            super.remove(oldGlassPane);\n        }\n        if (glassPane != null) {\n            AWTAccessor.getComponentAccessor().setMixingCutoutShape(glassPane,\n                    new Rectangle());\n            glassPane.setVisible(isGlassPaneVisible);\n            super.addImpl(glassPane, null, 0);\n        }\n        this.glassPane = glassPane;\n        firePropertyChange(\"glassPane\", oldGlassPane, glassPane);\n        revalidate();\n        repaint();\n    }"}
{"Number":"1184","API Relative Path":"javax.swing.JLayer.java-setLayout(LayoutManager)","Corresponding Source":"/**\n     * Sets the layout manager for this container.  This method is\n     * overridden to prevent the layout manager from being set.\n     * <p>Note:  If {@code mgr} is non-{@code null}, this\n     * method will throw an exception as layout managers are not supported on\n     * a {@code JLayer}.\n     *\n     * @param mgr the specified layout manager\n     * @exception IllegalArgumentException this method is not supported\n     */\n    public void setLayout(LayoutManager mgr) {\n        if (mgr != null) {\n            throw new IllegalArgumentException(\"JLayer.setLayout() not supported\");\n        }\n    }"}
{"Number":"1185","API Relative Path":"javax.swing.JLayer.java-setLayout(LayoutManager)","Corresponding Source":"/**\n     * Sets the layout manager for this container.  This method is\n     * overridden to prevent the layout manager from being set.\n     * <p>Note:  If {@code mgr} is non-{@code null}, this\n     * method will throw an exception as layout managers are not supported on\n     * a {@code JLayer}.\n     *\n     * @param mgr the specified layout manager\n     * @exception IllegalArgumentException this method is not supported\n     */\n    public void setLayout(LayoutManager mgr) {\n        if (mgr != null) {\n            throw new IllegalArgumentException(\"JLayer.setLayout() not supported\");\n        }\n    }"}
{"Number":"1186","API Relative Path":"javax.swing.JLayeredPane.java-getLayeredPaneAbove(Component)","Corresponding Source":"/** Convenience method that returns the first JLayeredPane which\n      * contains the specified component. Note that all JFrames have a\n      * JLayeredPane at their root, so any component in a JFrame will\n      * have a JLayeredPane parent.\n      *\n      * @param c the Component to check\n      * @return the JLayeredPane that contains the component, or\n      *         null if no JLayeredPane is found in the component\n      *         hierarchy\n      * @see JFrame\n      * @see JRootPane\n      */\n    public static JLayeredPane getLayeredPaneAbove(Component c) {\n        if(c == null) return null;\n\n        Component parent = c.getParent();\n        while(parent != null && !(parent instanceof JLayeredPane))\n            parent = parent.getParent();\n        return (JLayeredPane)parent;\n    }"}
{"Number":"1187","API Relative Path":"javax.swing.JLayeredPane.java-setLayer(Component-int-int)","Corresponding Source":"/** Sets the layer attribute for the specified component and\n      * also sets its position within that layer.\n      *\n      * @param c         the Component to set the layer for\n      * @param layer     an int specifying the layer to set, where\n      *                  lower numbers are closer to the bottom\n      * @param position  an int specifying the position within the\n      *                  layer, where 0 is the topmost position and -1\n      *                  is the bottommost position\n      */\n    public void setLayer(Component c, int layer, int position)  {\n        Integer layerObj;\n        layerObj = getObjectForLayer(layer);\n\n        if(layer == getLayer(c) && position == getPosition(c)) {\n                repaint(c.getBounds());\n            return;\n        }\n\n        /// MAKE SURE THIS AND putLayer(JComponent c, int layer) are SYNCED\n        if(c instanceof JComponent)\n            ((JComponent)c).putClientProperty(LAYER_PROPERTY, layerObj);\n        else\n            getComponentToLayer().put(c, layerObj);\n\n        if(c.getParent() == null || c.getParent() != this) {\n            repaint(c.getBounds());\n            return;\n        }\n\n        int index = insertIndexForLayer(c, layer, position);\n\n        setComponentZOrder(c, index);\n        repaint(c.getBounds());\n    }"}
{"Number":"1188","API Relative Path":"javax.swing.JLayeredPane.java-setLayer(Component-int-int)","Corresponding Source":"/** Sets the layer attribute for the specified component and\n      * also sets its position within that layer.\n      *\n      * @param c         the Component to set the layer for\n      * @param layer     an int specifying the layer to set, where\n      *                  lower numbers are closer to the bottom\n      * @param position  an int specifying the position within the\n      *                  layer, where 0 is the topmost position and -1\n      *                  is the bottommost position\n      */\n    public void setLayer(Component c, int layer, int position)  {\n        Integer layerObj;\n        layerObj = getObjectForLayer(layer);\n\n        if(layer == getLayer(c) && position == getPosition(c)) {\n                repaint(c.getBounds());\n            return;\n        }\n\n        /// MAKE SURE THIS AND putLayer(JComponent c, int layer) are SYNCED\n        if(c instanceof JComponent)\n            ((JComponent)c).putClientProperty(LAYER_PROPERTY, layerObj);\n        else\n            getComponentToLayer().put(c, layerObj);\n\n        if(c.getParent() == null || c.getParent() != this) {\n            repaint(c.getBounds());\n            return;\n        }\n\n        int index = insertIndexForLayer(c, layer, position);\n\n        setComponentZOrder(c, index);\n        repaint(c.getBounds());\n    }"}
{"Number":"1189","API Relative Path":"javax.swing.JList.java-addListSelectionListener(ListSelectionListener)","Corresponding Source":"/**\n     * Adds a listener to the list, to be notified each time a change to the\n     * selection occurs; the preferred way of listening for selection state\n     * changes. {@code JList} takes care of listening for selection state\n     * changes in the selection model, and notifies the given listener of\n     * each change. {@code ListSelectionEvent}s sent to the listener have a\n     * {@code source} property set to this list.\n     *\n     * @param listener the {@code ListSelectionListener} to add\n     * @see #getSelectionModel\n     * @see #getListSelectionListeners\n     */\n    public void addListSelectionListener(ListSelectionListener listener)\n    {\n        if (selectionListener == null) {\n            selectionListener = new ListSelectionHandler();\n            getSelectionModel().addListSelectionListener(selectionListener);\n        }\n\n        listenerList.add(ListSelectionListener.class, listener);\n    }"}
{"Number":"1190","API Relative Path":"javax.swing.JList.java-JList(ListModel)","Corresponding Source":"/**\n     * Constructs a {@code JList} that displays elements from the specified,\n     * {@code non-null}, model. All {@code JList} constructors delegate to\n     * this one.\n     * <p>\n     * This constructor registers the list with the {@code ToolTipManager},\n     * allowing for tooltips to be provided by the cell renderers.\n     *\n     * @param dataModel the model for the list\n     * @exception IllegalArgumentException if the model is {@code null}\n     */\n    public JList(ListModel<E> dataModel)\n    {\n        if (dataModel == null) {\n            throw new IllegalArgumentException(\"dataModel must be non null\");\n        }\n\n        // Register with the ToolTipManager so that tooltips from the\n        // renderer show through.\n        ToolTipManager toolTipManager = ToolTipManager.sharedInstance();\n        toolTipManager.registerComponent(this);\n\n        layoutOrientation = VERTICAL;\n\n        this.dataModel = dataModel;\n        selectionModel = createSelectionModel();\n        setAutoscrolls(true);\n        setOpaque(true);\n        updateUI();\n    }"}
{"Number":"1191","API Relative Path":"javax.swing.JList.java-removeListSelectionListener(ListSelectionListener)","Corresponding Source":"/**\n     * Removes a selection listener from the list.\n     *\n     * @param listener the {@code ListSelectionListener} to remove\n     * @see #addListSelectionListener\n     * @see #getSelectionModel\n     */\n    public void removeListSelectionListener(ListSelectionListener listener) {\n        listenerList.remove(ListSelectionListener.class, listener);\n    }"}
{"Number":"1192","API Relative Path":"javax.swing.JMenu.java-add(Action)","Corresponding Source":"/**\n     * Creates a new menu item attached to the specified\n     * <code>Action<\/code> object and appends it to the end of this menu.\n     *\n     * @param a the <code>Action<\/code> for the menu item to be added\n     * @see Action\n     */\n    public JMenuItem add(Action a) {\n        JMenuItem mi = createActionComponent(a);\n        mi.setAction(a);\n        add(mi);\n        return mi;\n    }"}
{"Number":"1193","API Relative Path":"javax.swing.JMenu.java-addMenuListener(MenuListener)","Corresponding Source":"/**\n     * Adds a listener for menu events.\n     *\n     * @param l the listener to be added\n     */\n    public void addMenuListener(MenuListener l) {\n        listenerList.add(MenuListener.class, l);\n    }"}
{"Number":"1194","API Relative Path":"javax.swing.JMenu.java-getItem(int)","Corresponding Source":"/**\n     * Returns the <code>JMenuItem<\/code> at the specified position.\n     * If the component at <code>pos<\/code> is not a menu item,\n     * <code>null<\/code> is returned.\n     * This method is included for AWT compatibility.\n     *\n     * @param pos    an integer specifying the position\n     * @exception   IllegalArgumentException if the value of\n     *                       <code>pos<\/code> &lt; 0\n     * @return  the menu item at the specified position; or <code>null<\/code>\n     *          if the item as the specified position is not a menu item\n     */\n    public JMenuItem getItem(int pos) {\n        if (pos < 0) {\n            throw new IllegalArgumentException(\"index less than zero.\");\n        }\n\n        Component c = getMenuComponent(pos);\n        if (c instanceof JMenuItem) {\n            JMenuItem mi = (JMenuItem) c;\n            return mi;\n        }\n\n        // 4173633\n        return null;\n    }"}
{"Number":"1195","API Relative Path":"javax.swing.JMenu.java-insert(Action-int)","Corresponding Source":"/**\n     * Inserts a new menu item attached to the specified <code>Action<\/code>\n     * object at a given position.\n     *\n     * @param a the <code>Action<\/code> object for the menu item to add\n     * @param pos an integer specifying the position at which to add the\n     *               new menu item\n     * @exception IllegalArgumentException if the value of\n     *                  <code>pos<\/code> &lt; 0\n     */\n    public JMenuItem insert(Action a, int pos) {\n        if (pos < 0) {\n            throw new IllegalArgumentException(\"index less than zero.\");\n        }\n\n        ensurePopupMenuCreated();\n        JMenuItem mi = new JMenuItem(a);\n        mi.setHorizontalTextPosition(JButton.TRAILING);\n        mi.setVerticalTextPosition(JButton.CENTER);\n        popupMenu.insert(mi, pos);\n        return mi;\n    }"}
{"Number":"1196","API Relative Path":"javax.swing.JMenu.java-insert(Action-int)","Corresponding Source":"/**\n     * Inserts a new menu item attached to the specified <code>Action<\/code>\n     * object at a given position.\n     *\n     * @param a the <code>Action<\/code> object for the menu item to add\n     * @param pos an integer specifying the position at which to add the\n     *               new menu item\n     * @exception IllegalArgumentException if the value of\n     *                  <code>pos<\/code> &lt; 0\n     */\n    public JMenuItem insert(Action a, int pos) {\n        if (pos < 0) {\n            throw new IllegalArgumentException(\"index less than zero.\");\n        }\n\n        ensurePopupMenuCreated();\n        JMenuItem mi = new JMenuItem(a);\n        mi.setHorizontalTextPosition(JButton.TRAILING);\n        mi.setVerticalTextPosition(JButton.CENTER);\n        popupMenu.insert(mi, pos);\n        return mi;\n    }"}
{"Number":"1197","API Relative Path":"javax.swing.JMenu.java-insert(JMenuItem-int)","Corresponding Source":"/**\n     * Inserts the specified <code>JMenuitem<\/code> at a given position.\n     *\n     * @param mi the <code>JMenuitem<\/code> to add\n     * @param pos an integer specifying the position at which to add the\n     *               new <code>JMenuitem<\/code>\n     * @return the new menu item\n     * @exception IllegalArgumentException if the value of\n     *                  <code>pos<\/code> &lt; 0\n     */\n    public JMenuItem insert(JMenuItem mi, int pos) {\n        if (pos < 0) {\n            throw new IllegalArgumentException(\"index less than zero.\");\n        }\n        ensurePopupMenuCreated();\n        popupMenu.insert(mi, pos);\n        return mi;\n    }"}
{"Number":"1198","API Relative Path":"javax.swing.JMenu.java-insert(String-int)","Corresponding Source":"/**\n     * Inserts a new menu item with the specified text at a\n     * given position.\n     *\n     * @param s the text for the menu item to add\n     * @param pos an integer specifying the position at which to add the\n     *               new menu item\n     * @exception IllegalArgumentException when the value of\n     *                  <code>pos<\/code> &lt; 0\n     */\n    public void insert(String s, int pos) {\n        if (pos < 0) {\n            throw new IllegalArgumentException(\"index less than zero.\");\n        }\n\n        ensurePopupMenuCreated();\n        popupMenu.insert(new JMenuItem(s), pos);\n    }"}
{"Number":"1199","API Relative Path":"javax.swing.JMenu.java-insertSeparator(int)","Corresponding Source":"/**\n     * Inserts a separator at the specified position.\n     *\n     * @param       index an integer specifying the position at which to\n     *                    insert the menu separator\n     * @exception   IllegalArgumentException if the value of\n     *                       <code>index<\/code> &lt; 0\n     */\n    public void insertSeparator(int index) {\n        if (index < 0) {\n            throw new IllegalArgumentException(\"index less than zero.\");\n        }\n\n        ensurePopupMenuCreated();\n        popupMenu.insert( new JPopupMenu.Separator(), index );\n    }"}
{"Number":"1200","API Relative Path":"javax.swing.JMenu.java-insertSeparator(int)","Corresponding Source":"/**\n     * Inserts a separator at the specified position.\n     *\n     * @param       index an integer specifying the position at which to\n     *                    insert the menu separator\n     * @exception   IllegalArgumentException if the value of\n     *                       <code>index<\/code> &lt; 0\n     */\n    public void insertSeparator(int index) {\n        if (index < 0) {\n            throw new IllegalArgumentException(\"index less than zero.\");\n        }\n\n        ensurePopupMenuCreated();\n        popupMenu.insert( new JPopupMenu.Separator(), index );\n    }"}
{"Number":"1201","API Relative Path":"javax.swing.JMenu.java-insertSeparator(int)","Corresponding Source":"/**\n     * Inserts a separator at the specified position.\n     *\n     * @param       index an integer specifying the position at which to\n     *                    insert the menu separator\n     * @exception   IllegalArgumentException if the value of\n     *                       <code>index<\/code> &lt; 0\n     */\n    public void insertSeparator(int index) {\n        if (index < 0) {\n            throw new IllegalArgumentException(\"index less than zero.\");\n        }\n\n        ensurePopupMenuCreated();\n        popupMenu.insert( new JPopupMenu.Separator(), index );\n    }"}
{"Number":"1202","API Relative Path":"javax.swing.JMenu.java-JMenu(Action)","Corresponding Source":"/**\n     * Constructs a menu whose properties are taken from the\n     * <code>Action<\/code> supplied.\n     * @param a an <code>Action<\/code>\n     *\n     * @since 1.3\n     */\n    public JMenu(Action a) {\n        this();\n        setAction(a);\n    }"}
{"Number":"1203","API Relative Path":"javax.swing.JMenu.java-remove(int)","Corresponding Source":"/**\n     * Removes the menu item at the specified index from this menu.\n     *\n     * @param       pos the position of the item to be removed\n     * @exception   IllegalArgumentException if the value of\n     *                       <code>pos<\/code> &lt; 0, or if <code>pos<\/code>\n     *                       is greater than the number of menu items\n     */\n    public void remove(int pos) {\n        if (pos < 0) {\n            throw new IllegalArgumentException(\"index less than zero.\");\n        }\n        if (pos > getItemCount()) {\n            throw new IllegalArgumentException(\"index greater than the number of items.\");\n        }\n        if (popupMenu != null)\n            popupMenu.remove(pos);\n    }"}
{"Number":"1204","API Relative Path":"javax.swing.JMenu.java-removeMenuListener(MenuListener)","Corresponding Source":"/**\n     * Removes a listener for menu events.\n     *\n     * @param l the listener to be removed\n     */\n    public void removeMenuListener(MenuListener l) {\n        listenerList.remove(MenuListener.class, l);\n    }"}
{"Number":"1205","API Relative Path":"javax.swing.JMenuBar.java-setMargin(Insets)","Corresponding Source":"/**\n     * Sets the margin between the menubar's border and\n     * its menus. Setting to <code>null<\/code> will cause the menubar to\n     * use the default margins.\n     *\n     * @param m an Insets object containing the margin values\n     * @see Insets\n     * @beaninfo\n     *        bound: true\n     *    attribute: visualUpdate true\n     *  description: The space between the menubar's border and its contents\n     */\n    public void setMargin(Insets m) {\n        Insets old = margin;\n        this.margin = m;\n        firePropertyChange(\"margin\", old, m);\n        if (old == null || !old.equals(m)) {\n            revalidate();\n            repaint();\n        }\n    }"}
{"Number":"1206","API Relative Path":"javax.swing.JMenuItem.java-addMenuDragMouseListener(MenuDragMouseListener)","Corresponding Source":"/**\n     * Adds a <code>MenuDragMouseListener<\/code> to the menu item.\n     *\n     * @param l the <code>MenuDragMouseListener<\/code> to be added\n     */\n    public void addMenuDragMouseListener(MenuDragMouseListener l) {\n        listenerList.add(MenuDragMouseListener.class, l);\n    }"}
{"Number":"1207","API Relative Path":"javax.swing.JMenuItem.java-addMenuKeyListener(MenuKeyListener)","Corresponding Source":"/**\n     * Adds a <code>MenuKeyListener<\/code> to the menu item.\n     *\n     * @param l the <code>MenuKeyListener<\/code> to be added\n     */\n    public void addMenuKeyListener(MenuKeyListener l) {\n        listenerList.add(MenuKeyListener.class, l);\n    }"}
{"Number":"1208","API Relative Path":"javax.swing.JMenuItem.java-JMenuItem(Action)","Corresponding Source":"/**\n     * Creates a menu item whose properties are taken from the\n     * specified <code>Action<\/code>.\n     *\n     * @param a the action of the <code>JMenuItem<\/code>\n     * @since 1.3\n     */\n    public JMenuItem(Action a) {\n        this();\n        setAction(a);\n    }"}
{"Number":"1209","API Relative Path":"javax.swing.JMenuItem.java-removeMenuDragMouseListener(MenuDragMouseListener)","Corresponding Source":"/**\n     * Removes a <code>MenuDragMouseListener<\/code> from the menu item.\n     *\n     * @param l the <code>MenuDragMouseListener<\/code> to be removed\n     */\n    public void removeMenuDragMouseListener(MenuDragMouseListener l) {\n        listenerList.remove(MenuDragMouseListener.class, l);\n    }"}
{"Number":"1210","API Relative Path":"javax.swing.JMenuItem.java-removeMenuKeyListener(MenuKeyListener)","Corresponding Source":"/**\n     * Removes a <code>MenuKeyListener<\/code> from the menu item.\n     *\n     * @param l the <code>MenuKeyListener<\/code> to be removed\n     */\n    public void removeMenuKeyListener(MenuKeyListener l) {\n        listenerList.remove(MenuKeyListener.class, l);\n    }"}
{"Number":"1211","API Relative Path":"javax.swing.JOptionPane.java-createInternalFrame(Component-String)","Corresponding Source":"/**\n     * Creates and returns an instance of <code>JInternalFrame<\/code>.\n     * The internal frame is created with the specified title,\n     * and wrapping the <code>JOptionPane<\/code>.\n     * The returned <code>JInternalFrame<\/code> is\n     * added to the <code>JDesktopPane<\/code> ancestor of\n     * <code>parentComponent<\/code>, or components\n     * parent if one its ancestors isn't a <code>JDesktopPane<\/code>,\n     * or if <code>parentComponent<\/code>\n     * doesn't have a parent then a <code>RuntimeException<\/code> is thrown.\n     *\n     * @param parentComponent  the parent <code>Component<\/code> for\n     *          the internal frame\n     * @param title    the <code>String<\/code> to display in the\n     *          frame's title bar\n     * @return a <code>JInternalFrame<\/code> containing a\n     *          <code>JOptionPane<\/code>\n     * @exception RuntimeException if <code>parentComponent<\/code> does\n     *          not have a valid parent\n     */\n    public JInternalFrame createInternalFrame(Component parentComponent,\n                                 String title) {\n        Container parent =\n                JOptionPane.getDesktopPaneForComponent(parentComponent);\n\n        if (parent == null && (parentComponent == null ||\n                (parent = parentComponent.getParent()) == null)) {\n            throw new RuntimeException(\"JOptionPane: parentComponent does \" +\n                    \"not have a valid parent\");\n        }\n\n        // Option dialogs should be closable only\n        final JInternalFrame  iFrame = new JInternalFrame(title, false, true,\n                                                           false, false);\n\n        iFrame.putClientProperty(\"JInternalFrame.frameType\", \"optionDialog\");\n        iFrame.putClientProperty(\"JInternalFrame.messageType\",\n                                 Integer.valueOf(getMessageType()));\n\n        iFrame.addInternalFrameListener(new InternalFrameAdapter() {\n            public void internalFrameClosing(InternalFrameEvent e) {\n                if (getValue() == UNINITIALIZED_VALUE) {\n                    setValue(null);\n                }\n            }\n        });\n        addPropertyChangeListener(new PropertyChangeListener() {\n            public void propertyChange(PropertyChangeEvent event) {\n                // Let the defaultCloseOperation handle the closing\n                // if the user closed the iframe without selecting a button\n                // (newValue = null in that case).  Otherwise, close the dialog.\n                if (iFrame.isVisible() &&\n                        event.getSource() == JOptionPane.this &&\n                        event.getPropertyName().equals(VALUE_PROPERTY)) {\n                // Use reflection to get Container.stopLWModal().\n                try {\n                    Method method = AccessController.doPrivileged(\n                        new ModalPrivilegedAction(\n                            Container.class, \"stopLWModal\"));\n                    if (method != null) {\n                        method.invoke(iFrame, (Object[])null);\n                    }\n                } catch (IllegalAccessException ex) {\n                } catch (IllegalArgumentException ex) {\n                } catch (InvocationTargetException ex) {\n                }\n\n                try {\n                    iFrame.setClosed(true);\n                }\n                catch (java.beans.PropertyVetoException e) {\n                }\n\n                iFrame.setVisible(false);\n                }\n            }\n        });\n        iFrame.getContentPane().add(this, BorderLayout.CENTER);\n        if (parent instanceof JDesktopPane) {\n            parent.add(iFrame, JLayeredPane.MODAL_LAYER);\n        } else {\n            parent.add(iFrame, BorderLayout.CENTER);\n        }\n        Dimension iFrameSize = iFrame.getPreferredSize();\n        Dimension rootSize = parent.getSize();\n        Dimension parentSize = parentComponent.getSize();\n\n        iFrame.setBounds((rootSize.width - iFrameSize.width) / 2,\n                         (rootSize.height - iFrameSize.height) / 2,\n                         iFrameSize.width, iFrameSize.height);\n        // We want dialog centered relative to its parent component\n        Point iFrameCoord =\n          SwingUtilities.convertPoint(parentComponent, 0, 0, parent);\n        int x = (parentSize.width - iFrameSize.width) / 2 + iFrameCoord.x;\n        int y = (parentSize.height - iFrameSize.height) / 2 + iFrameCoord.y;\n\n        // If possible, dialog should be fully visible\n        int ovrx = x + iFrameSize.width - rootSize.width;\n        int ovry = y + iFrameSize.height - rootSize.height;\n        x = Math.max((ovrx > 0? x - ovrx: x), 0);\n        y = Math.max((ovry > 0? y - ovry: y), 0);\n        iFrame.setBounds(x, y, iFrameSize.width, iFrameSize.height);\n\n        parent.validate();\n        try {\n            iFrame.setSelected(true);\n        } catch (java.beans.PropertyVetoException e) {}\n\n        return iFrame;\n    }"}
{"Number":"1212","API Relative Path":"javax.swing.JOptionPane.java-createInternalFrame(Component-String)","Corresponding Source":"/**\n     * Creates and returns an instance of <code>JInternalFrame<\/code>.\n     * The internal frame is created with the specified title,\n     * and wrapping the <code>JOptionPane<\/code>.\n     * The returned <code>JInternalFrame<\/code> is\n     * added to the <code>JDesktopPane<\/code> ancestor of\n     * <code>parentComponent<\/code>, or components\n     * parent if one its ancestors isn't a <code>JDesktopPane<\/code>,\n     * or if <code>parentComponent<\/code>\n     * doesn't have a parent then a <code>RuntimeException<\/code> is thrown.\n     *\n     * @param parentComponent  the parent <code>Component<\/code> for\n     *          the internal frame\n     * @param title    the <code>String<\/code> to display in the\n     *          frame's title bar\n     * @return a <code>JInternalFrame<\/code> containing a\n     *          <code>JOptionPane<\/code>\n     * @exception RuntimeException if <code>parentComponent<\/code> does\n     *          not have a valid parent\n     */\n    public JInternalFrame createInternalFrame(Component parentComponent,\n                                 String title) {\n        Container parent =\n                JOptionPane.getDesktopPaneForComponent(parentComponent);\n\n        if (parent == null && (parentComponent == null ||\n                (parent = parentComponent.getParent()) == null)) {\n            throw new RuntimeException(\"JOptionPane: parentComponent does \" +\n                    \"not have a valid parent\");\n        }\n\n        // Option dialogs should be closable only\n        final JInternalFrame  iFrame = new JInternalFrame(title, false, true,\n                                                           false, false);\n\n        iFrame.putClientProperty(\"JInternalFrame.frameType\", \"optionDialog\");\n        iFrame.putClientProperty(\"JInternalFrame.messageType\",\n                                 Integer.valueOf(getMessageType()));\n\n        iFrame.addInternalFrameListener(new InternalFrameAdapter() {\n            public void internalFrameClosing(InternalFrameEvent e) {\n                if (getValue() == UNINITIALIZED_VALUE) {\n                    setValue(null);\n                }\n            }\n        });\n        addPropertyChangeListener(new PropertyChangeListener() {\n            public void propertyChange(PropertyChangeEvent event) {\n                // Let the defaultCloseOperation handle the closing\n                // if the user closed the iframe without selecting a button\n                // (newValue = null in that case).  Otherwise, close the dialog.\n                if (iFrame.isVisible() &&\n                        event.getSource() == JOptionPane.this &&\n                        event.getPropertyName().equals(VALUE_PROPERTY)) {\n                // Use reflection to get Container.stopLWModal().\n                try {\n                    Method method = AccessController.doPrivileged(\n                        new ModalPrivilegedAction(\n                            Container.class, \"stopLWModal\"));\n                    if (method != null) {\n                        method.invoke(iFrame, (Object[])null);\n                    }\n                } catch (IllegalAccessException ex) {\n                } catch (IllegalArgumentException ex) {\n                } catch (InvocationTargetException ex) {\n                }\n\n                try {\n                    iFrame.setClosed(true);\n                }\n                catch (java.beans.PropertyVetoException e) {\n                }\n\n                iFrame.setVisible(false);\n                }\n            }\n        });\n        iFrame.getContentPane().add(this, BorderLayout.CENTER);\n        if (parent instanceof JDesktopPane) {\n            parent.add(iFrame, JLayeredPane.MODAL_LAYER);\n        } else {\n            parent.add(iFrame, BorderLayout.CENTER);\n        }\n        Dimension iFrameSize = iFrame.getPreferredSize();\n        Dimension rootSize = parent.getSize();\n        Dimension parentSize = parentComponent.getSize();\n\n        iFrame.setBounds((rootSize.width - iFrameSize.width) / 2,\n                         (rootSize.height - iFrameSize.height) / 2,\n                         iFrameSize.width, iFrameSize.height);\n        // We want dialog centered relative to its parent component\n        Point iFrameCoord =\n          SwingUtilities.convertPoint(parentComponent, 0, 0, parent);\n        int x = (parentSize.width - iFrameSize.width) / 2 + iFrameCoord.x;\n        int y = (parentSize.height - iFrameSize.height) / 2 + iFrameCoord.y;\n\n        // If possible, dialog should be fully visible\n        int ovrx = x + iFrameSize.width - rootSize.width;\n        int ovry = y + iFrameSize.height - rootSize.height;\n        x = Math.max((ovrx > 0? x - ovrx: x), 0);\n        y = Math.max((ovry > 0? y - ovry: y), 0);\n        iFrame.setBounds(x, y, iFrameSize.width, iFrameSize.height);\n\n        parent.validate();\n        try {\n            iFrame.setSelected(true);\n        } catch (java.beans.PropertyVetoException e) {}\n\n        return iFrame;\n    }"}
{"Number":"1213","API Relative Path":"javax.swing.JOptionPane.java-getDesktopPaneForComponent(Component)","Corresponding Source":"/**\n     * Returns the specified component's desktop pane.\n     *\n     * @param parentComponent the <code>Component<\/code> to check for a\n     *          desktop\n     * @return the <code>JDesktopPane<\/code> that contains the component,\n     *          or <code>null<\/code> if the component is <code>null<\/code>\n     *          or does not have an ancestor that is a\n     *          <code>JInternalFrame<\/code>\n     */\n    public static JDesktopPane getDesktopPaneForComponent(Component parentComponent) {\n        if(parentComponent == null)\n            return null;\n        if(parentComponent instanceof JDesktopPane)\n            return (JDesktopPane)parentComponent;\n        return getDesktopPaneForComponent(parentComponent.getParent());\n    }"}
{"Number":"1214","API Relative Path":"javax.swing.JOptionPane.java-JOptionPane(Object-int-int-Icon-Object[]-Object)","Corresponding Source":"/**\n     * Creates an instance of <code>JOptionPane<\/code> to display a message\n     * with the specified message type, icon, and options, with the\n     * initially-selected option specified.\n     *\n     * @param message the <code>Object<\/code> to display\n     * @param messageType the type of message to be displayed:\n     *                  <code>ERROR_MESSAGE<\/code>,\n     *                  <code>INFORMATION_MESSAGE<\/code>,\n     *                  <code>WARNING_MESSAGE<\/code>,\n     *                  <code>QUESTION_MESSAGE<\/code>,\n     *                  or <code>PLAIN_MESSAGE<\/code>\n     * @param optionType the options to display in the pane:\n     *                  <code>DEFAULT_OPTION<\/code>,\n     *                  <code>YES_NO_OPTION<\/code>,\n     *                  <code>YES_NO_CANCEL_OPTION<\/code>,\n     *                  <code>OK_CANCEL_OPTION<\/code>\n     * @param icon the Icon image to display\n     * @param options  the choices the user can select\n     * @param initialValue the choice that is initially selected; if\n     *                  <code>null<\/code>, then nothing will be initially selected;\n     *                  only meaningful if <code>options<\/code> is used\n     */\n    public JOptionPane(Object message, int messageType, int optionType,\n                       Icon icon, Object[] options, Object initialValue) {\n\n        this.message = message;\n        this.options = options;\n        this.initialValue = initialValue;\n        this.icon = icon;\n        setMessageType(messageType);\n        setOptionType(optionType);\n        value = UNINITIALIZED_VALUE;\n        inputValue = UNINITIALIZED_VALUE;\n        updateUI();\n    }"}
{"Number":"1215","API Relative Path":"javax.swing.JOptionPane.java-JOptionPane(Object-int-int-Icon-Object[]-Object)","Corresponding Source":"/**\n     * Creates an instance of <code>JOptionPane<\/code> to display a message\n     * with the specified message type, icon, and options, with the\n     * initially-selected option specified.\n     *\n     * @param message the <code>Object<\/code> to display\n     * @param messageType the type of message to be displayed:\n     *                  <code>ERROR_MESSAGE<\/code>,\n     *                  <code>INFORMATION_MESSAGE<\/code>,\n     *                  <code>WARNING_MESSAGE<\/code>,\n     *                  <code>QUESTION_MESSAGE<\/code>,\n     *                  or <code>PLAIN_MESSAGE<\/code>\n     * @param optionType the options to display in the pane:\n     *                  <code>DEFAULT_OPTION<\/code>,\n     *                  <code>YES_NO_OPTION<\/code>,\n     *                  <code>YES_NO_CANCEL_OPTION<\/code>,\n     *                  <code>OK_CANCEL_OPTION<\/code>\n     * @param icon the Icon image to display\n     * @param options  the choices the user can select\n     * @param initialValue the choice that is initially selected; if\n     *                  <code>null<\/code>, then nothing will be initially selected;\n     *                  only meaningful if <code>options<\/code> is used\n     */\n    public JOptionPane(Object message, int messageType, int optionType,\n                       Icon icon, Object[] options, Object initialValue) {\n\n        this.message = message;\n        this.options = options;\n        this.initialValue = initialValue;\n        this.icon = icon;\n        setMessageType(messageType);\n        setOptionType(optionType);\n        value = UNINITIALIZED_VALUE;\n        inputValue = UNINITIALIZED_VALUE;\n        updateUI();\n    }"}
{"Number":"1216","API Relative Path":"javax.swing.JOptionPane.java-setMessageType(int)","Corresponding Source":"/**\n     * Sets the option pane's message type.\n     * The message type is used by the Look and Feel to determine the\n     * icon to display (if not supplied) as well as potentially how to\n     * lay out the <code>parentComponent<\/code>.\n     * @param newType an integer specifying the kind of message to display:\n     *                <code>ERROR_MESSAGE<\/code>, <code>INFORMATION_MESSAGE<\/code>,\n     *                <code>WARNING_MESSAGE<\/code>,\n     *                <code>QUESTION_MESSAGE<\/code>, or <code>PLAIN_MESSAGE<\/code>\n     * @exception RuntimeException if <code>newType<\/code> is not one of the\n     *          legal values listed above\n\n     * @see #getMessageType\n     * @beaninfo\n     *   preferred: true\n     *       bound: true\n     * description: The option pane's message type.\n     */\n    public void setMessageType(int newType) {\n        if(newType != ERROR_MESSAGE && newType != INFORMATION_MESSAGE &&\n           newType != WARNING_MESSAGE && newType != QUESTION_MESSAGE &&\n           newType != PLAIN_MESSAGE)\n            throw new RuntimeException(\"JOptionPane: type must be one of JOptionPane.ERROR_MESSAGE, JOptionPane.INFORMATION_MESSAGE, JOptionPane.WARNING_MESSAGE, JOptionPane.QUESTION_MESSAGE or JOptionPane.PLAIN_MESSAGE\");\n\n        int           oldType = messageType;\n\n        messageType = newType;\n        firePropertyChange(MESSAGE_TYPE_PROPERTY, oldType, messageType);\n    }"}
{"Number":"1217","API Relative Path":"javax.swing.JOptionPane.java-setOptionType(int)","Corresponding Source":"/**\n     * Sets the options to display.\n     * The option type is used by the Look and Feel to\n     * determine what buttons to show (unless options are supplied).\n     * @param newType an integer specifying the options the {@literal L&F} is to display:\n     *                  <code>DEFAULT_OPTION<\/code>,\n     *                  <code>YES_NO_OPTION<\/code>,\n     *                  <code>YES_NO_CANCEL_OPTION<\/code>,\n     *                  or <code>OK_CANCEL_OPTION<\/code>\n     * @exception RuntimeException if <code>newType<\/code> is not one of\n     *          the legal values listed above\n     *\n     * @see #getOptionType\n     * @see #setOptions\n     * @beaninfo\n     *   preferred: true\n     *       bound: true\n     * description: The option pane's option type.\n      */\n    public void setOptionType(int newType) {\n        if(newType != DEFAULT_OPTION && newType != YES_NO_OPTION &&\n           newType != YES_NO_CANCEL_OPTION && newType != OK_CANCEL_OPTION)\n            throw new RuntimeException(\"JOptionPane: option type must be one of JOptionPane.DEFAULT_OPTION, JOptionPane.YES_NO_OPTION, JOptionPane.YES_NO_CANCEL_OPTION or JOptionPane.OK_CANCEL_OPTION\");\n\n        int            oldType = optionType;\n\n        optionType = newType;\n        firePropertyChange(OPTION_TYPE_PROPERTY, oldType, optionType);\n    }"}
{"Number":"1218","API Relative Path":"javax.swing.JOptionPane.java-showConfirmDialog(Component-Object-String-int-int-Icon)","Corresponding Source":"/**\n     * Brings up a dialog with a specified icon, where the number of\n     * choices is determined by the <code>optionType<\/code> parameter.\n     * The <code>messageType<\/code> parameter is primarily used to supply\n     * a default icon from the look and feel.\n     *\n     * @param parentComponent determines the <code>Frame<\/code> in which the\n     *                  dialog is displayed; if <code>null<\/code>,\n     *                  or if the <code>parentComponent<\/code> has no\n     *                  <code>Frame<\/code>, a\n     *                  default <code>Frame<\/code> is used\n     * @param message   the Object to display\n     * @param title     the title string for the dialog\n     * @param optionType an int designating the options available on the dialog:\n     *                  <code>YES_NO_OPTION<\/code>,\n     *                  <code>YES_NO_CANCEL_OPTION<\/code>,\n     *                  or <code>OK_CANCEL_OPTION<\/code>\n     * @param messageType an int designating the kind of message this is,\n     *                  primarily used to determine the icon from the pluggable\n     *                  Look and Feel: <code>ERROR_MESSAGE<\/code>,\n     *                  <code>INFORMATION_MESSAGE<\/code>,\n     *                  <code>WARNING_MESSAGE<\/code>,\n     *                  <code>QUESTION_MESSAGE<\/code>,\n     *                  or <code>PLAIN_MESSAGE<\/code>\n     * @param icon      the icon to display in the dialog\n     * @return an int indicating the option selected by the user\n     * @exception HeadlessException if\n     *   <code>GraphicsEnvironment.isHeadless<\/code> returns\n     *   <code>true<\/code>\n     * @see java.awt.GraphicsEnvironment#isHeadless\n     */\n    public static int showConfirmDialog(Component parentComponent,\n        Object message, String title, int optionType,\n        int messageType, Icon icon) throws HeadlessException {\n        return showOptionDialog(parentComponent, message, title, optionType,\n                                messageType, icon, null, null);\n    }"}
{"Number":"1219","API Relative Path":"javax.swing.JOptionPane.java-showConfirmDialog(Component-Object-String-int-int-Icon)","Corresponding Source":"/**\n     * Brings up a dialog with a specified icon, where the number of\n     * choices is determined by the <code>optionType<\/code> parameter.\n     * The <code>messageType<\/code> parameter is primarily used to supply\n     * a default icon from the look and feel.\n     *\n     * @param parentComponent determines the <code>Frame<\/code> in which the\n     *                  dialog is displayed; if <code>null<\/code>,\n     *                  or if the <code>parentComponent<\/code> has no\n     *                  <code>Frame<\/code>, a\n     *                  default <code>Frame<\/code> is used\n     * @param message   the Object to display\n     * @param title     the title string for the dialog\n     * @param optionType an int designating the options available on the dialog:\n     *                  <code>YES_NO_OPTION<\/code>,\n     *                  <code>YES_NO_CANCEL_OPTION<\/code>,\n     *                  or <code>OK_CANCEL_OPTION<\/code>\n     * @param messageType an int designating the kind of message this is,\n     *                  primarily used to determine the icon from the pluggable\n     *                  Look and Feel: <code>ERROR_MESSAGE<\/code>,\n     *                  <code>INFORMATION_MESSAGE<\/code>,\n     *                  <code>WARNING_MESSAGE<\/code>,\n     *                  <code>QUESTION_MESSAGE<\/code>,\n     *                  or <code>PLAIN_MESSAGE<\/code>\n     * @param icon      the icon to display in the dialog\n     * @return an int indicating the option selected by the user\n     * @exception HeadlessException if\n     *   <code>GraphicsEnvironment.isHeadless<\/code> returns\n     *   <code>true<\/code>\n     * @see java.awt.GraphicsEnvironment#isHeadless\n     */\n    public static int showConfirmDialog(Component parentComponent,\n        Object message, String title, int optionType,\n        int messageType, Icon icon) throws HeadlessException {\n        return showOptionDialog(parentComponent, message, title, optionType,\n                                messageType, icon, null, null);\n    }"}
{"Number":"1220","API Relative Path":"javax.swing.JOptionPane.java-showInputDialog(Component-Object-String-int-Icon-Object[]-Object)","Corresponding Source":"/**\n     * Prompts the user for input in a blocking dialog where the\n     * initial selection, possible selections, and all other options can\n     * be specified. The user will able to choose from\n     * <code>selectionValues<\/code>, where <code>null<\/code> implies the\n     * user can input\n     * whatever they wish, usually by means of a <code>JTextField<\/code>.\n     * <code>initialSelectionValue<\/code> is the initial value to prompt\n     * the user with. It is up to the UI to decide how best to represent\n     * the <code>selectionValues<\/code>, but usually a\n     * <code>JComboBox<\/code>, <code>JList<\/code>, or\n     * <code>JTextField<\/code> will be used.\n     *\n     * @param parentComponent  the parent <code>Component<\/code> for the\n     *                  dialog\n     * @param message  the <code>Object<\/code> to display\n     * @param title    the <code>String<\/code> to display in the\n     *                  dialog title bar\n     * @param messageType the type of message to be displayed:\n     *                  <code>ERROR_MESSAGE<\/code>,\n     *                  <code>INFORMATION_MESSAGE<\/code>,\n     *                  <code>WARNING_MESSAGE<\/code>,\n     *                  <code>QUESTION_MESSAGE<\/code>,\n     *                  or <code>PLAIN_MESSAGE<\/code>\n     * @param icon     the <code>Icon<\/code> image to display\n     * @param selectionValues an array of <code>Object<\/code>s that\n     *                  gives the possible selections\n     * @param initialSelectionValue the value used to initialize the input\n     *                 field\n     * @return user's input, or <code>null<\/code> meaning the user\n     *                  canceled the input\n     * @exception HeadlessException if\n     *   <code>GraphicsEnvironment.isHeadless<\/code> returns\n     *   <code>true<\/code>\n     * @see java.awt.GraphicsEnvironment#isHeadless\n     */\n    public static Object showInputDialog(Component parentComponent,\n        Object message, String title, int messageType, Icon icon,\n        Object[] selectionValues, Object initialSelectionValue)\n        throws HeadlessException {\n        JOptionPane    pane = new JOptionPane(message, messageType,\n                                              OK_CANCEL_OPTION, icon,\n                                              null, null);\n\n        pane.setWantsInput(true);\n        pane.setSelectionValues(selectionValues);\n        pane.setInitialSelectionValue(initialSelectionValue);\n        pane.setComponentOrientation(((parentComponent == null) ?\n            getRootFrame() : parentComponent).getComponentOrientation());\n\n        int style = styleFromMessageType(messageType);\n        JDialog dialog = pane.createDialog(parentComponent, title, style);\n\n        pane.selectInitialValue();\n        dialog.show();\n        dialog.dispose();\n\n        Object value = pane.getInputValue();\n\n        if (value == UNINITIALIZED_VALUE) {\n            return null;\n        }\n        return value;\n    }"}
{"Number":"1221","API Relative Path":"javax.swing.JOptionPane.java-showInternalConfirmDialog(Component-Object-String-int-int-Icon)","Corresponding Source":"/**\n     * Brings up an internal dialog panel with a specified icon, where\n     * the number of choices is determined by the <code>optionType<\/code>\n     * parameter.\n     * The <code>messageType<\/code> parameter is primarily used to supply\n     * a default icon from the look and feel.\n     *\n     * @param parentComponent determines the <code>Frame<\/code>\n     *          in which the dialog is displayed; if <code>null<\/code>,\n     *          or if the parentComponent has no Frame, a\n     *          default <code>Frame<\/code> is used\n     * @param message   the object to display in the dialog; a\n     *          <code>Component<\/code> object is rendered as a\n     *          <code>Component<\/code>; a <code>String<\/code>\n     *          object is rendered as a string; other objects are\n     *          converted to a <code>String<\/code> using the\n     *          <code>toString<\/code> method\n     * @param title     the title string for the dialog\n     * @param optionType an integer designating the options available\n     *          on the dialog:\n     *          <code>YES_NO_OPTION<\/code>, or\n     *          <code>YES_NO_CANCEL_OPTION<\/code>.\n     * @param messageType an integer designating the kind of message this is,\n     *          primarily used to determine the icon from the pluggable\n     *          Look and Feel: <code>ERROR_MESSAGE<\/code>,\n     *          <code>INFORMATION_MESSAGE<\/code>,\n     *          <code>WARNING_MESSAGE<\/code>, <code>QUESTION_MESSAGE<\/code>,\n     *          or <code>PLAIN_MESSAGE<\/code>\n     * @param icon      the icon to display in the dialog\n     * @return an integer indicating the option selected by the user\n     */\n    public static int showInternalConfirmDialog(Component parentComponent,\n                                        Object message,\n                                        String title, int optionType,\n                                        int messageType, Icon icon) {\n        return showInternalOptionDialog(parentComponent, message, title, optionType,\n                                        messageType, icon, null, null);\n    }"}
{"Number":"1222","API Relative Path":"javax.swing.JOptionPane.java-showInternalConfirmDialog(Component-Object-String-int-int-Icon)","Corresponding Source":"/**\n     * Brings up an internal dialog panel with a specified icon, where\n     * the number of choices is determined by the <code>optionType<\/code>\n     * parameter.\n     * The <code>messageType<\/code> parameter is primarily used to supply\n     * a default icon from the look and feel.\n     *\n     * @param parentComponent determines the <code>Frame<\/code>\n     *          in which the dialog is displayed; if <code>null<\/code>,\n     *          or if the parentComponent has no Frame, a\n     *          default <code>Frame<\/code> is used\n     * @param message   the object to display in the dialog; a\n     *          <code>Component<\/code> object is rendered as a\n     *          <code>Component<\/code>; a <code>String<\/code>\n     *          object is rendered as a string; other objects are\n     *          converted to a <code>String<\/code> using the\n     *          <code>toString<\/code> method\n     * @param title     the title string for the dialog\n     * @param optionType an integer designating the options available\n     *          on the dialog:\n     *          <code>YES_NO_OPTION<\/code>, or\n     *          <code>YES_NO_CANCEL_OPTION<\/code>.\n     * @param messageType an integer designating the kind of message this is,\n     *          primarily used to determine the icon from the pluggable\n     *          Look and Feel: <code>ERROR_MESSAGE<\/code>,\n     *          <code>INFORMATION_MESSAGE<\/code>,\n     *          <code>WARNING_MESSAGE<\/code>, <code>QUESTION_MESSAGE<\/code>,\n     *          or <code>PLAIN_MESSAGE<\/code>\n     * @param icon      the icon to display in the dialog\n     * @return an integer indicating the option selected by the user\n     */\n    public static int showInternalConfirmDialog(Component parentComponent,\n                                        Object message,\n                                        String title, int optionType,\n                                        int messageType, Icon icon) {\n        return showInternalOptionDialog(parentComponent, message, title, optionType,\n                                        messageType, icon, null, null);\n    }"}
{"Number":"1223","API Relative Path":"javax.swing.JOptionPane.java-showInternalConfirmDialog(Component-Object-String-int-int-Icon)","Corresponding Source":"/**\n     * Brings up an internal dialog panel with a specified icon, where\n     * the number of choices is determined by the <code>optionType<\/code>\n     * parameter.\n     * The <code>messageType<\/code> parameter is primarily used to supply\n     * a default icon from the look and feel.\n     *\n     * @param parentComponent determines the <code>Frame<\/code>\n     *          in which the dialog is displayed; if <code>null<\/code>,\n     *          or if the parentComponent has no Frame, a\n     *          default <code>Frame<\/code> is used\n     * @param message   the object to display in the dialog; a\n     *          <code>Component<\/code> object is rendered as a\n     *          <code>Component<\/code>; a <code>String<\/code>\n     *          object is rendered as a string; other objects are\n     *          converted to a <code>String<\/code> using the\n     *          <code>toString<\/code> method\n     * @param title     the title string for the dialog\n     * @param optionType an integer designating the options available\n     *          on the dialog:\n     *          <code>YES_NO_OPTION<\/code>, or\n     *          <code>YES_NO_CANCEL_OPTION<\/code>.\n     * @param messageType an integer designating the kind of message this is,\n     *          primarily used to determine the icon from the pluggable\n     *          Look and Feel: <code>ERROR_MESSAGE<\/code>,\n     *          <code>INFORMATION_MESSAGE<\/code>,\n     *          <code>WARNING_MESSAGE<\/code>, <code>QUESTION_MESSAGE<\/code>,\n     *          or <code>PLAIN_MESSAGE<\/code>\n     * @param icon      the icon to display in the dialog\n     * @return an integer indicating the option selected by the user\n     */\n    public static int showInternalConfirmDialog(Component parentComponent,\n                                        Object message,\n                                        String title, int optionType,\n                                        int messageType, Icon icon) {\n        return showInternalOptionDialog(parentComponent, message, title, optionType,\n                                        messageType, icon, null, null);\n    }"}
{"Number":"1224","API Relative Path":"javax.swing.JOptionPane.java-showInternalInputDialog(Component-Object-String-int-Icon-Object[]-Object)","Corresponding Source":"/**\n     * Prompts the user for input in a blocking internal dialog where\n     * the initial selection, possible selections, and all other\n     * options can be specified. The user will able to choose from\n     * <code>selectionValues<\/code>, where <code>null<\/code>\n     * implies the user can input\n     * whatever they wish, usually by means of a <code>JTextField<\/code>.\n     * <code>initialSelectionValue<\/code> is the initial value to prompt\n     * the user with. It is up to the UI to decide how best to represent\n     * the <code>selectionValues<\/code>, but usually a\n     * <code>JComboBox<\/code>, <code>JList<\/code>, or\n     * <code>JTextField<\/code> will be used.\n     *\n     * @param parentComponent the parent <code>Component<\/code> for the dialog\n     * @param message  the <code>Object<\/code> to display\n     * @param title    the <code>String<\/code> to display in the dialog\n     *          title bar\n     * @param messageType the type of message to be displayed:\n     *                  <code>ERROR_MESSAGE<\/code>, <code>INFORMATION_MESSAGE<\/code>,\n     *                  <code>WARNING_MESSAGE<\/code>,\n     *                  <code>QUESTION_MESSAGE<\/code>, or <code>PLAIN_MESSAGE<\/code>\n     * @param icon     the <code>Icon<\/code> image to display\n     * @param selectionValues an array of <code>Objects<\/code> that\n     *                  gives the possible selections\n     * @param initialSelectionValue the value used to initialize the input\n     *                  field\n     * @return user's input, or <code>null<\/code> meaning the user\n     *          canceled the input\n     */\n    public static Object showInternalInputDialog(Component parentComponent,\n            Object message, String title, int messageType, Icon icon,\n            Object[] selectionValues, Object initialSelectionValue) {\n        JOptionPane pane = new JOptionPane(message, messageType,\n                OK_CANCEL_OPTION, icon, null, null);\n        pane.putClientProperty(PopupFactory_FORCE_HEAVYWEIGHT_POPUP,\n                Boolean.TRUE);\n        Component fo = KeyboardFocusManager.getCurrentKeyboardFocusManager().\n                getFocusOwner();\n\n        pane.setWantsInput(true);\n        pane.setSelectionValues(selectionValues);\n        pane.setInitialSelectionValue(initialSelectionValue);\n\n        JInternalFrame dialog =\n            pane.createInternalFrame(parentComponent, title);\n\n        pane.selectInitialValue();\n        dialog.setVisible(true);\n\n        /* Since all input will be blocked until this dialog is dismissed,\n         * make sure its parent containers are visible first (this component\n         * is tested below).  This is necessary for JApplets, because\n         * because an applet normally isn't made visible until after its\n         * start() method returns -- if this method is called from start(),\n         * the applet will appear to hang while an invisible modal frame\n         * waits for input.\n         */\n        if (dialog.isVisible() && !dialog.isShowing()) {\n            Container parent = dialog.getParent();\n            while (parent != null) {\n                if (parent.isVisible() == false) {\n                    parent.setVisible(true);\n                }\n                parent = parent.getParent();\n            }\n        }\n\n        // Use reflection to get Container.startLWModal.\n        try {\n            Method method = AccessController.doPrivileged(new ModalPrivilegedAction(\n                    Container.class, \"startLWModal\"));\n            if (method != null) {\n                method.invoke(dialog, (Object[])null);\n            }\n        } catch (IllegalAccessException ex) {\n        } catch (IllegalArgumentException ex) {\n        } catch (InvocationTargetException ex) {\n        }\n\n        if (parentComponent instanceof JInternalFrame) {\n            try {\n                ((JInternalFrame)parentComponent).setSelected(true);\n            } catch (java.beans.PropertyVetoException e) {\n            }\n        }\n\n        if (fo != null && fo.isShowing()) {\n            fo.requestFocus();\n        }\n        Object value = pane.getInputValue();\n\n        if (value == UNINITIALIZED_VALUE) {\n            return null;\n        }\n        return value;\n    }"}
{"Number":"1225","API Relative Path":"javax.swing.JOptionPane.java-showInternalInputDialog(Component-Object-String-int-Icon-Object[]-Object)","Corresponding Source":"/**\n     * Prompts the user for input in a blocking internal dialog where\n     * the initial selection, possible selections, and all other\n     * options can be specified. The user will able to choose from\n     * <code>selectionValues<\/code>, where <code>null<\/code>\n     * implies the user can input\n     * whatever they wish, usually by means of a <code>JTextField<\/code>.\n     * <code>initialSelectionValue<\/code> is the initial value to prompt\n     * the user with. It is up to the UI to decide how best to represent\n     * the <code>selectionValues<\/code>, but usually a\n     * <code>JComboBox<\/code>, <code>JList<\/code>, or\n     * <code>JTextField<\/code> will be used.\n     *\n     * @param parentComponent the parent <code>Component<\/code> for the dialog\n     * @param message  the <code>Object<\/code> to display\n     * @param title    the <code>String<\/code> to display in the dialog\n     *          title bar\n     * @param messageType the type of message to be displayed:\n     *                  <code>ERROR_MESSAGE<\/code>, <code>INFORMATION_MESSAGE<\/code>,\n     *                  <code>WARNING_MESSAGE<\/code>,\n     *                  <code>QUESTION_MESSAGE<\/code>, or <code>PLAIN_MESSAGE<\/code>\n     * @param icon     the <code>Icon<\/code> image to display\n     * @param selectionValues an array of <code>Objects<\/code> that\n     *                  gives the possible selections\n     * @param initialSelectionValue the value used to initialize the input\n     *                  field\n     * @return user's input, or <code>null<\/code> meaning the user\n     *          canceled the input\n     */\n    public static Object showInternalInputDialog(Component parentComponent,\n            Object message, String title, int messageType, Icon icon,\n            Object[] selectionValues, Object initialSelectionValue) {\n        JOptionPane pane = new JOptionPane(message, messageType,\n                OK_CANCEL_OPTION, icon, null, null);\n        pane.putClientProperty(PopupFactory_FORCE_HEAVYWEIGHT_POPUP,\n                Boolean.TRUE);\n        Component fo = KeyboardFocusManager.getCurrentKeyboardFocusManager().\n                getFocusOwner();\n\n        pane.setWantsInput(true);\n        pane.setSelectionValues(selectionValues);\n        pane.setInitialSelectionValue(initialSelectionValue);\n\n        JInternalFrame dialog =\n            pane.createInternalFrame(parentComponent, title);\n\n        pane.selectInitialValue();\n        dialog.setVisible(true);\n\n        /* Since all input will be blocked until this dialog is dismissed,\n         * make sure its parent containers are visible first (this component\n         * is tested below).  This is necessary for JApplets, because\n         * because an applet normally isn't made visible until after its\n         * start() method returns -- if this method is called from start(),\n         * the applet will appear to hang while an invisible modal frame\n         * waits for input.\n         */\n        if (dialog.isVisible() && !dialog.isShowing()) {\n            Container parent = dialog.getParent();\n            while (parent != null) {\n                if (parent.isVisible() == false) {\n                    parent.setVisible(true);\n                }\n                parent = parent.getParent();\n            }\n        }\n\n        // Use reflection to get Container.startLWModal.\n        try {\n            Method method = AccessController.doPrivileged(new ModalPrivilegedAction(\n                    Container.class, \"startLWModal\"));\n            if (method != null) {\n                method.invoke(dialog, (Object[])null);\n            }\n        } catch (IllegalAccessException ex) {\n        } catch (IllegalArgumentException ex) {\n        } catch (InvocationTargetException ex) {\n        }\n\n        if (parentComponent instanceof JInternalFrame) {\n            try {\n                ((JInternalFrame)parentComponent).setSelected(true);\n            } catch (java.beans.PropertyVetoException e) {\n            }\n        }\n\n        if (fo != null && fo.isShowing()) {\n            fo.requestFocus();\n        }\n        Object value = pane.getInputValue();\n\n        if (value == UNINITIALIZED_VALUE) {\n            return null;\n        }\n        return value;\n    }"}
{"Number":"1226","API Relative Path":"javax.swing.JOptionPane.java-showInternalInputDialog(Component-Object-String-int-Icon-Object[]-Object)","Corresponding Source":"/**\n     * Prompts the user for input in a blocking internal dialog where\n     * the initial selection, possible selections, and all other\n     * options can be specified. The user will able to choose from\n     * <code>selectionValues<\/code>, where <code>null<\/code>\n     * implies the user can input\n     * whatever they wish, usually by means of a <code>JTextField<\/code>.\n     * <code>initialSelectionValue<\/code> is the initial value to prompt\n     * the user with. It is up to the UI to decide how best to represent\n     * the <code>selectionValues<\/code>, but usually a\n     * <code>JComboBox<\/code>, <code>JList<\/code>, or\n     * <code>JTextField<\/code> will be used.\n     *\n     * @param parentComponent the parent <code>Component<\/code> for the dialog\n     * @param message  the <code>Object<\/code> to display\n     * @param title    the <code>String<\/code> to display in the dialog\n     *          title bar\n     * @param messageType the type of message to be displayed:\n     *                  <code>ERROR_MESSAGE<\/code>, <code>INFORMATION_MESSAGE<\/code>,\n     *                  <code>WARNING_MESSAGE<\/code>,\n     *                  <code>QUESTION_MESSAGE<\/code>, or <code>PLAIN_MESSAGE<\/code>\n     * @param icon     the <code>Icon<\/code> image to display\n     * @param selectionValues an array of <code>Objects<\/code> that\n     *                  gives the possible selections\n     * @param initialSelectionValue the value used to initialize the input\n     *                  field\n     * @return user's input, or <code>null<\/code> meaning the user\n     *          canceled the input\n     */\n    public static Object showInternalInputDialog(Component parentComponent,\n            Object message, String title, int messageType, Icon icon,\n            Object[] selectionValues, Object initialSelectionValue) {\n        JOptionPane pane = new JOptionPane(message, messageType,\n                OK_CANCEL_OPTION, icon, null, null);\n        pane.putClientProperty(PopupFactory_FORCE_HEAVYWEIGHT_POPUP,\n                Boolean.TRUE);\n        Component fo = KeyboardFocusManager.getCurrentKeyboardFocusManager().\n                getFocusOwner();\n\n        pane.setWantsInput(true);\n        pane.setSelectionValues(selectionValues);\n        pane.setInitialSelectionValue(initialSelectionValue);\n\n        JInternalFrame dialog =\n            pane.createInternalFrame(parentComponent, title);\n\n        pane.selectInitialValue();\n        dialog.setVisible(true);\n\n        /* Since all input will be blocked until this dialog is dismissed,\n         * make sure its parent containers are visible first (this component\n         * is tested below).  This is necessary for JApplets, because\n         * because an applet normally isn't made visible until after its\n         * start() method returns -- if this method is called from start(),\n         * the applet will appear to hang while an invisible modal frame\n         * waits for input.\n         */\n        if (dialog.isVisible() && !dialog.isShowing()) {\n            Container parent = dialog.getParent();\n            while (parent != null) {\n                if (parent.isVisible() == false) {\n                    parent.setVisible(true);\n                }\n                parent = parent.getParent();\n            }\n        }\n\n        // Use reflection to get Container.startLWModal.\n        try {\n            Method method = AccessController.doPrivileged(new ModalPrivilegedAction(\n                    Container.class, \"startLWModal\"));\n            if (method != null) {\n                method.invoke(dialog, (Object[])null);\n            }\n        } catch (IllegalAccessException ex) {\n        } catch (IllegalArgumentException ex) {\n        } catch (InvocationTargetException ex) {\n        }\n\n        if (parentComponent instanceof JInternalFrame) {\n            try {\n                ((JInternalFrame)parentComponent).setSelected(true);\n            } catch (java.beans.PropertyVetoException e) {\n            }\n        }\n\n        if (fo != null && fo.isShowing()) {\n            fo.requestFocus();\n        }\n        Object value = pane.getInputValue();\n\n        if (value == UNINITIALIZED_VALUE) {\n            return null;\n        }\n        return value;\n    }"}
{"Number":"1227","API Relative Path":"javax.swing.JOptionPane.java-showInternalMessageDialog(Component-Object-String-int-Icon)","Corresponding Source":"/**\n     * Brings up an internal dialog panel displaying a message,\n     * specifying all parameters.\n     *\n     * @param parentComponent determines the <code>Frame<\/code>\n     *          in which the dialog is displayed; if <code>null<\/code>,\n     *          or if the <code>parentComponent<\/code> has no\n     *          <code>Frame<\/code>, a default <code>Frame<\/code> is used\n     * @param message   the <code>Object<\/code> to display\n     * @param title     the title string for the dialog\n     * @param messageType the type of message to be displayed:\n     *                  <code>ERROR_MESSAGE<\/code>,\n     *                  <code>INFORMATION_MESSAGE<\/code>,\n     *                  <code>WARNING_MESSAGE<\/code>,\n     *                  <code>QUESTION_MESSAGE<\/code>,\n     *                  or <code>PLAIN_MESSAGE<\/code>\n     * @param icon      an icon to display in the dialog that helps the user\n     *                  identify the kind of message that is being displayed\n     */\n    public static void showInternalMessageDialog(Component parentComponent,\n                                         Object message,\n                                         String title, int messageType,\n                                         Icon icon){\n        showInternalOptionDialog(parentComponent, message, title, DEFAULT_OPTION,\n                                 messageType, icon, null, null);\n    }"}
{"Number":"1228","API Relative Path":"javax.swing.JOptionPane.java-showInternalMessageDialog(Component-Object-String-int-Icon)","Corresponding Source":"/**\n     * Brings up an internal dialog panel displaying a message,\n     * specifying all parameters.\n     *\n     * @param parentComponent determines the <code>Frame<\/code>\n     *          in which the dialog is displayed; if <code>null<\/code>,\n     *          or if the <code>parentComponent<\/code> has no\n     *          <code>Frame<\/code>, a default <code>Frame<\/code> is used\n     * @param message   the <code>Object<\/code> to display\n     * @param title     the title string for the dialog\n     * @param messageType the type of message to be displayed:\n     *                  <code>ERROR_MESSAGE<\/code>,\n     *                  <code>INFORMATION_MESSAGE<\/code>,\n     *                  <code>WARNING_MESSAGE<\/code>,\n     *                  <code>QUESTION_MESSAGE<\/code>,\n     *                  or <code>PLAIN_MESSAGE<\/code>\n     * @param icon      an icon to display in the dialog that helps the user\n     *                  identify the kind of message that is being displayed\n     */\n    public static void showInternalMessageDialog(Component parentComponent,\n                                         Object message,\n                                         String title, int messageType,\n                                         Icon icon){\n        showInternalOptionDialog(parentComponent, message, title, DEFAULT_OPTION,\n                                 messageType, icon, null, null);\n    }"}
{"Number":"1229","API Relative Path":"javax.swing.JOptionPane.java-showInternalOptionDialog(Component-Object-String-int-int-Icon-Object[]-Object)","Corresponding Source":"/**\n     * Brings up an internal dialog panel with a specified icon, where\n     * the initial choice is determined by the <code>initialValue<\/code>\n     * parameter and the number of choices is determined by the\n     * <code>optionType<\/code> parameter.\n     * <p>\n     * If <code>optionType<\/code> is <code>YES_NO_OPTION<\/code>, or\n     * <code>YES_NO_CANCEL_OPTION<\/code>\n     * and the <code>options<\/code> parameter is <code>null<\/code>,\n     * then the options are supplied by the Look and Feel.\n     * <p>\n     * The <code>messageType<\/code> parameter is primarily used to supply\n     * a default icon from the look and feel.\n     *\n     * @param parentComponent determines the <code>Frame<\/code>\n     *          in which the dialog is displayed; if <code>null<\/code>,\n     *          or if the <code>parentComponent<\/code> has no\n     *          <code>Frame<\/code>, a default <code>Frame<\/code> is used\n     * @param message   the object to display in the dialog; a\n     *          <code>Component<\/code> object is rendered as a\n     *          <code>Component<\/code>; a <code>String<\/code>\n     *          object is rendered as a string. Other objects are\n     *          converted to a <code>String<\/code> using the\n     *          <code>toString<\/code> method\n     * @param title     the title string for the dialog\n     * @param optionType an integer designating the options available\n     *          on the dialog: <code>YES_NO_OPTION<\/code>,\n     *          or <code>YES_NO_CANCEL_OPTION<\/code>\n     * @param messageType an integer designating the kind of message this is;\n     *          primarily used to determine the icon from the\n     *          pluggable Look and Feel: <code>ERROR_MESSAGE<\/code>,\n     *          <code>INFORMATION_MESSAGE<\/code>,\n     *          <code>WARNING_MESSAGE<\/code>, <code>QUESTION_MESSAGE<\/code>,\n     *          or <code>PLAIN_MESSAGE<\/code>\n     * @param icon      the icon to display in the dialog\n     * @param options   an array of objects indicating the possible choices\n     *          the user can make; if the objects are components, they\n     *          are rendered properly; non-<code>String<\/code>\n     *          objects are rendered using their <code>toString<\/code>\n     *          methods; if this parameter is <code>null<\/code>,\n     *          the options are determined by the Look and Feel\n     * @param initialValue the object that represents the default selection\n     *          for the dialog; only meaningful if <code>options<\/code>\n     *          is used; can be <code>null<\/code>\n     * @return an integer indicating the option chosen by the user,\n     *          or <code>CLOSED_OPTION<\/code> if the user closed the Dialog\n     */\n    public static int showInternalOptionDialog(Component parentComponent,\n                                       Object message,\n                                       String title, int optionType,\n                                       int messageType, Icon icon,\n                                       Object[] options, Object initialValue) {\n        JOptionPane pane = new JOptionPane(message, messageType,\n                optionType, icon, options, initialValue);\n        pane.putClientProperty(PopupFactory_FORCE_HEAVYWEIGHT_POPUP,\n                Boolean.TRUE);\n        Component fo = KeyboardFocusManager.getCurrentKeyboardFocusManager().\n                getFocusOwner();\n\n        pane.setInitialValue(initialValue);\n\n        JInternalFrame dialog =\n            pane.createInternalFrame(parentComponent, title);\n        pane.selectInitialValue();\n        dialog.setVisible(true);\n\n        /* Since all input will be blocked until this dialog is dismissed,\n         * make sure its parent containers are visible first (this component\n         * is tested below).  This is necessary for JApplets, because\n         * because an applet normally isn't made visible until after its\n         * start() method returns -- if this method is called from start(),\n         * the applet will appear to hang while an invisible modal frame\n         * waits for input.\n         */\n        if (dialog.isVisible() && !dialog.isShowing()) {\n            Container parent = dialog.getParent();\n            while (parent != null) {\n                if (parent.isVisible() == false) {\n                    parent.setVisible(true);\n                }\n                parent = parent.getParent();\n            }\n        }\n\n        // Use reflection to get Container.startLWModal.\n        try {\n            Method method = AccessController.doPrivileged(new ModalPrivilegedAction(\n                    Container.class, \"startLWModal\"));\n            if (method != null) {\n                method.invoke(dialog, (Object[])null);\n            }\n        } catch (IllegalAccessException ex) {\n        } catch (IllegalArgumentException ex) {\n        } catch (InvocationTargetException ex) {\n        }\n\n        if (parentComponent instanceof JInternalFrame) {\n            try {\n                ((JInternalFrame)parentComponent).setSelected(true);\n            } catch (java.beans.PropertyVetoException e) {\n            }\n        }\n\n        Object selectedValue = pane.getValue();\n\n        if (fo != null && fo.isShowing()) {\n            fo.requestFocus();\n        }\n        if (selectedValue == null) {\n            return CLOSED_OPTION;\n        }\n        if (options == null) {\n            if (selectedValue instanceof Integer) {\n                return ((Integer)selectedValue).intValue();\n            }\n            return CLOSED_OPTION;\n        }\n        for(int counter = 0, maxCounter = options.length;\n            counter < maxCounter; counter++) {\n            if (options[counter].equals(selectedValue)) {\n                return counter;\n            }\n        }\n        return CLOSED_OPTION;\n    }"}
{"Number":"1230","API Relative Path":"javax.swing.JOptionPane.java-showInternalOptionDialog(Component-Object-String-int-int-Icon-Object[]-Object)","Corresponding Source":"/**\n     * Brings up an internal dialog panel with a specified icon, where\n     * the initial choice is determined by the <code>initialValue<\/code>\n     * parameter and the number of choices is determined by the\n     * <code>optionType<\/code> parameter.\n     * <p>\n     * If <code>optionType<\/code> is <code>YES_NO_OPTION<\/code>, or\n     * <code>YES_NO_CANCEL_OPTION<\/code>\n     * and the <code>options<\/code> parameter is <code>null<\/code>,\n     * then the options are supplied by the Look and Feel.\n     * <p>\n     * The <code>messageType<\/code> parameter is primarily used to supply\n     * a default icon from the look and feel.\n     *\n     * @param parentComponent determines the <code>Frame<\/code>\n     *          in which the dialog is displayed; if <code>null<\/code>,\n     *          or if the <code>parentComponent<\/code> has no\n     *          <code>Frame<\/code>, a default <code>Frame<\/code> is used\n     * @param message   the object to display in the dialog; a\n     *          <code>Component<\/code> object is rendered as a\n     *          <code>Component<\/code>; a <code>String<\/code>\n     *          object is rendered as a string. Other objects are\n     *          converted to a <code>String<\/code> using the\n     *          <code>toString<\/code> method\n     * @param title     the title string for the dialog\n     * @param optionType an integer designating the options available\n     *          on the dialog: <code>YES_NO_OPTION<\/code>,\n     *          or <code>YES_NO_CANCEL_OPTION<\/code>\n     * @param messageType an integer designating the kind of message this is;\n     *          primarily used to determine the icon from the\n     *          pluggable Look and Feel: <code>ERROR_MESSAGE<\/code>,\n     *          <code>INFORMATION_MESSAGE<\/code>,\n     *          <code>WARNING_MESSAGE<\/code>, <code>QUESTION_MESSAGE<\/code>,\n     *          or <code>PLAIN_MESSAGE<\/code>\n     * @param icon      the icon to display in the dialog\n     * @param options   an array of objects indicating the possible choices\n     *          the user can make; if the objects are components, they\n     *          are rendered properly; non-<code>String<\/code>\n     *          objects are rendered using their <code>toString<\/code>\n     *          methods; if this parameter is <code>null<\/code>,\n     *          the options are determined by the Look and Feel\n     * @param initialValue the object that represents the default selection\n     *          for the dialog; only meaningful if <code>options<\/code>\n     *          is used; can be <code>null<\/code>\n     * @return an integer indicating the option chosen by the user,\n     *          or <code>CLOSED_OPTION<\/code> if the user closed the Dialog\n     */\n    public static int showInternalOptionDialog(Component parentComponent,\n                                       Object message,\n                                       String title, int optionType,\n                                       int messageType, Icon icon,\n                                       Object[] options, Object initialValue) {\n        JOptionPane pane = new JOptionPane(message, messageType,\n                optionType, icon, options, initialValue);\n        pane.putClientProperty(PopupFactory_FORCE_HEAVYWEIGHT_POPUP,\n                Boolean.TRUE);\n        Component fo = KeyboardFocusManager.getCurrentKeyboardFocusManager().\n                getFocusOwner();\n\n        pane.setInitialValue(initialValue);\n\n        JInternalFrame dialog =\n            pane.createInternalFrame(parentComponent, title);\n        pane.selectInitialValue();\n        dialog.setVisible(true);\n\n        /* Since all input will be blocked until this dialog is dismissed,\n         * make sure its parent containers are visible first (this component\n         * is tested below).  This is necessary for JApplets, because\n         * because an applet normally isn't made visible until after its\n         * start() method returns -- if this method is called from start(),\n         * the applet will appear to hang while an invisible modal frame\n         * waits for input.\n         */\n        if (dialog.isVisible() && !dialog.isShowing()) {\n            Container parent = dialog.getParent();\n            while (parent != null) {\n                if (parent.isVisible() == false) {\n                    parent.setVisible(true);\n                }\n                parent = parent.getParent();\n            }\n        }\n\n        // Use reflection to get Container.startLWModal.\n        try {\n            Method method = AccessController.doPrivileged(new ModalPrivilegedAction(\n                    Container.class, \"startLWModal\"));\n            if (method != null) {\n                method.invoke(dialog, (Object[])null);\n            }\n        } catch (IllegalAccessException ex) {\n        } catch (IllegalArgumentException ex) {\n        } catch (InvocationTargetException ex) {\n        }\n\n        if (parentComponent instanceof JInternalFrame) {\n            try {\n                ((JInternalFrame)parentComponent).setSelected(true);\n            } catch (java.beans.PropertyVetoException e) {\n            }\n        }\n\n        Object selectedValue = pane.getValue();\n\n        if (fo != null && fo.isShowing()) {\n            fo.requestFocus();\n        }\n        if (selectedValue == null) {\n            return CLOSED_OPTION;\n        }\n        if (options == null) {\n            if (selectedValue instanceof Integer) {\n                return ((Integer)selectedValue).intValue();\n            }\n            return CLOSED_OPTION;\n        }\n        for(int counter = 0, maxCounter = options.length;\n            counter < maxCounter; counter++) {\n            if (options[counter].equals(selectedValue)) {\n                return counter;\n            }\n        }\n        return CLOSED_OPTION;\n    }"}
{"Number":"1231","API Relative Path":"javax.swing.JOptionPane.java-showInternalOptionDialog(Component-Object-String-int-int-Icon-Object[]-Object)","Corresponding Source":"/**\n     * Brings up an internal dialog panel with a specified icon, where\n     * the initial choice is determined by the <code>initialValue<\/code>\n     * parameter and the number of choices is determined by the\n     * <code>optionType<\/code> parameter.\n     * <p>\n     * If <code>optionType<\/code> is <code>YES_NO_OPTION<\/code>, or\n     * <code>YES_NO_CANCEL_OPTION<\/code>\n     * and the <code>options<\/code> parameter is <code>null<\/code>,\n     * then the options are supplied by the Look and Feel.\n     * <p>\n     * The <code>messageType<\/code> parameter is primarily used to supply\n     * a default icon from the look and feel.\n     *\n     * @param parentComponent determines the <code>Frame<\/code>\n     *          in which the dialog is displayed; if <code>null<\/code>,\n     *          or if the <code>parentComponent<\/code> has no\n     *          <code>Frame<\/code>, a default <code>Frame<\/code> is used\n     * @param message   the object to display in the dialog; a\n     *          <code>Component<\/code> object is rendered as a\n     *          <code>Component<\/code>; a <code>String<\/code>\n     *          object is rendered as a string. Other objects are\n     *          converted to a <code>String<\/code> using the\n     *          <code>toString<\/code> method\n     * @param title     the title string for the dialog\n     * @param optionType an integer designating the options available\n     *          on the dialog: <code>YES_NO_OPTION<\/code>,\n     *          or <code>YES_NO_CANCEL_OPTION<\/code>\n     * @param messageType an integer designating the kind of message this is;\n     *          primarily used to determine the icon from the\n     *          pluggable Look and Feel: <code>ERROR_MESSAGE<\/code>,\n     *          <code>INFORMATION_MESSAGE<\/code>,\n     *          <code>WARNING_MESSAGE<\/code>, <code>QUESTION_MESSAGE<\/code>,\n     *          or <code>PLAIN_MESSAGE<\/code>\n     * @param icon      the icon to display in the dialog\n     * @param options   an array of objects indicating the possible choices\n     *          the user can make; if the objects are components, they\n     *          are rendered properly; non-<code>String<\/code>\n     *          objects are rendered using their <code>toString<\/code>\n     *          methods; if this parameter is <code>null<\/code>,\n     *          the options are determined by the Look and Feel\n     * @param initialValue the object that represents the default selection\n     *          for the dialog; only meaningful if <code>options<\/code>\n     *          is used; can be <code>null<\/code>\n     * @return an integer indicating the option chosen by the user,\n     *          or <code>CLOSED_OPTION<\/code> if the user closed the Dialog\n     */\n    public static int showInternalOptionDialog(Component parentComponent,\n                                       Object message,\n                                       String title, int optionType,\n                                       int messageType, Icon icon,\n                                       Object[] options, Object initialValue) {\n        JOptionPane pane = new JOptionPane(message, messageType,\n                optionType, icon, options, initialValue);\n        pane.putClientProperty(PopupFactory_FORCE_HEAVYWEIGHT_POPUP,\n                Boolean.TRUE);\n        Component fo = KeyboardFocusManager.getCurrentKeyboardFocusManager().\n                getFocusOwner();\n\n        pane.setInitialValue(initialValue);\n\n        JInternalFrame dialog =\n            pane.createInternalFrame(parentComponent, title);\n        pane.selectInitialValue();\n        dialog.setVisible(true);\n\n        /* Since all input will be blocked until this dialog is dismissed,\n         * make sure its parent containers are visible first (this component\n         * is tested below).  This is necessary for JApplets, because\n         * because an applet normally isn't made visible until after its\n         * start() method returns -- if this method is called from start(),\n         * the applet will appear to hang while an invisible modal frame\n         * waits for input.\n         */\n        if (dialog.isVisible() && !dialog.isShowing()) {\n            Container parent = dialog.getParent();\n            while (parent != null) {\n                if (parent.isVisible() == false) {\n                    parent.setVisible(true);\n                }\n                parent = parent.getParent();\n            }\n        }\n\n        // Use reflection to get Container.startLWModal.\n        try {\n            Method method = AccessController.doPrivileged(new ModalPrivilegedAction(\n                    Container.class, \"startLWModal\"));\n            if (method != null) {\n                method.invoke(dialog, (Object[])null);\n            }\n        } catch (IllegalAccessException ex) {\n        } catch (IllegalArgumentException ex) {\n        } catch (InvocationTargetException ex) {\n        }\n\n        if (parentComponent instanceof JInternalFrame) {\n            try {\n                ((JInternalFrame)parentComponent).setSelected(true);\n            } catch (java.beans.PropertyVetoException e) {\n            }\n        }\n\n        Object selectedValue = pane.getValue();\n\n        if (fo != null && fo.isShowing()) {\n            fo.requestFocus();\n        }\n        if (selectedValue == null) {\n            return CLOSED_OPTION;\n        }\n        if (options == null) {\n            if (selectedValue instanceof Integer) {\n                return ((Integer)selectedValue).intValue();\n            }\n            return CLOSED_OPTION;\n        }\n        for(int counter = 0, maxCounter = options.length;\n            counter < maxCounter; counter++) {\n            if (options[counter].equals(selectedValue)) {\n                return counter;\n            }\n        }\n        return CLOSED_OPTION;\n    }"}
{"Number":"1232","API Relative Path":"javax.swing.JOptionPane.java-showInternalOptionDialog(Component-Object-String-int-int-Icon-Object[]-Object)","Corresponding Source":"/**\n     * Brings up an internal dialog panel with a specified icon, where\n     * the initial choice is determined by the <code>initialValue<\/code>\n     * parameter and the number of choices is determined by the\n     * <code>optionType<\/code> parameter.\n     * <p>\n     * If <code>optionType<\/code> is <code>YES_NO_OPTION<\/code>, or\n     * <code>YES_NO_CANCEL_OPTION<\/code>\n     * and the <code>options<\/code> parameter is <code>null<\/code>,\n     * then the options are supplied by the Look and Feel.\n     * <p>\n     * The <code>messageType<\/code> parameter is primarily used to supply\n     * a default icon from the look and feel.\n     *\n     * @param parentComponent determines the <code>Frame<\/code>\n     *          in which the dialog is displayed; if <code>null<\/code>,\n     *          or if the <code>parentComponent<\/code> has no\n     *          <code>Frame<\/code>, a default <code>Frame<\/code> is used\n     * @param message   the object to display in the dialog; a\n     *          <code>Component<\/code> object is rendered as a\n     *          <code>Component<\/code>; a <code>String<\/code>\n     *          object is rendered as a string. Other objects are\n     *          converted to a <code>String<\/code> using the\n     *          <code>toString<\/code> method\n     * @param title     the title string for the dialog\n     * @param optionType an integer designating the options available\n     *          on the dialog: <code>YES_NO_OPTION<\/code>,\n     *          or <code>YES_NO_CANCEL_OPTION<\/code>\n     * @param messageType an integer designating the kind of message this is;\n     *          primarily used to determine the icon from the\n     *          pluggable Look and Feel: <code>ERROR_MESSAGE<\/code>,\n     *          <code>INFORMATION_MESSAGE<\/code>,\n     *          <code>WARNING_MESSAGE<\/code>, <code>QUESTION_MESSAGE<\/code>,\n     *          or <code>PLAIN_MESSAGE<\/code>\n     * @param icon      the icon to display in the dialog\n     * @param options   an array of objects indicating the possible choices\n     *          the user can make; if the objects are components, they\n     *          are rendered properly; non-<code>String<\/code>\n     *          objects are rendered using their <code>toString<\/code>\n     *          methods; if this parameter is <code>null<\/code>,\n     *          the options are determined by the Look and Feel\n     * @param initialValue the object that represents the default selection\n     *          for the dialog; only meaningful if <code>options<\/code>\n     *          is used; can be <code>null<\/code>\n     * @return an integer indicating the option chosen by the user,\n     *          or <code>CLOSED_OPTION<\/code> if the user closed the Dialog\n     */\n    public static int showInternalOptionDialog(Component parentComponent,\n                                       Object message,\n                                       String title, int optionType,\n                                       int messageType, Icon icon,\n                                       Object[] options, Object initialValue) {\n        JOptionPane pane = new JOptionPane(message, messageType,\n                optionType, icon, options, initialValue);\n        pane.putClientProperty(PopupFactory_FORCE_HEAVYWEIGHT_POPUP,\n                Boolean.TRUE);\n        Component fo = KeyboardFocusManager.getCurrentKeyboardFocusManager().\n                getFocusOwner();\n\n        pane.setInitialValue(initialValue);\n\n        JInternalFrame dialog =\n            pane.createInternalFrame(parentComponent, title);\n        pane.selectInitialValue();\n        dialog.setVisible(true);\n\n        /* Since all input will be blocked until this dialog is dismissed,\n         * make sure its parent containers are visible first (this component\n         * is tested below).  This is necessary for JApplets, because\n         * because an applet normally isn't made visible until after its\n         * start() method returns -- if this method is called from start(),\n         * the applet will appear to hang while an invisible modal frame\n         * waits for input.\n         */\n        if (dialog.isVisible() && !dialog.isShowing()) {\n            Container parent = dialog.getParent();\n            while (parent != null) {\n                if (parent.isVisible() == false) {\n                    parent.setVisible(true);\n                }\n                parent = parent.getParent();\n            }\n        }\n\n        // Use reflection to get Container.startLWModal.\n        try {\n            Method method = AccessController.doPrivileged(new ModalPrivilegedAction(\n                    Container.class, \"startLWModal\"));\n            if (method != null) {\n                method.invoke(dialog, (Object[])null);\n            }\n        } catch (IllegalAccessException ex) {\n        } catch (IllegalArgumentException ex) {\n        } catch (InvocationTargetException ex) {\n        }\n\n        if (parentComponent instanceof JInternalFrame) {\n            try {\n                ((JInternalFrame)parentComponent).setSelected(true);\n            } catch (java.beans.PropertyVetoException e) {\n            }\n        }\n\n        Object selectedValue = pane.getValue();\n\n        if (fo != null && fo.isShowing()) {\n            fo.requestFocus();\n        }\n        if (selectedValue == null) {\n            return CLOSED_OPTION;\n        }\n        if (options == null) {\n            if (selectedValue instanceof Integer) {\n                return ((Integer)selectedValue).intValue();\n            }\n            return CLOSED_OPTION;\n        }\n        for(int counter = 0, maxCounter = options.length;\n            counter < maxCounter; counter++) {\n            if (options[counter].equals(selectedValue)) {\n                return counter;\n            }\n        }\n        return CLOSED_OPTION;\n    }"}
{"Number":"1233","API Relative Path":"javax.swing.JOptionPane.java-showMessageDialog(Component-Object-String-int-Icon)","Corresponding Source":"/**\n     * Brings up a dialog displaying a message, specifying all parameters.\n     *\n     * @param parentComponent determines the <code>Frame<\/code> in which the\n     *                  dialog is displayed; if <code>null<\/code>,\n     *                  or if the <code>parentComponent<\/code> has no\n     *                  <code>Frame<\/code>, a\n     *                  default <code>Frame<\/code> is used\n     * @param message   the <code>Object<\/code> to display\n     * @param title     the title string for the dialog\n     * @param messageType the type of message to be displayed:\n     *                  <code>ERROR_MESSAGE<\/code>,\n     *                  <code>INFORMATION_MESSAGE<\/code>,\n     *                  <code>WARNING_MESSAGE<\/code>,\n     *                  <code>QUESTION_MESSAGE<\/code>,\n     *                  or <code>PLAIN_MESSAGE<\/code>\n     * @param icon      an icon to display in the dialog that helps the user\n     *                  identify the kind of message that is being displayed\n     * @exception HeadlessException if\n     *   <code>GraphicsEnvironment.isHeadless<\/code> returns\n     *   <code>true<\/code>\n     * @see java.awt.GraphicsEnvironment#isHeadless\n     */\n    public static void showMessageDialog(Component parentComponent,\n        Object message, String title, int messageType, Icon icon)\n        throws HeadlessException {\n        showOptionDialog(parentComponent, message, title, DEFAULT_OPTION,\n                         messageType, icon, null, null);\n    }"}
{"Number":"1234","API Relative Path":"javax.swing.JOptionPane.java-showOptionDialog(Component-Object-String-int-int-Icon-Object[]-Object)","Corresponding Source":"/**\n     * Brings up a dialog with a specified icon, where the initial\n     * choice is determined by the <code>initialValue<\/code> parameter and\n     * the number of choices is determined by the <code>optionType<\/code>\n     * parameter.\n     * <p>\n     * If <code>optionType<\/code> is <code>YES_NO_OPTION<\/code>,\n     * or <code>YES_NO_CANCEL_OPTION<\/code>\n     * and the <code>options<\/code> parameter is <code>null<\/code>,\n     * then the options are\n     * supplied by the look and feel.\n     * <p>\n     * The <code>messageType<\/code> parameter is primarily used to supply\n     * a default icon from the look and feel.\n     *\n     * @param parentComponent determines the <code>Frame<\/code>\n     *                  in which the dialog is displayed;  if\n     *                  <code>null<\/code>, or if the\n     *                  <code>parentComponent<\/code> has no\n     *                  <code>Frame<\/code>, a\n     *                  default <code>Frame<\/code> is used\n     * @param message   the <code>Object<\/code> to display\n     * @param title     the title string for the dialog\n     * @param optionType an integer designating the options available on the\n     *                  dialog: <code>DEFAULT_OPTION<\/code>,\n     *                  <code>YES_NO_OPTION<\/code>,\n     *                  <code>YES_NO_CANCEL_OPTION<\/code>,\n     *                  or <code>OK_CANCEL_OPTION<\/code>\n     * @param messageType an integer designating the kind of message this is,\n     *                  primarily used to determine the icon from the\n     *                  pluggable Look and Feel: <code>ERROR_MESSAGE<\/code>,\n     *                  <code>INFORMATION_MESSAGE<\/code>,\n     *                  <code>WARNING_MESSAGE<\/code>,\n     *                  <code>QUESTION_MESSAGE<\/code>,\n     *                  or <code>PLAIN_MESSAGE<\/code>\n     * @param icon      the icon to display in the dialog\n     * @param options   an array of objects indicating the possible choices\n     *                  the user can make; if the objects are components, they\n     *                  are rendered properly; non-<code>String<\/code>\n     *                  objects are\n     *                  rendered using their <code>toString<\/code> methods;\n     *                  if this parameter is <code>null<\/code>,\n     *                  the options are determined by the Look and Feel\n     * @param initialValue the object that represents the default selection\n     *                  for the dialog; only meaningful if <code>options<\/code>\n     *                  is used; can be <code>null<\/code>\n     * @return an integer indicating the option chosen by the user,\n     *                  or <code>CLOSED_OPTION<\/code> if the user closed\n     *                  the dialog\n     * @exception HeadlessException if\n     *   <code>GraphicsEnvironment.isHeadless<\/code> returns\n     *   <code>true<\/code>\n     * @see java.awt.GraphicsEnvironment#isHeadless\n     */\n    public static int showOptionDialog(Component parentComponent,\n        Object message, String title, int optionType, int messageType,\n        Icon icon, Object[] options, Object initialValue)\n        throws HeadlessException {\n        JOptionPane             pane = new JOptionPane(message, messageType,\n                                                       optionType, icon,\n                                                       options, initialValue);\n\n        pane.setInitialValue(initialValue);\n        pane.setComponentOrientation(((parentComponent == null) ?\n            getRootFrame() : parentComponent).getComponentOrientation());\n\n        int style = styleFromMessageType(messageType);\n        JDialog dialog = pane.createDialog(parentComponent, title, style);\n\n        pane.selectInitialValue();\n        dialog.show();\n        dialog.dispose();\n\n        Object        selectedValue = pane.getValue();\n\n        if(selectedValue == null)\n            return CLOSED_OPTION;\n        if(options == null) {\n            if(selectedValue instanceof Integer)\n                return ((Integer)selectedValue).intValue();\n            return CLOSED_OPTION;\n        }\n        for(int counter = 0, maxCounter = options.length;\n            counter < maxCounter; counter++) {\n            if(options[counter].equals(selectedValue))\n                return counter;\n        }\n        return CLOSED_OPTION;\n    }"}
{"Number":"1235","API Relative Path":"javax.swing.JOptionPane.java-showOptionDialog(Component-Object-String-int-int-Icon-Object[]-Object)","Corresponding Source":"/**\n     * Brings up a dialog with a specified icon, where the initial\n     * choice is determined by the <code>initialValue<\/code> parameter and\n     * the number of choices is determined by the <code>optionType<\/code>\n     * parameter.\n     * <p>\n     * If <code>optionType<\/code> is <code>YES_NO_OPTION<\/code>,\n     * or <code>YES_NO_CANCEL_OPTION<\/code>\n     * and the <code>options<\/code> parameter is <code>null<\/code>,\n     * then the options are\n     * supplied by the look and feel.\n     * <p>\n     * The <code>messageType<\/code> parameter is primarily used to supply\n     * a default icon from the look and feel.\n     *\n     * @param parentComponent determines the <code>Frame<\/code>\n     *                  in which the dialog is displayed;  if\n     *                  <code>null<\/code>, or if the\n     *                  <code>parentComponent<\/code> has no\n     *                  <code>Frame<\/code>, a\n     *                  default <code>Frame<\/code> is used\n     * @param message   the <code>Object<\/code> to display\n     * @param title     the title string for the dialog\n     * @param optionType an integer designating the options available on the\n     *                  dialog: <code>DEFAULT_OPTION<\/code>,\n     *                  <code>YES_NO_OPTION<\/code>,\n     *                  <code>YES_NO_CANCEL_OPTION<\/code>,\n     *                  or <code>OK_CANCEL_OPTION<\/code>\n     * @param messageType an integer designating the kind of message this is,\n     *                  primarily used to determine the icon from the\n     *                  pluggable Look and Feel: <code>ERROR_MESSAGE<\/code>,\n     *                  <code>INFORMATION_MESSAGE<\/code>,\n     *                  <code>WARNING_MESSAGE<\/code>,\n     *                  <code>QUESTION_MESSAGE<\/code>,\n     *                  or <code>PLAIN_MESSAGE<\/code>\n     * @param icon      the icon to display in the dialog\n     * @param options   an array of objects indicating the possible choices\n     *                  the user can make; if the objects are components, they\n     *                  are rendered properly; non-<code>String<\/code>\n     *                  objects are\n     *                  rendered using their <code>toString<\/code> methods;\n     *                  if this parameter is <code>null<\/code>,\n     *                  the options are determined by the Look and Feel\n     * @param initialValue the object that represents the default selection\n     *                  for the dialog; only meaningful if <code>options<\/code>\n     *                  is used; can be <code>null<\/code>\n     * @return an integer indicating the option chosen by the user,\n     *                  or <code>CLOSED_OPTION<\/code> if the user closed\n     *                  the dialog\n     * @exception HeadlessException if\n     *   <code>GraphicsEnvironment.isHeadless<\/code> returns\n     *   <code>true<\/code>\n     * @see java.awt.GraphicsEnvironment#isHeadless\n     */\n    public static int showOptionDialog(Component parentComponent,\n        Object message, String title, int optionType, int messageType,\n        Icon icon, Object[] options, Object initialValue)\n        throws HeadlessException {\n        JOptionPane             pane = new JOptionPane(message, messageType,\n                                                       optionType, icon,\n                                                       options, initialValue);\n\n        pane.setInitialValue(initialValue);\n        pane.setComponentOrientation(((parentComponent == null) ?\n            getRootFrame() : parentComponent).getComponentOrientation());\n\n        int style = styleFromMessageType(messageType);\n        JDialog dialog = pane.createDialog(parentComponent, title, style);\n\n        pane.selectInitialValue();\n        dialog.show();\n        dialog.dispose();\n\n        Object        selectedValue = pane.getValue();\n\n        if(selectedValue == null)\n            return CLOSED_OPTION;\n        if(options == null) {\n            if(selectedValue instanceof Integer)\n                return ((Integer)selectedValue).intValue();\n            return CLOSED_OPTION;\n        }\n        for(int counter = 0, maxCounter = options.length;\n            counter < maxCounter; counter++) {\n            if(options[counter].equals(selectedValue))\n                return counter;\n        }\n        return CLOSED_OPTION;\n    }"}
{"Number":"1236","API Relative Path":"javax.swing.JPopupMenu.java-add(Action)","Corresponding Source":"/**\n     * Appends a new menu item to the end of the menu which\n     * dispatches the specified <code>Action<\/code> object.\n     *\n     * @param a the <code>Action<\/code> to add to the menu\n     * @return the new menu item\n     * @see Action\n     */\n    public JMenuItem add(Action a) {\n        JMenuItem mi = createActionComponent(a);\n        mi.setAction(a);\n        add(mi);\n        return mi;\n    }"}
{"Number":"1237","API Relative Path":"javax.swing.JPopupMenu.java-addMenuKeyListener(MenuKeyListener)","Corresponding Source":"/**\n     * Adds a <code>MenuKeyListener<\/code> to the popup menu.\n     *\n     * @param l the <code>MenuKeyListener<\/code> to be added\n     * @since 1.5\n     */\n    public void addMenuKeyListener(MenuKeyListener l) {\n        listenerList.add(MenuKeyListener.class, l);\n    }"}
{"Number":"1238","API Relative Path":"javax.swing.JPopupMenu.java-addPopupMenuListener(PopupMenuListener)","Corresponding Source":"/**\n     *  Adds a <code>PopupMenu<\/code> listener.\n     *\n     *  @param l  the <code>PopupMenuListener<\/code> to add\n     */\n    public void addPopupMenuListener(PopupMenuListener l) {\n        listenerList.add(PopupMenuListener.class,l);\n    }"}
{"Number":"1239","API Relative Path":"javax.swing.JPopupMenu.java-insert(Action-int)","Corresponding Source":"/**\n     * Inserts a menu item for the specified <code>Action<\/code> object at\n     * a given position.\n     *\n     * @param a  the <code>Action<\/code> object to insert\n     * @param index      specifies the position at which to insert the\n     *                   <code>Action<\/code>, where 0 is the first\n     * @exception IllegalArgumentException if <code>index<\/code> &lt; 0\n     * @see Action\n     */\n    public void insert(Action a, int index) {\n        JMenuItem mi = createActionComponent(a);\n        mi.setAction(a);\n        insert(mi, index);\n    }"}
{"Number":"1240","API Relative Path":"javax.swing.JPopupMenu.java-insert(Component-int)","Corresponding Source":"/**\n     * Inserts the specified component into the menu at a given\n     * position.\n     *\n     * @param component  the <code>Component<\/code> to insert\n     * @param index      specifies the position at which\n     *                   to insert the component, where 0 is the first\n     * @exception IllegalArgumentException if <code>index<\/code> &lt; 0\n     */\n    public void insert(Component component, int index) {\n        if (index < 0) {\n            throw new IllegalArgumentException(\"index less than zero.\");\n        }\n\n        int nitems = getComponentCount();\n        // PENDING(ges): Why not use an array?\n        Vector<Component> tempItems = new Vector<Component>();\n\n        /* Remove the item at index, nitems-index times\n           storing them in a temporary vector in the\n           order they appear on the menu.\n           */\n        for (int i = index ; i < nitems; i++) {\n            tempItems.addElement(getComponent(index));\n            remove(index);\n        }\n\n        add(component);\n\n        /* Add the removed items back to the menu, they are\n           already in the correct order in the temp vector.\n           */\n        for (Component tempItem : tempItems) {\n            add(tempItem);\n        }\n    }"}
{"Number":"1241","API Relative Path":"javax.swing.JPopupMenu.java-insert(Component-int)","Corresponding Source":"/**\n     * Inserts the specified component into the menu at a given\n     * position.\n     *\n     * @param component  the <code>Component<\/code> to insert\n     * @param index      specifies the position at which\n     *                   to insert the component, where 0 is the first\n     * @exception IllegalArgumentException if <code>index<\/code> &lt; 0\n     */\n    public void insert(Component component, int index) {\n        if (index < 0) {\n            throw new IllegalArgumentException(\"index less than zero.\");\n        }\n\n        int nitems = getComponentCount();\n        // PENDING(ges): Why not use an array?\n        Vector<Component> tempItems = new Vector<Component>();\n\n        /* Remove the item at index, nitems-index times\n           storing them in a temporary vector in the\n           order they appear on the menu.\n           */\n        for (int i = index ; i < nitems; i++) {\n            tempItems.addElement(getComponent(index));\n            remove(index);\n        }\n\n        add(component);\n\n        /* Add the removed items back to the menu, they are\n           already in the correct order in the temp vector.\n           */\n        for (Component tempItem : tempItems) {\n            add(tempItem);\n        }\n    }"}
{"Number":"1242","API Relative Path":"javax.swing.JPopupMenu.java-remove(int)","Corresponding Source":"/**\n     * Removes the component at the specified index from this popup menu.\n     *\n     * @param       pos the position of the item to be removed\n     * @exception   IllegalArgumentException if the value of\n     *                          <code>pos<\/code> &lt; 0, or if the value of\n     *                          <code>pos<\/code> is greater than the\n     *                          number of items\n     */\n    public void remove(int pos) {\n        if (pos < 0) {\n            throw new IllegalArgumentException(\"index less than zero.\");\n        }\n        if (pos > getComponentCount() -1) {\n            throw new IllegalArgumentException(\"index greater than the number of items.\");\n        }\n        super.remove(pos);\n    }"}
{"Number":"1243","API Relative Path":"javax.swing.JPopupMenu.java-removeMenuKeyListener(MenuKeyListener)","Corresponding Source":"/**\n     * Removes a <code>MenuKeyListener<\/code> from the popup menu.\n     *\n     * @param l the <code>MenuKeyListener<\/code> to be removed\n     * @since 1.5\n     */\n    public void removeMenuKeyListener(MenuKeyListener l) {\n        listenerList.remove(MenuKeyListener.class, l);\n    }"}
{"Number":"1244","API Relative Path":"javax.swing.JPopupMenu.java-removePopupMenuListener(PopupMenuListener)","Corresponding Source":"/**\n     * Removes a <code>PopupMenu<\/code> listener.\n     *\n     * @param l  the <code>PopupMenuListener<\/code> to remove\n     */\n    public void removePopupMenuListener(PopupMenuListener l) {\n        listenerList.remove(PopupMenuListener.class,l);\n    }"}
{"Number":"1245","API Relative Path":"javax.swing.JProgressBar.java-addChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Adds the specified <code>ChangeListener<\/code> to the progress bar.\n     *\n     * @param l the <code>ChangeListener<\/code> to add\n     */\n    public void addChangeListener(ChangeListener l) {\n        listenerList.add(ChangeListener.class, l);\n    }"}
{"Number":"1246","API Relative Path":"javax.swing.JProgressBar.java-JProgressBar(int-int-int)","Corresponding Source":"/**\n     * Creates a progress bar using the specified orientation,\n     * minimum, and maximum.\n     * By default, a border is painted but a progress string is not.\n     * Sets the initial value of the progress bar to the specified minimum.\n     * <p>\n     * The <code>BoundedRangeModel<\/code> that holds the progress bar's data\n     * handles any issues that may arise from improperly setting the\n     * minimum, initial, and maximum values on the progress bar.\n     * See the {@code BoundedRangeModel} documentation for details.\n     *\n     * @param orient  the desired orientation of the progress bar\n     * @param min  the minimum value of the progress bar\n     * @param max  the maximum value of the progress bar\n     * @throws IllegalArgumentException if {@code orient} is an illegal value\n     *\n     * @see BoundedRangeModel\n     * @see #setOrientation\n     * @see #setBorderPainted\n     * @see #setStringPainted\n     * @see #setString\n     * @see #setIndeterminate\n     */\n    public JProgressBar(int orient, int min, int max)\n    {\n        // Creating the model this way is a bit simplistic, but\n        //  I believe that it is the the most common usage of this\n        //  component - it's what people will expect.\n        setModel(new DefaultBoundedRangeModel(min, 0, min, max));\n        updateUI();\n\n        setOrientation(orient);      // documented with set/getOrientation()\n        setBorderPainted(true);      // documented with is/setBorderPainted()\n        setStringPainted(false);     // see setStringPainted\n        setString(null);             // see getString\n        setIndeterminate(false);     // see setIndeterminate\n    }"}
{"Number":"1247","API Relative Path":"javax.swing.JProgressBar.java-removeChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Removes a <code>ChangeListener<\/code> from the progress bar.\n     *\n     * @param l the <code>ChangeListener<\/code> to remove\n     */\n    public void removeChangeListener(ChangeListener l) {\n        listenerList.remove(ChangeListener.class, l);\n    }"}
{"Number":"1248","API Relative Path":"javax.swing.JRadioButton.java-JRadioButton(Action)","Corresponding Source":"/**\n     * Creates a radiobutton where properties are taken from the\n     * Action supplied.\n     *\n     * @since 1.3\n     */\n    public JRadioButton(Action a) {\n        this();\n        setAction(a);\n    }"}
{"Number":"1249","API Relative Path":"javax.swing.JRadioButtonMenuItem.java-JRadioButtonMenuItem(Action)","Corresponding Source":"/**\n     * Creates a radio button menu item whose properties are taken from the\n     * <code>Action<\/code> supplied.\n     *\n     * @param  a the <code>Action<\/code> on which to base the radio\n     *          button menu item\n     *\n     * @since 1.3\n     */\n    public JRadioButtonMenuItem(Action a) {\n        this();\n        setAction(a);\n    }"}
{"Number":"1250","API Relative Path":"javax.swing.JRootPane.java-setWindowDecorationStyle(int)","Corresponding Source":"/**\n     * Sets the type of Window decorations (such as borders, widgets for\n     * closing a Window, title ...) the <code>JRootPane<\/code> should\n     * provide. The default is to provide no Window decorations\n     * (<code>NONE<\/code>).\n     * <p>\n     * This is only a hint, and some look and feels may not support\n     * this.\n     * This is a bound property.\n     *\n     * @param windowDecorationStyle Constant identifying Window decorations\n     *        to provide.\n     * @see JDialog#setDefaultLookAndFeelDecorated\n     * @see JFrame#setDefaultLookAndFeelDecorated\n     * @see LookAndFeel#getSupportsWindowDecorations\n     * @throws IllegalArgumentException if <code>style<\/code> is\n     *        not one of: <code>NONE<\/code>, <code>FRAME<\/code>,\n     *        <code>PLAIN_DIALOG<\/code>, <code>INFORMATION_DIALOG<\/code>,\n     *        <code>ERROR_DIALOG<\/code>, <code>COLOR_CHOOSER_DIALOG<\/code>,\n     *        <code>FILE_CHOOSER_DIALOG<\/code>, <code>QUESTION_DIALOG<\/code>, or\n     *        <code>WARNING_DIALOG<\/code>.\n     * @since 1.4\n     * @beaninfo\n     *        bound: true\n     *         enum: NONE                   JRootPane.NONE\n     *               FRAME                  JRootPane.FRAME\n     *               PLAIN_DIALOG           JRootPane.PLAIN_DIALOG\n     *               INFORMATION_DIALOG     JRootPane.INFORMATION_DIALOG\n     *               ERROR_DIALOG           JRootPane.ERROR_DIALOG\n     *               COLOR_CHOOSER_DIALOG   JRootPane.COLOR_CHOOSER_DIALOG\n     *               FILE_CHOOSER_DIALOG    JRootPane.FILE_CHOOSER_DIALOG\n     *               QUESTION_DIALOG        JRootPane.QUESTION_DIALOG\n     *               WARNING_DIALOG         JRootPane.WARNING_DIALOG\n     *       expert: true\n     *    attribute: visualUpdate true\n     *  description: Identifies the type of Window decorations to provide\n     */\n    public void setWindowDecorationStyle(int windowDecorationStyle) {\n        if (windowDecorationStyle < 0 ||\n                  windowDecorationStyle > WARNING_DIALOG) {\n            throw new IllegalArgumentException(\"Invalid decoration style\");\n        }\n        int oldWindowDecorationStyle = getWindowDecorationStyle();\n        this.windowDecorationStyle = windowDecorationStyle;\n        firePropertyChange(\"windowDecorationStyle\",\n                            oldWindowDecorationStyle,\n                            windowDecorationStyle);\n    }"}
{"Number":"1251","API Relative Path":"javax.swing.JScrollBar.java-addAdjustmentListener(AdjustmentListener)","Corresponding Source":"/**\n     * Adds an AdjustmentListener.  Adjustment listeners are notified\n     * each time the scrollbar's model changes.  Adjustment events are\n     * provided for backwards compatibility with java.awt.Scrollbar.\n     * <p>\n     * Note that the AdjustmentEvents type property will always have a\n     * placeholder value of AdjustmentEvent.TRACK because all changes\n     * to a BoundedRangeModels value are considered equivalent.  To change\n     * the value of a BoundedRangeModel one just sets its value property,\n     * i.e. model.setValue(123).  No information about the origin of the\n     * change, e.g. it's a block decrement, is provided.  We don't try\n     * fabricate the origin of the change here.\n     *\n     * @param l the AdjustmentLister to add\n     * @see #removeAdjustmentListener\n     * @see BoundedRangeModel#addChangeListener\n     */\n    public void addAdjustmentListener(AdjustmentListener l)   {\n        listenerList.add(AdjustmentListener.class, l);\n    }"}
{"Number":"1252","API Relative Path":"javax.swing.JScrollBar.java-JScrollBar(int-int-int-int-int)","Corresponding Source":"/**\n     * Creates a scrollbar with the specified orientation,\n     * value, extent, minimum, and maximum.\n     * The \"extent\" is the size of the viewable area. It is also known\n     * as the \"visible amount\".\n     * <p>\n     * Note: Use <code>setBlockIncrement<\/code> to set the block\n     * increment to a size slightly smaller than the view's extent.\n     * That way, when the user jumps the knob to an adjacent position,\n     * one or two lines of the original contents remain in view.\n     *\n     * @exception IllegalArgumentException if orientation is not one of VERTICAL, HORIZONTAL\n     *\n     * @see #setOrientation\n     * @see #setValue\n     * @see #setVisibleAmount\n     * @see #setMinimum\n     * @see #setMaximum\n     */\n    public JScrollBar(int orientation, int value, int extent, int min, int max)\n    {\n        checkOrientation(orientation);\n        this.unitIncrement = 1;\n        this.blockIncrement = (extent == 0) ? 1 : extent;\n        this.orientation = orientation;\n        this.model = new DefaultBoundedRangeModel(value, extent, min, max);\n        this.model.addChangeListener(fwdAdjustmentEvents);\n        setRequestFocusEnabled(false);\n        updateUI();\n    }"}
{"Number":"1253","API Relative Path":"javax.swing.JScrollBar.java-removeAdjustmentListener(AdjustmentListener)","Corresponding Source":"/**\n     * Removes an AdjustmentEvent listener.\n     *\n     * @param l the AdjustmentLister to remove\n     * @see #addAdjustmentListener\n     */\n    public void removeAdjustmentListener(AdjustmentListener l)  {\n        listenerList.remove(AdjustmentListener.class, l);\n    }"}
{"Number":"1254","API Relative Path":"javax.swing.JScrollPane.java-setColumnHeader(JViewport)","Corresponding Source":"/**\n     * Removes the old columnHeader, if it exists; if the new columnHeader\n     * isn't <code>null<\/code>, syncs the x coordinate of its viewPosition\n     * with the viewport (if there is one) and then adds it to the scroll pane.\n     * <p>\n     * Most applications will find it more convenient to use\n     * <code>setColumnHeaderView<\/code>\n     * to add a column header component and its viewport to the scroll pane.\n     *\n     * @see #getColumnHeader\n     * @see #setColumnHeaderView\n     *\n     * @beaninfo\n     *        bound: true\n     *  description: The column header child for this scrollpane\n     *    attribute: visualUpdate true\n     */\n    public void setColumnHeader(JViewport columnHeader) {\n        JViewport old = getColumnHeader();\n        this.columnHeader = columnHeader;\n        if (columnHeader != null) {\n            add(columnHeader, COLUMN_HEADER);\n        }\n        else if (old != null) {\n            remove(old);\n        }\n        firePropertyChange(\"columnHeader\", old, columnHeader);\n\n        revalidate();\n        repaint();\n    }"}
{"Number":"1255","API Relative Path":"javax.swing.JScrollPane.java-setColumnHeader(JViewport)","Corresponding Source":"/**\n     * Removes the old columnHeader, if it exists; if the new columnHeader\n     * isn't <code>null<\/code>, syncs the x coordinate of its viewPosition\n     * with the viewport (if there is one) and then adds it to the scroll pane.\n     * <p>\n     * Most applications will find it more convenient to use\n     * <code>setColumnHeaderView<\/code>\n     * to add a column header component and its viewport to the scroll pane.\n     *\n     * @see #getColumnHeader\n     * @see #setColumnHeaderView\n     *\n     * @beaninfo\n     *        bound: true\n     *  description: The column header child for this scrollpane\n     *    attribute: visualUpdate true\n     */\n    public void setColumnHeader(JViewport columnHeader) {\n        JViewport old = getColumnHeader();\n        this.columnHeader = columnHeader;\n        if (columnHeader != null) {\n            add(columnHeader, COLUMN_HEADER);\n        }\n        else if (old != null) {\n            remove(old);\n        }\n        firePropertyChange(\"columnHeader\", old, columnHeader);\n\n        revalidate();\n        repaint();\n    }"}
{"Number":"1256","API Relative Path":"javax.swing.JScrollPane.java-setColumnHeaderView(Component)","Corresponding Source":"/**\n     * Creates a column-header viewport if necessary, sets\n     * its view, and then adds the column-header viewport\n     * to the scrollpane.  For example:\n     * <pre>\n     * JScrollPane scrollpane = new JScrollPane();\n     * scrollpane.setViewportView(myBigComponentToScroll);\n     * scrollpane.setColumnHeaderView(myBigComponentsColumnHeader);\n     * <\/pre>\n     *\n     * @see #setColumnHeader\n     * @see JViewport#setView\n     *\n     * @param view the component to display as the column header\n     */\n    public void setColumnHeaderView(Component view) {\n        if (getColumnHeader() == null) {\n            setColumnHeader(createViewport());\n        }\n        getColumnHeader().setView(view);\n    }"}
{"Number":"1257","API Relative Path":"javax.swing.JScrollPane.java-setColumnHeaderView(Component)","Corresponding Source":"/**\n     * Creates a column-header viewport if necessary, sets\n     * its view, and then adds the column-header viewport\n     * to the scrollpane.  For example:\n     * <pre>\n     * JScrollPane scrollpane = new JScrollPane();\n     * scrollpane.setViewportView(myBigComponentToScroll);\n     * scrollpane.setColumnHeaderView(myBigComponentsColumnHeader);\n     * <\/pre>\n     *\n     * @see #setColumnHeader\n     * @see JViewport#setView\n     *\n     * @param view the component to display as the column header\n     */\n    public void setColumnHeaderView(Component view) {\n        if (getColumnHeader() == null) {\n            setColumnHeader(createViewport());\n        }\n        getColumnHeader().setView(view);\n    }"}
{"Number":"1258","API Relative Path":"javax.swing.JScrollPane.java-setCorner(String-Component)","Corresponding Source":"/**\n     * Adds a child that will appear in one of the scroll panes\n     * corners, if there's room.   For example with both scrollbars\n     * showing (on the right and bottom edges of the scrollpane)\n     * the lower left corner component will be shown in the space\n     * between ends of the two scrollbars. Legal values for\n     * the <b>key<\/b> are:\n     * <ul>\n     * <li>ScrollPaneConstants.LOWER_LEFT_CORNER\n     * <li>ScrollPaneConstants.LOWER_RIGHT_CORNER\n     * <li>ScrollPaneConstants.UPPER_LEFT_CORNER\n     * <li>ScrollPaneConstants.UPPER_RIGHT_CORNER\n     * <li>ScrollPaneConstants.LOWER_LEADING_CORNER\n     * <li>ScrollPaneConstants.LOWER_TRAILING_CORNER\n     * <li>ScrollPaneConstants.UPPER_LEADING_CORNER\n     * <li>ScrollPaneConstants.UPPER_TRAILING_CORNER\n     * <\/ul>\n     * <p>\n     * Although \"corner\" doesn't match any beans property\n     * signature, <code>PropertyChange<\/code> events are generated with the\n     * property name set to the corner key.\n     *\n     * @param key identifies which corner the component will appear in\n     * @param corner one of the following components:\n     * <ul>\n     * <li>lowerLeft\n     * <li>lowerRight\n     * <li>upperLeft\n     * <li>upperRight\n     * <\/ul>\n     * @exception IllegalArgumentException if corner key is invalid\n     */\n    public void setCorner(String key, Component corner)\n    {\n        Component old;\n        boolean isLeftToRight = getComponentOrientation().isLeftToRight();\n        if (key.equals(LOWER_LEADING_CORNER)) {\n            key = isLeftToRight ? LOWER_LEFT_CORNER : LOWER_RIGHT_CORNER;\n        } else if (key.equals(LOWER_TRAILING_CORNER)) {\n            key = isLeftToRight ? LOWER_RIGHT_CORNER : LOWER_LEFT_CORNER;\n        } else if (key.equals(UPPER_LEADING_CORNER)) {\n            key = isLeftToRight ? UPPER_LEFT_CORNER : UPPER_RIGHT_CORNER;\n        } else if (key.equals(UPPER_TRAILING_CORNER)) {\n            key = isLeftToRight ? UPPER_RIGHT_CORNER : UPPER_LEFT_CORNER;\n        }\n        if (key.equals(LOWER_LEFT_CORNER)) {\n            old = lowerLeft;\n            lowerLeft = corner;\n        }\n        else if (key.equals(LOWER_RIGHT_CORNER)) {\n            old = lowerRight;\n            lowerRight = corner;\n        }\n        else if (key.equals(UPPER_LEFT_CORNER)) {\n            old = upperLeft;\n            upperLeft = corner;\n        }\n        else if (key.equals(UPPER_RIGHT_CORNER)) {\n            old = upperRight;\n            upperRight = corner;\n        }\n        else {\n            throw new IllegalArgumentException(\"invalid corner key\");\n        }\n        if (old != null) {\n            remove(old);\n        }\n        if (corner != null) {\n            add(corner, key);\n        }\n        firePropertyChange(key, old, corner);\n        revalidate();\n        repaint();\n    }"}
{"Number":"1259","API Relative Path":"javax.swing.JScrollPane.java-setCorner(String-Component)","Corresponding Source":"/**\n     * Adds a child that will appear in one of the scroll panes\n     * corners, if there's room.   For example with both scrollbars\n     * showing (on the right and bottom edges of the scrollpane)\n     * the lower left corner component will be shown in the space\n     * between ends of the two scrollbars. Legal values for\n     * the <b>key<\/b> are:\n     * <ul>\n     * <li>ScrollPaneConstants.LOWER_LEFT_CORNER\n     * <li>ScrollPaneConstants.LOWER_RIGHT_CORNER\n     * <li>ScrollPaneConstants.UPPER_LEFT_CORNER\n     * <li>ScrollPaneConstants.UPPER_RIGHT_CORNER\n     * <li>ScrollPaneConstants.LOWER_LEADING_CORNER\n     * <li>ScrollPaneConstants.LOWER_TRAILING_CORNER\n     * <li>ScrollPaneConstants.UPPER_LEADING_CORNER\n     * <li>ScrollPaneConstants.UPPER_TRAILING_CORNER\n     * <\/ul>\n     * <p>\n     * Although \"corner\" doesn't match any beans property\n     * signature, <code>PropertyChange<\/code> events are generated with the\n     * property name set to the corner key.\n     *\n     * @param key identifies which corner the component will appear in\n     * @param corner one of the following components:\n     * <ul>\n     * <li>lowerLeft\n     * <li>lowerRight\n     * <li>upperLeft\n     * <li>upperRight\n     * <\/ul>\n     * @exception IllegalArgumentException if corner key is invalid\n     */\n    public void setCorner(String key, Component corner)\n    {\n        Component old;\n        boolean isLeftToRight = getComponentOrientation().isLeftToRight();\n        if (key.equals(LOWER_LEADING_CORNER)) {\n            key = isLeftToRight ? LOWER_LEFT_CORNER : LOWER_RIGHT_CORNER;\n        } else if (key.equals(LOWER_TRAILING_CORNER)) {\n            key = isLeftToRight ? LOWER_RIGHT_CORNER : LOWER_LEFT_CORNER;\n        } else if (key.equals(UPPER_LEADING_CORNER)) {\n            key = isLeftToRight ? UPPER_LEFT_CORNER : UPPER_RIGHT_CORNER;\n        } else if (key.equals(UPPER_TRAILING_CORNER)) {\n            key = isLeftToRight ? UPPER_RIGHT_CORNER : UPPER_LEFT_CORNER;\n        }\n        if (key.equals(LOWER_LEFT_CORNER)) {\n            old = lowerLeft;\n            lowerLeft = corner;\n        }\n        else if (key.equals(LOWER_RIGHT_CORNER)) {\n            old = lowerRight;\n            lowerRight = corner;\n        }\n        else if (key.equals(UPPER_LEFT_CORNER)) {\n            old = upperLeft;\n            upperLeft = corner;\n        }\n        else if (key.equals(UPPER_RIGHT_CORNER)) {\n            old = upperRight;\n            upperRight = corner;\n        }\n        else {\n            throw new IllegalArgumentException(\"invalid corner key\");\n        }\n        if (old != null) {\n            remove(old);\n        }\n        if (corner != null) {\n            add(corner, key);\n        }\n        firePropertyChange(key, old, corner);\n        revalidate();\n        repaint();\n    }"}
{"Number":"1260","API Relative Path":"javax.swing.JScrollPane.java-setHorizontalScrollBar(JScrollBar)","Corresponding Source":"/**\n     * Adds the scrollbar that controls the viewport's horizontal view\n     * position to the scrollpane.\n     * This is usually unnecessary, as <code>JScrollPane<\/code> creates\n     * horizontal and vertical scrollbars by default.\n     *\n     * @param horizontalScrollBar the horizontal scrollbar to be added\n     * @see #createHorizontalScrollBar\n     * @see #getHorizontalScrollBar\n     *\n     * @beaninfo\n     *        expert: true\n     *         bound: true\n     *   description: The horizontal scrollbar.\n     */\n    public void setHorizontalScrollBar(JScrollBar horizontalScrollBar) {\n        JScrollBar old = getHorizontalScrollBar();\n        this.horizontalScrollBar = horizontalScrollBar;\n        if (horizontalScrollBar != null) {\n            add(horizontalScrollBar, HORIZONTAL_SCROLLBAR);\n        }\n        else if (old != null) {\n            remove(old);\n        }\n        firePropertyChange(\"horizontalScrollBar\", old, horizontalScrollBar);\n\n        revalidate();\n        repaint();\n    }"}
{"Number":"1261","API Relative Path":"javax.swing.JScrollPane.java-setHorizontalScrollBar(JScrollBar)","Corresponding Source":"/**\n     * Adds the scrollbar that controls the viewport's horizontal view\n     * position to the scrollpane.\n     * This is usually unnecessary, as <code>JScrollPane<\/code> creates\n     * horizontal and vertical scrollbars by default.\n     *\n     * @param horizontalScrollBar the horizontal scrollbar to be added\n     * @see #createHorizontalScrollBar\n     * @see #getHorizontalScrollBar\n     *\n     * @beaninfo\n     *        expert: true\n     *         bound: true\n     *   description: The horizontal scrollbar.\n     */\n    public void setHorizontalScrollBar(JScrollBar horizontalScrollBar) {\n        JScrollBar old = getHorizontalScrollBar();\n        this.horizontalScrollBar = horizontalScrollBar;\n        if (horizontalScrollBar != null) {\n            add(horizontalScrollBar, HORIZONTAL_SCROLLBAR);\n        }\n        else if (old != null) {\n            remove(old);\n        }\n        firePropertyChange(\"horizontalScrollBar\", old, horizontalScrollBar);\n\n        revalidate();\n        repaint();\n    }"}
{"Number":"1262","API Relative Path":"javax.swing.JScrollPane.java-setLayout(LayoutManager)","Corresponding Source":"/**\n     * Sets the layout manager for this <code>JScrollPane<\/code>.\n     * This method overrides <code>setLayout<\/code> in\n     * <code>java.awt.Container<\/code> to ensure that only\n     * <code>LayoutManager<\/code>s which\n     * are subclasses of <code>ScrollPaneLayout<\/code> can be used in a\n     * <code>JScrollPane<\/code>. If <code>layout<\/code> is non-null, this\n     * will invoke <code>syncWithScrollPane<\/code> on it.\n     *\n     * @param layout the specified layout manager\n     * @exception ClassCastException if layout is not a\n     *                  <code>ScrollPaneLayout<\/code>\n     * @see java.awt.Container#getLayout\n     * @see java.awt.Container#setLayout\n     *\n     * @beaninfo\n     *    hidden: true\n     */\n    public void setLayout(LayoutManager layout) {\n        if (layout instanceof ScrollPaneLayout) {\n            super.setLayout(layout);\n            ((ScrollPaneLayout)layout).syncWithScrollPane(this);\n        }\n        else if (layout == null) {\n            super.setLayout(layout);\n        }\n        else {\n            String s = \"layout of JScrollPane must be a ScrollPaneLayout\";\n            throw new ClassCastException(s);\n        }\n    }"}
{"Number":"1263","API Relative Path":"javax.swing.JScrollPane.java-setRowHeader(JViewport)","Corresponding Source":"/**\n     * Removes the old rowHeader, if it exists; if the new rowHeader\n     * isn't <code>null<\/code>, syncs the y coordinate of its\n     * viewPosition with\n     * the viewport (if there is one) and then adds it to the scroll pane.\n     * <p>\n     * Most applications will find it more convenient to use\n     * <code>setRowHeaderView<\/code>\n     * to add a row header component and its viewport to the scroll pane.\n     *\n     * @param rowHeader the new row header to be used; if <code>null<\/code>\n     *          the old row header is still removed and the new rowHeader\n     *          is set to <code>null<\/code>\n     * @see #getRowHeader\n     * @see #setRowHeaderView\n     *\n     * @beaninfo\n     *        bound: true\n     *       expert: true\n     *  description: The row header child for this scrollpane\n     */\n    public void setRowHeader(JViewport rowHeader) {\n        JViewport old = getRowHeader();\n        this.rowHeader = rowHeader;\n        if (rowHeader != null) {\n            add(rowHeader, ROW_HEADER);\n        }\n        else if (old != null) {\n            remove(old);\n        }\n        firePropertyChange(\"rowHeader\", old, rowHeader);\n        revalidate();\n        repaint();\n    }"}
{"Number":"1264","API Relative Path":"javax.swing.JScrollPane.java-setRowHeader(JViewport)","Corresponding Source":"/**\n     * Removes the old rowHeader, if it exists; if the new rowHeader\n     * isn't <code>null<\/code>, syncs the y coordinate of its\n     * viewPosition with\n     * the viewport (if there is one) and then adds it to the scroll pane.\n     * <p>\n     * Most applications will find it more convenient to use\n     * <code>setRowHeaderView<\/code>\n     * to add a row header component and its viewport to the scroll pane.\n     *\n     * @param rowHeader the new row header to be used; if <code>null<\/code>\n     *          the old row header is still removed and the new rowHeader\n     *          is set to <code>null<\/code>\n     * @see #getRowHeader\n     * @see #setRowHeaderView\n     *\n     * @beaninfo\n     *        bound: true\n     *       expert: true\n     *  description: The row header child for this scrollpane\n     */\n    public void setRowHeader(JViewport rowHeader) {\n        JViewport old = getRowHeader();\n        this.rowHeader = rowHeader;\n        if (rowHeader != null) {\n            add(rowHeader, ROW_HEADER);\n        }\n        else if (old != null) {\n            remove(old);\n        }\n        firePropertyChange(\"rowHeader\", old, rowHeader);\n        revalidate();\n        repaint();\n    }"}
{"Number":"1265","API Relative Path":"javax.swing.JScrollPane.java-setRowHeaderView(Component)","Corresponding Source":"/**\n     * Creates a row-header viewport if necessary, sets\n     * its view and then adds the row-header viewport\n     * to the scrollpane.  For example:\n     * <pre>\n     * JScrollPane scrollpane = new JScrollPane();\n     * scrollpane.setViewportView(myBigComponentToScroll);\n     * scrollpane.setRowHeaderView(myBigComponentsRowHeader);\n     * <\/pre>\n     *\n     * @see #setRowHeader\n     * @see JViewport#setView\n     * @param view the component to display as the row header\n     */\n    public void setRowHeaderView(Component view) {\n        if (getRowHeader() == null) {\n            setRowHeader(createViewport());\n        }\n        getRowHeader().setView(view);\n    }"}
{"Number":"1266","API Relative Path":"javax.swing.JScrollPane.java-setRowHeaderView(Component)","Corresponding Source":"/**\n     * Creates a row-header viewport if necessary, sets\n     * its view and then adds the row-header viewport\n     * to the scrollpane.  For example:\n     * <pre>\n     * JScrollPane scrollpane = new JScrollPane();\n     * scrollpane.setViewportView(myBigComponentToScroll);\n     * scrollpane.setRowHeaderView(myBigComponentsRowHeader);\n     * <\/pre>\n     *\n     * @see #setRowHeader\n     * @see JViewport#setView\n     * @param view the component to display as the row header\n     */\n    public void setRowHeaderView(Component view) {\n        if (getRowHeader() == null) {\n            setRowHeader(createViewport());\n        }\n        getRowHeader().setView(view);\n    }"}
{"Number":"1267","API Relative Path":"javax.swing.JScrollPane.java-setVerticalScrollBar(JScrollBar)","Corresponding Source":"/**\n     * Adds the scrollbar that controls the viewports vertical view position\n     * to the scrollpane.  This is usually unnecessary,\n     * as <code>JScrollPane<\/code> creates vertical and\n     * horizontal scrollbars by default.\n     *\n     * @param verticalScrollBar the new vertical scrollbar to be added\n     * @see #createVerticalScrollBar\n     * @see #getVerticalScrollBar\n     *\n     * @beaninfo\n     *        expert: true\n     *         bound: true\n     *   description: The vertical scrollbar.\n     */\n    public void setVerticalScrollBar(JScrollBar verticalScrollBar) {\n        JScrollBar old = getVerticalScrollBar();\n        this.verticalScrollBar = verticalScrollBar;\n        add(verticalScrollBar, VERTICAL_SCROLLBAR);\n        firePropertyChange(\"verticalScrollBar\", old, verticalScrollBar);\n\n        revalidate();\n        repaint();\n    }"}
{"Number":"1268","API Relative Path":"javax.swing.JScrollPane.java-setVerticalScrollBar(JScrollBar)","Corresponding Source":"/**\n     * Adds the scrollbar that controls the viewports vertical view position\n     * to the scrollpane.  This is usually unnecessary,\n     * as <code>JScrollPane<\/code> creates vertical and\n     * horizontal scrollbars by default.\n     *\n     * @param verticalScrollBar the new vertical scrollbar to be added\n     * @see #createVerticalScrollBar\n     * @see #getVerticalScrollBar\n     *\n     * @beaninfo\n     *        expert: true\n     *         bound: true\n     *   description: The vertical scrollbar.\n     */\n    public void setVerticalScrollBar(JScrollBar verticalScrollBar) {\n        JScrollBar old = getVerticalScrollBar();\n        this.verticalScrollBar = verticalScrollBar;\n        add(verticalScrollBar, VERTICAL_SCROLLBAR);\n        firePropertyChange(\"verticalScrollBar\", old, verticalScrollBar);\n\n        revalidate();\n        repaint();\n    }"}
{"Number":"1269","API Relative Path":"javax.swing.JScrollPane.java-setViewport(JViewport)","Corresponding Source":"/**\n     * Removes the old viewport (if there is one); forces the\n     * viewPosition of the new viewport to be in the +x,+y quadrant;\n     * syncs up the row and column headers (if there are any) with the\n     * new viewport; and finally syncs the scrollbars and\n     * headers with the new viewport.\n     * <p>\n     * Most applications will find it more convenient to use\n     * <code>setViewportView<\/code>\n     * to add a viewport and a view to the scrollpane.\n     *\n     * @param viewport the new viewport to be used; if viewport is\n     *          <code>null<\/code>, the old viewport is still removed\n     *          and the new viewport is set to <code>null<\/code>\n     * @see #createViewport\n     * @see #getViewport\n     * @see #setViewportView\n     *\n     * @beaninfo\n     *       expert: true\n     *        bound: true\n     *    attribute: visualUpdate true\n     *  description: The viewport child for this scrollpane\n     *\n     */\n    public void setViewport(JViewport viewport) {\n        JViewport old = getViewport();\n        this.viewport = viewport;\n        if (viewport != null) {\n            add(viewport, VIEWPORT);\n        }\n        else if (old != null) {\n            remove(old);\n        }\n        firePropertyChange(\"viewport\", old, viewport);\n\n        if (accessibleContext != null) {\n            ((AccessibleJScrollPane)accessibleContext).resetViewPort();\n        }\n\n        revalidate();\n        repaint();\n    }"}
{"Number":"1270","API Relative Path":"javax.swing.JScrollPane.java-setViewport(JViewport)","Corresponding Source":"/**\n     * Removes the old viewport (if there is one); forces the\n     * viewPosition of the new viewport to be in the +x,+y quadrant;\n     * syncs up the row and column headers (if there are any) with the\n     * new viewport; and finally syncs the scrollbars and\n     * headers with the new viewport.\n     * <p>\n     * Most applications will find it more convenient to use\n     * <code>setViewportView<\/code>\n     * to add a viewport and a view to the scrollpane.\n     *\n     * @param viewport the new viewport to be used; if viewport is\n     *          <code>null<\/code>, the old viewport is still removed\n     *          and the new viewport is set to <code>null<\/code>\n     * @see #createViewport\n     * @see #getViewport\n     * @see #setViewportView\n     *\n     * @beaninfo\n     *       expert: true\n     *        bound: true\n     *    attribute: visualUpdate true\n     *  description: The viewport child for this scrollpane\n     *\n     */\n    public void setViewport(JViewport viewport) {\n        JViewport old = getViewport();\n        this.viewport = viewport;\n        if (viewport != null) {\n            add(viewport, VIEWPORT);\n        }\n        else if (old != null) {\n            remove(old);\n        }\n        firePropertyChange(\"viewport\", old, viewport);\n\n        if (accessibleContext != null) {\n            ((AccessibleJScrollPane)accessibleContext).resetViewPort();\n        }\n\n        revalidate();\n        repaint();\n    }"}
{"Number":"1271","API Relative Path":"javax.swing.JScrollPane.java-setViewportView(Component)","Corresponding Source":"/**\n     * Creates a viewport if necessary and then sets its view.  Applications\n     * that don't provide the view directly to the <code>JScrollPane<\/code>\n     * constructor\n     * should use this method to specify the scrollable child that's going\n     * to be displayed in the scrollpane. For example:\n     * <pre>\n     * JScrollPane scrollpane = new JScrollPane();\n     * scrollpane.setViewportView(myBigComponentToScroll);\n     * <\/pre>\n     * Applications should not add children directly to the scrollpane.\n     *\n     * @param view the component to add to the viewport\n     * @see #setViewport\n     * @see JViewport#setView\n     */\n    public void setViewportView(Component view) {\n        if (getViewport() == null) {\n            setViewport(createViewport());\n        }\n        getViewport().setView(view);\n    }"}
{"Number":"1272","API Relative Path":"javax.swing.JScrollPane.java-setViewportView(Component)","Corresponding Source":"/**\n     * Creates a viewport if necessary and then sets its view.  Applications\n     * that don't provide the view directly to the <code>JScrollPane<\/code>\n     * constructor\n     * should use this method to specify the scrollable child that's going\n     * to be displayed in the scrollpane. For example:\n     * <pre>\n     * JScrollPane scrollpane = new JScrollPane();\n     * scrollpane.setViewportView(myBigComponentToScroll);\n     * <\/pre>\n     * Applications should not add children directly to the scrollpane.\n     *\n     * @param view the component to add to the viewport\n     * @see #setViewport\n     * @see JViewport#setView\n     */\n    public void setViewportView(Component view) {\n        if (getViewport() == null) {\n            setViewport(createViewport());\n        }\n        getViewport().setView(view);\n    }"}
{"Number":"1273","API Relative Path":"javax.swing.JSlider.java-addChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Adds a ChangeListener to the slider.\n     *\n     * @param l the ChangeListener to add\n     * @see #fireStateChanged\n     * @see #removeChangeListener\n     */\n    public void addChangeListener(ChangeListener l) {\n        listenerList.add(ChangeListener.class, l);\n    }"}
{"Number":"1274","API Relative Path":"javax.swing.JSlider.java-JSlider(int-int-int-int)","Corresponding Source":"/**\n     * Creates a slider with the specified orientation and the\n     * specified minimum, maximum, and initial values.\n     * The orientation can be\n     * either <code>SwingConstants.VERTICAL<\/code> or\n     * <code>SwingConstants.HORIZONTAL<\/code>.\n     * <p>\n     * The <code>BoundedRangeModel<\/code> that holds the slider's data\n     * handles any issues that may arise from improperly setting the\n     * minimum, initial, and maximum values on the slider.  See the\n     * {@code BoundedRangeModel} documentation for details.\n     *\n     * @param orientation  the orientation of the slider\n     * @param min  the minimum value of the slider\n     * @param max  the maximum value of the slider\n     * @param value  the initial value of the slider\n     *\n     * @throws IllegalArgumentException if orientation is not one of {@code VERTICAL}, {@code HORIZONTAL}\n     *\n     * @see BoundedRangeModel\n     * @see #setOrientation\n     * @see #setMinimum\n     * @see #setMaximum\n     * @see #setValue\n     */\n    public JSlider(int orientation, int min, int max, int value)\n    {\n        checkOrientation(orientation);\n        this.orientation = orientation;\n        setModel(new DefaultBoundedRangeModel(value, 0, min, max));\n        updateUI();\n    }"}
{"Number":"1275","API Relative Path":"javax.swing.JSlider.java-removeChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Removes a ChangeListener from the slider.\n     *\n     * @param l the ChangeListener to remove\n     * @see #fireStateChanged\n     * @see #addChangeListener\n\n     */\n    public void removeChangeListener(ChangeListener l) {\n        listenerList.remove(ChangeListener.class, l);\n    }"}
{"Number":"1276","API Relative Path":"javax.swing.JSpinner.java-addChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Adds a listener to the list that is notified each time a change\n     * to the model occurs.  The source of <code>ChangeEvents<\/code>\n     * delivered to <code>ChangeListeners<\/code> will be this\n     * <code>JSpinner<\/code>.  Note also that replacing the model\n     * will not affect listeners added directly to JSpinner.\n     * Applications can add listeners to  the model directly.  In that\n     * case is that the source of the event would be the\n     * <code>SpinnerModel<\/code>.\n     *\n     * @param listener the <code>ChangeListener<\/code> to add\n     * @see #removeChangeListener\n     * @see #getModel\n     */\n    public void addChangeListener(ChangeListener listener) {\n        if (modelListener == null) {\n            modelListener = new ModelListener();\n            getModel().addChangeListener(modelListener);\n        }\n        listenerList.add(ChangeListener.class, listener);\n    }"}
{"Number":"1277","API Relative Path":"javax.swing.JSpinner.java-removeChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Removes a <code>ChangeListener<\/code> from this spinner.\n     *\n     * @param listener the <code>ChangeListener<\/code> to remove\n     * @see #fireStateChanged\n     * @see #addChangeListener\n     */\n    public void removeChangeListener(ChangeListener listener) {\n        listenerList.remove(ChangeListener.class, listener);\n    }"}
{"Number":"1278","API Relative Path":"javax.swing.JSplitPane.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified component to this split pane.\n     * If <code>constraints<\/code> identifies the left/top or\n     * right/bottom child component, and a component with that identifier\n     * was previously added, it will be removed and then <code>comp<\/code>\n     * will be added in its place. If <code>constraints<\/code> is not\n     * one of the known identifiers the layout manager may throw an\n     * <code>IllegalArgumentException<\/code>.\n     * <p>\n     * The possible constraints objects (Strings) are:\n     * <ul>\n     * <li>JSplitPane.TOP\n     * <li>JSplitPane.LEFT\n     * <li>JSplitPane.BOTTOM\n     * <li>JSplitPane.RIGHT\n     * <\/ul>\n     * If the <code>constraints<\/code> object is <code>null<\/code>,\n     * the component is added in the\n     * first available position (left/top if open, else right/bottom).\n     *\n     * @param comp        the component to add\n     * @param constraints an <code>Object<\/code> specifying the\n     *                    layout constraints\n     *                    (position) for this component\n     * @param index       an integer specifying the index in the container's\n     *                    list.\n     * @exception IllegalArgumentException  if the <code>constraints<\/code>\n     *          object does not match an existing component\n     * @see java.awt.Container#addImpl(Component, Object, int)\n     */\n    protected void addImpl(Component comp, Object constraints, int index)\n    {\n        Component             toRemove;\n\n        if (constraints != null && !(constraints instanceof String)) {\n            throw new IllegalArgumentException(\"cannot add to layout: \" +\n                                               \"constraint must be a string \" +\n                                               \"(or null)\");\n        }\n\n        /* If the constraints are null and the left/right component is\n           invalid, add it at the left/right component. */\n        if (constraints == null) {\n            if (getLeftComponent() == null) {\n                constraints = JSplitPane.LEFT;\n            } else if (getRightComponent() == null) {\n                constraints = JSplitPane.RIGHT;\n            }\n        }\n\n        /* Find the Component that already exists and remove it. */\n        if (constraints != null && (constraints.equals(JSplitPane.LEFT) ||\n                                   constraints.equals(JSplitPane.TOP))) {\n            toRemove = getLeftComponent();\n            if (toRemove != null) {\n                remove(toRemove);\n            }\n            leftComponent = comp;\n            index = -1;\n        } else if (constraints != null &&\n                   (constraints.equals(JSplitPane.RIGHT) ||\n                    constraints.equals(JSplitPane.BOTTOM))) {\n            toRemove = getRightComponent();\n            if (toRemove != null) {\n                remove(toRemove);\n            }\n            rightComponent = comp;\n            index = -1;\n        } else if (constraints != null &&\n                constraints.equals(JSplitPane.DIVIDER)) {\n            index = -1;\n        }\n        /* LayoutManager should raise for else condition here. */\n\n        super.addImpl(comp, constraints, index);\n\n        // Update the JSplitPane on the screen\n        revalidate();\n        repaint();\n    }"}
{"Number":"1279","API Relative Path":"javax.swing.JSplitPane.java-setDividerLocation(double)","Corresponding Source":"/**\n     * Sets the divider location as a percentage of the\n     * <code>JSplitPane<\/code>'s size.\n     * <p>\n     * This method is implemented in terms of\n     * <code>setDividerLocation(int)<\/code>.\n     * This method immediately changes the size of the split pane based on\n     * its current size. If the split pane is not correctly realized and on\n     * screen, this method will have no effect (new divider location will\n     * become (current size * proportionalLocation) which is 0).\n     *\n     * @param proportionalLocation  a double-precision floating point value\n     *        that specifies a percentage, from zero (top/left) to 1.0\n     *        (bottom/right)\n     * @exception IllegalArgumentException if the specified location is &lt; 0\n     *            or &gt; 1.0\n     * @beaninfo\n     *  description: The location of the divider.\n     */\n    public void setDividerLocation(double proportionalLocation) {\n        if (proportionalLocation < 0.0 ||\n           proportionalLocation > 1.0) {\n            throw new IllegalArgumentException(\"proportional location must \" +\n                                               \"be between 0.0 and 1.0.\");\n        }\n        if (getOrientation() == VERTICAL_SPLIT) {\n            setDividerLocation((int)((double)(getHeight() - getDividerSize()) *\n                                     proportionalLocation));\n        } else {\n            setDividerLocation((int)((double)(getWidth() - getDividerSize()) *\n                                     proportionalLocation));\n        }\n    }"}
{"Number":"1280","API Relative Path":"javax.swing.JSplitPane.java-setLeftComponent(Component)","Corresponding Source":"/**\n     * Sets the component to the left (or above) the divider.\n     *\n     * @param comp the <code>Component<\/code> to display in that position\n     */\n    public void setLeftComponent(Component comp) {\n        if (comp == null) {\n            if (leftComponent != null) {\n                remove(leftComponent);\n                leftComponent = null;\n            }\n        } else {\n            add(comp, JSplitPane.LEFT);\n        }\n    }"}
{"Number":"1281","API Relative Path":"javax.swing.JSplitPane.java-setLeftComponent(Component)","Corresponding Source":"/**\n     * Sets the component to the left (or above) the divider.\n     *\n     * @param comp the <code>Component<\/code> to display in that position\n     */\n    public void setLeftComponent(Component comp) {\n        if (comp == null) {\n            if (leftComponent != null) {\n                remove(leftComponent);\n                leftComponent = null;\n            }\n        } else {\n            add(comp, JSplitPane.LEFT);\n        }\n    }"}
{"Number":"1282","API Relative Path":"javax.swing.JSplitPane.java-setRightComponent(Component)","Corresponding Source":"/**\n     * Sets the component to the right (or below) the divider.\n     *\n     * @param comp the <code>Component<\/code> to display in that position\n     * @beaninfo\n     *    preferred: true\n     *  description: The component to the right (or below) the divider.\n     */\n    public void setRightComponent(Component comp) {\n        if (comp == null) {\n            if (rightComponent != null) {\n                remove(rightComponent);\n                rightComponent = null;\n            }\n        } else {\n            add(comp, JSplitPane.RIGHT);\n        }\n    }"}
{"Number":"1283","API Relative Path":"javax.swing.JSplitPane.java-setRightComponent(Component)","Corresponding Source":"/**\n     * Sets the component to the right (or below) the divider.\n     *\n     * @param comp the <code>Component<\/code> to display in that position\n     * @beaninfo\n     *    preferred: true\n     *  description: The component to the right (or below) the divider.\n     */\n    public void setRightComponent(Component comp) {\n        if (comp == null) {\n            if (rightComponent != null) {\n                remove(rightComponent);\n                rightComponent = null;\n            }\n        } else {\n            add(comp, JSplitPane.RIGHT);\n        }\n    }"}
{"Number":"1284","API Relative Path":"javax.swing.JTabbedPane.java-add(Component-int)","Corresponding Source":"/**\n     * Adds a <code>component<\/code> at the specified tab index with a tab\n     * title defaulting to the name of the component.\n     * Cover method for <code>insertTab<\/code>.\n     *\n     * @param component the component to be displayed when this tab is clicked\n     * @param index the position to insert this new tab\n     * @return the component\n     *\n     * @see #insertTab\n     * @see #removeTabAt\n     */\n    public Component add(Component component, int index) {\n        if (!(component instanceof UIResource)) {\n            // Container.add() interprets -1 as \"append\", so convert\n            // the index appropriately to be handled by the vector\n            insertTab(component.getName(), null, component, null,\n                      index == -1? getTabCount() : index);\n        } else {\n            super.add(component, index);\n        }\n        return component;\n    }"}
{"Number":"1285","API Relative Path":"javax.swing.JTabbedPane.java-add(Component-int)","Corresponding Source":"/**\n     * Adds a <code>component<\/code> at the specified tab index with a tab\n     * title defaulting to the name of the component.\n     * Cover method for <code>insertTab<\/code>.\n     *\n     * @param component the component to be displayed when this tab is clicked\n     * @param index the position to insert this new tab\n     * @return the component\n     *\n     * @see #insertTab\n     * @see #removeTabAt\n     */\n    public Component add(Component component, int index) {\n        if (!(component instanceof UIResource)) {\n            // Container.add() interprets -1 as \"append\", so convert\n            // the index appropriately to be handled by the vector\n            insertTab(component.getName(), null, component, null,\n                      index == -1? getTabCount() : index);\n        } else {\n            super.add(component, index);\n        }\n        return component;\n    }"}
{"Number":"1286","API Relative Path":"javax.swing.JTabbedPane.java-add(Component-Object-int)","Corresponding Source":"/**\n     * Adds a <code>component<\/code> at the specified tab index.\n     * If <code>constraints<\/code> is a <code>String<\/code> or an\n     * <code>Icon<\/code>, it will be used for the tab title,\n     * otherwise the component's name will be used as the tab title.\n     * Cover method for <code>insertTab<\/code>.\n     *\n     * @param component the component to be displayed when this tab is clicked\n     * @param constraints the object to be displayed in the tab\n     * @param index the position to insert this new tab\n     *\n     * @see #insertTab\n     * @see #removeTabAt\n     */\n    public void add(Component component, Object constraints, int index) {\n        if (!(component instanceof UIResource)) {\n\n            Icon icon = constraints instanceof Icon? (Icon)constraints : null;\n            String title = constraints instanceof String? (String)constraints : null;\n            // Container.add() interprets -1 as \"append\", so convert\n            // the index appropriately to be handled by the vector\n            insertTab(title, icon, component, null, index == -1? getTabCount() : index);\n        } else {\n            super.add(component, constraints, index);\n        }\n    }"}
{"Number":"1287","API Relative Path":"javax.swing.JTabbedPane.java-add(Component-Object-int)","Corresponding Source":"/**\n     * Adds a <code>component<\/code> at the specified tab index.\n     * If <code>constraints<\/code> is a <code>String<\/code> or an\n     * <code>Icon<\/code>, it will be used for the tab title,\n     * otherwise the component's name will be used as the tab title.\n     * Cover method for <code>insertTab<\/code>.\n     *\n     * @param component the component to be displayed when this tab is clicked\n     * @param constraints the object to be displayed in the tab\n     * @param index the position to insert this new tab\n     *\n     * @see #insertTab\n     * @see #removeTabAt\n     */\n    public void add(Component component, Object constraints, int index) {\n        if (!(component instanceof UIResource)) {\n\n            Icon icon = constraints instanceof Icon? (Icon)constraints : null;\n            String title = constraints instanceof String? (String)constraints : null;\n            // Container.add() interprets -1 as \"append\", so convert\n            // the index appropriately to be handled by the vector\n            insertTab(title, icon, component, null, index == -1? getTabCount() : index);\n        } else {\n            super.add(component, constraints, index);\n        }\n    }"}
{"Number":"1288","API Relative Path":"javax.swing.JTabbedPane.java-addChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Adds a <code>ChangeListener<\/code> to this tabbedpane.\n     *\n     * @param l the <code>ChangeListener<\/code> to add\n     * @see #fireStateChanged\n     * @see #removeChangeListener\n     */\n    public void addChangeListener(ChangeListener l) {\n        listenerList.add(ChangeListener.class, l);\n    }"}
{"Number":"1289","API Relative Path":"javax.swing.JTabbedPane.java-addTab(String-Component)","Corresponding Source":"/**\n     * Adds a <code>component<\/code> represented by a <code>title<\/code>\n     * and no icon.\n     * Cover method for <code>insertTab<\/code>.\n     *\n     * @param title the title to be displayed in this tab\n     * @param component the component to be displayed when this tab is clicked\n     *\n     * @see #insertTab\n     * @see #removeTabAt\n     */\n    public void addTab(String title, Component component) {\n        insertTab(title, null, component, null, pages.size());\n    }"}
{"Number":"1290","API Relative Path":"javax.swing.JTabbedPane.java-addTab(String-Component)","Corresponding Source":"/**\n     * Adds a <code>component<\/code> represented by a <code>title<\/code>\n     * and no icon.\n     * Cover method for <code>insertTab<\/code>.\n     *\n     * @param title the title to be displayed in this tab\n     * @param component the component to be displayed when this tab is clicked\n     *\n     * @see #insertTab\n     * @see #removeTabAt\n     */\n    public void addTab(String title, Component component) {\n        insertTab(title, null, component, null, pages.size());\n    }"}
{"Number":"1291","API Relative Path":"javax.swing.JTabbedPane.java-addTab(String-Icon-Component)","Corresponding Source":"/**\n     * Adds a <code>component<\/code> represented by a <code>title<\/code>\n     * and/or <code>icon<\/code>, either of which can be <code>null<\/code>.\n     * Cover method for <code>insertTab<\/code>.\n     *\n     * @param title the title to be displayed in this tab\n     * @param icon the icon to be displayed in this tab\n     * @param component the component to be displayed when this tab is clicked\n     *\n     * @see #insertTab\n     * @see #removeTabAt\n     */\n    public void addTab(String title, Icon icon, Component component) {\n        insertTab(title, icon, component, null, pages.size());\n    }"}
{"Number":"1292","API Relative Path":"javax.swing.JTabbedPane.java-addTab(String-Icon-Component)","Corresponding Source":"/**\n     * Adds a <code>component<\/code> represented by a <code>title<\/code>\n     * and/or <code>icon<\/code>, either of which can be <code>null<\/code>.\n     * Cover method for <code>insertTab<\/code>.\n     *\n     * @param title the title to be displayed in this tab\n     * @param icon the icon to be displayed in this tab\n     * @param component the component to be displayed when this tab is clicked\n     *\n     * @see #insertTab\n     * @see #removeTabAt\n     */\n    public void addTab(String title, Icon icon, Component component) {\n        insertTab(title, icon, component, null, pages.size());\n    }"}
{"Number":"1293","API Relative Path":"javax.swing.JTabbedPane.java-addTab(String-Icon-Component-String)","Corresponding Source":"/**\n     * Adds a <code>component<\/code> and <code>tip<\/code>\n     * represented by a <code>title<\/code> and/or <code>icon<\/code>,\n     * either of which can be <code>null<\/code>.\n     * Cover method for <code>insertTab<\/code>.\n     *\n     * @param title the title to be displayed in this tab\n     * @param icon the icon to be displayed in this tab\n     * @param component the component to be displayed when this tab is clicked\n     * @param tip the tooltip to be displayed for this tab\n     *\n     * @see #insertTab\n     * @see #removeTabAt\n     */\n    public void addTab(String title, Icon icon, Component component, String tip) {\n        insertTab(title, icon, component, tip, pages.size());\n    }"}
{"Number":"1294","API Relative Path":"javax.swing.JTabbedPane.java-addTab(String-Icon-Component-String)","Corresponding Source":"/**\n     * Adds a <code>component<\/code> and <code>tip<\/code>\n     * represented by a <code>title<\/code> and/or <code>icon<\/code>,\n     * either of which can be <code>null<\/code>.\n     * Cover method for <code>insertTab<\/code>.\n     *\n     * @param title the title to be displayed in this tab\n     * @param icon the icon to be displayed in this tab\n     * @param component the component to be displayed when this tab is clicked\n     * @param tip the tooltip to be displayed for this tab\n     *\n     * @see #insertTab\n     * @see #removeTabAt\n     */\n    public void addTab(String title, Icon icon, Component component, String tip) {\n        insertTab(title, icon, component, tip, pages.size());\n    }"}
{"Number":"1295","API Relative Path":"javax.swing.JTabbedPane.java-getBoundsAt(int)","Corresponding Source":"/**\n     * Returns the tab bounds at <code>index<\/code>.  If the tab at\n     * this index is not currently visible in the UI, then returns\n     * <code>null<\/code>.\n     * If there is no UI set on this <code>tabbedpane<\/code>,\n     * then returns <code>null<\/code>.\n     *\n     * @param index the index to be queried\n     * @return a <code>Rectangle<\/code> containing the tab bounds at\n     *          <code>index<\/code>, or <code>null<\/code> if tab at\n     *          <code>index<\/code> is not currently visible in the UI,\n     *          or if there is no UI set on this <code>tabbedpane<\/code>\n     * @exception IndexOutOfBoundsException if index is out of range\n     *            {@code (index < 0 || index >= tab count)}\n     */\n    public Rectangle getBoundsAt(int index) {\n        checkIndex(index);\n        if (ui != null) {\n            return ((TabbedPaneUI)ui).getTabBounds(this, index);\n        }\n        return null;\n    }"}
{"Number":"1296","API Relative Path":"javax.swing.JTabbedPane.java-getDisplayedMnemonicIndexAt(int)","Corresponding Source":"/**\n     * Returns the character, as an index, that the look and feel should\n     * provide decoration for as representing the mnemonic character.\n     *\n     * @since 1.4\n     * @param tabIndex the index of the tab that the mnemonic refers to\n     * @return index representing mnemonic character if one exists;\n     *    otherwise returns -1\n     * @exception IndexOutOfBoundsException if index is out of range\n     *            (<code>tabIndex<\/code> &lt; 0 ||\n     *              <code>tabIndex<\/code> &gt;= tab count)\n     * @see #setDisplayedMnemonicIndexAt(int,int)\n     * @see #setMnemonicAt(int,int)\n     */\n    public int getDisplayedMnemonicIndexAt(int tabIndex) {\n        checkIndex(tabIndex);\n\n        Page page = pages.get(tabIndex);\n        return page.getDisplayedMnemonicIndex();\n    }"}
{"Number":"1297","API Relative Path":"javax.swing.JTabbedPane.java-getMnemonicAt(int)","Corresponding Source":"/**\n     * Returns the keyboard mnemonic for accessing the specified tab.\n     * The mnemonic is the key which when combined with the look and feel's\n     * mouseless modifier (usually Alt) will activate the specified\n     * tab.\n     *\n     * @since 1.4\n     * @param tabIndex the index of the tab that the mnemonic refers to\n     * @return the key code which represents the mnemonic;\n     *         -1 if a mnemonic is not specified for the tab\n     * @exception IndexOutOfBoundsException if index is out of range\n     *            (<code>tabIndex<\/code> &lt; 0 ||\n     *              <code>tabIndex<\/code> &gt;= tab count)\n     * @see #setDisplayedMnemonicIndexAt(int,int)\n     * @see #setMnemonicAt(int,int)\n     */\n    public int getMnemonicAt(int tabIndex) {\n        checkIndex(tabIndex);\n\n        Page page = pages.get(tabIndex);\n        return page.getMnemonic();\n    }"}
{"Number":"1298","API Relative Path":"javax.swing.JTabbedPane.java-insertTab(String-Icon-Component-String-int)","Corresponding Source":"/**\n     * Inserts a new tab for the given component, at the given index,\n     * represented by the given title and/or icon, either of which may\n     * be {@code null}.\n     *\n     * @param title the title to be displayed on the tab\n     * @param icon the icon to be displayed on the tab\n     * @param component the component to be displayed when this tab is clicked.\n     * @param tip the tooltip to be displayed for this tab\n     * @param index the position to insert this new tab\n     *       ({@code > 0 and <= getTabCount()})\n     *\n     * @throws IndexOutOfBoundsException if the index is out of range\n     *         ({@code < 0 or > getTabCount()})\n     *\n     * @see #addTab\n     * @see #removeTabAt\n     */\n    public void insertTab(String title, Icon icon, Component component, String tip, int index) {\n        int newIndex = index;\n\n        // If component already exists, remove corresponding\n        // tab so that new tab gets added correctly\n        // Note: we are allowing component=null because of compatibility,\n        // but we really should throw an exception because much of the\n        // rest of the JTabbedPane implementation isn't designed to deal\n        // with null components for tabs.\n        int removeIndex = indexOfComponent(component);\n        if (component != null && removeIndex != -1) {\n            removeTabAt(removeIndex);\n            if (newIndex > removeIndex) {\n                newIndex--;\n            }\n        }\n\n        int selectedIndex = getSelectedIndex();\n\n        pages.add(\n            newIndex,\n            new Page(this, title != null? title : \"\", icon, null, component, tip));\n\n\n        if (component != null) {\n            addImpl(component, null, -1);\n            component.setVisible(false);\n        } else {\n            firePropertyChange(\"indexForNullComponent\", -1, index);\n        }\n\n        if (pages.size() == 1) {\n            setSelectedIndex(0);\n        }\n\n        if (selectedIndex >= newIndex) {\n            setSelectedIndexImpl(selectedIndex + 1, false);\n        }\n\n        if (!haveRegistered && tip != null) {\n            ToolTipManager.sharedInstance().registerComponent(this);\n            haveRegistered = true;\n        }\n\n        if (accessibleContext != null) {\n            accessibleContext.firePropertyChange(\n                    AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,\n                    null, component);\n        }\n        revalidate();\n        repaint();\n    }"}
{"Number":"1299","API Relative Path":"javax.swing.JTabbedPane.java-insertTab(String-Icon-Component-String-int)","Corresponding Source":"/**\n     * Inserts a new tab for the given component, at the given index,\n     * represented by the given title and/or icon, either of which may\n     * be {@code null}.\n     *\n     * @param title the title to be displayed on the tab\n     * @param icon the icon to be displayed on the tab\n     * @param component the component to be displayed when this tab is clicked.\n     * @param tip the tooltip to be displayed for this tab\n     * @param index the position to insert this new tab\n     *       ({@code > 0 and <= getTabCount()})\n     *\n     * @throws IndexOutOfBoundsException if the index is out of range\n     *         ({@code < 0 or > getTabCount()})\n     *\n     * @see #addTab\n     * @see #removeTabAt\n     */\n    public void insertTab(String title, Icon icon, Component component, String tip, int index) {\n        int newIndex = index;\n\n        // If component already exists, remove corresponding\n        // tab so that new tab gets added correctly\n        // Note: we are allowing component=null because of compatibility,\n        // but we really should throw an exception because much of the\n        // rest of the JTabbedPane implementation isn't designed to deal\n        // with null components for tabs.\n        int removeIndex = indexOfComponent(component);\n        if (component != null && removeIndex != -1) {\n            removeTabAt(removeIndex);\n            if (newIndex > removeIndex) {\n                newIndex--;\n            }\n        }\n\n        int selectedIndex = getSelectedIndex();\n\n        pages.add(\n            newIndex,\n            new Page(this, title != null? title : \"\", icon, null, component, tip));\n\n\n        if (component != null) {\n            addImpl(component, null, -1);\n            component.setVisible(false);\n        } else {\n            firePropertyChange(\"indexForNullComponent\", -1, index);\n        }\n\n        if (pages.size() == 1) {\n            setSelectedIndex(0);\n        }\n\n        if (selectedIndex >= newIndex) {\n            setSelectedIndexImpl(selectedIndex + 1, false);\n        }\n\n        if (!haveRegistered && tip != null) {\n            ToolTipManager.sharedInstance().registerComponent(this);\n            haveRegistered = true;\n        }\n\n        if (accessibleContext != null) {\n            accessibleContext.firePropertyChange(\n                    AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,\n                    null, component);\n        }\n        revalidate();\n        repaint();\n    }"}
{"Number":"1300","API Relative Path":"javax.swing.JTabbedPane.java-JTabbedPane(int-int)","Corresponding Source":"/**\n     * Creates an empty <code>TabbedPane<\/code> with the specified tab placement\n     * and tab layout policy.  Tab placement may be either:\n     * <code>JTabbedPane.TOP<\/code>, <code>JTabbedPane.BOTTOM<\/code>,\n     * <code>JTabbedPane.LEFT<\/code>, or <code>JTabbedPane.RIGHT<\/code>.\n     * Tab layout policy may be either: <code>JTabbedPane.WRAP_TAB_LAYOUT<\/code>\n     * or <code>JTabbedPane.SCROLL_TAB_LAYOUT<\/code>.\n     *\n     * @param tabPlacement the placement for the tabs relative to the content\n     * @param tabLayoutPolicy the policy for laying out tabs when all tabs will not fit on one run\n     * @exception IllegalArgumentException if tab placement or tab layout policy are not\n     *            one of the above supported values\n     * @see #addTab\n     * @since 1.4\n     */\n    public JTabbedPane(int tabPlacement, int tabLayoutPolicy) {\n        setTabPlacement(tabPlacement);\n        setTabLayoutPolicy(tabLayoutPolicy);\n        pages = new ArrayList<Page>(1);\n        setModel(new DefaultSingleSelectionModel());\n        updateUI();\n    }"}
{"Number":"1301","API Relative Path":"javax.swing.JTabbedPane.java-JTabbedPane(int-int)","Corresponding Source":"/**\n     * Creates an empty <code>TabbedPane<\/code> with the specified tab placement\n     * and tab layout policy.  Tab placement may be either:\n     * <code>JTabbedPane.TOP<\/code>, <code>JTabbedPane.BOTTOM<\/code>,\n     * <code>JTabbedPane.LEFT<\/code>, or <code>JTabbedPane.RIGHT<\/code>.\n     * Tab layout policy may be either: <code>JTabbedPane.WRAP_TAB_LAYOUT<\/code>\n     * or <code>JTabbedPane.SCROLL_TAB_LAYOUT<\/code>.\n     *\n     * @param tabPlacement the placement for the tabs relative to the content\n     * @param tabLayoutPolicy the policy for laying out tabs when all tabs will not fit on one run\n     * @exception IllegalArgumentException if tab placement or tab layout policy are not\n     *            one of the above supported values\n     * @see #addTab\n     * @since 1.4\n     */\n    public JTabbedPane(int tabPlacement, int tabLayoutPolicy) {\n        setTabPlacement(tabPlacement);\n        setTabLayoutPolicy(tabLayoutPolicy);\n        pages = new ArrayList<Page>(1);\n        setModel(new DefaultSingleSelectionModel());\n        updateUI();\n    }"}
{"Number":"1302","API Relative Path":"javax.swing.JTabbedPane.java-remove(int)","Corresponding Source":"/**\n     * Removes the tab and component which corresponds to the specified index.\n     *\n     * @param index the index of the component to remove from the\n     *          <code>tabbedpane<\/code>\n     * @exception IndexOutOfBoundsException if index is out of range\n     *            {@code (index < 0 || index >= tab count)}\n     * @see #addTab\n     * @see #removeTabAt\n     */\n    public void remove(int index) {\n        removeTabAt(index);\n    }"}
{"Number":"1303","API Relative Path":"javax.swing.JTabbedPane.java-remove(int)","Corresponding Source":"/**\n     * Removes the tab and component which corresponds to the specified index.\n     *\n     * @param index the index of the component to remove from the\n     *          <code>tabbedpane<\/code>\n     * @exception IndexOutOfBoundsException if index is out of range\n     *            {@code (index < 0 || index >= tab count)}\n     * @see #addTab\n     * @see #removeTabAt\n     */\n    public void remove(int index) {\n        removeTabAt(index);\n    }"}
{"Number":"1304","API Relative Path":"javax.swing.JTabbedPane.java-removeChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Removes a <code>ChangeListener<\/code> from this tabbedpane.\n     *\n     * @param l the <code>ChangeListener<\/code> to remove\n     * @see #fireStateChanged\n     * @see #addChangeListener\n     */\n    public void removeChangeListener(ChangeListener l) {\n        listenerList.remove(ChangeListener.class, l);\n    }"}
{"Number":"1305","API Relative Path":"javax.swing.JTabbedPane.java-removeTabAt(int)","Corresponding Source":"/**\n     * Removes the tab at <code>index<\/code>.\n     * After the component associated with <code>index<\/code> is removed,\n     * its visibility is reset to true to ensure it will be visible\n     * if added to other containers.\n     * @param index the index of the tab to be removed\n     * @exception IndexOutOfBoundsException if index is out of range\n     *            {@code (index < 0 || index >= tab count)}\n     *\n     * @see #addTab\n     * @see #insertTab\n     */\n    public void removeTabAt(int index) {\n        checkIndex(index);\n\n        Component component = getComponentAt(index);\n        boolean shouldChangeFocus = false;\n        int selected = getSelectedIndex();\n        String oldName = null;\n\n        /* if we're about to remove the visible component */\n        if (component == visComp) {\n            shouldChangeFocus = (SwingUtilities.findFocusOwner(visComp) != null);\n            visComp = null;\n        }\n\n        if (accessibleContext != null) {\n            /* if we're removing the selected page */\n            if (index == selected) {\n                /* fire an accessible notification that it's unselected */\n                pages.get(index).firePropertyChange(\n                    AccessibleContext.ACCESSIBLE_STATE_PROPERTY,\n                    AccessibleState.SELECTED, null);\n\n                oldName = accessibleContext.getAccessibleName();\n            }\n\n            accessibleContext.firePropertyChange(\n                    AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,\n                    component, null);\n        }\n\n        // Force the tabComponent to be cleaned up.\n        setTabComponentAt(index, null);\n        pages.remove(index);\n\n        // NOTE 4/15/2002 (joutwate):\n        // This fix is implemented using client properties since there is\n        // currently no IndexPropertyChangeEvent.  Once\n        // IndexPropertyChangeEvents have been added this code should be\n        // modified to use it.\n        putClientProperty(\"__index_to_remove__\", Integer.valueOf(index));\n\n        /* if the selected tab is after the removal */\n        if (selected > index) {\n            setSelectedIndexImpl(selected - 1, false);\n\n        /* if the selected tab is the last tab */\n        } else if (selected >= getTabCount()) {\n            setSelectedIndexImpl(selected - 1, false);\n            Page newSelected = (selected != 0)\n                ? pages.get(selected - 1)\n                : null;\n\n            changeAccessibleSelection(null, oldName, newSelected);\n\n        /* selected index hasn't changed, but the associated tab has */\n        } else if (index == selected) {\n            fireStateChanged();\n            changeAccessibleSelection(null, oldName, pages.get(index));\n        }\n\n        // We can't assume the tab indices correspond to the\n        // container's children array indices, so make sure we\n        // remove the correct child!\n        if (component != null) {\n            Component components[] = getComponents();\n            for (int i = components.length; --i >= 0; ) {\n                if (components[i] == component) {\n                    super.remove(i);\n                    component.setVisible(true);\n                    break;\n                }\n            }\n        }\n\n        if (shouldChangeFocus) {\n            SwingUtilities2.tabbedPaneChangeFocusTo(getSelectedComponent());\n        }\n\n        revalidate();\n        repaint();\n    }"}
{"Number":"1306","API Relative Path":"javax.swing.JTabbedPane.java-removeTabAt(int)","Corresponding Source":"/**\n     * Removes the tab at <code>index<\/code>.\n     * After the component associated with <code>index<\/code> is removed,\n     * its visibility is reset to true to ensure it will be visible\n     * if added to other containers.\n     * @param index the index of the tab to be removed\n     * @exception IndexOutOfBoundsException if index is out of range\n     *            {@code (index < 0 || index >= tab count)}\n     *\n     * @see #addTab\n     * @see #insertTab\n     */\n    public void removeTabAt(int index) {\n        checkIndex(index);\n\n        Component component = getComponentAt(index);\n        boolean shouldChangeFocus = false;\n        int selected = getSelectedIndex();\n        String oldName = null;\n\n        /* if we're about to remove the visible component */\n        if (component == visComp) {\n            shouldChangeFocus = (SwingUtilities.findFocusOwner(visComp) != null);\n            visComp = null;\n        }\n\n        if (accessibleContext != null) {\n            /* if we're removing the selected page */\n            if (index == selected) {\n                /* fire an accessible notification that it's unselected */\n                pages.get(index).firePropertyChange(\n                    AccessibleContext.ACCESSIBLE_STATE_PROPERTY,\n                    AccessibleState.SELECTED, null);\n\n                oldName = accessibleContext.getAccessibleName();\n            }\n\n            accessibleContext.firePropertyChange(\n                    AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,\n                    component, null);\n        }\n\n        // Force the tabComponent to be cleaned up.\n        setTabComponentAt(index, null);\n        pages.remove(index);\n\n        // NOTE 4/15/2002 (joutwate):\n        // This fix is implemented using client properties since there is\n        // currently no IndexPropertyChangeEvent.  Once\n        // IndexPropertyChangeEvents have been added this code should be\n        // modified to use it.\n        putClientProperty(\"__index_to_remove__\", Integer.valueOf(index));\n\n        /* if the selected tab is after the removal */\n        if (selected > index) {\n            setSelectedIndexImpl(selected - 1, false);\n\n        /* if the selected tab is the last tab */\n        } else if (selected >= getTabCount()) {\n            setSelectedIndexImpl(selected - 1, false);\n            Page newSelected = (selected != 0)\n                ? pages.get(selected - 1)\n                : null;\n\n            changeAccessibleSelection(null, oldName, newSelected);\n\n        /* selected index hasn't changed, but the associated tab has */\n        } else if (index == selected) {\n            fireStateChanged();\n            changeAccessibleSelection(null, oldName, pages.get(index));\n        }\n\n        // We can't assume the tab indices correspond to the\n        // container's children array indices, so make sure we\n        // remove the correct child!\n        if (component != null) {\n            Component components[] = getComponents();\n            for (int i = components.length; --i >= 0; ) {\n                if (components[i] == component) {\n                    super.remove(i);\n                    component.setVisible(true);\n                    break;\n                }\n            }\n        }\n\n        if (shouldChangeFocus) {\n            SwingUtilities2.tabbedPaneChangeFocusTo(getSelectedComponent());\n        }\n\n        revalidate();\n        repaint();\n    }"}
{"Number":"1307","API Relative Path":"javax.swing.JTabbedPane.java-setBackgroundAt(int-Color)","Corresponding Source":"/**\n     * Sets the background color at <code>index<\/code> to\n     * <code>background<\/code>\n     * which can be <code>null<\/code>, in which case the tab's background color\n     * will default to the background color of the <code>tabbedpane<\/code>.\n     * An internal exception is raised if there is no tab at that index.\n     * <p>\n     * It is up to the look and feel to honor this property, some may\n     * choose to ignore it.\n     *\n     * @param index the tab index where the background should be set\n     * @param background the color to be displayed in the tab's background\n     * @exception IndexOutOfBoundsException if index is out of range\n     *            {@code (index < 0 || index >= tab count)}\n     *\n     * @see #getBackgroundAt\n     * @beaninfo\n     *    preferred: true\n     *    attribute: visualUpdate true\n     *  description: The background color at the specified tab index.\n     */\n    public void setBackgroundAt(int index, Color background) {\n        Color oldBg = pages.get(index).background;\n        pages.get(index).setBackground(background);\n        if (background == null || oldBg == null ||\n            !background.equals(oldBg)) {\n            Rectangle tabBounds = getBoundsAt(index);\n            if (tabBounds != null) {\n                repaint(tabBounds);\n            }\n        }\n    }"}
{"Number":"1308","API Relative Path":"javax.swing.JTabbedPane.java-setBackgroundAt(int-Color)","Corresponding Source":"/**\n     * Sets the background color at <code>index<\/code> to\n     * <code>background<\/code>\n     * which can be <code>null<\/code>, in which case the tab's background color\n     * will default to the background color of the <code>tabbedpane<\/code>.\n     * An internal exception is raised if there is no tab at that index.\n     * <p>\n     * It is up to the look and feel to honor this property, some may\n     * choose to ignore it.\n     *\n     * @param index the tab index where the background should be set\n     * @param background the color to be displayed in the tab's background\n     * @exception IndexOutOfBoundsException if index is out of range\n     *            {@code (index < 0 || index >= tab count)}\n     *\n     * @see #getBackgroundAt\n     * @beaninfo\n     *    preferred: true\n     *    attribute: visualUpdate true\n     *  description: The background color at the specified tab index.\n     */\n    public void setBackgroundAt(int index, Color background) {\n        Color oldBg = pages.get(index).background;\n        pages.get(index).setBackground(background);\n        if (background == null || oldBg == null ||\n            !background.equals(oldBg)) {\n            Rectangle tabBounds = getBoundsAt(index);\n            if (tabBounds != null) {\n                repaint(tabBounds);\n            }\n        }\n    }"}
{"Number":"1309","API Relative Path":"javax.swing.JTabbedPane.java-setComponentAt(int-Component)","Corresponding Source":"/**\n     * Sets the component at <code>index<\/code> to <code>component<\/code>.\n     * An internal exception is raised if there is no tab at that index.\n     *\n     * @param index the tab index where this component is being placed\n     * @param component the component for the tab\n     * @exception IndexOutOfBoundsException if index is out of range\n     *            {@code (index < 0 || index >= tab count)}\n     *\n     * @see #getComponentAt\n     * @beaninfo\n     *    attribute: visualUpdate true\n     *  description: The component at the specified tab index.\n     */\n    public void setComponentAt(int index, Component component) {\n        Page page = pages.get(index);\n        if (component != page.component) {\n            boolean shouldChangeFocus = false;\n\n            if (page.component != null) {\n                shouldChangeFocus =\n                    (SwingUtilities.findFocusOwner(page.component) != null);\n\n                // REMIND(aim): this is really silly;\n                // why not if (page.component.getParent() == this) remove(component)\n                synchronized(getTreeLock()) {\n                    int count = getComponentCount();\n                    Component children[] = getComponents();\n                    for (int i = 0; i < count; i++) {\n                        if (children[i] == page.component) {\n                            super.remove(i);\n                        }\n                    }\n                }\n            }\n\n            page.component = component;\n            boolean selectedPage = (getSelectedIndex() == index);\n\n            if (selectedPage) {\n                this.visComp = component;\n            }\n\n            if (component != null) {\n                component.setVisible(selectedPage);\n                addImpl(component, null, -1);\n\n                if (shouldChangeFocus) {\n                    SwingUtilities2.tabbedPaneChangeFocusTo(component);\n                }\n            } else {\n                repaint();\n            }\n\n            revalidate();\n        }\n    }"}
{"Number":"1310","API Relative Path":"javax.swing.JTabbedPane.java-setComponentAt(int-Component)","Corresponding Source":"/**\n     * Sets the component at <code>index<\/code> to <code>component<\/code>.\n     * An internal exception is raised if there is no tab at that index.\n     *\n     * @param index the tab index where this component is being placed\n     * @param component the component for the tab\n     * @exception IndexOutOfBoundsException if index is out of range\n     *            {@code (index < 0 || index >= tab count)}\n     *\n     * @see #getComponentAt\n     * @beaninfo\n     *    attribute: visualUpdate true\n     *  description: The component at the specified tab index.\n     */\n    public void setComponentAt(int index, Component component) {\n        Page page = pages.get(index);\n        if (component != page.component) {\n            boolean shouldChangeFocus = false;\n\n            if (page.component != null) {\n                shouldChangeFocus =\n                    (SwingUtilities.findFocusOwner(page.component) != null);\n\n                // REMIND(aim): this is really silly;\n                // why not if (page.component.getParent() == this) remove(component)\n                synchronized(getTreeLock()) {\n                    int count = getComponentCount();\n                    Component children[] = getComponents();\n                    for (int i = 0; i < count; i++) {\n                        if (children[i] == page.component) {\n                            super.remove(i);\n                        }\n                    }\n                }\n            }\n\n            page.component = component;\n            boolean selectedPage = (getSelectedIndex() == index);\n\n            if (selectedPage) {\n                this.visComp = component;\n            }\n\n            if (component != null) {\n                component.setVisible(selectedPage);\n                addImpl(component, null, -1);\n\n                if (shouldChangeFocus) {\n                    SwingUtilities2.tabbedPaneChangeFocusTo(component);\n                }\n            } else {\n                repaint();\n            }\n\n            revalidate();\n        }\n    }"}
{"Number":"1311","API Relative Path":"javax.swing.JTabbedPane.java-setDisplayedMnemonicIndexAt(int-int)","Corresponding Source":"/**\n     * Provides a hint to the look and feel as to which character in the\n     * text should be decorated to represent the mnemonic. Not all look and\n     * feels may support this. A value of -1 indicates either there is\n     * no mnemonic for this tab, or you do not wish the mnemonic to be\n     * displayed for this tab.\n     * <p>\n     * The value of this is updated as the properties relating to the\n     * mnemonic change (such as the mnemonic itself, the text...).\n     * You should only ever have to call this if\n     * you do not wish the default character to be underlined. For example, if\n     * the text at tab index 3 was 'Apple Price', with a mnemonic of 'p',\n     * and you wanted the 'P'\n     * to be decorated, as 'Apple <u>P<\/u>rice', you would have to invoke\n     * <code>setDisplayedMnemonicIndex(3, 6)<\/code> after invoking\n     * <code>setMnemonicAt(3, KeyEvent.VK_P)<\/code>.\n     * <p>Note that it is the programmer's responsibility to ensure\n     * that each tab has a unique mnemonic or unpredictable results may\n     * occur.\n     *\n     * @since 1.4\n     * @param tabIndex the index of the tab that the mnemonic refers to\n     * @param mnemonicIndex index into the <code>String<\/code> to underline\n     * @exception IndexOutOfBoundsException if <code>tabIndex<\/code> is\n     *            out of range ({@code tabIndex < 0 || tabIndex >= tab\n     *            count})\n     * @exception IllegalArgumentException will be thrown if\n     *            <code>mnemonicIndex<\/code> is &gt;= length of the tab\n     *            title , or &lt; -1\n     * @see #setMnemonicAt(int,int)\n     * @see #getDisplayedMnemonicIndexAt(int)\n     *\n     * @beaninfo\n     *        bound: true\n     *    attribute: visualUpdate true\n     *  description: the index into the String to draw the keyboard character\n     *               mnemonic at\n     */\n    public void setDisplayedMnemonicIndexAt(int tabIndex, int mnemonicIndex) {\n        checkIndex(tabIndex);\n\n        Page page = pages.get(tabIndex);\n\n        page.setDisplayedMnemonicIndex(mnemonicIndex);\n    }"}
{"Number":"1312","API Relative Path":"javax.swing.JTabbedPane.java-setForegroundAt(int-Color)","Corresponding Source":"/**\n     * Sets the foreground color at <code>index<\/code> to\n     * <code>foreground<\/code> which can be\n     * <code>null<\/code>, in which case the tab's foreground color\n     * will default to the foreground color of this <code>tabbedpane<\/code>.\n     * An internal exception is raised if there is no tab at that index.\n     * <p>\n     * It is up to the look and feel to honor this property, some may\n     * choose to ignore it.\n     *\n     * @param index the tab index where the foreground should be set\n     * @param foreground the color to be displayed as the tab's foreground\n     * @exception IndexOutOfBoundsException if index is out of range\n     *            {@code (index < 0 || index >= tab count)}\n     *\n     * @see #getForegroundAt\n     * @beaninfo\n     *    preferred: true\n     *    attribute: visualUpdate true\n     *  description: The foreground color at the specified tab index.\n     */\n    public void setForegroundAt(int index, Color foreground) {\n        Color oldFg = pages.get(index).foreground;\n        pages.get(index).setForeground(foreground);\n        if (foreground == null || oldFg == null ||\n            !foreground.equals(oldFg)) {\n            Rectangle tabBounds = getBoundsAt(index);\n            if (tabBounds != null) {\n                repaint(tabBounds);\n            }\n        }\n    }"}
{"Number":"1313","API Relative Path":"javax.swing.JTabbedPane.java-setForegroundAt(int-Color)","Corresponding Source":"/**\n     * Sets the foreground color at <code>index<\/code> to\n     * <code>foreground<\/code> which can be\n     * <code>null<\/code>, in which case the tab's foreground color\n     * will default to the foreground color of this <code>tabbedpane<\/code>.\n     * An internal exception is raised if there is no tab at that index.\n     * <p>\n     * It is up to the look and feel to honor this property, some may\n     * choose to ignore it.\n     *\n     * @param index the tab index where the foreground should be set\n     * @param foreground the color to be displayed as the tab's foreground\n     * @exception IndexOutOfBoundsException if index is out of range\n     *            {@code (index < 0 || index >= tab count)}\n     *\n     * @see #getForegroundAt\n     * @beaninfo\n     *    preferred: true\n     *    attribute: visualUpdate true\n     *  description: The foreground color at the specified tab index.\n     */\n    public void setForegroundAt(int index, Color foreground) {\n        Color oldFg = pages.get(index).foreground;\n        pages.get(index).setForeground(foreground);\n        if (foreground == null || oldFg == null ||\n            !foreground.equals(oldFg)) {\n            Rectangle tabBounds = getBoundsAt(index);\n            if (tabBounds != null) {\n                repaint(tabBounds);\n            }\n        }\n    }"}
{"Number":"1314","API Relative Path":"javax.swing.JTabbedPane.java-setMnemonicAt(int-int)","Corresponding Source":"/**\n     * Sets the keyboard mnemonic for accessing the specified tab.\n     * The mnemonic is the key which when combined with the look and feel's\n     * mouseless modifier (usually Alt) will activate the specified\n     * tab.\n     * <p>\n     * A mnemonic must correspond to a single key on the keyboard\n     * and should be specified using one of the <code>VK_XXX<\/code>\n     * keycodes defined in <code>java.awt.event.KeyEvent<\/code>\n     * or one of the extended keycodes obtained through\n     * <code>java.awt.event.KeyEvent.getExtendedKeyCodeForChar<\/code>.\n     * Mnemonics are case-insensitive, therefore a key event\n     * with the corresponding keycode would cause the button to be\n     * activated whether or not the Shift modifier was pressed.\n     * <p>\n     * This will update the displayed mnemonic property for the specified\n     * tab.\n     *\n     * @since 1.4\n     * @param tabIndex the index of the tab that the mnemonic refers to\n     * @param mnemonic the key code which represents the mnemonic\n     * @exception IndexOutOfBoundsException if <code>tabIndex<\/code> is out\n     *            of range ({@code tabIndex < 0 || tabIndex >= tab count})\n     * @see #getMnemonicAt(int)\n     * @see #setDisplayedMnemonicIndexAt(int,int)\n     *\n     * @beaninfo\n     *        bound: true\n     *    attribute: visualUpdate true\n     *  description: The keyboard mnenmonic, as a KeyEvent VK constant,\n     *               for the specified tab\n     */\n    public void setMnemonicAt(int tabIndex, int mnemonic) {\n        checkIndex(tabIndex);\n\n        Page page = pages.get(tabIndex);\n        page.setMnemonic(mnemonic);\n\n        firePropertyChange(\"mnemonicAt\", null, null);\n    }"}
{"Number":"1315","API Relative Path":"javax.swing.JTabbedPane.java-setSelectedIndex(int)","Corresponding Source":"/**\n     * Sets the selected index for this tabbedpane. The index must be\n     * a valid tab index or -1, which indicates that no tab should be selected\n     * (can also be used when there are no tabs in the tabbedpane).  If a -1\n     * value is specified when the tabbedpane contains one or more tabs, then\n     * the results will be implementation defined.\n     *\n     * @param index  the index to be selected\n     * @exception IndexOutOfBoundsException if index is out of range\n     *            {@code (index < -1 || index >= tab count)}\n     *\n     * @see #getSelectedIndex\n     * @see SingleSelectionModel#setSelectedIndex\n     * @beaninfo\n     *   preferred: true\n     * description: The tabbedpane's selected tab index.\n     */\n    public void setSelectedIndex(int index) {\n        if (index != -1) {\n            checkIndex(index);\n        }\n        setSelectedIndexImpl(index, true);\n    }"}
{"Number":"1316","API Relative Path":"javax.swing.JTabbedPane.java-setTabComponentAt(int-Component)","Corresponding Source":"/**\n    * Sets the component that is responsible for rendering the\n    * title for the specified tab.  A null value means\n    * <code>JTabbedPane<\/code> will render the title and/or icon for\n    * the specified tab.  A non-null value means the component will\n    * render the title and <code>JTabbedPane<\/code> will not render\n    * the title and/or icon.\n    * <p>\n    * Note: The component must not be one that the developer has\n    *       already added to the tabbed pane.\n    *\n    * @param index the tab index where the component should be set\n    * @param component the component to render the title for the\n    *                  specified tab\n    * @exception IndexOutOfBoundsException if index is out of range\n    *            {@code (index < 0 || index >= tab count)}\n    * @exception IllegalArgumentException if component has already been\n    *            added to this <code>JTabbedPane<\/code>\n    *\n    * @see #getTabComponentAt\n    * @beaninfo\n    *    preferred: true\n    *    attribute: visualUpdate true\n    *  description: The tab component at the specified tab index.\n    * @since 1.6\n    */\n    public void setTabComponentAt(int index, Component component) {\n        if (component != null && indexOfComponent(component) != -1) {\n            throw new IllegalArgumentException(\"Component is already added to this JTabbedPane\");\n        }\n        Component oldValue = getTabComponentAt(index);\n        if (component != oldValue) {\n            int tabComponentIndex = indexOfTabComponent(component);\n            if (tabComponentIndex != -1) {\n                setTabComponentAt(tabComponentIndex, null);\n            }\n            pages.get(index).tabComponent = component;\n            firePropertyChange(\"indexForTabComponent\", -1, index);\n        }\n    }"}
{"Number":"1317","API Relative Path":"javax.swing.JTabbedPane.java-setTabLayoutPolicy(int)","Corresponding Source":"/**\n     * Sets the policy which the tabbedpane will use in laying out the tabs\n     * when all the tabs will not fit within a single run.\n     * Possible values are:\n     * <ul>\n     * <li><code>JTabbedPane.WRAP_TAB_LAYOUT<\/code>\n     * <li><code>JTabbedPane.SCROLL_TAB_LAYOUT<\/code>\n     * <\/ul>\n     *\n     * The default value, if not set by the UI, is <code>JTabbedPane.WRAP_TAB_LAYOUT<\/code>.\n     * <p>\n     * Some look and feels might only support a subset of the possible\n     * layout policies, in which case the value of this property may be\n     * ignored.\n     *\n     * @param tabLayoutPolicy the policy used to layout the tabs\n     * @exception IllegalArgumentException if layoutPolicy value isn't one\n     *                          of the above valid values\n     * @see #getTabLayoutPolicy\n     * @since 1.4\n     *\n     * @beaninfo\n     *    preferred: true\n     *        bound: true\n     *    attribute: visualUpdate true\n     *         enum: WRAP_TAB_LAYOUT JTabbedPane.WRAP_TAB_LAYOUT\n     *               SCROLL_TAB_LAYOUT JTabbedPane.SCROLL_TAB_LAYOUT\n     *  description: The tabbedpane's policy for laying out the tabs\n     *\n     */\n    public void setTabLayoutPolicy(int tabLayoutPolicy) {\n        if (tabLayoutPolicy != WRAP_TAB_LAYOUT && tabLayoutPolicy != SCROLL_TAB_LAYOUT) {\n            throw new IllegalArgumentException(\"illegal tab layout policy: must be WRAP_TAB_LAYOUT or SCROLL_TAB_LAYOUT\");\n        }\n        if (this.tabLayoutPolicy != tabLayoutPolicy) {\n            int oldValue = this.tabLayoutPolicy;\n            this.tabLayoutPolicy = tabLayoutPolicy;\n            firePropertyChange(\"tabLayoutPolicy\", oldValue, tabLayoutPolicy);\n            revalidate();\n            repaint();\n        }\n    }"}
{"Number":"1318","API Relative Path":"javax.swing.JTabbedPane.java-setTabPlacement(int)","Corresponding Source":"/**\n     * Sets the tab placement for this tabbedpane.\n     * Possible values are:<ul>\n     * <li><code>JTabbedPane.TOP<\/code>\n     * <li><code>JTabbedPane.BOTTOM<\/code>\n     * <li><code>JTabbedPane.LEFT<\/code>\n     * <li><code>JTabbedPane.RIGHT<\/code>\n     * <\/ul>\n     * The default value, if not set, is <code>SwingConstants.TOP<\/code>.\n     *\n     * @param tabPlacement the placement for the tabs relative to the content\n     * @exception IllegalArgumentException if tab placement value isn't one\n     *                          of the above valid values\n     *\n     * @beaninfo\n     *    preferred: true\n     *        bound: true\n     *    attribute: visualUpdate true\n     *         enum: TOP JTabbedPane.TOP\n     *               LEFT JTabbedPane.LEFT\n     *               BOTTOM JTabbedPane.BOTTOM\n     *               RIGHT JTabbedPane.RIGHT\n     *  description: The tabbedpane's tab placement.\n     *\n     */\n    public void setTabPlacement(int tabPlacement) {\n        if (tabPlacement != TOP && tabPlacement != LEFT &&\n            tabPlacement != BOTTOM && tabPlacement != RIGHT) {\n            throw new IllegalArgumentException(\"illegal tab placement: must be TOP, BOTTOM, LEFT, or RIGHT\");\n        }\n        if (this.tabPlacement != tabPlacement) {\n            int oldValue = this.tabPlacement;\n            this.tabPlacement = tabPlacement;\n            firePropertyChange(\"tabPlacement\", oldValue, tabPlacement);\n            revalidate();\n            repaint();\n        }\n    }"}
{"Number":"1319","API Relative Path":"javax.swing.JTable.java-addColumnSelectionInterval(int-int)","Corresponding Source":"/**\n     * Adds the columns from <code>index0<\/code> to <code>index1<\/code>,\n     * inclusive, to the current selection.\n     *\n     * @exception IllegalArgumentException      if <code>index0<\/code> or\n     *                                          <code>index1<\/code> lie outside\n     *                                          [0, <code>getColumnCount()<\/code>-1]\n     * @param   index0 one end of the interval\n     * @param   index1 the other end of the interval\n     */\n    public void addColumnSelectionInterval(int index0, int index1) {\n        columnModel.getSelectionModel().addSelectionInterval(boundColumn(index0), boundColumn(index1));\n    }"}
{"Number":"1320","API Relative Path":"javax.swing.JTable.java-addRowSelectionInterval(int-int)","Corresponding Source":"/**\n     * Adds the rows from <code>index0<\/code> to <code>index1<\/code>, inclusive, to\n     * the current selection.\n     *\n     * @exception IllegalArgumentException      if <code>index0<\/code> or <code>index1<\/code>\n     *                                          lie outside [0, <code>getRowCount()<\/code>-1]\n     * @param   index0 one end of the interval\n     * @param   index1 the other end of the interval\n     */\n    public void addRowSelectionInterval(int index0, int index1) {\n        selectionModel.addSelectionInterval(boundRow(index0), boundRow(index1));\n    }"}
{"Number":"1321","API Relative Path":"javax.swing.JTable.java-getDefaultEditor(Class)","Corresponding Source":"/**\n     * Returns the editor to be used when no editor has been set in\n     * a <code>TableColumn<\/code>. During the editing of cells the editor is fetched from\n     * a <code>Hashtable<\/code> of entries according to the class of the cells in the column. If\n     * there is no entry for this <code>columnClass<\/code> the method returns\n     * the entry for the most specific superclass. The <code>JTable<\/code> installs entries\n     * for <code>Object<\/code>, <code>Number<\/code>, and <code>Boolean<\/code>, all of which can be modified\n     * or replaced.\n     *\n     * @param   columnClass  return the default cell editor for this columnClass\n     * @return the default cell editor to be used for this columnClass\n     * @see     #setDefaultEditor\n     * @see     #getColumnClass\n     */\n    public TableCellEditor getDefaultEditor(Class<?> columnClass) {\n        if (columnClass == null) {\n            return null;\n        }\n        else {\n            Object editor = defaultEditorsByColumnClass.get(columnClass);\n            if (editor != null) {\n                return (TableCellEditor)editor;\n            }\n            else {\n                return getDefaultEditor(columnClass.getSuperclass());\n            }\n        }\n    }"}
{"Number":"1322","API Relative Path":"javax.swing.JTable.java-getDefaultRenderer(Class)","Corresponding Source":"/**\n     * Returns the cell renderer to be used when no renderer has been set in\n     * a <code>TableColumn<\/code>. During the rendering of cells the renderer is fetched from\n     * a <code>Hashtable<\/code> of entries according to the class of the cells in the column. If\n     * there is no entry for this <code>columnClass<\/code> the method returns\n     * the entry for the most specific superclass. The <code>JTable<\/code> installs entries\n     * for <code>Object<\/code>, <code>Number<\/code>, and <code>Boolean<\/code>, all of which can be modified\n     * or replaced.\n     *\n     * @param   columnClass   return the default cell renderer\n     *                        for this columnClass\n     * @return  the renderer for this columnClass\n     * @see     #setDefaultRenderer\n     * @see     #getColumnClass\n     */\n    public TableCellRenderer getDefaultRenderer(Class<?> columnClass) {\n        if (columnClass == null) {\n            return null;\n        }\n        else {\n            Object renderer = defaultRenderersByColumnClass.get(columnClass);\n            if (renderer != null) {\n                return (TableCellRenderer)renderer;\n            }\n            else {\n                Class c = columnClass.getSuperclass();\n                if (c == null && columnClass != Object.class) {\n                    c = Object.class;\n                }\n                return getDefaultRenderer(c);\n            }\n        }\n    }"}
{"Number":"1323","API Relative Path":"javax.swing.JTable.java-JTable(TableModel-TableColumnModel-ListSelectionModel)","Corresponding Source":"/**\n     * Constructs a <code>JTable<\/code> that is initialized with\n     * <code>dm<\/code> as the data model, <code>cm<\/code> as the\n     * column model, and <code>sm<\/code> as the selection model.\n     * If any of the parameters are <code>null<\/code> this method\n     * will initialize the table with the corresponding default model.\n     * The <code>autoCreateColumnsFromModel<\/code> flag is set to false\n     * if <code>cm<\/code> is non-null, otherwise it is set to true\n     * and the column model is populated with suitable\n     * <code>TableColumns<\/code> for the columns in <code>dm<\/code>.\n     *\n     * @param dm        the data model for the table\n     * @param cm        the column model for the table\n     * @param sm        the row selection model for the table\n     * @see #createDefaultDataModel\n     * @see #createDefaultColumnModel\n     * @see #createDefaultSelectionModel\n     */\n    public JTable(TableModel dm, TableColumnModel cm, ListSelectionModel sm) {\n        super();\n        setLayout(null);\n\n        setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n                           JComponent.getManagingFocusForwardTraversalKeys());\n        setFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,\n                           JComponent.getManagingFocusBackwardTraversalKeys());\n        if (cm == null) {\n            cm = createDefaultColumnModel();\n            autoCreateColumnsFromModel = true;\n        }\n        setColumnModel(cm);\n\n        if (sm == null) {\n            sm = createDefaultSelectionModel();\n        }\n        setSelectionModel(sm);\n\n    // Set the model last, that way if the autoCreatColumnsFromModel has\n    // been set above, we will automatically populate an empty columnModel\n    // with suitable columns for the new model.\n        if (dm == null) {\n            dm = createDefaultDataModel();\n        }\n        setModel(dm);\n\n        initializeLocalVars();\n        updateUI();\n    }"}
{"Number":"1324","API Relative Path":"javax.swing.JTable.java-JTable(TableModel-TableColumnModel-ListSelectionModel)","Corresponding Source":"/**\n     * Constructs a <code>JTable<\/code> that is initialized with\n     * <code>dm<\/code> as the data model, <code>cm<\/code> as the\n     * column model, and <code>sm<\/code> as the selection model.\n     * If any of the parameters are <code>null<\/code> this method\n     * will initialize the table with the corresponding default model.\n     * The <code>autoCreateColumnsFromModel<\/code> flag is set to false\n     * if <code>cm<\/code> is non-null, otherwise it is set to true\n     * and the column model is populated with suitable\n     * <code>TableColumns<\/code> for the columns in <code>dm<\/code>.\n     *\n     * @param dm        the data model for the table\n     * @param cm        the column model for the table\n     * @param sm        the row selection model for the table\n     * @see #createDefaultDataModel\n     * @see #createDefaultColumnModel\n     * @see #createDefaultSelectionModel\n     */\n    public JTable(TableModel dm, TableColumnModel cm, ListSelectionModel sm) {\n        super();\n        setLayout(null);\n\n        setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n                           JComponent.getManagingFocusForwardTraversalKeys());\n        setFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,\n                           JComponent.getManagingFocusBackwardTraversalKeys());\n        if (cm == null) {\n            cm = createDefaultColumnModel();\n            autoCreateColumnsFromModel = true;\n        }\n        setColumnModel(cm);\n\n        if (sm == null) {\n            sm = createDefaultSelectionModel();\n        }\n        setSelectionModel(sm);\n\n    // Set the model last, that way if the autoCreatColumnsFromModel has\n    // been set above, we will automatically populate an empty columnModel\n    // with suitable columns for the new model.\n        if (dm == null) {\n            dm = createDefaultDataModel();\n        }\n        setModel(dm);\n\n        initializeLocalVars();\n        updateUI();\n    }"}
{"Number":"1325","API Relative Path":"javax.swing.JTable.java-JTable(TableModel-TableColumnModel-ListSelectionModel)","Corresponding Source":"/**\n     * Constructs a <code>JTable<\/code> that is initialized with\n     * <code>dm<\/code> as the data model, <code>cm<\/code> as the\n     * column model, and <code>sm<\/code> as the selection model.\n     * If any of the parameters are <code>null<\/code> this method\n     * will initialize the table with the corresponding default model.\n     * The <code>autoCreateColumnsFromModel<\/code> flag is set to false\n     * if <code>cm<\/code> is non-null, otherwise it is set to true\n     * and the column model is populated with suitable\n     * <code>TableColumns<\/code> for the columns in <code>dm<\/code>.\n     *\n     * @param dm        the data model for the table\n     * @param cm        the column model for the table\n     * @param sm        the row selection model for the table\n     * @see #createDefaultDataModel\n     * @see #createDefaultColumnModel\n     * @see #createDefaultSelectionModel\n     */\n    public JTable(TableModel dm, TableColumnModel cm, ListSelectionModel sm) {\n        super();\n        setLayout(null);\n\n        setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n                           JComponent.getManagingFocusForwardTraversalKeys());\n        setFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,\n                           JComponent.getManagingFocusBackwardTraversalKeys());\n        if (cm == null) {\n            cm = createDefaultColumnModel();\n            autoCreateColumnsFromModel = true;\n        }\n        setColumnModel(cm);\n\n        if (sm == null) {\n            sm = createDefaultSelectionModel();\n        }\n        setSelectionModel(sm);\n\n    // Set the model last, that way if the autoCreatColumnsFromModel has\n    // been set above, we will automatically populate an empty columnModel\n    // with suitable columns for the new model.\n        if (dm == null) {\n            dm = createDefaultDataModel();\n        }\n        setModel(dm);\n\n        initializeLocalVars();\n        updateUI();\n    }"}
{"Number":"1326","API Relative Path":"javax.swing.JTable.java-print(PrintMode-MessageFormat-MessageFormat-boolean-PrintRequestAttributeSet-boolean-PrintService)","Corresponding Source":"/**\n     * Prints this <code>JTable<\/code>. Takes steps that the majority of\n     * developers would take in order to print a <code>JTable<\/code>.\n     * In short, it prepares the table, calls <code>getPrintable<\/code> to\n     * fetch an appropriate <code>Printable<\/code>, and then sends it to the\n     * printer.\n     * <p>\n     * A <code>boolean<\/code> parameter allows you to specify whether or not\n     * a printing dialog is displayed to the user. When it is, the user may\n     * use the dialog to change the destination printer or printing attributes,\n     * or even to cancel the print. Another two parameters allow for a\n     * <code>PrintService<\/code> and printing attributes to be specified.\n     * These parameters can be used either to provide initial values for the\n     * print dialog, or to specify values when the dialog is not shown.\n     * <p>\n     * A second <code>boolean<\/code> parameter allows you to specify whether\n     * or not to perform printing in an interactive mode. If <code>true<\/code>,\n     * a modal progress dialog, with an abort option, is displayed for the\n     * duration of printing . This dialog also prevents any user action which\n     * may affect the table. However, it can not prevent the table from being\n     * modified by code (for example, another thread that posts updates using\n     * <code>SwingUtilities.invokeLater<\/code>). It is therefore the\n     * responsibility of the developer to ensure that no other code modifies\n     * the table in any way during printing (invalid modifications include\n     * changes in: size, renderers, or underlying data). Printing behavior is\n     * undefined when the table is changed during printing.\n     * <p>\n     * If <code>false<\/code> is specified for this parameter, no dialog will\n     * be displayed and printing will begin immediately on the event-dispatch\n     * thread. This blocks any other events, including repaints, from being\n     * processed until printing is complete. Although this effectively prevents\n     * the table from being changed, it doesn't provide a good user experience.\n     * For this reason, specifying <code>false<\/code> is only recommended when\n     * printing from an application with no visible GUI.\n     * <p>\n     * Note: Attempting to show the printing dialog or run interactively, while\n     * in headless mode, will result in a <code>HeadlessException<\/code>.\n     * <p>\n     * Before fetching the printable, this method will gracefully terminate\n     * editing, if necessary, to prevent an editor from showing in the printed\n     * result. Additionally, <code>JTable<\/code> will prepare its renderers\n     * during printing such that selection and focus are not indicated.\n     * As far as customizing further how the table looks in the printout,\n     * developers can provide custom renderers or paint code that conditionalize\n     * on the value of {@link javax.swing.JComponent#isPaintingForPrint()}.\n     * <p>\n     * See {@link #getPrintable} for more description on how the table is\n     * printed.\n     *\n     * @param  printMode        the printing mode that the printable should use\n     * @param  headerFormat     a <code>MessageFormat<\/code> specifying the text\n     *                          to be used in printing a header,\n     *                          or <code>null<\/code> for none\n     * @param  footerFormat     a <code>MessageFormat<\/code> specifying the text\n     *                          to be used in printing a footer,\n     *                          or <code>null<\/code> for none\n     * @param  showPrintDialog  whether or not to display a print dialog\n     * @param  attr             a <code>PrintRequestAttributeSet<\/code>\n     *                          specifying any printing attributes,\n     *                          or <code>null<\/code> for none\n     * @param  interactive      whether or not to print in an interactive mode\n     * @param  service          the destination <code>PrintService<\/code>,\n     *                          or <code>null<\/code> to use the default printer\n     * @return true, unless printing is cancelled by the user\n     * @throws HeadlessException if the method is asked to show a printing\n     *                           dialog or run interactively, and\n     *                           <code>GraphicsEnvironment.isHeadless<\/code>\n     *                           returns <code>true<\/code>\n     * @throws  SecurityException if a security manager exists and its\n     *          {@link java.lang.SecurityManager#checkPrintJobAccess}\n     *          method disallows this thread from creating a print job request\n     * @throws PrinterException if an error in the print system causes the job\n     *                          to be aborted\n     * @see #getPrintable\n     * @see java.awt.GraphicsEnvironment#isHeadless\n     *\n     * @since 1.6\n     */\n    public boolean print(PrintMode printMode,\n                         MessageFormat headerFormat,\n                         MessageFormat footerFormat,\n                         boolean showPrintDialog,\n                         PrintRequestAttributeSet attr,\n                         boolean interactive,\n                         PrintService service) throws PrinterException,\n                                                      HeadlessException {\n\n        // complain early if an invalid parameter is specified for headless mode\n        boolean isHeadless = GraphicsEnvironment.isHeadless();\n        if (isHeadless) {\n            if (showPrintDialog) {\n                throw new HeadlessException(\"Can't show print dialog.\");\n            }\n\n            if (interactive) {\n                throw new HeadlessException(\"Can't run interactively.\");\n            }\n        }\n\n        // Get a PrinterJob.\n        // Do this before anything with side-effects since it may throw a\n        // security exception - in which case we don't want to do anything else.\n        final PrinterJob job = PrinterJob.getPrinterJob();\n\n        if (isEditing()) {\n            // try to stop cell editing, and failing that, cancel it\n            if (!getCellEditor().stopCellEditing()) {\n                getCellEditor().cancelCellEditing();\n            }\n        }\n\n        if (attr == null) {\n            attr = new HashPrintRequestAttributeSet();\n        }\n\n        final PrintingStatus printingStatus;\n\n         // fetch the Printable\n        Printable printable =\n             getPrintable(printMode, headerFormat, footerFormat);\n\n        if (interactive) {\n            // wrap the Printable so that we can print on another thread\n            printable = new ThreadSafePrintable(printable);\n            printingStatus = PrintingStatus.createPrintingStatus(this, job);\n            printable = printingStatus.createNotificationPrintable(printable);\n        } else {\n            // to please compiler\n            printingStatus = null;\n        }\n\n        // set the printable on the PrinterJob\n        job.setPrintable(printable);\n\n        // if specified, set the PrintService on the PrinterJob\n        if (service != null) {\n            job.setPrintService(service);\n        }\n\n        // if requested, show the print dialog\n        if (showPrintDialog && !job.printDialog(attr)) {\n            // the user cancelled the print dialog\n            return false;\n        }\n\n        // if not interactive, just print on this thread (no dialog)\n        if (!interactive) {\n            // do the printing\n            job.print(attr);\n\n            // we're done\n            return true;\n        }\n\n        // make sure this is clear since we'll check it after\n        printError = null;\n\n        // to synchronize on\n        final Object lock = new Object();\n\n        // copied so we can access from the inner class\n        final PrintRequestAttributeSet copyAttr = attr;\n\n        // this runnable will be used to do the printing\n        // (and save any throwables) on another thread\n        Runnable runnable = new Runnable() {\n            public void run() {\n                try {\n                    // do the printing\n                    job.print(copyAttr);\n                } catch (Throwable t) {\n                    // save any Throwable to be rethrown\n                    synchronized(lock) {\n                        printError = t;\n                    }\n                } finally {\n                    // we're finished - hide the dialog\n                    printingStatus.dispose();\n                }\n            }\n        };\n\n        // start printing on another thread\n        Thread th = new Thread(runnable);\n        th.start();\n\n        printingStatus.showModal(true);\n\n        // look for any error that the printing may have generated\n        Throwable pe;\n        synchronized(lock) {\n            pe = printError;\n            printError = null;\n        }\n\n        // check the type of error and handle it\n        if (pe != null) {\n            // a subclass of PrinterException meaning the job was aborted,\n            // in this case, by the user\n            if (pe instanceof PrinterAbortException) {\n                return false;\n            } else if (pe instanceof PrinterException) {\n                throw (PrinterException)pe;\n            } else if (pe instanceof RuntimeException) {\n                throw (RuntimeException)pe;\n            } else if (pe instanceof Error) {\n                throw (Error)pe;\n            }\n\n            // can not happen\n            throw new AssertionError(pe);\n        }\n\n        return true;\n    }"}
{"Number":"1327","API Relative Path":"javax.swing.JTable.java-print(PrintMode-MessageFormat-MessageFormat-boolean-PrintRequestAttributeSet-boolean-PrintService)","Corresponding Source":"/**\n     * Prints this <code>JTable<\/code>. Takes steps that the majority of\n     * developers would take in order to print a <code>JTable<\/code>.\n     * In short, it prepares the table, calls <code>getPrintable<\/code> to\n     * fetch an appropriate <code>Printable<\/code>, and then sends it to the\n     * printer.\n     * <p>\n     * A <code>boolean<\/code> parameter allows you to specify whether or not\n     * a printing dialog is displayed to the user. When it is, the user may\n     * use the dialog to change the destination printer or printing attributes,\n     * or even to cancel the print. Another two parameters allow for a\n     * <code>PrintService<\/code> and printing attributes to be specified.\n     * These parameters can be used either to provide initial values for the\n     * print dialog, or to specify values when the dialog is not shown.\n     * <p>\n     * A second <code>boolean<\/code> parameter allows you to specify whether\n     * or not to perform printing in an interactive mode. If <code>true<\/code>,\n     * a modal progress dialog, with an abort option, is displayed for the\n     * duration of printing . This dialog also prevents any user action which\n     * may affect the table. However, it can not prevent the table from being\n     * modified by code (for example, another thread that posts updates using\n     * <code>SwingUtilities.invokeLater<\/code>). It is therefore the\n     * responsibility of the developer to ensure that no other code modifies\n     * the table in any way during printing (invalid modifications include\n     * changes in: size, renderers, or underlying data). Printing behavior is\n     * undefined when the table is changed during printing.\n     * <p>\n     * If <code>false<\/code> is specified for this parameter, no dialog will\n     * be displayed and printing will begin immediately on the event-dispatch\n     * thread. This blocks any other events, including repaints, from being\n     * processed until printing is complete. Although this effectively prevents\n     * the table from being changed, it doesn't provide a good user experience.\n     * For this reason, specifying <code>false<\/code> is only recommended when\n     * printing from an application with no visible GUI.\n     * <p>\n     * Note: Attempting to show the printing dialog or run interactively, while\n     * in headless mode, will result in a <code>HeadlessException<\/code>.\n     * <p>\n     * Before fetching the printable, this method will gracefully terminate\n     * editing, if necessary, to prevent an editor from showing in the printed\n     * result. Additionally, <code>JTable<\/code> will prepare its renderers\n     * during printing such that selection and focus are not indicated.\n     * As far as customizing further how the table looks in the printout,\n     * developers can provide custom renderers or paint code that conditionalize\n     * on the value of {@link javax.swing.JComponent#isPaintingForPrint()}.\n     * <p>\n     * See {@link #getPrintable} for more description on how the table is\n     * printed.\n     *\n     * @param  printMode        the printing mode that the printable should use\n     * @param  headerFormat     a <code>MessageFormat<\/code> specifying the text\n     *                          to be used in printing a header,\n     *                          or <code>null<\/code> for none\n     * @param  footerFormat     a <code>MessageFormat<\/code> specifying the text\n     *                          to be used in printing a footer,\n     *                          or <code>null<\/code> for none\n     * @param  showPrintDialog  whether or not to display a print dialog\n     * @param  attr             a <code>PrintRequestAttributeSet<\/code>\n     *                          specifying any printing attributes,\n     *                          or <code>null<\/code> for none\n     * @param  interactive      whether or not to print in an interactive mode\n     * @param  service          the destination <code>PrintService<\/code>,\n     *                          or <code>null<\/code> to use the default printer\n     * @return true, unless printing is cancelled by the user\n     * @throws HeadlessException if the method is asked to show a printing\n     *                           dialog or run interactively, and\n     *                           <code>GraphicsEnvironment.isHeadless<\/code>\n     *                           returns <code>true<\/code>\n     * @throws  SecurityException if a security manager exists and its\n     *          {@link java.lang.SecurityManager#checkPrintJobAccess}\n     *          method disallows this thread from creating a print job request\n     * @throws PrinterException if an error in the print system causes the job\n     *                          to be aborted\n     * @see #getPrintable\n     * @see java.awt.GraphicsEnvironment#isHeadless\n     *\n     * @since 1.6\n     */\n    public boolean print(PrintMode printMode,\n                         MessageFormat headerFormat,\n                         MessageFormat footerFormat,\n                         boolean showPrintDialog,\n                         PrintRequestAttributeSet attr,\n                         boolean interactive,\n                         PrintService service) throws PrinterException,\n                                                      HeadlessException {\n\n        // complain early if an invalid parameter is specified for headless mode\n        boolean isHeadless = GraphicsEnvironment.isHeadless();\n        if (isHeadless) {\n            if (showPrintDialog) {\n                throw new HeadlessException(\"Can't show print dialog.\");\n            }\n\n            if (interactive) {\n                throw new HeadlessException(\"Can't run interactively.\");\n            }\n        }\n\n        // Get a PrinterJob.\n        // Do this before anything with side-effects since it may throw a\n        // security exception - in which case we don't want to do anything else.\n        final PrinterJob job = PrinterJob.getPrinterJob();\n\n        if (isEditing()) {\n            // try to stop cell editing, and failing that, cancel it\n            if (!getCellEditor().stopCellEditing()) {\n                getCellEditor().cancelCellEditing();\n            }\n        }\n\n        if (attr == null) {\n            attr = new HashPrintRequestAttributeSet();\n        }\n\n        final PrintingStatus printingStatus;\n\n         // fetch the Printable\n        Printable printable =\n             getPrintable(printMode, headerFormat, footerFormat);\n\n        if (interactive) {\n            // wrap the Printable so that we can print on another thread\n            printable = new ThreadSafePrintable(printable);\n            printingStatus = PrintingStatus.createPrintingStatus(this, job);\n            printable = printingStatus.createNotificationPrintable(printable);\n        } else {\n            // to please compiler\n            printingStatus = null;\n        }\n\n        // set the printable on the PrinterJob\n        job.setPrintable(printable);\n\n        // if specified, set the PrintService on the PrinterJob\n        if (service != null) {\n            job.setPrintService(service);\n        }\n\n        // if requested, show the print dialog\n        if (showPrintDialog && !job.printDialog(attr)) {\n            // the user cancelled the print dialog\n            return false;\n        }\n\n        // if not interactive, just print on this thread (no dialog)\n        if (!interactive) {\n            // do the printing\n            job.print(attr);\n\n            // we're done\n            return true;\n        }\n\n        // make sure this is clear since we'll check it after\n        printError = null;\n\n        // to synchronize on\n        final Object lock = new Object();\n\n        // copied so we can access from the inner class\n        final PrintRequestAttributeSet copyAttr = attr;\n\n        // this runnable will be used to do the printing\n        // (and save any throwables) on another thread\n        Runnable runnable = new Runnable() {\n            public void run() {\n                try {\n                    // do the printing\n                    job.print(copyAttr);\n                } catch (Throwable t) {\n                    // save any Throwable to be rethrown\n                    synchronized(lock) {\n                        printError = t;\n                    }\n                } finally {\n                    // we're finished - hide the dialog\n                    printingStatus.dispose();\n                }\n            }\n        };\n\n        // start printing on another thread\n        Thread th = new Thread(runnable);\n        th.start();\n\n        printingStatus.showModal(true);\n\n        // look for any error that the printing may have generated\n        Throwable pe;\n        synchronized(lock) {\n            pe = printError;\n            printError = null;\n        }\n\n        // check the type of error and handle it\n        if (pe != null) {\n            // a subclass of PrinterException meaning the job was aborted,\n            // in this case, by the user\n            if (pe instanceof PrinterAbortException) {\n                return false;\n            } else if (pe instanceof PrinterException) {\n                throw (PrinterException)pe;\n            } else if (pe instanceof RuntimeException) {\n                throw (RuntimeException)pe;\n            } else if (pe instanceof Error) {\n                throw (Error)pe;\n            }\n\n            // can not happen\n            throw new AssertionError(pe);\n        }\n\n        return true;\n    }"}
{"Number":"1328","API Relative Path":"javax.swing.JTable.java-removeColumnSelectionInterval(int-int)","Corresponding Source":"/**\n     * Deselects the columns from <code>index0<\/code> to <code>index1<\/code>, inclusive.\n     *\n     * @exception IllegalArgumentException      if <code>index0<\/code> or\n     *                                          <code>index1<\/code> lie outside\n     *                                          [0, <code>getColumnCount()<\/code>-1]\n     * @param   index0 one end of the interval\n     * @param   index1 the other end of the interval\n     */\n    public void removeColumnSelectionInterval(int index0, int index1) {\n        columnModel.getSelectionModel().removeSelectionInterval(boundColumn(index0), boundColumn(index1));\n    }"}
{"Number":"1329","API Relative Path":"javax.swing.JTable.java-removeRowSelectionInterval(int-int)","Corresponding Source":"/**\n     * Deselects the rows from <code>index0<\/code> to <code>index1<\/code>, inclusive.\n     *\n     * @exception IllegalArgumentException      if <code>index0<\/code> or\n     *                                          <code>index1<\/code> lie outside\n     *                                          [0, <code>getRowCount()<\/code>-1]\n     * @param   index0 one end of the interval\n     * @param   index1 the other end of the interval\n     */\n    public void removeRowSelectionInterval(int index0, int index1) {\n        selectionModel.removeSelectionInterval(boundRow(index0), boundRow(index1));\n    }"}
{"Number":"1330","API Relative Path":"javax.swing.JTable.java-setColumnSelectionInterval(int-int)","Corresponding Source":"/**\n     * Selects the columns from <code>index0<\/code> to <code>index1<\/code>,\n     * inclusive.\n     *\n     * @exception IllegalArgumentException      if <code>index0<\/code> or\n     *                                          <code>index1<\/code> lie outside\n     *                                          [0, <code>getColumnCount()<\/code>-1]\n     * @param   index0 one end of the interval\n     * @param   index1 the other end of the interval\n     */\n    public void setColumnSelectionInterval(int index0, int index1) {\n        columnModel.getSelectionModel().setSelectionInterval(boundColumn(index0), boundColumn(index1));\n    }"}
{"Number":"1331","API Relative Path":"javax.swing.JTable.java-setModel(TableModel)","Corresponding Source":"//\n// Managing models\n//\n\n    /**\n     * Sets the data model for this table to <code>newModel<\/code> and registers\n     * with it for listener notifications from the new data model.\n     *\n     * @param   dataModel        the new data source for this table\n     * @exception IllegalArgumentException      if <code>newModel<\/code> is <code>null<\/code>\n     * @see     #getModel\n     * @beaninfo\n     *  bound: true\n     *  description: The model that is the source of the data for this view.\n     */\n    public void setModel(TableModel dataModel) {\n        if (dataModel == null) {\n            throw new IllegalArgumentException(\"Cannot set a null TableModel\");\n        }\n        if (this.dataModel != dataModel) {\n            TableModel old = this.dataModel;\n            if (old != null) {\n                old.removeTableModelListener(this);\n            }\n            this.dataModel = dataModel;\n            dataModel.addTableModelListener(this);\n\n            tableChanged(new TableModelEvent(dataModel, TableModelEvent.HEADER_ROW));\n\n            firePropertyChange(\"model\", old, dataModel);\n\n            if (getAutoCreateRowSorter()) {\n                setRowSorter(new TableRowSorter<TableModel>(dataModel));\n            }\n        }\n    }"}
{"Number":"1332","API Relative Path":"javax.swing.JTable.java-setRowHeight(int)","Corresponding Source":"/**\n     * Sets the height, in pixels, of all cells to <code>rowHeight<\/code>,\n     * revalidates, and repaints.\n     * The height of the cells will be equal to the row height minus\n     * the row margin.\n     *\n     * @param   rowHeight                       new row height\n     * @exception IllegalArgumentException      if <code>rowHeight<\/code> is\n     *                                          less than 1\n     * @see     #getRowHeight\n     * @beaninfo\n     *  bound: true\n     *  description: The height of the specified row.\n     */\n    public void setRowHeight(int rowHeight) {\n        if (rowHeight <= 0) {\n            throw new IllegalArgumentException(\"New row height less than 1\");\n        }\n        int old = this.rowHeight;\n        this.rowHeight = rowHeight;\n        rowModel = null;\n        if (sortManager != null) {\n            sortManager.modelRowSizes = null;\n        }\n        isRowHeightSet = true;\n        resizeAndRepaint();\n        firePropertyChange(\"rowHeight\", old, rowHeight);\n    }"}
{"Number":"1333","API Relative Path":"javax.swing.JTable.java-setRowHeight(int-int)","Corresponding Source":"/**\n     * Sets the height for <code>row<\/code> to <code>rowHeight<\/code>,\n     * revalidates, and repaints. The height of the cells in this row\n     * will be equal to the row height minus the row margin.\n     *\n     * @param   row                             the row whose height is being\n                                                changed\n     * @param   rowHeight                       new row height, in pixels\n     * @exception IllegalArgumentException      if <code>rowHeight<\/code> is\n     *                                          less than 1\n     * @beaninfo\n     *  bound: true\n     *  description: The height in pixels of the cells in <code>row<\/code>\n     * @since 1.3\n     */\n    public void setRowHeight(int row, int rowHeight) {\n        if (rowHeight <= 0) {\n            throw new IllegalArgumentException(\"New row height less than 1\");\n        }\n        getRowModel().setSize(row, rowHeight);\n        if (sortManager != null) {\n            sortManager.setViewRowHeight(row, rowHeight);\n        }\n        resizeAndRepaint();\n    }"}
{"Number":"1334","API Relative Path":"javax.swing.JTable.java-setRowSelectionInterval(int-int)","Corresponding Source":"/**\n     * Selects the rows from <code>index0<\/code> to <code>index1<\/code>,\n     * inclusive.\n     *\n     * @exception IllegalArgumentException      if <code>index0<\/code> or\n     *                                          <code>index1<\/code> lie outside\n     *                                          [0, <code>getRowCount()<\/code>-1]\n     * @param   index0 one end of the interval\n     * @param   index1 the other end of the interval\n     */\n    public void setRowSelectionInterval(int index0, int index1) {\n        selectionModel.setSelectionInterval(boundRow(index0), boundRow(index1));\n    }"}
{"Number":"1335","API Relative Path":"javax.swing.JTextArea.java-getLineEndOffset(int)","Corresponding Source":"/**\n     * Determines the offset of the end of the given line.\n     *\n     * @param line  the line &gt;= 0\n     * @return the offset &gt;= 0\n     * @exception BadLocationException Thrown if the line is\n     * less than zero or greater or equal to the number of\n     * lines contained in the document (as reported by\n     * getLineCount).\n     */\n    public int getLineEndOffset(int line) throws BadLocationException {\n        int lineCount = getLineCount();\n        if (line < 0) {\n            throw new BadLocationException(\"Negative line\", -1);\n        } else if (line >= lineCount) {\n            throw new BadLocationException(\"No such line\", getDocument().getLength()+1);\n        } else {\n            Element map = getDocument().getDefaultRootElement();\n            Element lineElem = map.getElement(line);\n            int endOffset = lineElem.getEndOffset();\n            // hide the implicit break at the end of the document\n            return ((line == lineCount - 1) ? (endOffset - 1) : endOffset);\n        }\n    }"}
{"Number":"1336","API Relative Path":"javax.swing.JTextArea.java-getLineStartOffset(int)","Corresponding Source":"/**\n     * Determines the offset of the start of the given line.\n     *\n     * @param line  the line number to translate &gt;= 0\n     * @return the offset &gt;= 0\n     * @exception BadLocationException thrown if the line is\n     * less than zero or greater or equal to the number of\n     * lines contained in the document (as reported by\n     * getLineCount).\n     */\n    public int getLineStartOffset(int line) throws BadLocationException {\n        int lineCount = getLineCount();\n        if (line < 0) {\n            throw new BadLocationException(\"Negative line\", -1);\n        } else if (line >= lineCount) {\n            throw new BadLocationException(\"No such line\", getDocument().getLength()+1);\n        } else {\n            Element map = getDocument().getDefaultRootElement();\n            Element lineElem = map.getElement(line);\n            return lineElem.getStartOffset();\n        }\n    }"}
{"Number":"1337","API Relative Path":"javax.swing.JTextField.java-addActionListener(ActionListener)","Corresponding Source":"/**\n     * Adds the specified action listener to receive\n     * action events from this textfield.\n     *\n     * @param l the action listener to be added\n     */\n    public synchronized void addActionListener(ActionListener l) {\n        listenerList.add(ActionListener.class, l);\n    }"}
{"Number":"1338","API Relative Path":"javax.swing.JTextField.java-removeActionListener(ActionListener)","Corresponding Source":"/**\n     * Removes the specified action listener so that it no longer\n     * receives action events from this textfield.\n     *\n     * @param l the action listener to be removed\n     */\n    public synchronized void removeActionListener(ActionListener l) {\n        if ((l != null) && (getAction() == l)) {\n            setAction(null);\n        } else {\n            listenerList.remove(ActionListener.class, l);\n        }\n    }"}
{"Number":"1339","API Relative Path":"javax.swing.JTextField.java-setAction(Action)","Corresponding Source":"/**\n     * Sets the <code>Action<\/code> for the <code>ActionEvent<\/code> source.\n     * The new <code>Action<\/code> replaces\n     * any previously set <code>Action<\/code> but does not affect\n     * <code>ActionListeners<\/code> independently\n     * added with <code>addActionListener<\/code>.\n     * If the <code>Action<\/code> is already a registered\n     * <code>ActionListener<\/code>\n     * for the <code>ActionEvent<\/code> source, it is not re-registered.\n     * <p>\n     * Setting the <code>Action<\/code> results in immediately changing\n     * all the properties described in <a href=\"Action.html#buttonActions\">\n     * Swing Components Supporting <code>Action<\/code><\/a>.\n     * Subsequently, the textfield's properties are automatically updated\n     * as the <code>Action<\/code>'s properties change.\n     * <p>\n     * This method uses three other methods to set\n     * and help track the <code>Action<\/code>'s property values.\n     * It uses the <code>configurePropertiesFromAction<\/code> method\n     * to immediately change the textfield's properties.\n     * To track changes in the <code>Action<\/code>'s property values,\n     * this method registers the <code>PropertyChangeListener<\/code>\n     * returned by <code>createActionPropertyChangeListener<\/code>. The\n     * default {@code PropertyChangeListener} invokes the\n     * {@code actionPropertyChanged} method when a property in the\n     * {@code Action} changes.\n     *\n     * @param a the <code>Action<\/code> for the <code>JTextField<\/code>,\n     *          or <code>null<\/code>\n     * @since 1.3\n     * @see Action\n     * @see #getAction\n     * @see #configurePropertiesFromAction\n     * @see #createActionPropertyChangeListener\n     * @see #actionPropertyChanged\n     * @beaninfo\n     *        bound: true\n     *    attribute: visualUpdate true\n     *  description: the Action instance connected with this ActionEvent source\n     */\n    public void setAction(Action a) {\n        Action oldValue = getAction();\n        if (action==null || !action.equals(a)) {\n            action = a;\n            if (oldValue!=null) {\n                removeActionListener(oldValue);\n                oldValue.removePropertyChangeListener(actionPropertyChangeListener);\n                actionPropertyChangeListener = null;\n            }\n            configurePropertiesFromAction(action);\n            if (action!=null) {\n                // Don't add if it is already a listener\n                if (!isListener(ActionListener.class, action)) {\n                    addActionListener(action);\n                }\n                // Reverse linkage:\n                actionPropertyChangeListener = createActionPropertyChangeListener(action);\n                action.addPropertyChangeListener(actionPropertyChangeListener);\n            }\n            firePropertyChange(\"action\", oldValue, action);\n        }\n    }"}
{"Number":"1340","API Relative Path":"javax.swing.JTextField.java-setHorizontalAlignment(int)","Corresponding Source":"/**\n     * Sets the horizontal alignment of the text.\n     * Valid keys are:\n     * <ul>\n     * <li><code>JTextField.LEFT<\/code>\n     * <li><code>JTextField.CENTER<\/code>\n     * <li><code>JTextField.RIGHT<\/code>\n     * <li><code>JTextField.LEADING<\/code>\n     * <li><code>JTextField.TRAILING<\/code>\n     * <\/ul>\n     * <code>invalidate<\/code> and <code>repaint<\/code> are called when the\n     * alignment is set,\n     * and a <code>PropertyChange<\/code> event (\"horizontalAlignment\") is fired.\n     *\n     * @param alignment the alignment\n     * @exception IllegalArgumentException if <code>alignment<\/code>\n     *  is not a valid key\n     * @beaninfo\n     *   preferred: true\n     *       bound: true\n     * description: Set the field alignment to LEFT, CENTER, RIGHT,\n     *              LEADING (the default) or TRAILING\n     *        enum: LEFT JTextField.LEFT CENTER JTextField.CENTER RIGHT JTextField.RIGHT\n     *              LEADING JTextField.LEADING TRAILING JTextField.TRAILING\n     */\n     public void setHorizontalAlignment(int alignment) {\n        if (alignment == horizontalAlignment) return;\n        int oldValue = horizontalAlignment;\n        if ((alignment == LEFT) || (alignment == CENTER) ||\n            (alignment == RIGHT)|| (alignment == LEADING) ||\n            (alignment == TRAILING)) {\n            horizontalAlignment = alignment;\n        } else {\n            throw new IllegalArgumentException(\"horizontalAlignment\");\n        }\n        firePropertyChange(\"horizontalAlignment\", oldValue, horizontalAlignment);\n        invalidate();\n        repaint();\n    }"}
{"Number":"1341","API Relative Path":"javax.swing.JTextPane.java-setDocument(Document)","Corresponding Source":"/**\n     * Associates the editor with a text document.  This\n     * must be a <code>StyledDocument<\/code>.\n     *\n     * @param doc  the document to display/edit\n     * @exception IllegalArgumentException  if <code>doc<\/code> can't\n     *   be narrowed to a <code>StyledDocument<\/code> which is the\n     *   required type of model for this text component\n     */\n    public void setDocument(Document doc) {\n        if (doc instanceof StyledDocument) {\n            super.setDocument(doc);\n        } else {\n            throw new IllegalArgumentException(\"Model must be StyledDocument\");\n        }\n    }"}
{"Number":"1342","API Relative Path":"javax.swing.JTextPane.java-setEditorKit(EditorKit)","Corresponding Source":"/**\n     * Sets the currently installed kit for handling\n     * content.  This is the bound property that\n     * establishes the content type of the editor.\n     *\n     * @param kit the desired editor behavior\n     * @exception IllegalArgumentException if kit is not a\n     *          <code>StyledEditorKit<\/code>\n     */\n    public final void setEditorKit(EditorKit kit) {\n        if (kit instanceof StyledEditorKit) {\n            super.setEditorKit(kit);\n        } else {\n            throw new IllegalArgumentException(\"Must be StyledEditorKit\");\n        }\n    }"}
{"Number":"1343","API Relative Path":"javax.swing.JToggleButton.java-JToggleButton(Action)","Corresponding Source":"/**\n     * Creates a toggle button where properties are taken from the\n     * Action supplied.\n     *\n     * @since 1.3\n     */\n    public JToggleButton(Action a) {\n        this();\n        setAction(a);\n    }"}
{"Number":"1344","API Relative Path":"javax.swing.JToolBar.java-add(Action)","Corresponding Source":"/**\n     * Adds a new <code>JButton<\/code> which dispatches the action.\n     *\n     * @param a the <code>Action<\/code> object to add as a new menu item\n     * @return the new button which dispatches the action\n     */\n    public JButton add(Action a) {\n        JButton b = createActionComponent(a);\n        b.setAction(a);\n        add(b);\n        return b;\n    }"}
{"Number":"1345","API Relative Path":"javax.swing.JTree.java-addTreeExpansionListener(TreeExpansionListener)","Corresponding Source":"/**\n     * Adds a listener for <code>TreeExpansion<\/code> events.\n     *\n     * @param tel a TreeExpansionListener that will be notified when\n     *            a tree node is expanded or collapsed (a \"negative\n     *            expansion\")\n     */\n    public void addTreeExpansionListener(TreeExpansionListener tel) {\n        if (settingUI) {\n            uiTreeExpansionListener = tel;\n        }\n        listenerList.add(TreeExpansionListener.class, tel);\n    }"}
{"Number":"1346","API Relative Path":"javax.swing.JTree.java-addTreeSelectionListener(TreeSelectionListener)","Corresponding Source":"/**\n     * Adds a listener for <code>TreeSelection<\/code> events.\n     *\n     * @param tsl the <code>TreeSelectionListener<\/code> that will be notified\n     *            when a node is selected or deselected (a \"negative\n     *            selection\")\n     */\n    public void addTreeSelectionListener(TreeSelectionListener tsl) {\n        listenerList.add(TreeSelectionListener.class,tsl);\n        if(listenerList.getListenerCount(TreeSelectionListener.class) != 0\n           && selectionRedirector == null) {\n            selectionRedirector = new TreeSelectionRedirector();\n            selectionModel.addTreeSelectionListener(selectionRedirector);\n        }\n    }"}
{"Number":"1347","API Relative Path":"javax.swing.JTree.java-addTreeWillExpandListener(TreeWillExpandListener)","Corresponding Source":"/**\n     * Adds a listener for <code>TreeWillExpand<\/code> events.\n     *\n     * @param tel a <code>TreeWillExpandListener<\/code> that will be notified\n     *            when a tree node will be expanded or collapsed (a \"negative\n     *            expansion\")\n     */\n    public void addTreeWillExpandListener(TreeWillExpandListener tel) {\n        listenerList.add(TreeWillExpandListener.class, tel);\n    }"}
{"Number":"1348","API Relative Path":"javax.swing.JTree.java-collapsePath(TreePath)","Corresponding Source":"/**\n     * Ensures that the node identified by the specified path is\n     * collapsed and viewable.\n     *\n     * @param path  the <code>TreePath<\/code> identifying a node\n      */\n    public void collapsePath(TreePath path) {\n        setExpandedState(path, false);\n    }"}
{"Number":"1349","API Relative Path":"javax.swing.JTree.java-expandPath(TreePath)","Corresponding Source":"/**\n     * Ensures that the node identified by the specified path is\n     * expanded and viewable. If the last item in the path is a\n     * leaf, this will have no effect.\n     *\n     * @param path  the <code>TreePath<\/code> identifying a node\n     */\n    public void expandPath(TreePath path) {\n        // Only expand if not leaf!\n        TreeModel          model = getModel();\n\n        if(path != null && model != null &&\n           !model.isLeaf(path.getLastPathComponent())) {\n            setExpandedState(path, true);\n        }\n    }"}
{"Number":"1350","API Relative Path":"javax.swing.JTree.java-expandPath(TreePath)","Corresponding Source":"/**\n     * Ensures that the node identified by the specified path is\n     * expanded and viewable. If the last item in the path is a\n     * leaf, this will have no effect.\n     *\n     * @param path  the <code>TreePath<\/code> identifying a node\n     */\n    public void expandPath(TreePath path) {\n        // Only expand if not leaf!\n        TreeModel          model = getModel();\n\n        if(path != null && model != null &&\n           !model.isLeaf(path.getLastPathComponent())) {\n            setExpandedState(path, true);\n        }\n    }"}
{"Number":"1351","API Relative Path":"javax.swing.JTree.java-getDescendantToggledPaths(TreePath)","Corresponding Source":"/**\n     * Returns an <code>Enumeration<\/code> of <code>TreePaths<\/code>\n     * that have been expanded that\n     * are descendants of <code>parent<\/code>.\n     */\n    protected Enumeration<TreePath>\n        getDescendantToggledPaths(TreePath parent)\n    {\n        if(parent == null)\n            return null;\n\n        Vector<TreePath> descendants = new Vector<TreePath>();\n        Enumeration<TreePath> nodes = expandedState.keys();\n\n        while(nodes.hasMoreElements()) {\n            TreePath path = nodes.nextElement();\n            if(parent.isDescendant(path))\n                descendants.addElement(path);\n        }\n        return descendants.elements();\n    }"}
{"Number":"1352","API Relative Path":"javax.swing.JTree.java-makeVisible(TreePath)","Corresponding Source":"/**\n     * Ensures that the node identified by path is currently viewable.\n     *\n     * @param path  the <code>TreePath<\/code> to make visible\n     */\n    public void makeVisible(TreePath path) {\n        if(path != null) {\n            TreePath        parentPath = path.getParentPath();\n\n            if(parentPath != null) {\n                expandPath(parentPath);\n            }\n        }\n    }"}
{"Number":"1353","API Relative Path":"javax.swing.JTree.java-removeDescendantToggledPaths(Enumeration)","Corresponding Source":"/**\n     * Removes any descendants of the <code>TreePaths<\/code> in\n     * <code>toRemove<\/code>\n     * that have been expanded.\n     *\n     * @param toRemove an enumeration of the paths to remove; a value of\n     *        {@code null} is ignored\n     * @throws ClassCastException if {@code toRemove} contains an\n     *         element that is not a {@code TreePath}; {@code null}\n     *         values are ignored\n     */\n     protected void\n         removeDescendantToggledPaths(Enumeration<TreePath> toRemove)\n    {\n         if(toRemove != null) {\n             while(toRemove.hasMoreElements()) {\n                 Enumeration<?> descendants = getDescendantToggledPaths\n                         (toRemove.nextElement());\n\n                 if(descendants != null) {\n                     while(descendants.hasMoreElements()) {\n                         expandedState.remove(descendants.nextElement());\n                     }\n                 }\n             }\n         }\n     }"}
{"Number":"1354","API Relative Path":"javax.swing.JTree.java-removeTreeExpansionListener(TreeExpansionListener)","Corresponding Source":"/**\n     * Removes a listener for <code>TreeExpansion<\/code> events.\n     *\n     * @param tel the <code>TreeExpansionListener<\/code> to remove\n     */\n    public void removeTreeExpansionListener(TreeExpansionListener tel) {\n        listenerList.remove(TreeExpansionListener.class, tel);\n        if (uiTreeExpansionListener == tel) {\n            uiTreeExpansionListener = null;\n        }\n    }"}
{"Number":"1355","API Relative Path":"javax.swing.JTree.java-removeTreeSelectionListener(TreeSelectionListener)","Corresponding Source":"/**\n     * Removes a <code>TreeSelection<\/code> listener.\n     *\n     * @param tsl the <code>TreeSelectionListener<\/code> to remove\n     */\n    public void removeTreeSelectionListener(TreeSelectionListener tsl) {\n        listenerList.remove(TreeSelectionListener.class,tsl);\n        if(listenerList.getListenerCount(TreeSelectionListener.class) == 0\n           && selectionRedirector != null) {\n            selectionModel.removeTreeSelectionListener\n                (selectionRedirector);\n            selectionRedirector = null;\n        }\n    }"}
{"Number":"1356","API Relative Path":"javax.swing.JTree.java-removeTreeWillExpandListener(TreeWillExpandListener)","Corresponding Source":"/**\n     * Removes a listener for <code>TreeWillExpand<\/code> events.\n     *\n     * @param tel the <code>TreeWillExpandListener<\/code> to remove\n     */\n    public void removeTreeWillExpandListener(TreeWillExpandListener tel) {\n        listenerList.remove(TreeWillExpandListener.class, tel);\n    }"}
{"Number":"1357","API Relative Path":"javax.swing.JTree.java-scrollPathToVisible(TreePath)","Corresponding Source":"/**\n     * Makes sure all the path components in path are expanded (except\n     * for the last path component) and scrolls so that the\n     * node identified by the path is displayed. Only works when this\n     * <code>JTree<\/code> is contained in a <code>JScrollPane<\/code>.\n     *\n     * @param path  the <code>TreePath<\/code> identifying the node to\n     *          bring into view\n     */\n    public void scrollPathToVisible(TreePath path) {\n        if(path != null) {\n            makeVisible(path);\n\n            Rectangle          bounds = getPathBounds(path);\n\n            if(bounds != null) {\n                scrollRectToVisible(bounds);\n                if (accessibleContext != null) {\n                    ((AccessibleJTree)accessibleContext).fireVisibleDataPropertyChange();\n                }\n            }\n        }\n    }"}
{"Number":"1358","API Relative Path":"javax.swing.JTree.java-scrollPathToVisible(TreePath)","Corresponding Source":"/**\n     * Makes sure all the path components in path are expanded (except\n     * for the last path component) and scrolls so that the\n     * node identified by the path is displayed. Only works when this\n     * <code>JTree<\/code> is contained in a <code>JScrollPane<\/code>.\n     *\n     * @param path  the <code>TreePath<\/code> identifying the node to\n     *          bring into view\n     */\n    public void scrollPathToVisible(TreePath path) {\n        if(path != null) {\n            makeVisible(path);\n\n            Rectangle          bounds = getPathBounds(path);\n\n            if(bounds != null) {\n                scrollRectToVisible(bounds);\n                if (accessibleContext != null) {\n                    ((AccessibleJTree)accessibleContext).fireVisibleDataPropertyChange();\n                }\n            }\n        }\n    }"}
{"Number":"1359","API Relative Path":"javax.swing.JTree.java-setExpandedState(TreePath-boolean)","Corresponding Source":"/**\n     * Sets the expanded state of this <code>JTree<\/code>.\n     * If <code>state<\/code> is\n     * true, all parents of <code>path<\/code> and path are marked as\n     * expanded. If <code>state<\/code> is false, all parents of\n     * <code>path<\/code> are marked EXPANDED, but <code>path<\/code> itself\n     * is marked collapsed.<p>\n     * This will fail if a <code>TreeWillExpandListener<\/code> vetos it.\n     */\n    protected void setExpandedState(TreePath path, boolean state) {\n        if(path != null) {\n            // Make sure all parents of path are expanded.\n            Stack<TreePath> stack;\n            TreePath parentPath = path.getParentPath();\n\n            if (expandedStack.size() == 0) {\n                stack = new Stack<TreePath>();\n            }\n            else {\n                stack = expandedStack.pop();\n            }\n\n            try {\n                while(parentPath != null) {\n                    if(isExpanded(parentPath)) {\n                        parentPath = null;\n                    }\n                    else {\n                        stack.push(parentPath);\n                        parentPath = parentPath.getParentPath();\n                    }\n                }\n                for(int counter = stack.size() - 1; counter >= 0; counter--) {\n                    parentPath = stack.pop();\n                    if(!isExpanded(parentPath)) {\n                        try {\n                            fireTreeWillExpand(parentPath);\n                        } catch (ExpandVetoException eve) {\n                            // Expand vetoed!\n                            return;\n                        }\n                        expandedState.put(parentPath, Boolean.TRUE);\n                        fireTreeExpanded(parentPath);\n                        if (accessibleContext != null) {\n                            ((AccessibleJTree)accessibleContext).\n                                              fireVisibleDataPropertyChange();\n                        }\n                    }\n                }\n            }\n            finally {\n                if (expandedStack.size() < TEMP_STACK_SIZE) {\n                    stack.removeAllElements();\n                    expandedStack.push(stack);\n                }\n            }\n            if(!state) {\n                // collapse last path.\n                Object          cValue = expandedState.get(path);\n\n                if(cValue != null && ((Boolean)cValue).booleanValue()) {\n                    try {\n                        fireTreeWillCollapse(path);\n                    }\n                    catch (ExpandVetoException eve) {\n                        return;\n                    }\n                    expandedState.put(path, Boolean.FALSE);\n                    fireTreeCollapsed(path);\n                    if (removeDescendantSelectedPaths(path, false) &&\n                        !isPathSelected(path)) {\n                        // A descendant was selected, select the parent.\n                        addSelectionPath(path);\n                    }\n                    if (accessibleContext != null) {\n                        ((AccessibleJTree)accessibleContext).\n                                    fireVisibleDataPropertyChange();\n                    }\n                }\n            }\n            else {\n                // Expand last path.\n                Object          cValue = expandedState.get(path);\n\n                if(cValue == null || !((Boolean)cValue).booleanValue()) {\n                    try {\n                        fireTreeWillExpand(path);\n                    }\n                    catch (ExpandVetoException eve) {\n                        return;\n                    }\n                    expandedState.put(path, Boolean.TRUE);\n                    fireTreeExpanded(path);\n                    if (accessibleContext != null) {\n                        ((AccessibleJTree)accessibleContext).\n                                          fireVisibleDataPropertyChange();\n                    }\n                }\n            }\n        }\n    }"}
{"Number":"1360","API Relative Path":"javax.swing.JViewport.java-addChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Adds a <code>ChangeListener<\/code> to the list that is\n     * notified each time the view's\n     * size, position, or the viewport's extent size has changed.\n     *\n     * @param l the <code>ChangeListener<\/code> to add\n     * @see #removeChangeListener\n     * @see #setViewPosition\n     * @see #setViewSize\n     * @see #setExtentSize\n     */\n    public void addChangeListener(ChangeListener l) {\n        listenerList.add(ChangeListener.class, l);\n    }"}
{"Number":"1361","API Relative Path":"javax.swing.JViewport.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Sets the <code>JViewport<\/code>'s one lightweight child,\n     * which can be <code>null<\/code>.\n     * (Since there is only one child which occupies the entire viewport,\n     * the <code>constraints<\/code> and <code>index<\/code>\n     * arguments are ignored.)\n     *\n     * @param child       the lightweight <code>child<\/code> of the viewport\n     * @param constraints the <code>constraints<\/code> to be respected\n     * @param index       the index\n     * @see #setView\n     */\n    protected void addImpl(Component child, Object constraints, int index) {\n      setView(child);\n    }"}
{"Number":"1362","API Relative Path":"javax.swing.JViewport.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Sets the <code>JViewport<\/code>'s one lightweight child,\n     * which can be <code>null<\/code>.\n     * (Since there is only one child which occupies the entire viewport,\n     * the <code>constraints<\/code> and <code>index<\/code>\n     * arguments are ignored.)\n     *\n     * @param child       the lightweight <code>child<\/code> of the viewport\n     * @param constraints the <code>constraints<\/code> to be respected\n     * @param index       the index\n     * @see #setView\n     */\n    protected void addImpl(Component child, Object constraints, int index) {\n      setView(child);\n    }"}
{"Number":"1363","API Relative Path":"javax.swing.JViewport.java-removeChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Removes a <code>ChangeListener<\/code> from the list that's notified each\n     * time the views size, position, or the viewports extent size\n     * has changed.\n     *\n     * @param l the <code>ChangeListener<\/code> to remove\n     * @see #addChangeListener\n     */\n    public void removeChangeListener(ChangeListener l) {\n        listenerList.remove(ChangeListener.class, l);\n    }"}
{"Number":"1364","API Relative Path":"javax.swing.JViewport.java-setBorder(Border)","Corresponding Source":"/**\n     * The viewport \"scrolls\" its child (called the \"view\") by the\n     * normal parent/child clipping (typically the view is moved in\n     * the opposite direction of the scroll).  A non-<code>null<\/code> border,\n     * or non-zero insets, isn't supported, to prevent the geometry\n     * of this component from becoming complex enough to inhibit\n     * subclassing.  To create a <code>JViewport<\/code> with a border,\n     * add it to a <code>JPanel<\/code> that has a border.\n     * <p>Note:  If <code>border<\/code> is non-<code>null<\/code>, this\n     * method will throw an exception as borders are not supported on\n     * a <code>JViewPort<\/code>.\n     *\n     * @param border the <code>Border<\/code> to set\n     * @exception IllegalArgumentException this method is not implemented\n     */\n    public final void setBorder(Border border) {\n        if (border != null) {\n            throw new IllegalArgumentException(\"JViewport.setBorder() not supported\");\n        }\n    }"}
{"Number":"1365","API Relative Path":"javax.swing.JViewport.java-setBorder(Border)","Corresponding Source":"/**\n     * The viewport \"scrolls\" its child (called the \"view\") by the\n     * normal parent/child clipping (typically the view is moved in\n     * the opposite direction of the scroll).  A non-<code>null<\/code> border,\n     * or non-zero insets, isn't supported, to prevent the geometry\n     * of this component from becoming complex enough to inhibit\n     * subclassing.  To create a <code>JViewport<\/code> with a border,\n     * add it to a <code>JPanel<\/code> that has a border.\n     * <p>Note:  If <code>border<\/code> is non-<code>null<\/code>, this\n     * method will throw an exception as borders are not supported on\n     * a <code>JViewPort<\/code>.\n     *\n     * @param border the <code>Border<\/code> to set\n     * @exception IllegalArgumentException this method is not implemented\n     */\n    public final void setBorder(Border border) {\n        if (border != null) {\n            throw new IllegalArgumentException(\"JViewport.setBorder() not supported\");\n        }\n    }"}
{"Number":"1366","API Relative Path":"javax.swing.JViewport.java-setView(Component)","Corresponding Source":"/**\n     * Sets the <code>JViewport<\/code>'s one lightweight child\n     * (<code>view<\/code>), which can be <code>null<\/code>.\n     *\n     * @param view the viewport's new lightweight child\n     *\n     * @see #getView\n     */\n    public void setView(Component view) {\n\n        /* Remove the viewport's existing children, if any.\n         * Note that removeAll() isn't used here because it\n         * doesn't call remove() (which JViewport overrides).\n         */\n        int n = getComponentCount();\n        for(int i = n - 1; i >= 0; i--) {\n            remove(getComponent(i));\n        }\n\n        isViewSizeSet = false;\n\n        if (view != null) {\n            super.addImpl(view, null, -1);\n            viewListener = createViewListener();\n            view.addComponentListener(viewListener);\n        }\n\n        if (hasHadValidView) {\n            // Only fire a change if a view has been installed.\n            fireStateChanged();\n        }\n        else if (view != null) {\n            hasHadValidView = true;\n        }\n\n        viewChanged = true;\n\n        revalidate();\n        repaint();\n    }"}
{"Number":"1367","API Relative Path":"javax.swing.JViewport.java-setView(Component)","Corresponding Source":"/**\n     * Sets the <code>JViewport<\/code>'s one lightweight child\n     * (<code>view<\/code>), which can be <code>null<\/code>.\n     *\n     * @param view the viewport's new lightweight child\n     *\n     * @see #getView\n     */\n    public void setView(Component view) {\n\n        /* Remove the viewport's existing children, if any.\n         * Note that removeAll() isn't used here because it\n         * doesn't call remove() (which JViewport overrides).\n         */\n        int n = getComponentCount();\n        for(int i = n - 1; i >= 0; i--) {\n            remove(getComponent(i));\n        }\n\n        isViewSizeSet = false;\n\n        if (view != null) {\n            super.addImpl(view, null, -1);\n            viewListener = createViewListener();\n            view.addComponentListener(viewListener);\n        }\n\n        if (hasHadValidView) {\n            // Only fire a change if a view has been installed.\n            fireStateChanged();\n        }\n        else if (view != null) {\n            hasHadValidView = true;\n        }\n\n        viewChanged = true;\n\n        revalidate();\n        repaint();\n    }"}
{"Number":"1368","API Relative Path":"javax.swing.JWindow.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified child <code>Component<\/code>.\n     * This method is overridden to conditionally forward calls to the\n     * <code>contentPane<\/code>.\n     * By default, children are added to the <code>contentPane<\/code> instead\n     * of the frame, refer to {@link javax.swing.RootPaneContainer} for\n     * details.\n     *\n     * @param comp the component to be enhanced\n     * @param constraints the constraints to be respected\n     * @param index the index\n     * @exception IllegalArgumentException if <code>index<\/code> is invalid\n     * @exception IllegalArgumentException if adding the container's parent\n     *                  to itself\n     * @exception IllegalArgumentException if adding a window to a container\n     *\n     * @see #setRootPaneCheckingEnabled\n     * @see javax.swing.RootPaneContainer\n     */\n    protected void addImpl(Component comp, Object constraints, int index)\n    {\n        if(isRootPaneCheckingEnabled()) {\n            getContentPane().add(comp, constraints, index);\n        }\n        else {\n            super.addImpl(comp, constraints, index);\n        }\n    }"}
{"Number":"1369","API Relative Path":"javax.swing.JWindow.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified child <code>Component<\/code>.\n     * This method is overridden to conditionally forward calls to the\n     * <code>contentPane<\/code>.\n     * By default, children are added to the <code>contentPane<\/code> instead\n     * of the frame, refer to {@link javax.swing.RootPaneContainer} for\n     * details.\n     *\n     * @param comp the component to be enhanced\n     * @param constraints the constraints to be respected\n     * @param index the index\n     * @exception IllegalArgumentException if <code>index<\/code> is invalid\n     * @exception IllegalArgumentException if adding the container's parent\n     *                  to itself\n     * @exception IllegalArgumentException if adding a window to a container\n     *\n     * @see #setRootPaneCheckingEnabled\n     * @see javax.swing.RootPaneContainer\n     */\n    protected void addImpl(Component comp, Object constraints, int index)\n    {\n        if(isRootPaneCheckingEnabled()) {\n            getContentPane().add(comp, constraints, index);\n        }\n        else {\n            super.addImpl(comp, constraints, index);\n        }\n    }"}
{"Number":"1370","API Relative Path":"javax.swing.JWindow.java-addImpl(Component-Object-int)","Corresponding Source":"/**\n     * Adds the specified child <code>Component<\/code>.\n     * This method is overridden to conditionally forward calls to the\n     * <code>contentPane<\/code>.\n     * By default, children are added to the <code>contentPane<\/code> instead\n     * of the frame, refer to {@link javax.swing.RootPaneContainer} for\n     * details.\n     *\n     * @param comp the component to be enhanced\n     * @param constraints the constraints to be respected\n     * @param index the index\n     * @exception IllegalArgumentException if <code>index<\/code> is invalid\n     * @exception IllegalArgumentException if adding the container's parent\n     *                  to itself\n     * @exception IllegalArgumentException if adding a window to a container\n     *\n     * @see #setRootPaneCheckingEnabled\n     * @see javax.swing.RootPaneContainer\n     */\n    protected void addImpl(Component comp, Object constraints, int index)\n    {\n        if(isRootPaneCheckingEnabled()) {\n            getContentPane().add(comp, constraints, index);\n        }\n        else {\n            super.addImpl(comp, constraints, index);\n        }\n    }"}
{"Number":"1371","API Relative Path":"javax.swing.KeyStroke.java-getKeyStroke(String)","Corresponding Source":"/**\n     * Parses a string and returns a <code>KeyStroke<\/code>.\n     * The string must have the following syntax:\n     * <pre>\n     *    &lt;modifiers&gt;* (&lt;typedID&gt; | &lt;pressedReleasedID&gt;)\n     *\n     *    modifiers := shift | control | ctrl | meta | alt | altGraph\n     *    typedID := typed &lt;typedKey&gt;\n     *    typedKey := string of length 1 giving Unicode character.\n     *    pressedReleasedID := (pressed | released) key\n     *    key := KeyEvent key code name, i.e. the name following \"VK_\".\n     * <\/pre>\n     * If typed, pressed or released is not specified, pressed is assumed. Here\n     * are some examples:\n     * <pre>\n     *     \"INSERT\" =&gt; getKeyStroke(KeyEvent.VK_INSERT, 0);\n     *     \"control DELETE\" =&gt; getKeyStroke(KeyEvent.VK_DELETE, InputEvent.CTRL_MASK);\n     *     \"alt shift X\" =&gt; getKeyStroke(KeyEvent.VK_X, InputEvent.ALT_MASK | InputEvent.SHIFT_MASK);\n     *     \"alt shift released X\" =&gt; getKeyStroke(KeyEvent.VK_X, InputEvent.ALT_MASK | InputEvent.SHIFT_MASK, true);\n     *     \"typed a\" =&gt; getKeyStroke('a');\n     * <\/pre>\n     *\n     * In order to maintain backward-compatibility, specifying a null String,\n     * or a String which is formatted incorrectly, returns null.\n     *\n     * @param s a String formatted as described above\n     * @return a KeyStroke object for that String, or null if the specified\n     *         String is null, or is formatted incorrectly\n     *\n     * @see java.awt.event.KeyEvent\n     */\n    public static KeyStroke getKeyStroke(String s) {\n        if (s == null || s.length() == 0) {\n            return null;\n        }\n        synchronized (AWTKeyStroke.class) {\n            registerSubclass(KeyStroke.class);\n            try {\n                return (KeyStroke)getAWTKeyStroke(s);\n            } catch (IllegalArgumentException e) {\n                return null;\n            }\n        }\n    }"}
{"Number":"1372","API Relative Path":"javax.swing.LookAndFeel.java-installProperty(JComponent-String-Object)","Corresponding Source":"/**\n     * Convenience method for installing a property with the specified name\n     * and value on a component if that property has not already been set\n     * by the developer.  This method is intended to be used by\n     * ui delegate instances that need to specify a default value for a\n     * property of primitive type (boolean, int, ..), but do not wish\n     * to override a value set by the client.  Since primitive property\n     * values cannot be wrapped with the {@code UIResource} marker, this method\n     * uses private state to determine whether the property has been set\n     * by the client.\n     *\n     * @throws IllegalArgumentException if the specified property is not\n     *         one which can be set using this method\n     * @throws ClassCastException if the property value has not been set\n     *         by the developer and the type does not match the property's type\n     * @throws NullPointerException if {@code c} is {@code null}, or the\n     *         named property has not been set by the developer and\n     *         {@code propertyValue} is {@code null}\n     * @param c target component to set the property on\n     * @param propertyName name of the property to set\n     * @param propertyValue value of the property\n     * @since 1.5\n     */\n    public static void installProperty(JComponent c,\n                                       String propertyName, Object propertyValue) {\n        // this is a special case because the JPasswordField's ancestor hierarchy\n        // includes a class outside of javax.swing, thus we cannot call setUIProperty\n        // directly.\n        if (SunToolkit.isInstanceOf(c, \"javax.swing.JPasswordField\")) {\n            if (!((JPasswordField)c).customSetUIProperty(propertyName, propertyValue)) {\n                c.setUIProperty(propertyName, propertyValue);\n            }\n        } else {\n            c.setUIProperty(propertyName, propertyValue);\n        }\n    }"}
{"Number":"1373","API Relative Path":"javax.swing.LookAndFeel.java-loadKeyBindings(InputMap-Object[])","Corresponding Source":"/**\n     * Populates an {@code InputMap} with the specified bindings.\n     * The bindings are supplied as a list of alternating\n     * {@code keystroke-action key} pairs. The {@code keystroke} is either\n     * an instance of {@code KeyStroke}, or a {@code String}\n     * that identifies the {@code KeyStroke} for the binding. Refer\n     * to {@code KeyStroke.getKeyStroke(String)} for the specific\n     * format. The {@code action key} part of the pair is the key\n     * registered in the {@code InputMap} for the {@code KeyStroke}.\n     * <p>\n     * The following illustrates loading an {@code InputMap} with two\n     * {@code key-action} pairs:\n     * <pre>\n     *   LookAndFeel.loadKeyBindings(inputMap, new Object[] {\n     *     \"control X\", \"cut\",\n     *     \"control V\", \"paste\"\n     *   });\n     * <\/pre>\n     * <p>\n     * Supplying a {@code null} list of bindings ({@code keys}) does not\n     * change {@code retMap} in any way.\n     * <p>\n     * Specifying a {@code null} {@code action key} results in\n     * removing the {@code keystroke's} entry from the {@code InputMap}.\n     * A {@code null} {@code keystroke} is ignored.\n     *\n     * @param retMap {@code InputMap} to add the {@code key-action}\n     *               pairs to\n     * @param keys bindings to add to {@code retMap}\n     * @throws NullPointerException if {@code keys} is\n     *         {@code non-null}, not empty, and {@code retMap} is\n     *         {@code null}\n     *\n     * @see KeyStroke#getKeyStroke(String)\n     * @see InputMap\n     *\n     * @since 1.3\n     */\n    public static void loadKeyBindings(InputMap retMap, Object[] keys) {\n        if (keys != null) {\n            for (int counter = 0, maxCounter = keys.length;\n                 counter < maxCounter; counter++) {\n                Object keyStrokeO = keys[counter++];\n                KeyStroke ks = (keyStrokeO instanceof KeyStroke) ?\n                                (KeyStroke)keyStrokeO :\n                                KeyStroke.getKeyStroke((String)keyStrokeO);\n                retMap.put(ks, keys[counter]);\n            }\n        }\n    }"}
{"Number":"1374","API Relative Path":"javax.swing.LookAndFeel.java-makeComponentInputMap(JComponent-Object[])","Corresponding Source":"/**\n     * Creates a {@code ComponentInputMapUIResource} from\n     * <code>keys<\/code>. This is a convenience method for creating a\n     * new {@code ComponentInputMapUIResource}, invoking {@code\n     * loadKeyBindings(map, keys)}, and returning the {@code\n     * ComponentInputMapUIResource}.\n     *\n     * @param c component to create the {@code ComponentInputMapUIResource}\n     *          with\n     * @param keys alternating pairs of {@code keystroke-action key}\n     *        pairs as described in {@link #loadKeyBindings}\n     * @return newly created and populated {@code InputMapUIResource}\n     * @throws IllegalArgumentException if {@code c} is {@code null}\n     *\n     * @see #loadKeyBindings\n     * @see ComponentInputMapUIResource\n     *\n     * @since 1.3\n     */\n    public static ComponentInputMap makeComponentInputMap(JComponent c,\n                                                          Object[] keys) {\n        ComponentInputMap retMap = new ComponentInputMapUIResource(c);\n        loadKeyBindings(retMap, keys);\n        return retMap;\n    }"}
{"Number":"1375","API Relative Path":"javax.swing.LookAndFeel.java-makeInputMap(Object[])","Corresponding Source":"/**\n     * Creates a {@code InputMapUIResource} from <code>keys<\/code>. This is\n     * a convenience method for creating a new {@code InputMapUIResource},\n     * invoking {@code loadKeyBindings(map, keys)}, and returning the\n     * {@code InputMapUIResource}.\n     *\n     * @param keys alternating pairs of {@code keystroke-action key}\n     *        pairs as described in {@link #loadKeyBindings}\n     * @return newly created and populated {@code InputMapUIResource}\n     * @see #loadKeyBindings\n     *\n     * @since 1.3\n     */\n    public static InputMap makeInputMap(Object[] keys) {\n        InputMap retMap = new InputMapUIResource();\n        loadKeyBindings(retMap, keys);\n        return retMap;\n    }"}
{"Number":"1376","API Relative Path":"javax.swing.MenuSelectionManager.java-addChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Adds a ChangeListener to the button.\n     *\n     * @param l the listener to add\n     */\n    public void addChangeListener(ChangeListener l) {\n        listenerList.add(ChangeListener.class, l);\n    }"}
{"Number":"1377","API Relative Path":"javax.swing.MenuSelectionManager.java-removeChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Removes a ChangeListener from the button.\n     *\n     * @param l the listener to remove\n     */\n    public void removeChangeListener(ChangeListener l) {\n        listenerList.remove(ChangeListener.class, l);\n    }"}
{"Number":"1378","API Relative Path":"javax.swing.OverlayLayout.java-getLayoutAlignmentX(Container)","Corresponding Source":"/**\n     * Returns the alignment along the x axis for the container.\n     *\n     * @param target the container\n     * @return the alignment &gt;= 0.0f &amp;&amp; &lt;= 1.0f\n     */\n    public float getLayoutAlignmentX(Container target) {\n        checkContainer(target);\n        checkRequests();\n        return xTotal.alignment;\n    }"}
{"Number":"1379","API Relative Path":"javax.swing.OverlayLayout.java-getLayoutAlignmentY(Container)","Corresponding Source":"/**\n     * Returns the alignment along the y axis for the container.\n     *\n     * @param target the container\n     * @return the alignment &gt;= 0.0f &amp;&amp; &lt;= 1.0f\n     */\n    public float getLayoutAlignmentY(Container target) {\n        checkContainer(target);\n        checkRequests();\n        return yTotal.alignment;\n    }"}
{"Number":"1380","API Relative Path":"javax.swing.OverlayLayout.java-invalidateLayout(Container)","Corresponding Source":"/**\n     * Indicates a child has changed its layout related information,\n     * which causes any cached calculations to be flushed.\n     *\n     * @param target the container\n     */\n    public void invalidateLayout(Container target) {\n        checkContainer(target);\n        xChildren = null;\n        yChildren = null;\n        xTotal = null;\n        yTotal = null;\n    }"}
{"Number":"1381","API Relative Path":"javax.swing.OverlayLayout.java-layoutContainer(Container)","Corresponding Source":"/**\n     * Called by the AWT when the specified container needs to be laid out.\n     *\n     * @param target  the container to lay out\n     *\n     * @exception AWTError  if the target isn't the container specified to the\n     *                      constructor\n     */\n    public void layoutContainer(Container target) {\n        checkContainer(target);\n        checkRequests();\n\n        int nChildren = target.getComponentCount();\n        int[] xOffsets = new int[nChildren];\n        int[] xSpans = new int[nChildren];\n        int[] yOffsets = new int[nChildren];\n        int[] ySpans = new int[nChildren];\n\n        // determine the child placements\n        Dimension alloc = target.getSize();\n        Insets in = target.getInsets();\n        alloc.width -= in.left + in.right;\n        alloc.height -= in.top + in.bottom;\n        SizeRequirements.calculateAlignedPositions(alloc.width, xTotal,\n                                                   xChildren, xOffsets,\n                                                   xSpans);\n        SizeRequirements.calculateAlignedPositions(alloc.height, yTotal,\n                                                   yChildren, yOffsets,\n                                                   ySpans);\n\n        // flush changes to the container\n        for (int i = 0; i < nChildren; i++) {\n            Component c = target.getComponent(i);\n            c.setBounds(in.left + xOffsets[i], in.top + yOffsets[i],\n                        xSpans[i], ySpans[i]);\n        }\n    }"}
{"Number":"1382","API Relative Path":"javax.swing.OverlayLayout.java-maximumLayoutSize(Container)","Corresponding Source":"/**\n     * Returns the maximum dimensions needed to lay out the components\n     * contained in the specified target container.  Recomputes the\n     * layout if it has been invalidated, and factors in the inset setting\n     * returned by <code>getInset<\/code>.\n     *\n     * @param target the component that needs to be laid out\n     * @return a <code>Dimension<\/code> object containing the maximum\n     *         dimensions\n     * @see #preferredLayoutSize\n     */\n    public Dimension maximumLayoutSize(Container target) {\n        checkContainer(target);\n        checkRequests();\n\n        Dimension size = new Dimension(xTotal.maximum, yTotal.maximum);\n        Insets insets = target.getInsets();\n        size.width += insets.left + insets.right;\n        size.height += insets.top + insets.bottom;\n        return size;\n    }"}
{"Number":"1383","API Relative Path":"javax.swing.OverlayLayout.java-minimumLayoutSize(Container)","Corresponding Source":"/**\n     * Returns the minimum dimensions needed to lay out the components\n     * contained in the specified target container.  Recomputes the layout\n     * if it has been invalidated, and factors in the current inset setting.\n     *\n     * @param target the component which needs to be laid out\n     * @return a Dimension object containing the minimum dimensions\n     * @see #preferredLayoutSize\n     */\n    public Dimension minimumLayoutSize(Container target) {\n        checkContainer(target);\n        checkRequests();\n\n        Dimension size = new Dimension(xTotal.minimum, yTotal.minimum);\n        Insets insets = target.getInsets();\n        size.width += insets.left + insets.right;\n        size.height += insets.top + insets.bottom;\n        return size;\n    }"}
{"Number":"1384","API Relative Path":"javax.swing.OverlayLayout.java-preferredLayoutSize(Container)","Corresponding Source":"/**\n     * Returns the preferred dimensions for this layout given the components\n     * in the specified target container.  Recomputes the layout if it\n     * has been invalidated.  Factors in the current inset setting returned\n     * by getInsets().\n     *\n     * @param target the component which needs to be laid out\n     * @return a Dimension object containing the preferred dimensions\n     * @see #minimumLayoutSize\n     */\n    public Dimension preferredLayoutSize(Container target) {\n        checkContainer(target);\n        checkRequests();\n\n        Dimension size = new Dimension(xTotal.preferred, yTotal.preferred);\n        Insets insets = target.getInsets();\n        size.width += insets.left + insets.right;\n        size.height += insets.top + insets.bottom;\n        return size;\n    }"}
{"Number":"1385","API Relative Path":"javax.swing.plaf.basic.BasicComboBoxUI.java-getSizeForComponent(Component)","Corresponding Source":"/**\n     * Returns the size a component would have if used as a cell renderer.\n     *\n     * @param comp a {@code Component} to check\n     * @return size of the component\n     * @since 1.7\n     */\n    protected Dimension getSizeForComponent(Component comp) {\n        // This has been refactored out in hopes that it may be investigated and\n        // simplified for the next major release. adding/removing\n        // the component to the currentValuePane and changing the font may be\n        // redundant operations.\n        currentValuePane.add(comp);\n        comp.setFont(comboBox.getFont());\n        Dimension d = comp.getPreferredSize();\n        currentValuePane.remove(comp);\n        return d;\n    }"}
{"Number":"1386","API Relative Path":"javax.swing.plaf.basic.BasicComboBoxUI.java-getSizeForComponent(Component)","Corresponding Source":"/**\n     * Returns the size a component would have if used as a cell renderer.\n     *\n     * @param comp a {@code Component} to check\n     * @return size of the component\n     * @since 1.7\n     */\n    protected Dimension getSizeForComponent(Component comp) {\n        // This has been refactored out in hopes that it may be investigated and\n        // simplified for the next major release. adding/removing\n        // the component to the currentValuePane and changing the font may be\n        // redundant operations.\n        currentValuePane.add(comp);\n        comp.setFont(comboBox.getFont());\n        Dimension d = comp.getPreferredSize();\n        currentValuePane.remove(comp);\n        return d;\n    }"}
{"Number":"1387","API Relative Path":"javax.swing.plaf.basic.BasicComboPopup.java-installComboBoxModelListeners(ComboBoxModel)","Corresponding Source":"/**\n     * Installs the listeners on the combo box model. Any listeners installed\n     * on the combo box model should be removed in\n     * <code>uninstallComboBoxModelListeners<\/code>.\n     *\n     * @param model The combo box model to install listeners\n     * @see #uninstallComboBoxModelListeners\n     */\n    protected void installComboBoxModelListeners( ComboBoxModel model ) {\n        if (model != null && (listDataListener = createListDataListener()) != null) {\n            model.addListDataListener(listDataListener);\n        }\n    }"}
{"Number":"1388","API Relative Path":"javax.swing.plaf.basic.BasicComboPopup.java-uninstallComboBoxModelListeners(ComboBoxModel)","Corresponding Source":"//\n    // end ComboPopup method implementations\n    //======================================\n\n    /**\n     * Removes the listeners from the combo box model\n     *\n     * @param model The combo box model to install listeners\n     * @see #installComboBoxModelListeners\n     */\n    protected void uninstallComboBoxModelListeners( ComboBoxModel model ) {\n        if (model != null && listDataListener != null) {\n            model.removeListDataListener(listDataListener);\n        }\n    }"}
{"Number":"1389","API Relative Path":"javax.swing.plaf.basic.BasicHTML.java-getBaseline(JComponent-int-int-int-int)","Corresponding Source":"/**\n     * Gets the baseline for the specified component.  This digs out\n     * the View client property, and if non-null the baseline is calculated\n     * from it.  Otherwise the baseline is the value <code>y + ascent<\/code>.\n     */\n    static int getBaseline(JComponent c, int y, int ascent,\n                                  int w, int h) {\n        View view = (View)c.getClientProperty(BasicHTML.propertyKey);\n        if (view != null) {\n            int baseline = getHTMLBaseline(view, w, h);\n            if (baseline < 0) {\n                return baseline;\n            }\n            return y + baseline;\n        }\n        return y + ascent;\n    }"}
{"Number":"1390","API Relative Path":"javax.swing.plaf.basic.BasicInternalFrameUI.java-replacePane(JComponent-JComponent)","Corresponding Source":"/**\n      * Installs necessary mouse handlers on <code>newPane<\/code>\n      * and adds it to the frame.\n      * Reverse process for the <code>currentPane<\/code>.\n      */\n    protected void replacePane(JComponent currentPane, JComponent newPane) {\n        if(currentPane != null) {\n            deinstallMouseHandlers(currentPane);\n            frame.remove(currentPane);\n        }\n        if(newPane != null) {\n           frame.add(newPane);\n           installMouseHandlers(newPane);\n        }\n    }"}
{"Number":"1391","API Relative Path":"javax.swing.plaf.basic.BasicInternalFrameUI.java-replacePane(JComponent-JComponent)","Corresponding Source":"/**\n      * Installs necessary mouse handlers on <code>newPane<\/code>\n      * and adds it to the frame.\n      * Reverse process for the <code>currentPane<\/code>.\n      */\n    protected void replacePane(JComponent currentPane, JComponent newPane) {\n        if(currentPane != null) {\n            deinstallMouseHandlers(currentPane);\n            frame.remove(currentPane);\n        }\n        if(newPane != null) {\n           frame.add(newPane);\n           installMouseHandlers(newPane);\n        }\n    }"}
{"Number":"1392","API Relative Path":"javax.swing.plaf.basic.BasicLookAndFeel.java-createAudioAction(Object)","Corresponding Source":"/**\n     * Creates and returns an {@code Action} used to play a sound.\n     * <p>\n     * If {@code key} is {@code non-null}, an {@code Action} is created\n     * using the value from the defaults with key {@code key}. The value\n     * identifies the sound resource to load when\n     * {@code actionPerformed} is invoked on the {@code Action}. The\n     * sound resource is loaded into a {@code byte[]} by way of\n     * {@code getClass().getResourceAsStream()}.\n     *\n     * @param key the key identifying the audio action\n     * @return      an {@code Action} used to play the source, or {@code null}\n     *              if {@code key} is {@code null}\n     * @see #playSound(Action)\n     * @since 1.4\n     */\n    protected Action createAudioAction(Object key) {\n        if (key != null) {\n            String audioKey = (String)key;\n            String audioValue = (String)UIManager.get(key);\n            return new AudioAction(audioKey, audioValue);\n        } else {\n            return null;\n        }\n    }"}
{"Number":"1393","API Relative Path":"javax.swing.plaf.basic.BasicLookAndFeel.java-playSound(Action)","Corresponding Source":"/**\n     * If necessary, invokes {@code actionPerformed} on\n     * {@code audioAction} to play a sound.\n     * The {@code actionPerformed} method is invoked if the value of\n     * the {@code \"AuditoryCues.playList\"} default is a {@code\n     * non-null} {@code Object[]} containing a {@code String} entry\n     * equal to the name of the {@code audioAction}.\n     *\n     * @param audioAction an Action that knows how to render the audio\n     *                    associated with the system or user activity\n     *                    that is occurring; a value of {@code null}, is\n     *                    ignored\n     * @throws ClassCastException if {@code audioAction} is {@code non-null}\n     *         and the value of the default {@code \"AuditoryCues.playList\"}\n     *         is not an {@code Object[]}\n     * @since 1.4\n     */\n    protected void playSound(Action audioAction) {\n        if (audioAction != null) {\n            Object[] audioStrings = (Object[])\n                                    UIManager.get(\"AuditoryCues.playList\");\n            if (audioStrings != null) {\n                // create a HashSet to help us decide to play or not\n                HashSet<Object> audioCues = new HashSet<Object>();\n                for (Object audioString : audioStrings) {\n                    audioCues.add(audioString);\n                }\n                // get the name of the Action\n                String actionName = (String)audioAction.getValue(Action.NAME);\n                // if the actionName is in the audioCues HashSet, play it.\n                if (audioCues.contains(actionName)) {\n                    audioAction.actionPerformed(new\n                        ActionEvent(this, ActionEvent.ACTION_PERFORMED,\n                                    actionName));\n                }\n            }\n        }\n    }"}
{"Number":"1394","API Relative Path":"javax.swing.plaf.basic.BasicOptionPaneUI.java-addButtonComponents(Container-Object[]-int)","Corresponding Source":"/**\n     * Creates the appropriate object to represent each of the objects in\n     * <code>buttons<\/code> and adds it to <code>container<\/code>. This\n     * differs from addMessageComponents in that it will recurse on\n     * <code>buttons<\/code> and that if button is not a Component\n     * it will create an instance of JButton.\n     */\n    protected void addButtonComponents(Container container, Object[] buttons,\n                                 int initialIndex) {\n        if (buttons != null && buttons.length > 0) {\n            boolean            sizeButtonsToSame = getSizeButtonsToSameWidth();\n            boolean            createdAll = true;\n            int                numButtons = buttons.length;\n            JButton[]          createdButtons = null;\n            int                maxWidth = 0;\n\n            if (sizeButtonsToSame) {\n                createdButtons = new JButton[numButtons];\n            }\n\n            for(int counter = 0; counter < numButtons; counter++) {\n                Object       button = buttons[counter];\n                Component    newComponent;\n\n                if (button instanceof Component) {\n                    createdAll = false;\n                    newComponent = (Component)button;\n                    container.add(newComponent);\n                    hasCustomComponents = true;\n\n                } else {\n                    JButton      aButton;\n\n                    if (button instanceof ButtonFactory) {\n                        aButton = ((ButtonFactory)button).createButton();\n                    }\n                    else if (button instanceof Icon)\n                        aButton = new JButton((Icon)button);\n                    else\n                        aButton = new JButton(button.toString());\n\n                    aButton.setName(\"OptionPane.button\");\n                    aButton.setMultiClickThreshhold(DefaultLookup.getInt(\n                          optionPane, this, \"OptionPane.buttonClickThreshhold\",\n                          0));\n                    configureButton(aButton);\n\n                    container.add(aButton);\n\n                    ActionListener buttonListener = createButtonActionListener(counter);\n                    if (buttonListener != null) {\n                        aButton.addActionListener(buttonListener);\n                    }\n                    newComponent = aButton;\n                }\n                if (sizeButtonsToSame && createdAll &&\n                   (newComponent instanceof JButton)) {\n                    createdButtons[counter] = (JButton)newComponent;\n                    maxWidth = Math.max(maxWidth,\n                                        newComponent.getMinimumSize().width);\n                }\n                if (counter == initialIndex) {\n                    initialFocusComponent = newComponent;\n                    if (initialFocusComponent instanceof JButton) {\n                        JButton defaultB = (JButton)initialFocusComponent;\n                        defaultB.addHierarchyListener(new HierarchyListener() {\n                            public void hierarchyChanged(HierarchyEvent e) {\n                                if ((e.getChangeFlags() &\n                                        HierarchyEvent.PARENT_CHANGED) != 0) {\n                                    JButton defaultButton = (JButton) e.getComponent();\n                                    JRootPane root =\n                                            SwingUtilities.getRootPane(defaultButton);\n                                    if (root != null) {\n                                        root.setDefaultButton(defaultButton);\n                                    }\n                                }\n                            }\n                        });\n                    }\n                }\n            }\n            ((ButtonAreaLayout)container.getLayout()).\n                              setSyncAllWidths((sizeButtonsToSame && createdAll));\n            /* Set the padding, windows seems to use 8 if <= 2 components,\n               otherwise 4 is used. It may actually just be the size of the\n               buttons is always the same, not sure. */\n            if (DefaultLookup.getBoolean(optionPane, this,\n                   \"OptionPane.setButtonMargin\", true) && sizeButtonsToSame &&\n                   createdAll) {\n                JButton               aButton;\n                int                   padSize;\n\n                padSize = (numButtons <= 2? 8 : 4);\n\n                for(int counter = 0; counter < numButtons; counter++) {\n                    aButton = createdButtons[counter];\n                    aButton.setMargin(new Insets(2, padSize, 2, padSize));\n                }\n            }\n        }\n    }"}
{"Number":"1395","API Relative Path":"javax.swing.plaf.basic.BasicOptionPaneUI.java-addMessageComponents(Container-GridBagConstraints-Object-int-boolean)","Corresponding Source":"/**\n     * Creates the appropriate object to represent <code>msg<\/code> and\n     * places it into <code>container<\/code>. If <code>msg<\/code> is an\n     * instance of Component, it is added directly, if it is an Icon,\n     * a JLabel is created to represent it, otherwise a JLabel is\n     * created for the string, if <code>d<\/code> is an Object[], this\n     * method will be recursively invoked for the children.\n     * <code>internallyCreated<\/code> is true if Objc is an instance\n     * of Component and was created internally by this method (this is\n     * used to correctly set hasCustomComponents only if !internallyCreated).\n     */\n    protected void addMessageComponents(Container container,\n                                     GridBagConstraints cons,\n                                     Object msg, int maxll,\n                                     boolean internallyCreated) {\n        if (msg == null) {\n            return;\n        }\n        if (msg instanceof Component) {\n            // To workaround problem where Gridbad will set child\n            // to its minimum size if its preferred size will not fit\n            // within allocated cells\n            if (msg instanceof JScrollPane || msg instanceof JPanel) {\n                cons.fill = GridBagConstraints.BOTH;\n                cons.weighty = 1;\n            } else {\n                cons.fill = GridBagConstraints.HORIZONTAL;\n            }\n            cons.weightx = 1;\n\n            container.add((Component) msg, cons);\n            cons.weightx = 0;\n            cons.weighty = 0;\n            cons.fill = GridBagConstraints.NONE;\n            cons.gridy++;\n            if (!internallyCreated) {\n                hasCustomComponents = true;\n            }\n\n        } else if (msg instanceof Object[]) {\n            Object [] msgs = (Object[]) msg;\n            for (Object o : msgs) {\n                addMessageComponents(container, cons, o, maxll, false);\n            }\n\n        } else if (msg instanceof Icon) {\n            JLabel label = new JLabel( (Icon)msg, SwingConstants.CENTER );\n            configureMessageLabel(label);\n            addMessageComponents(container, cons, label, maxll, true);\n\n        } else {\n            String s = msg.toString();\n            int len = s.length();\n            if (len <= 0) {\n                return;\n            }\n            int nl;\n            int nll = 0;\n\n            if ((nl = s.indexOf(newline)) >= 0) {\n                nll = newline.length();\n            } else if ((nl = s.indexOf(\"\\r\\n\")) >= 0) {\n                nll = 2;\n            } else if ((nl = s.indexOf('\\n')) >= 0) {\n                nll = 1;\n            }\n            if (nl >= 0) {\n                // break up newlines\n                if (nl == 0) {\n                    JPanel breakPanel = new JPanel() {\n                        public Dimension getPreferredSize() {\n                            Font       f = getFont();\n\n                            if (f != null) {\n                                return new Dimension(1, f.getSize() + 2);\n                            }\n                            return new Dimension(0, 0);\n                        }\n                    };\n                    breakPanel.setName(\"OptionPane.break\");\n                    addMessageComponents(container, cons, breakPanel, maxll,\n                                         true);\n                } else {\n                    addMessageComponents(container, cons, s.substring(0, nl),\n                                      maxll, false);\n                }\n                addMessageComponents(container, cons, s.substring(nl + nll), maxll,\n                                  false);\n\n            } else if (len > maxll) {\n                Container c = Box.createVerticalBox();\n                c.setName(\"OptionPane.verticalBox\");\n                burstStringInto(c, s, maxll);\n                addMessageComponents(container, cons, c, maxll, true );\n\n            } else {\n                JLabel label;\n                label = new JLabel( s, JLabel.LEADING );\n                label.setName(\"OptionPane.label\");\n                configureMessageLabel(label);\n                addMessageComponents(container, cons, label, maxll, true);\n            }\n        }\n    }"}
{"Number":"1396","API Relative Path":"javax.swing.plaf.basic.BasicScrollPaneUI.java-getBaseline(JComponent-int-int)","Corresponding Source":"/**\n     * Returns the baseline.\n     *\n     * @throws NullPointerException {@inheritDoc}\n     * @throws IllegalArgumentException {@inheritDoc}\n     * @see javax.swing.JComponent#getBaseline(int, int)\n     * @since 1.6\n     */\n    public int getBaseline(JComponent c, int width, int height) {\n        if (c == null) {\n            throw new NullPointerException(\"Component must be non-null\");\n        }\n\n        if (width < 0 || height < 0) {\n            throw new IllegalArgumentException(\"Width and height must be >= 0\");\n        }\n\n        JViewport viewport = scrollpane.getViewport();\n        Insets spInsets = scrollpane.getInsets();\n        int y = spInsets.top;\n        height = height - spInsets.top - spInsets.bottom;\n        width = width - spInsets.left - spInsets.right;\n        JViewport columnHeader = scrollpane.getColumnHeader();\n        if (columnHeader != null && columnHeader.isVisible()) {\n            Component header = columnHeader.getView();\n            if (header != null && header.isVisible()) {\n                // Header is always given it's preferred size.\n                Dimension headerPref = header.getPreferredSize();\n                int baseline = header.getBaseline(headerPref.width,\n                                                  headerPref.height);\n                if (baseline >= 0) {\n                    return y + baseline;\n                }\n            }\n            Dimension columnPref = columnHeader.getPreferredSize();\n            height -= columnPref.height;\n            y += columnPref.height;\n        }\n        Component view = (viewport == null) ? null : viewport.getView();\n        if (view != null && view.isVisible() &&\n                view.getBaselineResizeBehavior() ==\n                Component.BaselineResizeBehavior.CONSTANT_ASCENT) {\n            Border viewportBorder = scrollpane.getViewportBorder();\n            if (viewportBorder != null) {\n                Insets vpbInsets = viewportBorder.getBorderInsets(scrollpane);\n                y += vpbInsets.top;\n                height = height - vpbInsets.top - vpbInsets.bottom;\n                width = width - vpbInsets.left - vpbInsets.right;\n            }\n            if (view.getWidth() > 0 && view.getHeight() > 0) {\n                Dimension min = view.getMinimumSize();\n                width = Math.max(min.width, view.getWidth());\n                height = Math.max(min.height, view.getHeight());\n            }\n            if (width > 0 && height > 0) {\n                int baseline = view.getBaseline(width, height);\n                if (baseline > 0) {\n                    return y + baseline;\n                }\n            }\n        }\n        return -1;\n    }"}
{"Number":"1397","API Relative Path":"javax.swing.plaf.basic.BasicScrollPaneUI.java-getBaseline(JComponent-int-int)","Corresponding Source":"/**\n     * Returns the baseline.\n     *\n     * @throws NullPointerException {@inheritDoc}\n     * @throws IllegalArgumentException {@inheritDoc}\n     * @see javax.swing.JComponent#getBaseline(int, int)\n     * @since 1.6\n     */\n    public int getBaseline(JComponent c, int width, int height) {\n        if (c == null) {\n            throw new NullPointerException(\"Component must be non-null\");\n        }\n\n        if (width < 0 || height < 0) {\n            throw new IllegalArgumentException(\"Width and height must be >= 0\");\n        }\n\n        JViewport viewport = scrollpane.getViewport();\n        Insets spInsets = scrollpane.getInsets();\n        int y = spInsets.top;\n        height = height - spInsets.top - spInsets.bottom;\n        width = width - spInsets.left - spInsets.right;\n        JViewport columnHeader = scrollpane.getColumnHeader();\n        if (columnHeader != null && columnHeader.isVisible()) {\n            Component header = columnHeader.getView();\n            if (header != null && header.isVisible()) {\n                // Header is always given it's preferred size.\n                Dimension headerPref = header.getPreferredSize();\n                int baseline = header.getBaseline(headerPref.width,\n                                                  headerPref.height);\n                if (baseline >= 0) {\n                    return y + baseline;\n                }\n            }\n            Dimension columnPref = columnHeader.getPreferredSize();\n            height -= columnPref.height;\n            y += columnPref.height;\n        }\n        Component view = (viewport == null) ? null : viewport.getView();\n        if (view != null && view.isVisible() &&\n                view.getBaselineResizeBehavior() ==\n                Component.BaselineResizeBehavior.CONSTANT_ASCENT) {\n            Border viewportBorder = scrollpane.getViewportBorder();\n            if (viewportBorder != null) {\n                Insets vpbInsets = viewportBorder.getBorderInsets(scrollpane);\n                y += vpbInsets.top;\n                height = height - vpbInsets.top - vpbInsets.bottom;\n                width = width - vpbInsets.left - vpbInsets.right;\n            }\n            if (view.getWidth() > 0 && view.getHeight() > 0) {\n                Dimension min = view.getMinimumSize();\n                width = Math.max(min.width, view.getWidth());\n                height = Math.max(min.height, view.getHeight());\n            }\n            if (width > 0 && height > 0) {\n                int baseline = view.getBaseline(width, height);\n                if (baseline > 0) {\n                    return y + baseline;\n                }\n            }\n        }\n        return -1;\n    }"}
{"Number":"1398","API Relative Path":"javax.swing.plaf.basic.BasicSpinnerUI.java-replaceEditor(JComponent-JComponent)","Corresponding Source":"/**\n     * Called by the <code>PropertyChangeListener<\/code> when the\n     * <code>JSpinner<\/code> editor property changes.  It's the responsibility\n     * of this method to remove the old editor and add the new one.  By\n     * default this operation is just:\n     * <pre>\n     * spinner.remove(oldEditor);\n     * spinner.add(newEditor, \"Editor\");\n     * <\/pre>\n     * The implementation of <code>replaceEditor<\/code> should be coordinated\n     * with the <code>createEditor<\/code> method.\n     *\n     * @see #createEditor\n     * @see #createPropertyChangeListener\n     */\n    protected void replaceEditor(JComponent oldEditor, JComponent newEditor) {\n        spinner.remove(oldEditor);\n        maybeRemoveEditorBorder(newEditor);\n        installEditorBorderListener(newEditor);\n        newEditor.setInheritsPopupMenu(true);\n        spinner.add(newEditor, \"Editor\");\n    }"}
{"Number":"1399","API Relative Path":"javax.swing.plaf.basic.BasicSpinnerUI.java-replaceEditor(JComponent-JComponent)","Corresponding Source":"/**\n     * Called by the <code>PropertyChangeListener<\/code> when the\n     * <code>JSpinner<\/code> editor property changes.  It's the responsibility\n     * of this method to remove the old editor and add the new one.  By\n     * default this operation is just:\n     * <pre>\n     * spinner.remove(oldEditor);\n     * spinner.add(newEditor, \"Editor\");\n     * <\/pre>\n     * The implementation of <code>replaceEditor<\/code> should be coordinated\n     * with the <code>createEditor<\/code> method.\n     *\n     * @see #createEditor\n     * @see #createPropertyChangeListener\n     */\n    protected void replaceEditor(JComponent oldEditor, JComponent newEditor) {\n        spinner.remove(oldEditor);\n        maybeRemoveEditorBorder(newEditor);\n        installEditorBorderListener(newEditor);\n        newEditor.setInheritsPopupMenu(true);\n        spinner.add(newEditor, \"Editor\");\n    }"}
{"Number":"1400","API Relative Path":"javax.swing.plaf.basic.BasicTextUI.java-installUI(JComponent)","Corresponding Source":"/**\n     * Deinstalls the UI for a component.  This removes the listeners,\n     * uninstalls the highlighter, removes views, and nulls out the keymap.\n     *\n     * @param c the editor component\n     * @see ComponentUI#uninstallUI\n     */\n    public void uninstallUI(JComponent c) {\n        // detach from the model\n        editor.removePropertyChangeListener(updateHandler);\n        editor.getDocument().removeDocumentListener(updateHandler);\n\n        // view part\n        painted = false;\n        uninstallDefaults();\n        rootView.setView(null);\n        c.removeAll();\n        LayoutManager lm = c.getLayout();\n        if (lm instanceof UIResource) {\n            c.setLayout(null);\n        }\n\n        // controller part\n        uninstallKeyboardActions();\n        uninstallListeners();\n\n        editor = null;\n    }"}
{"Number":"1401","API Relative Path":"javax.swing.plaf.basic.BasicTreeUI.java-checkForClickInExpandControl(TreePath-int-int)","Corresponding Source":"//\n    // Following are primarily for handling mouse events.\n    //\n\n    /**\n     * If the <code>mouseX<\/code> and <code>mouseY<\/code> are in the\n     * expand/collapse region of the <code>row<\/code>, this will toggle\n     * the row.\n     */\n    protected void checkForClickInExpandControl(TreePath path,\n                                                int mouseX, int mouseY) {\n      if (isLocationInExpandControl(path, mouseX, mouseY)) {\n          handleExpandControlClick(path, mouseX, mouseY);\n        }\n    }"}
{"Number":"1402","API Relative Path":"javax.swing.plaf.basic.BasicTreeUI.java-handleExpandControlClick(TreePath-int-int)","Corresponding Source":"/**\n     * Messaged when the user clicks the particular row, this invokes\n     * toggleExpandState.\n     */\n    protected void handleExpandControlClick(TreePath path, int mouseX,\n                                            int mouseY) {\n        toggleExpandState(path);\n    }"}
{"Number":"1403","API Relative Path":"javax.swing.plaf.basic.BasicTreeUI.java-handleExpandControlClick(TreePath-int-int)","Corresponding Source":"/**\n     * Messaged when the user clicks the particular row, this invokes\n     * toggleExpandState.\n     */\n    protected void handleExpandControlClick(TreePath path, int mouseX,\n                                            int mouseY) {\n        toggleExpandState(path);\n    }"}
{"Number":"1404","API Relative Path":"javax.swing.plaf.basic.BasicTreeUI.java-handleExpandControlClick(TreePath-int-int)","Corresponding Source":"/**\n     * Messaged when the user clicks the particular row, this invokes\n     * toggleExpandState.\n     */\n    protected void handleExpandControlClick(TreePath path, int mouseX,\n                                            int mouseY) {\n        toggleExpandState(path);\n    }"}
{"Number":"1405","API Relative Path":"javax.swing.plaf.basic.BasicTreeUI.java-selectPathForEvent(TreePath-MouseEvent)","Corresponding Source":"/**\n     * Messaged to update the selection based on a MouseEvent over a\n     * particular row. If the event is a toggle selection event, the\n     * row is either selected, or deselected. If the event identifies\n     * a multi selection event, the selection is updated from the\n     * anchor point. Otherwise the row is selected, and if the event\n     * specified a toggle event the row is expanded/collapsed.\n     */\n    protected void selectPathForEvent(TreePath path, MouseEvent event) {\n        /* Adjust from the anchor point. */\n        if(isMultiSelectEvent(event)) {\n            TreePath    anchor = getAnchorSelectionPath();\n            int         anchorRow = (anchor == null) ? -1 :\n                                    getRowForPath(tree, anchor);\n\n            if(anchorRow == -1 || tree.getSelectionModel().\n                      getSelectionMode() == TreeSelectionModel.\n                      SINGLE_TREE_SELECTION) {\n                tree.setSelectionPath(path);\n            }\n            else {\n                int          row = getRowForPath(tree, path);\n                TreePath     lastAnchorPath = anchor;\n\n                if (isToggleSelectionEvent(event)) {\n                    if (tree.isRowSelected(anchorRow)) {\n                        tree.addSelectionInterval(anchorRow, row);\n                    } else {\n                        tree.removeSelectionInterval(anchorRow, row);\n                        tree.addSelectionInterval(row, row);\n                    }\n                } else if(row < anchorRow) {\n                    tree.setSelectionInterval(row, anchorRow);\n                } else {\n                    tree.setSelectionInterval(anchorRow, row);\n                }\n                lastSelectedRow = row;\n                setAnchorSelectionPath(lastAnchorPath);\n                setLeadSelectionPath(path);\n            }\n        }\n\n        // Should this event toggle the selection of this row?\n        /* Control toggles just this node. */\n        else if(isToggleSelectionEvent(event)) {\n            if(tree.isPathSelected(path))\n                tree.removeSelectionPath(path);\n            else\n                tree.addSelectionPath(path);\n            lastSelectedRow = getRowForPath(tree, path);\n            setAnchorSelectionPath(path);\n            setLeadSelectionPath(path);\n        }\n\n        /* Otherwise set the selection to just this interval. */\n        else if(SwingUtilities.isLeftMouseButton(event)) {\n            tree.setSelectionPath(path);\n            if(isToggleEvent(event)) {\n                toggleExpandState(path);\n            }\n        }\n    }"}
{"Number":"1406","API Relative Path":"javax.swing.plaf.basic.BasicTreeUI.java-selectPathForEvent(TreePath-MouseEvent)","Corresponding Source":"/**\n     * Messaged to update the selection based on a MouseEvent over a\n     * particular row. If the event is a toggle selection event, the\n     * row is either selected, or deselected. If the event identifies\n     * a multi selection event, the selection is updated from the\n     * anchor point. Otherwise the row is selected, and if the event\n     * specified a toggle event the row is expanded/collapsed.\n     */\n    protected void selectPathForEvent(TreePath path, MouseEvent event) {\n        /* Adjust from the anchor point. */\n        if(isMultiSelectEvent(event)) {\n            TreePath    anchor = getAnchorSelectionPath();\n            int         anchorRow = (anchor == null) ? -1 :\n                                    getRowForPath(tree, anchor);\n\n            if(anchorRow == -1 || tree.getSelectionModel().\n                      getSelectionMode() == TreeSelectionModel.\n                      SINGLE_TREE_SELECTION) {\n                tree.setSelectionPath(path);\n            }\n            else {\n                int          row = getRowForPath(tree, path);\n                TreePath     lastAnchorPath = anchor;\n\n                if (isToggleSelectionEvent(event)) {\n                    if (tree.isRowSelected(anchorRow)) {\n                        tree.addSelectionInterval(anchorRow, row);\n                    } else {\n                        tree.removeSelectionInterval(anchorRow, row);\n                        tree.addSelectionInterval(row, row);\n                    }\n                } else if(row < anchorRow) {\n                    tree.setSelectionInterval(row, anchorRow);\n                } else {\n                    tree.setSelectionInterval(anchorRow, row);\n                }\n                lastSelectedRow = row;\n                setAnchorSelectionPath(lastAnchorPath);\n                setLeadSelectionPath(path);\n            }\n        }\n\n        // Should this event toggle the selection of this row?\n        /* Control toggles just this node. */\n        else if(isToggleSelectionEvent(event)) {\n            if(tree.isPathSelected(path))\n                tree.removeSelectionPath(path);\n            else\n                tree.addSelectionPath(path);\n            lastSelectedRow = getRowForPath(tree, path);\n            setAnchorSelectionPath(path);\n            setLeadSelectionPath(path);\n        }\n\n        /* Otherwise set the selection to just this interval. */\n        else if(SwingUtilities.isLeftMouseButton(event)) {\n            tree.setSelectionPath(path);\n            if(isToggleEvent(event)) {\n                toggleExpandState(path);\n            }\n        }\n    }"}
{"Number":"1407","API Relative Path":"javax.swing.plaf.basic.BasicTreeUI.java-selectPathForEvent(TreePath-MouseEvent)","Corresponding Source":"/**\n     * Messaged to update the selection based on a MouseEvent over a\n     * particular row. If the event is a toggle selection event, the\n     * row is either selected, or deselected. If the event identifies\n     * a multi selection event, the selection is updated from the\n     * anchor point. Otherwise the row is selected, and if the event\n     * specified a toggle event the row is expanded/collapsed.\n     */\n    protected void selectPathForEvent(TreePath path, MouseEvent event) {\n        /* Adjust from the anchor point. */\n        if(isMultiSelectEvent(event)) {\n            TreePath    anchor = getAnchorSelectionPath();\n            int         anchorRow = (anchor == null) ? -1 :\n                                    getRowForPath(tree, anchor);\n\n            if(anchorRow == -1 || tree.getSelectionModel().\n                      getSelectionMode() == TreeSelectionModel.\n                      SINGLE_TREE_SELECTION) {\n                tree.setSelectionPath(path);\n            }\n            else {\n                int          row = getRowForPath(tree, path);\n                TreePath     lastAnchorPath = anchor;\n\n                if (isToggleSelectionEvent(event)) {\n                    if (tree.isRowSelected(anchorRow)) {\n                        tree.addSelectionInterval(anchorRow, row);\n                    } else {\n                        tree.removeSelectionInterval(anchorRow, row);\n                        tree.addSelectionInterval(row, row);\n                    }\n                } else if(row < anchorRow) {\n                    tree.setSelectionInterval(row, anchorRow);\n                } else {\n                    tree.setSelectionInterval(anchorRow, row);\n                }\n                lastSelectedRow = row;\n                setAnchorSelectionPath(lastAnchorPath);\n                setLeadSelectionPath(path);\n            }\n        }\n\n        // Should this event toggle the selection of this row?\n        /* Control toggles just this node. */\n        else if(isToggleSelectionEvent(event)) {\n            if(tree.isPathSelected(path))\n                tree.removeSelectionPath(path);\n            else\n                tree.addSelectionPath(path);\n            lastSelectedRow = getRowForPath(tree, path);\n            setAnchorSelectionPath(path);\n            setLeadSelectionPath(path);\n        }\n\n        /* Otherwise set the selection to just this interval. */\n        else if(SwingUtilities.isLeftMouseButton(event)) {\n            tree.setSelectionPath(path);\n            if(isToggleEvent(event)) {\n                toggleExpandState(path);\n            }\n        }\n    }"}
{"Number":"1408","API Relative Path":"javax.swing.plaf.basic.BasicTreeUI.java-startEditingAtPath(JTree-TreePath)","Corresponding Source":"/**\n      * Selects the last item in path and tries to edit it.  Editing will\n      * fail if the CellEditor won't allow it for the selected item.\n      */\n    public void startEditingAtPath(JTree tree, TreePath path) {\n        tree.scrollPathToVisible(path);\n        if(path != null && tree.isVisible(path))\n            startEditing(path, null);\n    }"}
{"Number":"1409","API Relative Path":"javax.swing.plaf.basic.BasicTreeUI.java-startEditingAtPath(JTree-TreePath)","Corresponding Source":"/**\n      * Selects the last item in path and tries to edit it.  Editing will\n      * fail if the CellEditor won't allow it for the selected item.\n      */\n    public void startEditingAtPath(JTree tree, TreePath path) {\n        tree.scrollPathToVisible(path);\n        if(path != null && tree.isVisible(path))\n            startEditing(path, null);\n    }"}
{"Number":"1410","API Relative Path":"javax.swing.plaf.basic.BasicTreeUI.java-startEditingAtPath(JTree-TreePath)","Corresponding Source":"/**\n      * Selects the last item in path and tries to edit it.  Editing will\n      * fail if the CellEditor won't allow it for the selected item.\n      */\n    public void startEditingAtPath(JTree tree, TreePath path) {\n        tree.scrollPathToVisible(path);\n        if(path != null && tree.isVisible(path))\n            startEditing(path, null);\n    }"}
{"Number":"1411","API Relative Path":"javax.swing.plaf.basic.BasicTreeUI.java-toggleExpandState(TreePath)","Corresponding Source":"/**\n     * Expands path if it is not expanded, or collapses row if it is expanded.\n     * If expanding a path and JTree scrolls on expand, ensureRowsAreVisible\n     * is invoked to scroll as many of the children to visible as possible\n     * (tries to scroll to last visible descendant of path).\n     */\n    protected void toggleExpandState(TreePath path) {\n        if(!tree.isExpanded(path)) {\n            int       row = getRowForPath(tree, path);\n\n            tree.expandPath(path);\n            updateSize();\n            if(row != -1) {\n                if(tree.getScrollsOnExpand())\n                    ensureRowsAreVisible(row, row + treeState.\n                                         getVisibleChildCount(path));\n                else\n                    ensureRowsAreVisible(row, row);\n            }\n        }\n        else {\n            tree.collapsePath(path);\n            updateSize();\n        }\n    }"}
{"Number":"1412","API Relative Path":"javax.swing.plaf.basic.BasicTreeUI.java-toggleExpandState(TreePath)","Corresponding Source":"/**\n     * Expands path if it is not expanded, or collapses row if it is expanded.\n     * If expanding a path and JTree scrolls on expand, ensureRowsAreVisible\n     * is invoked to scroll as many of the children to visible as possible\n     * (tries to scroll to last visible descendant of path).\n     */\n    protected void toggleExpandState(TreePath path) {\n        if(!tree.isExpanded(path)) {\n            int       row = getRowForPath(tree, path);\n\n            tree.expandPath(path);\n            updateSize();\n            if(row != -1) {\n                if(tree.getScrollsOnExpand())\n                    ensureRowsAreVisible(row, row + treeState.\n                                         getVisibleChildCount(path));\n                else\n                    ensureRowsAreVisible(row, row);\n            }\n        }\n        else {\n            tree.collapsePath(path);\n            updateSize();\n        }\n    }"}
{"Number":"1413","API Relative Path":"javax.swing.plaf.basic.BasicTreeUI.java-toggleExpandState(TreePath)","Corresponding Source":"/**\n     * Expands path if it is not expanded, or collapses row if it is expanded.\n     * If expanding a path and JTree scrolls on expand, ensureRowsAreVisible\n     * is invoked to scroll as many of the children to visible as possible\n     * (tries to scroll to last visible descendant of path).\n     */\n    protected void toggleExpandState(TreePath path) {\n        if(!tree.isExpanded(path)) {\n            int       row = getRowForPath(tree, path);\n\n            tree.expandPath(path);\n            updateSize();\n            if(row != -1) {\n                if(tree.getScrollsOnExpand())\n                    ensureRowsAreVisible(row, row + treeState.\n                                         getVisibleChildCount(path));\n                else\n                    ensureRowsAreVisible(row, row);\n            }\n        }\n        else {\n            tree.collapsePath(path);\n            updateSize();\n        }\n    }"}
{"Number":"1414","API Relative Path":"javax.swing.plaf.BorderUIResource.java-BorderUIResource(Border)","Corresponding Source":"/**\n     * Creates a UIResource border object which wraps\n     * an existing Border instance.\n     * @param delegate the border being wrapped\n     */\n    public BorderUIResource(Border delegate) {\n        if (delegate == null) {\n            throw new IllegalArgumentException(\"null border delegate argument\");\n        }\n        this.delegate = delegate;\n    }"}
{"Number":"1415","API Relative Path":"javax.swing.plaf.IconUIResource.java-IconUIResource(Icon)","Corresponding Source":"/**\n     * Creates a UIResource icon object which wraps\n     * an existing Icon instance.\n     * @param delegate the icon being wrapped\n     */\n    public IconUIResource(Icon delegate) {\n        if (delegate == null) {\n            throw new IllegalArgumentException(\"null delegate icon argument\");\n        }\n        this.delegate = delegate;\n    }"}
{"Number":"1416","API Relative Path":"javax.swing.plaf.metal.MetalComboBoxUI.java-paintCurrentValue(Graphics-Rectangle-boolean)","Corresponding Source":"/**\n     * If necessary paints the currently selected item.\n     *\n     * @param g Graphics to paint to\n     * @param bounds Region to paint current value to\n     * @param hasFocus whether or not the JComboBox has focus\n     * @throws NullPointerException if any of the arguments are null.\n     * @since 1.5\n     */\n    public void paintCurrentValue(Graphics g, Rectangle bounds,\n                                  boolean hasFocus) {\n        // This is really only called if we're using ocean.\n        if (MetalLookAndFeel.usingOcean()) {\n            bounds.x += 2;\n            bounds.width -= 3;\n            if (arrowButton != null) {\n                Insets buttonInsets = arrowButton.getInsets();\n                bounds.y += buttonInsets.top;\n                bounds.height -= (buttonInsets.top + buttonInsets.bottom);\n            }\n            else {\n                bounds.y += 2;\n                bounds.height -= 4;\n            }\n            super.paintCurrentValue(g, bounds, hasFocus);\n        }\n        else if (g == null || bounds == null) {\n            throw new NullPointerException(\n                \"Must supply a non-null Graphics and Rectangle\");\n        }\n    }"}
{"Number":"1417","API Relative Path":"javax.swing.plaf.metal.MetalComboBoxUI.java-paintCurrentValueBackground(Graphics-Rectangle-boolean)","Corresponding Source":"/**\n     * If necessary paints the background of the currently selected item.\n     *\n     * @param g Graphics to paint to\n     * @param bounds Region to paint background to\n     * @param hasFocus whether or not the JComboBox has focus\n     * @throws NullPointerException if any of the arguments are null.\n     * @since 1.5\n     */\n    public void paintCurrentValueBackground(Graphics g, Rectangle bounds,\n                                            boolean hasFocus) {\n        // This is really only called if we're using ocean.\n        if (MetalLookAndFeel.usingOcean()) {\n            g.setColor(MetalLookAndFeel.getControlDarkShadow());\n            g.drawRect(bounds.x, bounds.y, bounds.width, bounds.height - 1);\n            g.setColor(MetalLookAndFeel.getControlShadow());\n            g.drawRect(bounds.x + 1, bounds.y + 1, bounds.width - 2,\n                       bounds.height - 3);\n            if (hasFocus && !isPopupVisible(comboBox) &&\n                    arrowButton != null) {\n                g.setColor(listBox.getSelectionBackground());\n                Insets buttonInsets = arrowButton.getInsets();\n                if (buttonInsets.top > 2) {\n                    g.fillRect(bounds.x + 2, bounds.y + 2, bounds.width - 3,\n                               buttonInsets.top - 2);\n                }\n                if (buttonInsets.bottom > 2) {\n                    g.fillRect(bounds.x + 2, bounds.y + bounds.height -\n                               buttonInsets.bottom, bounds.width - 3,\n                               buttonInsets.bottom - 2);\n                }\n            }\n        }\n        else if (g == null || bounds == null) {\n            throw new NullPointerException(\n                \"Must supply a non-null Graphics and Rectangle\");\n        }\n    }"}
{"Number":"1418","API Relative Path":"javax.swing.plaf.metal.MetalMenuBarUI.java-update(Graphics-JComponent)","Corresponding Source":"/**\n     * If necessary paints the background of the component, then\n     * invokes <code>paint<\/code>.\n     *\n     * @param g Graphics to paint to\n     * @param c JComponent painting on\n     * @throws NullPointerException if <code>g<\/code> or <code>c<\/code> is\n     *         null\n     * @see javax.swing.plaf.ComponentUI#update\n     * @see javax.swing.plaf.ComponentUI#paint\n     * @since 1.5\n     */\n    public void update(Graphics g, JComponent c) {\n        boolean isOpaque = c.isOpaque();\n        if (g == null) {\n            throw new NullPointerException(\"Graphics must be non-null\");\n        }\n        if (isOpaque && (c.getBackground() instanceof UIResource) &&\n                        UIManager.get(\"MenuBar.gradient\") != null) {\n            if (MetalToolBarUI.doesMenuBarBorderToolBar((JMenuBar)c)) {\n                JToolBar tb = (JToolBar)MetalToolBarUI.\n                     findRegisteredComponentOfType(c, JToolBar.class);\n                if (tb.isOpaque() &&tb.getBackground() instanceof UIResource) {\n                    MetalUtils.drawGradient(c, g, \"MenuBar.gradient\", 0, 0,\n                                            c.getWidth(), c.getHeight() +\n                                            tb.getHeight(), true);\n                    paint(g, c);\n                    return;\n                }\n            }\n            MetalUtils.drawGradient(c, g, \"MenuBar.gradient\", 0, 0,\n                                    c.getWidth(), c.getHeight(),true);\n            paint(g, c);\n        }\n        else {\n            super.update(g, c);\n        }\n    }"}
{"Number":"1419","API Relative Path":"javax.swing.plaf.metal.MetalToolBarUI.java-doesMenuBarBorderToolBar(JMenuBar)","Corresponding Source":"/**\n     * Returns true if the passed in JMenuBar is above a horizontal\n     * JToolBar.\n     */\n    static boolean doesMenuBarBorderToolBar(JMenuBar c) {\n        JToolBar tb = (JToolBar)MetalToolBarUI.\n                    findRegisteredComponentOfType(c, JToolBar.class);\n        if (tb != null && tb.getOrientation() == JToolBar.HORIZONTAL) {\n            JRootPane rp = SwingUtilities.getRootPane(c);\n            Point point = new Point(0, 0);\n            point = SwingUtilities.convertPoint(c, point, rp);\n            int menuX = point.x;\n            int menuY = point.y;\n            point.x = point.y = 0;\n            point = SwingUtilities.convertPoint(tb, point, rp);\n            return (point.x == menuX && menuY + c.getHeight() == point.y &&\n                    c.getWidth() == tb.getWidth());\n        }\n        return false;\n    }"}
{"Number":"1420","API Relative Path":"javax.swing.plaf.metal.MetalToolBarUI.java-register(JComponent)","Corresponding Source":"/**\n     * Unregisters the specified component.\n     */\n    synchronized static void unregister(JComponent c) {\n        for (int counter = components.size() - 1; counter >= 0; counter--) {\n            // Search for the component, removing any flushed references\n            // along the way.\n            JComponent target = components.get(counter).get();\n\n            if (target == c || target == null) {\n                components.remove(counter);\n            }\n        }\n    }"}
{"Number":"1421","API Relative Path":"javax.swing.plaf.metal.MetalToolBarUI.java-update(Graphics-JComponent)","Corresponding Source":"/**\n     * If necessary paints the background of the component, then invokes\n     * <code>paint<\/code>.\n     *\n     * @param g Graphics to paint to\n     * @param c JComponent painting on\n     * @throws NullPointerException if <code>g<\/code> or <code>c<\/code> is\n     *         null\n     * @see javax.swing.plaf.ComponentUI#update\n     * @see javax.swing.plaf.ComponentUI#paint\n     * @since 1.5\n     */\n    public void update(Graphics g, JComponent c) {\n        if (g == null) {\n            throw new NullPointerException(\"graphics must be non-null\");\n        }\n        if (c.isOpaque() && (c.getBackground() instanceof UIResource) &&\n                            ((JToolBar)c).getOrientation() ==\n                      JToolBar.HORIZONTAL && UIManager.get(\n                     \"MenuBar.gradient\") != null) {\n            JRootPane rp = SwingUtilities.getRootPane(c);\n            JMenuBar mb = (JMenuBar)findRegisteredComponentOfType(\n                                    c, JMenuBar.class);\n            if (mb != null && mb.isOpaque() &&\n                              (mb.getBackground() instanceof UIResource)) {\n                Point point = new Point(0, 0);\n                point = SwingUtilities.convertPoint(c, point, rp);\n                int x = point.x;\n                int y = point.y;\n                point.x = point.y = 0;\n                point = SwingUtilities.convertPoint(mb, point, rp);\n                if (point.x == x && y == point.y + mb.getHeight() &&\n                     mb.getWidth() == c.getWidth() &&\n                     MetalUtils.drawGradient(c, g, \"MenuBar.gradient\",\n                     0, -mb.getHeight(), c.getWidth(), c.getHeight() +\n                     mb.getHeight(), true)) {\n                    setLastMenuBar(mb);\n                    paint(g, c);\n                    return;\n                }\n            }\n            if (MetalUtils.drawGradient(c, g, \"MenuBar.gradient\",\n                           0, 0, c.getWidth(), c.getHeight(), true)) {\n                setLastMenuBar(null);\n                paint(g, c);\n                return;\n            }\n        }\n        setLastMenuBar(null);\n        super.update(g, c);\n    }"}
{"Number":"1422","API Relative Path":"javax.swing.plaf.metal.MetalToolBarUI.java-update(Graphics-JComponent)","Corresponding Source":"/**\n     * If necessary paints the background of the component, then invokes\n     * <code>paint<\/code>.\n     *\n     * @param g Graphics to paint to\n     * @param c JComponent painting on\n     * @throws NullPointerException if <code>g<\/code> or <code>c<\/code> is\n     *         null\n     * @see javax.swing.plaf.ComponentUI#update\n     * @see javax.swing.plaf.ComponentUI#paint\n     * @since 1.5\n     */\n    public void update(Graphics g, JComponent c) {\n        if (g == null) {\n            throw new NullPointerException(\"graphics must be non-null\");\n        }\n        if (c.isOpaque() && (c.getBackground() instanceof UIResource) &&\n                            ((JToolBar)c).getOrientation() ==\n                      JToolBar.HORIZONTAL && UIManager.get(\n                     \"MenuBar.gradient\") != null) {\n            JRootPane rp = SwingUtilities.getRootPane(c);\n            JMenuBar mb = (JMenuBar)findRegisteredComponentOfType(\n                                    c, JMenuBar.class);\n            if (mb != null && mb.isOpaque() &&\n                              (mb.getBackground() instanceof UIResource)) {\n                Point point = new Point(0, 0);\n                point = SwingUtilities.convertPoint(c, point, rp);\n                int x = point.x;\n                int y = point.y;\n                point.x = point.y = 0;\n                point = SwingUtilities.convertPoint(mb, point, rp);\n                if (point.x == x && y == point.y + mb.getHeight() &&\n                     mb.getWidth() == c.getWidth() &&\n                     MetalUtils.drawGradient(c, g, \"MenuBar.gradient\",\n                     0, -mb.getHeight(), c.getWidth(), c.getHeight() +\n                     mb.getHeight(), true)) {\n                    setLastMenuBar(mb);\n                    paint(g, c);\n                    return;\n                }\n            }\n            if (MetalUtils.drawGradient(c, g, \"MenuBar.gradient\",\n                           0, 0, c.getWidth(), c.getHeight(), true)) {\n                setLastMenuBar(null);\n                paint(g, c);\n                return;\n            }\n        }\n        setLastMenuBar(null);\n        super.update(g, c);\n    }"}
{"Number":"1423","API Relative Path":"javax.swing.plaf.multi.MultiLookAndFeel.java-uisToArray(Vector)","Corresponding Source":"/**\n     * Creates an array,\n     * populates it with UI objects from the passed-in vector,\n     * and returns the array.\n     * If <code>uis<\/code> is null,\n     * this method returns an array with zero elements.\n     * If <code>uis<\/code> is an empty vector,\n     * this method returns <code>null<\/code>.\n     * A run-time error occurs if any objects in the <code>uis<\/code> vector\n     * are not of type <code>ComponentUI<\/code>.\n     *\n     * @param uis a vector containing <code>ComponentUI<\/code> objects\n     * @return an array equivalent to the passed-in vector\n     *\n     */\n    protected static ComponentUI[] uisToArray(Vector uis) {\n        if (uis == null) {\n            return new ComponentUI[0];\n        } else {\n            int count = uis.size();\n            if (count > 0) {\n                ComponentUI[] u = new ComponentUI[count];\n                for (int i = 0; i < count; i++) {\n                    u[i] = (ComponentUI)uis.elementAt(i);\n                }\n                return u;\n            } else {\n                return null;\n            }\n        }\n    }"}
{"Number":"1424","API Relative Path":"javax.swing.plaf.nimbus.AbstractRegionPainter.java-decodeAnchorX(float-float)","Corresponding Source":"/**\n     * Decodes and returns a float value representing the actual pixel location for\n     * the anchor point given the encoded X value of the control point, and the offset\n     * distance to the anchor from that control point.\n     *\n     * @param x an encoded x value of the bezier control point (0...1, or 1...2, or 2...3)\n     * @param dx the offset distance to the anchor from the control point x\n     * @return the decoded x location of the control point\n     * @throws IllegalArgumentException\n     *      if {@code x < 0} or {@code x > 3}\n     */\n    protected final float decodeAnchorX(float x, float dx) {\n        if (x >= 0 && x <= 1) {\n            return decodeX(x) + (dx * leftScale);\n        } else if (x > 1 && x < 2) {\n            return decodeX(x) + (dx * centerHScale);\n        } else if (x >= 2 && x <= 3) {\n            return decodeX(x) + (dx * rightScale);\n        } else {\n            throw new IllegalArgumentException(\"Invalid x\");\n        }\n    }"}
{"Number":"1425","API Relative Path":"javax.swing.plaf.nimbus.AbstractRegionPainter.java-decodeAnchorX(float-float)","Corresponding Source":"/**\n     * Decodes and returns a float value representing the actual pixel location for\n     * the anchor point given the encoded X value of the control point, and the offset\n     * distance to the anchor from that control point.\n     *\n     * @param x an encoded x value of the bezier control point (0...1, or 1...2, or 2...3)\n     * @param dx the offset distance to the anchor from the control point x\n     * @return the decoded x location of the control point\n     * @throws IllegalArgumentException\n     *      if {@code x < 0} or {@code x > 3}\n     */\n    protected final float decodeAnchorX(float x, float dx) {\n        if (x >= 0 && x <= 1) {\n            return decodeX(x) + (dx * leftScale);\n        } else if (x > 1 && x < 2) {\n            return decodeX(x) + (dx * centerHScale);\n        } else if (x >= 2 && x <= 3) {\n            return decodeX(x) + (dx * rightScale);\n        } else {\n            throw new IllegalArgumentException(\"Invalid x\");\n        }\n    }"}
{"Number":"1426","API Relative Path":"javax.swing.plaf.nimbus.AbstractRegionPainter.java-decodeAnchorY(float-float)","Corresponding Source":"/**\n     * Decodes and returns a float value representing the actual pixel location for\n     * the anchor point given the encoded Y value of the control point, and the offset\n     * distance to the anchor from that control point.\n     *\n     * @param y an encoded y value of the bezier control point (0...1, or 1...2, or 2...3)\n     * @param dy the offset distance to the anchor from the control point y\n     * @return the decoded y position of the control point\n     * @throws IllegalArgumentException\n     *      if {@code y < 0} or {@code y > 3}\n     */\n    protected final float decodeAnchorY(float y, float dy) {\n        if (y >= 0 && y <= 1) {\n            return decodeY(y) + (dy * topScale);\n        } else if (y > 1 && y < 2) {\n            return decodeY(y) + (dy * centerVScale);\n        } else if (y >= 2 && y <= 3) {\n            return decodeY(y) + (dy * bottomScale);\n        } else {\n            throw new IllegalArgumentException(\"Invalid y\");\n        }\n    }"}
{"Number":"1427","API Relative Path":"javax.swing.plaf.nimbus.AbstractRegionPainter.java-decodeAnchorY(float-float)","Corresponding Source":"/**\n     * Decodes and returns a float value representing the actual pixel location for\n     * the anchor point given the encoded Y value of the control point, and the offset\n     * distance to the anchor from that control point.\n     *\n     * @param y an encoded y value of the bezier control point (0...1, or 1...2, or 2...3)\n     * @param dy the offset distance to the anchor from the control point y\n     * @return the decoded y position of the control point\n     * @throws IllegalArgumentException\n     *      if {@code y < 0} or {@code y > 3}\n     */\n    protected final float decodeAnchorY(float y, float dy) {\n        if (y >= 0 && y <= 1) {\n            return decodeY(y) + (dy * topScale);\n        } else if (y > 1 && y < 2) {\n            return decodeY(y) + (dy * centerVScale);\n        } else if (y >= 2 && y <= 3) {\n            return decodeY(y) + (dy * bottomScale);\n        } else {\n            throw new IllegalArgumentException(\"Invalid y\");\n        }\n    }"}
{"Number":"1428","API Relative Path":"javax.swing.plaf.nimbus.AbstractRegionPainter.java-decodeX(float)","Corresponding Source":"/**\n     * Decodes and returns a float value representing the actual pixel location for\n     * the given encoded X value.\n     *\n     * @param x an encoded x value (0...1, or 1...2, or 2...3)\n     * @return the decoded x value\n     * @throws IllegalArgumentException\n     *      if {@code x < 0} or {@code x > 3}\n     */\n    protected final float decodeX(float x) {\n        if (x >= 0 && x <= 1) {\n            return x * leftWidth;\n        } else if (x > 1 && x < 2) {\n            return ((x-1) * centerWidth) + leftWidth;\n        } else if (x >= 2 && x <= 3) {\n            return ((x-2) * rightWidth) + leftWidth + centerWidth;\n        } else {\n            throw new IllegalArgumentException(\"Invalid x\");\n        }\n    }"}
{"Number":"1429","API Relative Path":"javax.swing.plaf.nimbus.AbstractRegionPainter.java-decodeY(float)","Corresponding Source":"/**\n     * Decodes and returns a float value representing the actual pixel location for\n     * the given encoded y value.\n     *\n     * @param y an encoded y value (0...1, or 1...2, or 2...3)\n     * @return the decoded y value\n     * @throws IllegalArgumentException\n     *      if {@code y < 0} or {@code y > 3}\n     */\n    protected final float decodeY(float y) {\n        if (y >= 0 && y <= 1) {\n            return y * topHeight;\n        } else if (y > 1 && y < 2) {\n            return ((y-1) * centerHeight) + topHeight;\n        } else if (y >= 2 && y <= 3) {\n            return ((y-2) * bottomHeight) + topHeight + centerHeight;\n        } else {\n            throw new IllegalArgumentException(\"Invalid y\");\n        }\n    }"}
{"Number":"1430","API Relative Path":"javax.swing.plaf.nimbus.DropShadowEffect.java-applyEffect(BufferedImage-BufferedImage-int-int)","Corresponding Source":"/**\n     * Apply the effect to the src image generating the result . The result image may or may not contain the source\n     * image depending on what the effect type is.\n     *\n     * @param src The source image for applying the effect to\n     * @param dst The destination image to paint effect result into. If this is null then a new image will be created\n     * @param w   The width of the src image to apply effect to, this allow the src and dst buffers to be bigger than\n     *            the area the need effect applied to it\n     * @param h   The height of the src image to apply effect to, this allow the src and dst buffers to be bigger than\n     *            the area the need effect applied to it\n     * @return Image with the result of the effect\n     */\n    @Override\n    BufferedImage applyEffect(BufferedImage src, BufferedImage dst, int w, int h) {\n        if (src == null || src.getType() != BufferedImage.TYPE_INT_ARGB){\n            throw new IllegalArgumentException(\"Effect only works with \" +\n                    \"source images of type BufferedImage.TYPE_INT_ARGB.\");\n        }\n        if (dst != null && dst.getType() != BufferedImage.TYPE_INT_ARGB){\n            throw new IllegalArgumentException(\"Effect only works with \" +\n                    \"destination images of type BufferedImage.TYPE_INT_ARGB.\");\n        }\n        // calculate offset\n        double trangleAngle = Math.toRadians(angle - 90);\n        int offsetX = (int) (Math.sin(trangleAngle) * distance);\n        int offsetY = (int) (Math.cos(trangleAngle) * distance);\n        // clac expanded size\n        int tmpOffX = offsetX + size;\n        int tmpOffY = offsetX + size;\n        int tmpW = w + offsetX + size + size;\n        int tmpH = h + offsetX + size;\n        // create tmp buffers\n        int[] lineBuf = getArrayCache().getTmpIntArray(w);\n        byte[] tmpBuf1 = getArrayCache().getTmpByteArray1(tmpW * tmpH);\n        Arrays.fill(tmpBuf1, (byte) 0x00);\n        byte[] tmpBuf2 = getArrayCache().getTmpByteArray2(tmpW * tmpH);\n        // extract src image alpha channel and inverse and offset\n        Raster srcRaster = src.getRaster();\n        for (int y = 0; y < h; y++) {\n            int dy = (y + tmpOffY);\n            int offset = dy * tmpW;\n            srcRaster.getDataElements(0, y, w, 1, lineBuf);\n            for (int x = 0; x < w; x++) {\n                int dx = x + tmpOffX;\n                tmpBuf1[offset + dx] = (byte) ((lineBuf[x] & 0xFF000000) >>> 24);\n            }\n        }\n        // blur\n        float[] kernel = EffectUtils.createGaussianKernel(size);\n        EffectUtils.blur(tmpBuf1, tmpBuf2, tmpW, tmpH, kernel, size); // horizontal pass\n        EffectUtils.blur(tmpBuf2, tmpBuf1, tmpH, tmpW, kernel, size);// vertical pass\n        //rescale\n        float spread = Math.min(1 / (1 - (0.01f * this.spread)), 255);\n        for (int i = 0; i < tmpBuf1.length; i++) {\n            int val = (int) (((int) tmpBuf1[i] & 0xFF) * spread);\n            tmpBuf1[i] = (val > 255) ? (byte) 0xFF : (byte) val;\n        }\n        // create color image with shadow color and greyscale image as alpha\n        if (dst == null) dst = new BufferedImage(w, h,\n                BufferedImage.TYPE_INT_ARGB);\n        WritableRaster shadowRaster = dst.getRaster();\n        int red = color.getRed(), green = color.getGreen(), blue = color.getBlue();\n        for (int y = 0; y < h; y++) {\n            int srcY = y + tmpOffY;\n            int shadowOffset = (srcY - offsetY) * tmpW;\n            for (int x = 0; x < w; x++) {\n                int srcX = x + tmpOffX;\n                lineBuf[x] = tmpBuf1[shadowOffset + (srcX - offsetX)] << 24 | red << 16 | green << 8 | blue;\n            }\n            shadowRaster.setDataElements(0, y, w, 1, lineBuf);\n        }\n        return dst;\n    }"}
{"Number":"1431","API Relative Path":"javax.swing.plaf.nimbus.EffectUtils.java-gaussianBlur(BufferedImage-BufferedImage-int)","Corresponding Source":"// =================================================================================================================\n    // Blur\n\n    /**\n     * Apply Gaussian Blur to Image\n     *\n     * @param src    The image tp\n     * @param dst    The destination image to draw blured src image into, null if you want a new one created\n     * @param radius The blur kernel radius\n     * @return The blured image\n     */\n    static BufferedImage gaussianBlur(BufferedImage src, BufferedImage dst, int radius) {\n        int width = src.getWidth();\n        int height = src.getHeight();\n        if (dst == null || dst.getWidth() != width || dst.getHeight() != height || src.getType() != dst.getType()) {\n            dst = createColorModelCompatibleImage(src);\n        }\n        float[] kernel = createGaussianKernel(radius);\n        if (src.getType() == BufferedImage.TYPE_INT_ARGB) {\n            int[] srcPixels = new int[width * height];\n            int[] dstPixels = new int[width * height];\n            getPixels(src, 0, 0, width, height, srcPixels);\n            // horizontal pass\n            blur(srcPixels, dstPixels, width, height, kernel, radius);\n            // vertical pass\n            //noinspection SuspiciousNameCombination\n            blur(dstPixels, srcPixels, height, width, kernel, radius);\n            // the result is now stored in srcPixels due to the 2nd pass\n            setPixels(dst, 0, 0, width, height, srcPixels);\n        } else if (src.getType() == BufferedImage.TYPE_BYTE_GRAY) {\n            byte[] srcPixels = new byte[width * height];\n            byte[] dstPixels = new byte[width * height];\n            getPixels(src, 0, 0, width, height, srcPixels);\n            // horizontal pass\n            blur(srcPixels, dstPixels, width, height, kernel, radius);\n            // vertical pass\n            //noinspection SuspiciousNameCombination\n            blur(dstPixels, srcPixels, height, width, kernel, radius);\n            // the result is now stored in srcPixels due to the 2nd pass\n            setPixels(dst, 0, 0, width, height, srcPixels);\n        } else {\n            throw new IllegalArgumentException(\"EffectUtils.gaussianBlur() src image is not a supported type, type=[\" +\n                    src.getType() + \"]\");\n        }\n        return dst;\n    }"}
{"Number":"1432","API Relative Path":"javax.swing.plaf.nimbus.EffectUtils.java-getPixels(BufferedImage-int-int-int-int-byte[])","Corresponding Source":"// =================================================================================================================\n    // Get/Set Pixels helper methods\n\n    /**\n     * <p>Returns an array of pixels, stored as integers, from a <code>BufferedImage<\/code>. The pixels are grabbed from\n     * a rectangular area defined by a location and two dimensions. Calling this method on an image of type different\n     * from <code>BufferedImage.TYPE_INT_ARGB<\/code> and <code>BufferedImage.TYPE_INT_RGB<\/code> will unmanage the\n     * image.<\/p>\n     *\n     * @param img    the source image\n     * @param x      the x location at which to start grabbing pixels\n     * @param y      the y location at which to start grabbing pixels\n     * @param w      the width of the rectangle of pixels to grab\n     * @param h      the height of the rectangle of pixels to grab\n     * @param pixels a pre-allocated array of pixels of size w*h; can be null\n     * @return <code>pixels<\/code> if non-null, a new array of integers otherwise\n     * @throws IllegalArgumentException is <code>pixels<\/code> is non-null and of length &lt; w*h\n     */\n    static byte[] getPixels(BufferedImage img,\n                                   int x, int y, int w, int h, byte[] pixels) {\n        if (w == 0 || h == 0) {\n            return new byte[0];\n        }\n\n        if (pixels == null) {\n            pixels = new byte[w * h];\n        } else if (pixels.length < w * h) {\n            throw new IllegalArgumentException(\"pixels array must have a length >= w*h\");\n        }\n\n        int imageType = img.getType();\n        if (imageType == BufferedImage.TYPE_BYTE_GRAY) {\n            Raster raster = img.getRaster();\n            return (byte[]) raster.getDataElements(x, y, w, h, pixels);\n        } else {\n            throw new IllegalArgumentException(\"Only type BYTE_GRAY is supported\");\n        }\n    }"}
{"Number":"1433","API Relative Path":"javax.swing.plaf.nimbus.EffectUtils.java-getPixels(BufferedImage-int-int-int-int-int[])","Corresponding Source":"/**\n     * <p>Returns an array of pixels, stored as integers, from a\n     * <code>BufferedImage<\/code>. The pixels are grabbed from a rectangular\n     * area defined by a location and two dimensions. Calling this method on\n     * an image of type different from <code>BufferedImage.TYPE_INT_ARGB<\/code>\n     * and <code>BufferedImage.TYPE_INT_RGB<\/code> will unmanage the image.<\/p>\n     *\n     * @param img the source image\n     * @param x the x location at which to start grabbing pixels\n     * @param y the y location at which to start grabbing pixels\n     * @param w the width of the rectangle of pixels to grab\n     * @param h the height of the rectangle of pixels to grab\n     * @param pixels a pre-allocated array of pixels of size w*h; can be null\n     * @return <code>pixels<\/code> if non-null, a new array of integers\n     *   otherwise\n     * @throws IllegalArgumentException is <code>pixels<\/code> is non-null and\n     *   of length &lt; w*h\n     */\n    public static int[] getPixels(BufferedImage img,\n                                  int x, int y, int w, int h, int[] pixels) {\n        if (w == 0 || h == 0) {\n            return new int[0];\n        }\n\n        if (pixels == null) {\n            pixels = new int[w * h];\n        } else if (pixels.length < w * h) {\n            throw new IllegalArgumentException(\"pixels array must have a length\" +\n                                               \" >= w*h\");\n        }\n\n        int imageType = img.getType();\n        if (imageType == BufferedImage.TYPE_INT_ARGB ||\n            imageType == BufferedImage.TYPE_INT_RGB) {\n            Raster raster = img.getRaster();\n            return (int[]) raster.getDataElements(x, y, w, h, pixels);\n        }\n\n        // Unmanages the image\n        return img.getRGB(x, y, w, h, pixels, 0, w);\n    }"}
{"Number":"1434","API Relative Path":"javax.swing.plaf.nimbus.EffectUtils.java-setPixels(BufferedImage-int-int-int-int-byte[])","Corresponding Source":"/**\n     * <p>Writes a rectangular area of pixels in the destination <code>BufferedImage<\/code>. Calling this method on an\n     * image of type different from <code>BufferedImage.TYPE_INT_ARGB<\/code> and <code>BufferedImage.TYPE_INT_RGB<\/code>\n     * will unmanage the image.<\/p>\n     *\n     * @param img    the destination image\n     * @param x      the x location at which to start storing pixels\n     * @param y      the y location at which to start storing pixels\n     * @param w      the width of the rectangle of pixels to store\n     * @param h      the height of the rectangle of pixels to store\n     * @param pixels an array of pixels, stored as integers\n     * @throws IllegalArgumentException is <code>pixels<\/code> is non-null and of length &lt; w*h\n     */\n    static void setPixels(BufferedImage img,\n                                 int x, int y, int w, int h, byte[] pixels) {\n        if (pixels == null || w == 0 || h == 0) {\n            return;\n        } else if (pixels.length < w * h) {\n            throw new IllegalArgumentException(\"pixels array must have a length >= w*h\");\n        }\n        int imageType = img.getType();\n        if (imageType == BufferedImage.TYPE_BYTE_GRAY) {\n            WritableRaster raster = img.getRaster();\n            raster.setDataElements(x, y, w, h, pixels);\n        } else {\n            throw new IllegalArgumentException(\"Only type BYTE_GRAY is supported\");\n        }\n    }"}
{"Number":"1435","API Relative Path":"javax.swing.plaf.nimbus.EffectUtils.java-setPixels(BufferedImage-int-int-int-int-byte[])","Corresponding Source":"/**\n     * <p>Writes a rectangular area of pixels in the destination <code>BufferedImage<\/code>. Calling this method on an\n     * image of type different from <code>BufferedImage.TYPE_INT_ARGB<\/code> and <code>BufferedImage.TYPE_INT_RGB<\/code>\n     * will unmanage the image.<\/p>\n     *\n     * @param img    the destination image\n     * @param x      the x location at which to start storing pixels\n     * @param y      the y location at which to start storing pixels\n     * @param w      the width of the rectangle of pixels to store\n     * @param h      the height of the rectangle of pixels to store\n     * @param pixels an array of pixels, stored as integers\n     * @throws IllegalArgumentException is <code>pixels<\/code> is non-null and of length &lt; w*h\n     */\n    static void setPixels(BufferedImage img,\n                                 int x, int y, int w, int h, byte[] pixels) {\n        if (pixels == null || w == 0 || h == 0) {\n            return;\n        } else if (pixels.length < w * h) {\n            throw new IllegalArgumentException(\"pixels array must have a length >= w*h\");\n        }\n        int imageType = img.getType();\n        if (imageType == BufferedImage.TYPE_BYTE_GRAY) {\n            WritableRaster raster = img.getRaster();\n            raster.setDataElements(x, y, w, h, pixels);\n        } else {\n            throw new IllegalArgumentException(\"Only type BYTE_GRAY is supported\");\n        }\n    }"}
{"Number":"1436","API Relative Path":"javax.swing.plaf.nimbus.EffectUtils.java-setPixels(BufferedImage-int-int-int-int-int[])","Corresponding Source":"/**\n     * <p>Writes a rectangular area of pixels in the destination\n     * <code>BufferedImage<\/code>. Calling this method on\n     * an image of type different from <code>BufferedImage.TYPE_INT_ARGB<\/code>\n     * and <code>BufferedImage.TYPE_INT_RGB<\/code> will unmanage the image.<\/p>\n     *\n     * @param img the destination image\n     * @param x the x location at which to start storing pixels\n     * @param y the y location at which to start storing pixels\n     * @param w the width of the rectangle of pixels to store\n     * @param h the height of the rectangle of pixels to store\n     * @param pixels an array of pixels, stored as integers\n     * @throws IllegalArgumentException is <code>pixels<\/code> is non-null and\n     *   of length &lt; w*h\n     */\n    public static void setPixels(BufferedImage img,\n                                 int x, int y, int w, int h, int[] pixels) {\n        if (pixels == null || w == 0 || h == 0) {\n            return;\n        } else if (pixels.length < w * h) {\n            throw new IllegalArgumentException(\"pixels array must have a length\" +\n                                               \" >= w*h\");\n        }\n\n        int imageType = img.getType();\n        if (imageType == BufferedImage.TYPE_INT_ARGB ||\n            imageType == BufferedImage.TYPE_INT_RGB) {\n            WritableRaster raster = img.getRaster();\n            raster.setDataElements(x, y, w, h, pixels);\n        } else {\n            // Unmanages the image\n            img.setRGB(x, y, w, h, pixels, 0, w);\n        }\n    }"}
{"Number":"1437","API Relative Path":"javax.swing.plaf.nimbus.EffectUtils.java-setPixels(BufferedImage-int-int-int-int-int[])","Corresponding Source":"/**\n     * <p>Writes a rectangular area of pixels in the destination\n     * <code>BufferedImage<\/code>. Calling this method on\n     * an image of type different from <code>BufferedImage.TYPE_INT_ARGB<\/code>\n     * and <code>BufferedImage.TYPE_INT_RGB<\/code> will unmanage the image.<\/p>\n     *\n     * @param img the destination image\n     * @param x the x location at which to start storing pixels\n     * @param y the y location at which to start storing pixels\n     * @param w the width of the rectangle of pixels to store\n     * @param h the height of the rectangle of pixels to store\n     * @param pixels an array of pixels, stored as integers\n     * @throws IllegalArgumentException is <code>pixels<\/code> is non-null and\n     *   of length &lt; w*h\n     */\n    public static void setPixels(BufferedImage img,\n                                 int x, int y, int w, int h, int[] pixels) {\n        if (pixels == null || w == 0 || h == 0) {\n            return;\n        } else if (pixels.length < w * h) {\n            throw new IllegalArgumentException(\"pixels array must have a length\" +\n                                               \" >= w*h\");\n        }\n\n        int imageType = img.getType();\n        if (imageType == BufferedImage.TYPE_INT_ARGB ||\n            imageType == BufferedImage.TYPE_INT_RGB) {\n            WritableRaster raster = img.getRaster();\n            raster.setDataElements(x, y, w, h, pixels);\n        } else {\n            // Unmanages the image\n            img.setRGB(x, y, w, h, pixels, 0, w);\n        }\n    }"}
{"Number":"1438","API Relative Path":"javax.swing.plaf.nimbus.ImageScalingHelper.java-paint(Graphics-int-int-int-int-Image-Insets-Insets-PaintType-int)","Corresponding Source":"/**\n     * Paints using the algorightm specified by <code>paintType<\/code>.\n     *\n     * @param g         Graphics to render to\n     * @param x         X-coordinate\n     * @param y         Y-coordinate\n     * @param w         Width to render to\n     * @param h         Height to render to\n     * @param image     Image to render from, if <code>null<\/code> this method will do nothing\n     * @param sInsets   Insets specifying the portion of the image that will be stretched or tiled, if <code>null<\/code>\n     *                  empty <code>Insets<\/code> will be used.\n     * @param dInsets   Destination insets specifying the portion of the image will be stretched or tiled, if\n     *                  <code>null<\/code> empty <code>Insets<\/code> will be used.\n     * @param paintType Specifies what type of algorithm to use in painting\n     * @param mask      Specifies portion of image to render, if <code>PAINT_ALL<\/code> is specified, any other regions\n     *                  specified will not be painted, for example PAINT_ALL | PAINT_CENTER paints everything but the\n     *                  center.\n     */\n    public static void paint(Graphics g, int x, int y, int w, int h,\n                      Image image, Insets sInsets,\n                      Insets dInsets, PaintType paintType, int mask) {\n        if (image == null || image.getWidth(null) <= 0 || image.getHeight(null) <= 0) {\n            return;\n        }\n        if (sInsets == null) {\n            sInsets = EMPTY_INSETS;\n        }\n        if (dInsets == null) {\n            dInsets = EMPTY_INSETS;\n        }\n        int iw = image.getWidth(null);\n        int ih = image.getHeight(null);\n\n        if (paintType == PaintType.CENTER) {\n            // Center the image\n            g.drawImage(image, x + (w - iw) / 2,\n                    y + (h - ih) / 2, null);\n        } else if (paintType == PaintType.TILE) {\n            // Tile the image\n            int lastIY = 0;\n            for (int yCounter = y, maxY = y + h; yCounter < maxY;\n                 yCounter += (ih - lastIY), lastIY = 0) {\n                int lastIX = 0;\n                for (int xCounter = x, maxX = x + w; xCounter < maxX;\n                     xCounter += (iw - lastIX), lastIX = 0) {\n                    int dx2 = Math.min(maxX, xCounter + iw - lastIX);\n                    int dy2 = Math.min(maxY, yCounter + ih - lastIY);\n                    g.drawImage(image, xCounter, yCounter, dx2, dy2,\n                            lastIX, lastIY, lastIX + dx2 - xCounter,\n                            lastIY + dy2 - yCounter, null);\n                }\n            }\n        } else {\n            int st = sInsets.top;\n            int sl = sInsets.left;\n            int sb = sInsets.bottom;\n            int sr = sInsets.right;\n\n            int dt = dInsets.top;\n            int dl = dInsets.left;\n            int db = dInsets.bottom;\n            int dr = dInsets.right;\n\n            // Constrain the insets to the size of the image\n            if (st + sb > ih) {\n                db = dt = sb = st = Math.max(0, ih / 2);\n            }\n            if (sl + sr > iw) {\n                dl = dr = sl = sr = Math.max(0, iw / 2);\n            }\n\n            // Constrain the insets to the size of the region we're painting\n            // in.\n            if (dt + db > h) {\n                dt = db = Math.max(0, h / 2 - 1);\n            }\n            if (dl + dr > w) {\n                dl = dr = Math.max(0, w / 2 - 1);\n            }\n\n            boolean stretch = (paintType == PaintType.PAINT9_STRETCH);\n            if ((mask & PAINT_ALL) != 0) {\n                mask = (PAINT_ALL - 1) & ~mask;\n            }\n\n            if ((mask & PAINT_LEFT) != 0) {\n                drawChunk(image, g, stretch, x, y + dt, x + dl, y + h - db,\n                        0, st, sl, ih - sb, false);\n            }\n            if ((mask & PAINT_TOP_LEFT) != 0) {\n                drawImage(image, g, x, y, x + dl, y + dt,\n                        0, 0, sl, st);\n            }\n            if ((mask & PAINT_TOP) != 0) {\n                drawChunk(image, g, stretch, x + dl, y, x + w - dr, y + dt,\n                        sl, 0, iw - sr, st, true);\n            }\n            if ((mask & PAINT_TOP_RIGHT) != 0) {\n                drawImage(image, g, x + w - dr, y, x + w, y + dt,\n                        iw - sr, 0, iw, st);\n            }\n            if ((mask & PAINT_RIGHT) != 0) {\n                drawChunk(image, g, stretch,\n                        x + w - dr, y + dt, x + w, y + h - db,\n                        iw - sr, st, iw, ih - sb, false);\n            }\n            if ((mask & PAINT_BOTTOM_RIGHT) != 0) {\n                drawImage(image, g, x + w - dr, y + h - db, x + w, y + h,\n                        iw - sr, ih - sb, iw, ih);\n            }\n            if ((mask & PAINT_BOTTOM) != 0) {\n                drawChunk(image, g, stretch,\n                        x + dl, y + h - db, x + w - dr, y + h,\n                        sl, ih - sb, iw - sr, ih, true);\n            }\n            if ((mask & PAINT_BOTTOM_LEFT) != 0) {\n                drawImage(image, g, x, y + h - db, x + dl, y + h,\n                        0, ih - sb, sl, ih);\n            }\n            if ((mask & PAINT_CENTER) != 0) {\n                drawImage(image, g, x + dl, y + dt, x + w - dr, y + h - db,\n                        sl, st, iw - sr, ih - sb);\n            }\n        }\n    }"}
{"Number":"1439","API Relative Path":"javax.swing.plaf.nimbus.InnerShadowEffect.java-applyEffect(BufferedImage-BufferedImage-int-int)","Corresponding Source":"/**\n     * Apply the effect to the src image generating the result . The result image may or may not contain the source\n     * image depending on what the effect type is.\n     *\n     * @param src The source image for applying the effect to\n     * @param dst The dstination image to paint effect result into. If this is null then a new image will be created\n     * @param w   The width of the src image to apply effect to, this allow the src and dst buffers to be bigger than\n     *            the area the need effect applied to it\n     * @param h   The height of the src image to apply effect to, this allow the src and dst buffers to be bigger than\n     *            the area the need effect applied to it\n     * @return Image with the result of the effect\n     */\n    BufferedImage applyEffect(BufferedImage src, BufferedImage dst, int w, int h) {\n        if (src == null || src.getType() != BufferedImage.TYPE_INT_ARGB){\n            throw new IllegalArgumentException(\"Effect only works with \" +\n                    \"source images of type BufferedImage.TYPE_INT_ARGB.\");\n        }\n        if (dst != null && dst.getType() != BufferedImage.TYPE_INT_ARGB){\n            throw new IllegalArgumentException(\"Effect only works with \" +\n                    \"destination images of type BufferedImage.TYPE_INT_ARGB.\");\n        }\n        // calculate offset\n        double trangleAngle = Math.toRadians(angle - 90);\n        int offsetX = (int) (Math.sin(trangleAngle) * distance);\n        int offsetY = (int) (Math.cos(trangleAngle) * distance);\n        // clac expanded size\n        int tmpOffX = offsetX + size;\n        int tmpOffY = offsetX + size;\n        int tmpW = w + offsetX + size + size;\n        int tmpH = h + offsetX + size;\n        // create tmp buffers\n        int[] lineBuf = getArrayCache().getTmpIntArray(w);\n        byte[] srcAlphaBuf = getArrayCache().getTmpByteArray1(tmpW * tmpH);\n        Arrays.fill(srcAlphaBuf, (byte) 0xFF);\n        byte[] tmpBuf1 = getArrayCache().getTmpByteArray2(tmpW * tmpH);\n        byte[] tmpBuf2 = getArrayCache().getTmpByteArray3(tmpW * tmpH);\n        // extract src image alpha channel and inverse and offset\n        Raster srcRaster = src.getRaster();\n        for (int y = 0; y < h; y++) {\n            int dy = (y + tmpOffY);\n            int offset = dy * tmpW;\n            srcRaster.getDataElements(0, y, w, 1, lineBuf);\n            for (int x = 0; x < w; x++) {\n                int dx = x + tmpOffX;\n                srcAlphaBuf[offset + dx] = (byte) ((255 - ((lineBuf[x] & 0xFF000000) >>> 24)) & 0xFF);\n            }\n        }\n        // blur\n        float[] kernel = EffectUtils.createGaussianKernel(size * 2);\n        EffectUtils.blur(srcAlphaBuf, tmpBuf2, tmpW, tmpH, kernel, size * 2); // horizontal pass\n        EffectUtils.blur(tmpBuf2, tmpBuf1, tmpH, tmpW, kernel, size * 2);// vertical pass\n        //rescale\n        float spread = Math.min(1 / (1 - (0.01f * this.spread)), 255);\n        for (int i = 0; i < tmpBuf1.length; i++) {\n            int val = (int) (((int) tmpBuf1[i] & 0xFF) * spread);\n            tmpBuf1[i] = (val > 255) ? (byte) 0xFF : (byte) val;\n        }\n        // create color image with shadow color and greyscale image as alpha\n        if (dst == null) dst = new BufferedImage(w, h,\n                BufferedImage.TYPE_INT_ARGB);\n        WritableRaster shadowRaster = dst.getRaster();\n        int red = color.getRed(), green = color.getGreen(), blue = color.getBlue();\n        for (int y = 0; y < h; y++) {\n            int srcY = y + tmpOffY;\n            int offset = srcY * tmpW;\n            int shadowOffset = (srcY - offsetY) * tmpW;\n            for (int x = 0; x < w; x++) {\n                int srcX = x + tmpOffX;\n                int origianlAlphaVal = 255 - ((int) srcAlphaBuf[offset + srcX] & 0xFF);\n                int shadowVal = (int) tmpBuf1[shadowOffset + (srcX - offsetX)] & 0xFF;\n                int alphaVal = Math.min(origianlAlphaVal, shadowVal);\n                lineBuf[x] = ((byte) alphaVal & 0xFF) << 24 | red << 16 | green << 8 | blue;\n            }\n            shadowRaster.setDataElements(0, y, w, 1, lineBuf);\n        }\n        return dst;\n    }"}
{"Number":"1440","API Relative Path":"javax.swing.plaf.nimbus.NimbusDefaults.java-getStyle(JComponent-Region)","Corresponding Source":"/**\n     * <p>Locate the style associated with the given region, and component.\n     * This is called from NimbusLookAndFeel in the SynthStyleFactory\n     * implementation.<\/p>\n     *\n     * <p>Lookup occurs as follows:<br/>\n     * Check the map of styles <code>m<\/code>. If the map contains no styles at\n     * all, then simply return the defaultStyle. If the map contains styles,\n     * then iterate over all of the styles for the Region <code>r<\/code> looking\n     * for the best match, based on prefix. If a match was made, then return\n     * that SynthStyle. Otherwise, return the defaultStyle.<\/p>\n     *\n     * @param comp The component associated with this region. For example, if\n     *        the Region is Region.Button then the component will be a JButton.\n     *        If the Region is a subregion, such as ScrollBarThumb, then the\n     *        associated component will be the component that subregion belongs\n     *        to, such as JScrollBar. The JComponent may be named. It may not be\n     *        null.\n     * @param r The region we are looking for a style for. May not be null.\n     */\n    SynthStyle getStyle(JComponent comp, Region r) {\n        //validate method arguments\n        if (comp == null || r == null) {\n            throw new IllegalArgumentException(\n                    \"Neither comp nor r may be null\");\n        }\n\n        //if there are no lazy styles registered for the region r, then return\n        //the default style\n        List<LazyStyle> styles = m.get(r);\n        if (styles == null || styles.size() == 0) {\n            return defaultStyle;\n        }\n\n        //Look for the best SynthStyle for this component/region pair.\n        LazyStyle foundStyle = null;\n        for (LazyStyle s : styles) {\n            if (s.matches(comp)) {\n                //replace the foundStyle if foundStyle is null, or\n                //if the new style \"s\" is more specific (ie, its path was\n                //longer), or if the foundStyle was \"simple\" and the new style\n                //was not (ie: the foundStyle was for something like Button and\n                //the new style was for something like \"MyButton\", hence, being\n                //more specific.) In all cases, favor the most specific style\n                //found.\n                if (foundStyle == null ||\n                   (foundStyle.parts.length < s.parts.length) ||\n                   (foundStyle.parts.length == s.parts.length \n                    && foundStyle.simple && !s.simple)) {\n                    foundStyle = s;\n                }\n            }\n        }\n\n        //return the style, if found, or the default style if not found\n        return foundStyle == null ? defaultStyle : foundStyle.getStyle(comp, r);\n    }"}
{"Number":"1441","API Relative Path":"javax.swing.plaf.nimbus.NimbusDefaults.java-register(Region-String)","Corresponding Source":"/**\n     * <p>Registers the given region and prefix. The prefix, if it contains\n     * quoted sections, refers to certain named components. If there are not\n     * quoted sections, then the prefix refers to a generic component type.<\/p>\n     *\n     * <p>If the given region/prefix combo has already been registered, then\n     * it will not be registered twice. The second registration attempt will\n     * fail silently.<\/p>\n     *\n     * @param region The Synth Region that is being registered. Such as Button,\n     *        or ScrollBarThumb.\n     * @param prefix The UIDefault prefix. For example, could be ComboBox, or if\n     *        a named components, \"MyComboBox\", or even something like\n     *        ToolBar:\"MyComboBox\":\"ComboBox.arrowButton\"\n     */\n    void register(Region region, String prefix) {\n        //validate the method arguments\n        if (region == null || prefix == null) {\n            throw new IllegalArgumentException(\n                    \"Neither Region nor Prefix may be null\");\n        }\n\n        //Add a LazyStyle for this region/prefix to m.\n        List<LazyStyle> styles = m.get(region);\n        if (styles == null) {\n            styles = new LinkedList<LazyStyle>();\n            styles.add(new LazyStyle(prefix));\n            m.put(region, styles);\n        } else {\n            //iterate over all the current styles and see if this prefix has\n            //already been registered. If not, then register it.\n            for (LazyStyle s : styles) {\n                if (prefix.equals(s.prefix)) {\n                    return;\n                }\n            }\n            styles.add(new LazyStyle(prefix));\n        }\n\n        //add this region to the map of registered regions\n        registeredRegions.put(region.getName(), region);\n    }"}
{"Number":"1442","API Relative Path":"javax.swing.plaf.nimbus.NimbusLookAndFeel.java-resolveToolbarConstraint(JToolBar)","Corresponding Source":"/**\n     * Package private method which returns either BorderLayout.NORTH,\n     * BorderLayout.SOUTH, BorderLayout.EAST, or BorderLayout.WEST depending\n     * on the location of the toolbar in its parent. The toolbar might be\n     * in PAGE_START, PAGE_END, CENTER, or some other position, but will be\n     * resolved to either NORTH,SOUTH,EAST, or WEST based on where the toolbar\n     * actually IS, with CENTER being NORTH.\n     *\n     * This code is used to determine where the border line should be drawn\n     * by the custom toolbar states, and also used by NimbusIcon to determine\n     * whether the handle icon needs to be shifted to look correct.\n     *\n     * Toollbars are unfortunately odd in the way these things are handled,\n     * and so this code exists to unify the logic related to toolbars so it can\n     * be shared among the static files such as NimbusIcon and generated files\n     * such as the ToolBar state classes.\n     */\n    static Object resolveToolbarConstraint(JToolBar toolbar) {\n        //NOTE: we don't worry about component orientation or PAGE_END etc\n        //because the BasicToolBarUI always uses an absolute position of\n        //NORTH/SOUTH/EAST/WEST.\n        if (toolbar != null) {\n            Container parent = toolbar.getParent();\n            if (parent != null) {\n                LayoutManager m = parent.getLayout();\n                if (m instanceof BorderLayout) {\n                    BorderLayout b = (BorderLayout)m;\n                    Object con = b.getConstraints(toolbar);\n                    if (con == SOUTH || con == EAST || con == WEST) {\n                        return con;\n                    }\n                    return NORTH;\n                }\n            }\n        }\n        return NORTH;\n    }"}
{"Number":"1443","API Relative Path":"javax.swing.plaf.synth.ColorType.java-ColorType(String)","Corresponding Source":"/**\n     * Creates a new ColorType with the specified description.\n     *\n     * @param description String description of the ColorType.\n     */\n    protected ColorType(String description) {\n        if (description == null) {\n            throw new NullPointerException(\n                          \"ColorType must have a valid description\");\n        }\n        this.description = description;\n        synchronized(ColorType.class) {\n            this.index = nextID++;\n        }\n    }"}
{"Number":"1444","API Relative Path":"javax.swing.plaf.synth.SynthButtonUI.java-getBaseline(JComponent-int-int)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getBaseline(JComponent c, int width, int height) {\n        if (c == null) {\n            throw new NullPointerException(\"Component must be non-null\");\n        }\n        if (width < 0 || height < 0) {\n            throw new IllegalArgumentException(\n                    \"Width and height must be >= 0\");\n        }\n        AbstractButton b = (AbstractButton)c;\n        String text = b.getText();\n        if (text == null || \"\".equals(text)) {\n            return -1;\n        }\n        Insets i = b.getInsets();\n        Rectangle viewRect = new Rectangle();\n        Rectangle textRect = new Rectangle();\n        Rectangle iconRect = new Rectangle();\n        viewRect.x = i.left;\n        viewRect.y = i.top;\n        viewRect.width = width - (i.right + viewRect.x);\n        viewRect.height = height - (i.bottom + viewRect.y);\n\n        // layout the text and icon\n        SynthContext context = getContext(b);\n        FontMetrics fm = context.getComponent().getFontMetrics(\n            context.getStyle().getFont(context));\n        context.getStyle().getGraphicsUtils(context).layoutText(\n            context, fm, b.getText(), b.getIcon(),\n            b.getHorizontalAlignment(), b.getVerticalAlignment(),\n            b.getHorizontalTextPosition(), b.getVerticalTextPosition(),\n            viewRect, iconRect, textRect, b.getIconTextGap());\n        View view = (View)b.getClientProperty(BasicHTML.propertyKey);\n        int baseline;\n        if (view != null) {\n            baseline = BasicHTML.getHTMLBaseline(view, textRect.width,\n                                                 textRect.height);\n            if (baseline >= 0) {\n                baseline += textRect.y;\n            }\n        }\n        else {\n            baseline = textRect.y + fm.getAscent();\n        }\n        context.dispose();\n        return baseline;\n    }"}
{"Number":"1445","API Relative Path":"javax.swing.plaf.synth.SynthButtonUI.java-getBaseline(JComponent-int-int)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getBaseline(JComponent c, int width, int height) {\n        if (c == null) {\n            throw new NullPointerException(\"Component must be non-null\");\n        }\n        if (width < 0 || height < 0) {\n            throw new IllegalArgumentException(\n                    \"Width and height must be >= 0\");\n        }\n        AbstractButton b = (AbstractButton)c;\n        String text = b.getText();\n        if (text == null || \"\".equals(text)) {\n            return -1;\n        }\n        Insets i = b.getInsets();\n        Rectangle viewRect = new Rectangle();\n        Rectangle textRect = new Rectangle();\n        Rectangle iconRect = new Rectangle();\n        viewRect.x = i.left;\n        viewRect.y = i.top;\n        viewRect.width = width - (i.right + viewRect.x);\n        viewRect.height = height - (i.bottom + viewRect.y);\n\n        // layout the text and icon\n        SynthContext context = getContext(b);\n        FontMetrics fm = context.getComponent().getFontMetrics(\n            context.getStyle().getFont(context));\n        context.getStyle().getGraphicsUtils(context).layoutText(\n            context, fm, b.getText(), b.getIcon(),\n            b.getHorizontalAlignment(), b.getVerticalAlignment(),\n            b.getHorizontalTextPosition(), b.getVerticalTextPosition(),\n            viewRect, iconRect, textRect, b.getIconTextGap());\n        View view = (View)b.getClientProperty(BasicHTML.propertyKey);\n        int baseline;\n        if (view != null) {\n            baseline = BasicHTML.getHTMLBaseline(view, textRect.width,\n                                                 textRect.height);\n            if (baseline >= 0) {\n                baseline += textRect.y;\n            }\n        }\n        else {\n            baseline = textRect.y + fm.getAscent();\n        }\n        context.dispose();\n        return baseline;\n    }"}
{"Number":"1446","API Relative Path":"javax.swing.plaf.synth.SynthContext.java-SynthContext(JComponent-Region-SynthStyle-int)","Corresponding Source":"/**\n     * Creates a SynthContext with the specified values. This is meant\n     * for subclasses and custom UI implementors. You very rarely need to\n     * construct a SynthContext, though some methods will take one.\n     *\n     * @param component JComponent\n     * @param region Identifies the portion of the JComponent\n     * @param style Style associated with the component\n     * @param state State of the component as defined in SynthConstants.\n     * @throws NullPointerException if component, region of style is null.\n     */\n    public SynthContext(JComponent component, Region region, SynthStyle style,\n                        int state) {\n        if (component == null || region == null || style == null) {\n            throw new NullPointerException(\n                \"You must supply a non-null component, region and style\");\n        }\n        reset(component, region, style, state);\n    }"}
{"Number":"1447","API Relative Path":"javax.swing.plaf.synth.SynthGraphicsUtils.java-paintText(SynthContext-Graphics-String-Icon-int-int-int-int-int-int-int)","Corresponding Source":"/**\n     * Paints an icon and text. This will render the text as html, if\n     * necessary, and offset the location by the insets of the component.\n     *\n     * @param ss SynthContext\n     * @param g Graphics to render string and icon into\n     * @param text Text to layout\n     * @param icon Icon to layout\n     * @param hAlign horizontal alignment\n     * @param vAlign vertical alignment\n     * @param hTextPosition horizontal text position\n     * @param vTextPosition vertical text position\n     * @param iconTextGap gap between icon and text\n     * @param mnemonicIndex Index into text to render the mnemonic at, -1\n     *        indicates no mnemonic.\n     * @param textOffset Amount to offset the text when painting\n     */\n    public void paintText(SynthContext ss, Graphics g, String text,\n                      Icon icon, int hAlign, int vAlign, int hTextPosition,\n                      int vTextPosition, int iconTextGap, int mnemonicIndex,\n                      int textOffset) {\n        if ((icon == null) && (text == null)) {\n            return;\n        }\n        JComponent c = ss.getComponent();\n        FontMetrics fm = SwingUtilities2.getFontMetrics(c, g);\n        Insets insets = SynthLookAndFeel.getPaintingInsets(ss, paintInsets);\n\n        paintViewR.x = insets.left;\n        paintViewR.y = insets.top;\n        paintViewR.width = c.getWidth() - (insets.left + insets.right);\n        paintViewR.height = c.getHeight() - (insets.top + insets.bottom);\n\n        paintIconR.x = paintIconR.y = paintIconR.width = paintIconR.height = 0;\n        paintTextR.x = paintTextR.y = paintTextR.width = paintTextR.height = 0;\n\n        String clippedText =\n            layoutText(ss, fm, text, icon, hAlign, vAlign,\n                   hTextPosition, vTextPosition, paintViewR, paintIconR,\n                   paintTextR, iconTextGap);\n\n        if (icon != null) {\n            Color color = g.getColor();\n\n            if (ss.getStyle().getBoolean(ss, \"TableHeader.alignSorterArrow\", false) &&\n                \"TableHeader.renderer\".equals(c.getName())) {\n                paintIconR.x = paintViewR.width - paintIconR.width;\n            } else {\n                paintIconR.x += textOffset;\n            }\n            paintIconR.y += textOffset;\n            SynthIcon.paintIcon(icon, ss, g, paintIconR.x, paintIconR.y,\n                                paintIconR.width, paintIconR.height);\n            g.setColor(color);\n        }\n\n        if (text != null) {\n            View v = (View) c.getClientProperty(BasicHTML.propertyKey);\n\n            if (v != null) {\n                v.paint(g, paintTextR);\n            } else {\n                paintTextR.x += textOffset;\n                paintTextR.y += textOffset;\n\n                paintText(ss, g, clippedText, paintTextR, mnemonicIndex);\n            }\n        }\n    }"}
{"Number":"1448","API Relative Path":"javax.swing.plaf.synth.SynthGraphicsUtils.java-paintText(SynthContext-Graphics-String-int-int-int)","Corresponding Source":"/**\n     * Paints text at the specified location. This will not attempt to\n     * render the text as html nor will it offset by the insets of the\n     * component.\n     *\n     * @param ss SynthContext\n     * @param g Graphics used to render string in.\n     * @param text Text to render\n     * @param x X location to draw text at.\n     * @param y Upper left corner to draw text at.\n     * @param mnemonicIndex Index to draw string at.\n     */\n    public void paintText(SynthContext ss, Graphics g, String text,\n                          int x, int y, int mnemonicIndex) {\n        if (text != null) {\n            JComponent c = ss.getComponent();\n            FontMetrics fm = SwingUtilities2.getFontMetrics(c, g);\n            y += fm.getAscent();\n            SwingUtilities2.drawStringUnderlineCharAt(c, g, text,\n                                                      mnemonicIndex, x, y);\n        }\n    }"}
{"Number":"1449","API Relative Path":"javax.swing.plaf.synth.SynthLabelUI.java-getBaseline(JComponent-int-int)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getBaseline(JComponent c, int width, int height) {\n        if (c == null) {\n            throw new NullPointerException(\"Component must be non-null\");\n        }\n        if (width < 0 || height < 0) {\n            throw new IllegalArgumentException(\n                    \"Width and height must be >= 0\");\n        }\n        JLabel label = (JLabel)c;\n        String text = label.getText();\n        if (text == null || \"\".equals(text)) {\n            return -1;\n        }\n        Insets i = label.getInsets();\n        Rectangle viewRect = new Rectangle();\n        Rectangle textRect = new Rectangle();\n        Rectangle iconRect = new Rectangle();\n        viewRect.x = i.left;\n        viewRect.y = i.top;\n        viewRect.width = width - (i.right + viewRect.x);\n        viewRect.height = height - (i.bottom + viewRect.y);\n\n        // layout the text and icon\n        SynthContext context = getContext(label);\n        FontMetrics fm = context.getComponent().getFontMetrics(\n            context.getStyle().getFont(context));\n        context.getStyle().getGraphicsUtils(context).layoutText(\n            context, fm, label.getText(), label.getIcon(),\n            label.getHorizontalAlignment(), label.getVerticalAlignment(),\n            label.getHorizontalTextPosition(), label.getVerticalTextPosition(),\n            viewRect, iconRect, textRect, label.getIconTextGap());\n        View view = (View)label.getClientProperty(BasicHTML.propertyKey);\n        int baseline;\n        if (view != null) {\n            baseline = BasicHTML.getHTMLBaseline(view, textRect.width,\n                                                 textRect.height);\n            if (baseline >= 0) {\n                baseline += textRect.y;\n            }\n        }\n        else {\n            baseline = textRect.y + fm.getAscent();\n        }\n        context.dispose();\n        return baseline;\n    }"}
{"Number":"1450","API Relative Path":"javax.swing.plaf.synth.SynthLabelUI.java-getBaseline(JComponent-int-int)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getBaseline(JComponent c, int width, int height) {\n        if (c == null) {\n            throw new NullPointerException(\"Component must be non-null\");\n        }\n        if (width < 0 || height < 0) {\n            throw new IllegalArgumentException(\n                    \"Width and height must be >= 0\");\n        }\n        JLabel label = (JLabel)c;\n        String text = label.getText();\n        if (text == null || \"\".equals(text)) {\n            return -1;\n        }\n        Insets i = label.getInsets();\n        Rectangle viewRect = new Rectangle();\n        Rectangle textRect = new Rectangle();\n        Rectangle iconRect = new Rectangle();\n        viewRect.x = i.left;\n        viewRect.y = i.top;\n        viewRect.width = width - (i.right + viewRect.x);\n        viewRect.height = height - (i.bottom + viewRect.y);\n\n        // layout the text and icon\n        SynthContext context = getContext(label);\n        FontMetrics fm = context.getComponent().getFontMetrics(\n            context.getStyle().getFont(context));\n        context.getStyle().getGraphicsUtils(context).layoutText(\n            context, fm, label.getText(), label.getIcon(),\n            label.getHorizontalAlignment(), label.getVerticalAlignment(),\n            label.getHorizontalTextPosition(), label.getVerticalTextPosition(),\n            viewRect, iconRect, textRect, label.getIconTextGap());\n        View view = (View)label.getClientProperty(BasicHTML.propertyKey);\n        int baseline;\n        if (view != null) {\n            baseline = BasicHTML.getHTMLBaseline(view, textRect.width,\n                                                 textRect.height);\n            if (baseline >= 0) {\n                baseline += textRect.y;\n            }\n        }\n        else {\n            baseline = textRect.y + fm.getAscent();\n        }\n        context.dispose();\n        return baseline;\n    }"}
{"Number":"1451","API Relative Path":"javax.swing.plaf.synth.SynthLookAndFeel.java-load(URL)","Corresponding Source":"/**\n     * Loads the set of <code>SynthStyle<\/code>s that will be used by\n     * this <code>SynthLookAndFeel<\/code>. Path based resources are resolved\n     * relatively to the specified <code>URL<\/code> of the style. For example\n     * an <code>Image<\/code> would be resolved by\n     * <code>new URL(synthFile, path)<\/code>. Refer to\n     * <a href=\"doc-files/synthFileFormat.html\">Synth File Format<\/a> for more\n     * information.\n     *\n     * @param url the <code>URL<\/code> to load the set of\n     *     <code>SynthStyle<\/code> from\n     * @throws ParseException if there is an error in parsing\n     * @throws IllegalArgumentException if synthSet is <code>null<\/code>\n     * @throws IOException if synthSet cannot be opened as an <code>InputStream<\/code>\n     * @since 1.6\n     */\n    public void load(URL url) throws ParseException, IOException {\n        if (url == null) {\n            throw new IllegalArgumentException(\n                \"You must supply a valid Synth set URL\");\n        }\n\n        if (defaultsMap == null) {\n            defaultsMap = new HashMap<String, Object>();\n        }\n\n        InputStream input = url.openStream();\n        new SynthParser().parse(input, (DefaultSynthStyleFactory) factory,\n                                url, null, defaultsMap);\n    }"}
{"Number":"1452","API Relative Path":"javax.swing.plaf.synth.SynthLookAndFeel.java-load(URL)","Corresponding Source":"/**\n     * Loads the set of <code>SynthStyle<\/code>s that will be used by\n     * this <code>SynthLookAndFeel<\/code>. Path based resources are resolved\n     * relatively to the specified <code>URL<\/code> of the style. For example\n     * an <code>Image<\/code> would be resolved by\n     * <code>new URL(synthFile, path)<\/code>. Refer to\n     * <a href=\"doc-files/synthFileFormat.html\">Synth File Format<\/a> for more\n     * information.\n     *\n     * @param url the <code>URL<\/code> to load the set of\n     *     <code>SynthStyle<\/code> from\n     * @throws ParseException if there is an error in parsing\n     * @throws IllegalArgumentException if synthSet is <code>null<\/code>\n     * @throws IOException if synthSet cannot be opened as an <code>InputStream<\/code>\n     * @since 1.6\n     */\n    public void load(URL url) throws ParseException, IOException {\n        if (url == null) {\n            throw new IllegalArgumentException(\n                \"You must supply a valid Synth set URL\");\n        }\n\n        if (defaultsMap == null) {\n            defaultsMap = new HashMap<String, Object>();\n        }\n\n        InputStream input = url.openStream();\n        new SynthParser().parse(input, (DefaultSynthStyleFactory) factory,\n                                url, null, defaultsMap);\n    }"}
{"Number":"1453","API Relative Path":"javax.swing.plaf.synth.SynthParser.java-parse(InputStream-DefaultSynthStyleFactory-URL-Class-Map)","Corresponding Source":"/**\n     * Parses a set of styles from <code>inputStream<\/code>, adding the\n     * resulting styles to the passed in DefaultSynthStyleFactory.\n     * Resources are resolved either from a URL or from a Class. When calling\n     * this method, one of the URL or the Class must be null but not both at\n     * the same time.\n     *\n     * @param inputStream XML document containing the styles to read\n     * @param factory DefaultSynthStyleFactory that new styles are added to\n     * @param urlResourceBase the URL used to resolve any resources, such as Images\n     * @param classResourceBase the Class used to resolve any resources, such as Images\n     * @param defaultsMap Map that UIDefaults properties are placed in\n     */\n    public void parse(InputStream inputStream,\n                      DefaultSynthStyleFactory factory,\n                      URL urlResourceBase, Class<?> classResourceBase,\n                      Map<String, Object> defaultsMap)\n                      throws ParseException, IllegalArgumentException {\n        if (inputStream == null || factory == null ||\n            (urlResourceBase == null && classResourceBase == null)) {\n            throw new IllegalArgumentException(\n                \"You must supply an InputStream, StyleFactory and Class or URL\");\n        }\n\n        assert(!(urlResourceBase != null && classResourceBase != null));\n\n        _factory = factory;\n        _classResourceBase = classResourceBase;\n        _urlResourceBase = urlResourceBase;\n        _defaultsMap = defaultsMap;\n        try {\n            try {\n                SAXParser saxParser = SAXParserFactory.newInstance().\n                                                   newSAXParser();\n                saxParser.parse(new BufferedInputStream(inputStream), this);\n            } catch (ParserConfigurationException e) {\n                throw new ParseException(\"Error parsing: \" + e, 0);\n            }\n            catch (SAXException se) {\n                throw new ParseException(\"Error parsing: \" + se + \" \" +\n                                         se.getException(), 0);\n            }\n            catch (IOException ioe) {\n                throw new ParseException(\"Error parsing: \" + ioe, 0);\n            }\n        } finally {\n            reset();\n        }\n    }"}
{"Number":"1454","API Relative Path":"javax.swing.plaf.synth.SynthSliderUI.java-getBaseline(JComponent-int-int)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getBaseline(JComponent c, int width, int height) {\n        if (c == null) {\n            throw new NullPointerException(\"Component must be non-null\");\n        }\n        if (width < 0 || height < 0) {\n            throw new IllegalArgumentException(\n                    \"Width and height must be >= 0\");\n        }\n        if (slider.getPaintLabels() && labelsHaveSameBaselines()) {\n            // Get the insets for the track.\n            Insets trackInsets = new Insets(0, 0, 0, 0);\n            SynthContext trackContext = getContext(slider,\n                                                   Region.SLIDER_TRACK);\n            style.getInsets(trackContext, trackInsets);\n            trackContext.dispose();\n            if (slider.getOrientation() == JSlider.HORIZONTAL) {\n                int valueHeight = 0;\n                if (paintValue) {\n                    SynthContext context = getContext(slider);\n                    valueHeight = context.getStyle().getGraphicsUtils(context).\n                            getMaximumCharHeight(context);\n                    context.dispose();\n                }\n                int tickHeight = 0;\n                if (slider.getPaintTicks()) {\n                    tickHeight = getTickLength();\n                }\n                int labelHeight = getHeightOfTallestLabel();\n                int contentHeight = valueHeight + trackHeight +\n                        trackInsets.top + trackInsets.bottom +\n                        tickHeight + labelHeight + 4;\n                int centerY = height / 2 - contentHeight / 2;\n                centerY += valueHeight + 2;\n                centerY += trackHeight + trackInsets.top + trackInsets.bottom;\n                centerY += tickHeight + 2;\n                JComponent label = (JComponent) slider.getLabelTable().elements().nextElement();\n                Dimension pref = label.getPreferredSize();\n                return centerY + label.getBaseline(pref.width, pref.height);\n            }\n            else { // VERTICAL\n                Integer value = slider.getInverted() ? getLowestValue() :\n                                                       getHighestValue();\n                if (value != null) {\n                    int valueY = insetCache.top;\n                    int valueHeight = 0;\n                    if (paintValue) {\n                        SynthContext context = getContext(slider);\n                        valueHeight = context.getStyle().getGraphicsUtils(\n                                context).getMaximumCharHeight(context);\n                        context.dispose();\n                    }\n                    int contentHeight = height - insetCache.top -\n                            insetCache.bottom;\n                    int trackY = valueY + valueHeight;\n                    int trackHeight = contentHeight - valueHeight;\n                    int yPosition = yPositionForValue(value.intValue(), trackY,\n                                                      trackHeight);\n                    JComponent label = (JComponent) slider.getLabelTable().get(value);\n                    Dimension pref = label.getPreferredSize();\n                    return yPosition - pref.height / 2 +\n                            label.getBaseline(pref.width, pref.height);\n                }\n            }\n        }\n        return -1;\n    }"}
{"Number":"1455","API Relative Path":"javax.swing.plaf.synth.SynthSliderUI.java-getBaseline(JComponent-int-int)","Corresponding Source":"/**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getBaseline(JComponent c, int width, int height) {\n        if (c == null) {\n            throw new NullPointerException(\"Component must be non-null\");\n        }\n        if (width < 0 || height < 0) {\n            throw new IllegalArgumentException(\n                    \"Width and height must be >= 0\");\n        }\n        if (slider.getPaintLabels() && labelsHaveSameBaselines()) {\n            // Get the insets for the track.\n            Insets trackInsets = new Insets(0, 0, 0, 0);\n            SynthContext trackContext = getContext(slider,\n                                                   Region.SLIDER_TRACK);\n            style.getInsets(trackContext, trackInsets);\n            trackContext.dispose();\n            if (slider.getOrientation() == JSlider.HORIZONTAL) {\n                int valueHeight = 0;\n                if (paintValue) {\n                    SynthContext context = getContext(slider);\n                    valueHeight = context.getStyle().getGraphicsUtils(context).\n                            getMaximumCharHeight(context);\n                    context.dispose();\n                }\n                int tickHeight = 0;\n                if (slider.getPaintTicks()) {\n                    tickHeight = getTickLength();\n                }\n                int labelHeight = getHeightOfTallestLabel();\n                int contentHeight = valueHeight + trackHeight +\n                        trackInsets.top + trackInsets.bottom +\n                        tickHeight + labelHeight + 4;\n                int centerY = height / 2 - contentHeight / 2;\n                centerY += valueHeight + 2;\n                centerY += trackHeight + trackInsets.top + trackInsets.bottom;\n                centerY += tickHeight + 2;\n                JComponent label = (JComponent) slider.getLabelTable().elements().nextElement();\n                Dimension pref = label.getPreferredSize();\n                return centerY + label.getBaseline(pref.width, pref.height);\n            }\n            else { // VERTICAL\n                Integer value = slider.getInverted() ? getLowestValue() :\n                                                       getHighestValue();\n                if (value != null) {\n                    int valueY = insetCache.top;\n                    int valueHeight = 0;\n                    if (paintValue) {\n                        SynthContext context = getContext(slider);\n                        valueHeight = context.getStyle().getGraphicsUtils(\n                                context).getMaximumCharHeight(context);\n                        context.dispose();\n                    }\n                    int contentHeight = height - insetCache.top -\n                            insetCache.bottom;\n                    int trackY = valueY + valueHeight;\n                    int trackHeight = contentHeight - valueHeight;\n                    int yPosition = yPositionForValue(value.intValue(), trackY,\n                                                      trackHeight);\n                    JComponent label = (JComponent) slider.getLabelTable().get(value);\n                    Dimension pref = label.getPreferredSize();\n                    return yPosition - pref.height / 2 +\n                            label.getBaseline(pref.width, pref.height);\n                }\n            }\n        }\n        return -1;\n    }"}
{"Number":"1456","API Relative Path":"javax.swing.plaf.synth.SynthSpinnerUI.java-replaceEditor(JComponent-JComponent)","Corresponding Source":"/**\n     * Called by the <code>PropertyChangeListener<\/code> when the\n     * <code>JSpinner<\/code> editor property changes.  It's the responsibility\n     * of this method to remove the old editor and add the new one.  By\n     * default this operation is just:\n     * <pre>\n     * spinner.remove(oldEditor);\n     * spinner.add(newEditor, \"Editor\");\n     * <\/pre>\n     * The implementation of <code>replaceEditor<\/code> should be coordinated\n     * with the <code>createEditor<\/code> method.\n     *\n     * @see #createEditor\n     * @see #createPropertyChangeListener\n     */\n    @Override\n    protected void replaceEditor(JComponent oldEditor, JComponent newEditor) {\n        spinner.remove(oldEditor);\n        spinner.add(newEditor, \"Editor\");\n        if (oldEditor instanceof JSpinner.DefaultEditor) {\n            JTextField tf = ((JSpinner.DefaultEditor)oldEditor).getTextField();\n            if (tf != null) {\n                tf.removeFocusListener(editorFocusHandler);\n            }\n        }\n        if (newEditor instanceof JSpinner.DefaultEditor) {\n            JTextField tf = ((JSpinner.DefaultEditor)newEditor).getTextField();\n            if (tf != null) {\n                tf.addFocusListener(editorFocusHandler);\n            }\n        }\n    }"}
{"Number":"1457","API Relative Path":"javax.swing.plaf.synth.SynthSpinnerUI.java-replaceEditor(JComponent-JComponent)","Corresponding Source":"/**\n     * Called by the <code>PropertyChangeListener<\/code> when the\n     * <code>JSpinner<\/code> editor property changes.  It's the responsibility\n     * of this method to remove the old editor and add the new one.  By\n     * default this operation is just:\n     * <pre>\n     * spinner.remove(oldEditor);\n     * spinner.add(newEditor, \"Editor\");\n     * <\/pre>\n     * The implementation of <code>replaceEditor<\/code> should be coordinated\n     * with the <code>createEditor<\/code> method.\n     *\n     * @see #createEditor\n     * @see #createPropertyChangeListener\n     */\n    @Override\n    protected void replaceEditor(JComponent oldEditor, JComponent newEditor) {\n        spinner.remove(oldEditor);\n        spinner.add(newEditor, \"Editor\");\n        if (oldEditor instanceof JSpinner.DefaultEditor) {\n            JTextField tf = ((JSpinner.DefaultEditor)oldEditor).getTextField();\n            if (tf != null) {\n                tf.removeFocusListener(editorFocusHandler);\n            }\n        }\n        if (newEditor instanceof JSpinner.DefaultEditor) {\n            JTextField tf = ((JSpinner.DefaultEditor)newEditor).getTextField();\n            if (tf != null) {\n                tf.addFocusListener(editorFocusHandler);\n            }\n        }\n    }"}
{"Number":"1458","API Relative Path":"javax.swing.Popup.java-reset(Component-Component-int-int)","Corresponding Source":"/**\n     * Resets the <code>Popup<\/code> to an initial state.\n     */\n    void reset(Component owner, Component contents, int ownerX, int ownerY) {\n        if (getComponent() == null) {\n            component = createComponent(owner);\n        }\n\n        Component c = getComponent();\n\n        if (c instanceof JWindow) {\n            JWindow component = (JWindow)getComponent();\n\n            component.setLocation(ownerX, ownerY);\n            component.getContentPane().add(contents, BorderLayout.CENTER);\n            component.invalidate();\n            component.validate();\n            if(component.isVisible()) {\n                // Do not call pack() if window is not visible to\n                // avoid early native peer creation\n                pack();\n            }\n        }\n    }"}
{"Number":"1459","API Relative Path":"javax.swing.Popup.java-reset(Component-Component-int-int)","Corresponding Source":"/**\n     * Resets the <code>Popup<\/code> to an initial state.\n     */\n    void reset(Component owner, Component contents, int ownerX, int ownerY) {\n        if (getComponent() == null) {\n            component = createComponent(owner);\n        }\n\n        Component c = getComponent();\n\n        if (c instanceof JWindow) {\n            JWindow component = (JWindow)getComponent();\n\n            component.setLocation(ownerX, ownerY);\n            component.getContentPane().add(contents, BorderLayout.CENTER);\n            component.invalidate();\n            component.validate();\n            if(component.isVisible()) {\n                // Do not call pack() if window is not visible to\n                // avoid early native peer creation\n                pack();\n            }\n        }\n    }"}
{"Number":"1460","API Relative Path":"javax.swing.RepaintManager.java-addDirtyRegion(Applet-int-int-int-int)","Corresponding Source":"/**\n     * Adds <code>applet<\/code> to the list of <code>Component<\/code>s that\n     * need to be repainted.\n     *\n     * @param applet Applet to repaint, null results in nothing happening.\n     * @param x X coordinate of the region to repaint\n     * @param y Y coordinate of the region to repaint\n     * @param w Width of the region to repaint\n     * @param h Height of the region to repaint\n     * @see JApplet#repaint\n     * @since 1.6\n     */\n    public void addDirtyRegion(Applet applet, int x, int y, int w, int h) {\n        addDirtyRegion0(applet, x, y, w, h);\n    }"}
{"Number":"1461","API Relative Path":"javax.swing.RepaintManager.java-addDirtyRegion(JComponent-int-int-int-int)","Corresponding Source":"/**\n     * Add a component in the list of components that should be refreshed.\n     * If <i>c<\/i> already has a dirty region, the rectangle <i>(x,y,w,h)<\/i>\n     * will be unioned with the region that should be redrawn.\n     *\n     * @param c Component to repaint, null results in nothing happening.\n     * @param x X coordinate of the region to repaint\n     * @param y Y coordinate of the region to repaint\n     * @param w Width of the region to repaint\n     * @param h Height of the region to repaint\n     * @see JComponent#repaint\n     */\n    public void addDirtyRegion(JComponent c, int x, int y, int w, int h)\n    {\n        RepaintManager delegate = getDelegate(c);\n        if (delegate != null) {\n            delegate.addDirtyRegion(c, x, y, w, h);\n            return;\n        }\n        addDirtyRegion0(c, x, y, w, h);\n    }"}
{"Number":"1462","API Relative Path":"javax.swing.RepaintManager.java-addDirtyRegion(Window-int-int-int-int)","Corresponding Source":"/**\n     * Adds <code>window<\/code> to the list of <code>Component<\/code>s that\n     * need to be repainted.\n     *\n     * @param window Window to repaint, null results in nothing happening.\n     * @param x X coordinate of the region to repaint\n     * @param y Y coordinate of the region to repaint\n     * @param w Width of the region to repaint\n     * @param h Height of the region to repaint\n     * @see JFrame#repaint\n     * @see JWindow#repaint\n     * @see JDialog#repaint\n     * @since 1.6\n     */\n    public void addDirtyRegion(Window window, int x, int y, int w, int h) {\n        addDirtyRegion0(window, x, y, w, h);\n    }"}
{"Number":"1463","API Relative Path":"javax.swing.RepaintManager.java-markCompletelyDirty(JComponent)","Corresponding Source":"/**\n     * Mark a component completely dirty. <b>aComponent<\/b> will be\n     * completely painted during the next paintDirtyRegions() call.\n     */\n    public void markCompletelyDirty(JComponent aComponent) {\n        RepaintManager delegate = getDelegate(aComponent);\n        if (delegate != null) {\n            delegate.markCompletelyDirty(aComponent);\n            return;\n        }\n        addDirtyRegion(aComponent,0,0,Integer.MAX_VALUE,Integer.MAX_VALUE);\n    }"}
{"Number":"1464","API Relative Path":"javax.swing.RowSorter.java-addRowSorterListener(RowSorterListener)","Corresponding Source":"/**\n     * Adds a <code>RowSorterListener<\/code> to receive notification\n     * about this <code>RowSorter<\/code>.  If the same\n     * listener is added more than once it will receive multiple\n     * notifications.  If <code>l<\/code> is <code>null<\/code> nothing\n     * is done.\n     *\n     * @param l the <code>RowSorterListener<\/code>\n     */\n    public void addRowSorterListener(RowSorterListener l) {\n        listenerList.add(RowSorterListener.class, l);\n    }"}
{"Number":"1465","API Relative Path":"javax.swing.RowSorter.java-removeRowSorterListener(RowSorterListener)","Corresponding Source":"/**\n     * Removes a <code>RowSorterListener<\/code>.  If\n     * <code>l<\/code> is <code>null<\/code> nothing is done.\n     *\n     * @param l the <code>RowSorterListener<\/code>\n     */\n    public void removeRowSorterListener(RowSorterListener l) {\n        listenerList.remove(RowSorterListener.class, l);\n    }"}
{"Number":"1466","API Relative Path":"javax.swing.SpinnerDateModel.java-setValue(Object)","Corresponding Source":"/**\n     * Sets the current <code>Date<\/code> for this sequence.\n     * If <code>value<\/code> is <code>null<\/code>,\n     * an <code>IllegalArgumentException<\/code> is thrown.  No bounds\n     * checking is done here:\n     * the new value may invalidate the <code>(start &lt;= value &lt; end)<\/code>\n     * invariant enforced by the constructors.  Naturally, one should ensure\n     * that the <code>(start &lt;= value &lt;= maximum)<\/code> invariant is true\n     * before calling the <code>nextValue<\/code>, <code>previousValue<\/code>,\n     * or <code>setValue<\/code> methods.\n     * <p>\n     * This method fires a <code>ChangeEvent<\/code> if the\n     * <code>value<\/code> has changed.\n     *\n     * @param value the current (non <code>null<\/code>)\n     *    <code>Date<\/code> for this sequence\n     * @throws IllegalArgumentException if value is <code>null<\/code>\n     *    or not a <code>Date<\/code>\n     * @see #getDate\n     * @see #getValue\n     * @see #addChangeListener\n     */\n    public void setValue(Object value) {\n        if ((value == null) || !(value instanceof Date)) {\n            throw new IllegalArgumentException(\"illegal value\");\n        }\n        if (!value.equals(this.value.getTime())) {\n            this.value.setTime((Date)value);\n            fireStateChanged();\n        }\n    }"}
{"Number":"1467","API Relative Path":"javax.swing.SpinnerDateModel.java-SpinnerDateModel(Date-Comparable-Comparable-int)","Corresponding Source":"/**\n     * Creates a <code>SpinnerDateModel<\/code> that represents a sequence of dates\n     * between <code>start<\/code> and <code>end<\/code>.  The\n     * <code>nextValue<\/code> and <code>previousValue<\/code> methods\n     * compute elements of the sequence by advancing or reversing\n     * the current date <code>value<\/code> by the\n     * <code>calendarField<\/code> time unit.  For a precise description\n     * of what it means to increment or decrement a <code>Calendar<\/code>\n     * <code>field<\/code>, see the <code>add<\/code> method in\n     * <code>java.util.Calendar<\/code>.\n     * <p>\n     * The <code>start<\/code> and <code>end<\/code> parameters can be\n     * <code>null<\/code> to indicate that the range doesn't have an\n     * upper or lower bound.  If <code>value<\/code> or\n     * <code>calendarField<\/code> is <code>null<\/code>, or if both\n     * <code>start<\/code> and <code>end<\/code> are specified and\n     * <code>minimum &gt; maximum<\/code> then an\n     * <code>IllegalArgumentException<\/code> is thrown.\n     * Similarly if <code>(minimum &lt;= value &lt;= maximum)<\/code> is false,\n     * an IllegalArgumentException is thrown.\n     *\n     * @param value the current (non <code>null<\/code>) value of the model\n     * @param start the first date in the sequence or <code>null<\/code>\n     * @param end the last date in the sequence or <code>null<\/code>\n     * @param calendarField one of\n     *   <ul>\n     *    <li><code>Calendar.ERA<\/code>\n     *    <li><code>Calendar.YEAR<\/code>\n     *    <li><code>Calendar.MONTH<\/code>\n     *    <li><code>Calendar.WEEK_OF_YEAR<\/code>\n     *    <li><code>Calendar.WEEK_OF_MONTH<\/code>\n     *    <li><code>Calendar.DAY_OF_MONTH<\/code>\n     *    <li><code>Calendar.DAY_OF_YEAR<\/code>\n     *    <li><code>Calendar.DAY_OF_WEEK<\/code>\n     *    <li><code>Calendar.DAY_OF_WEEK_IN_MONTH<\/code>\n     *    <li><code>Calendar.AM_PM<\/code>\n     *    <li><code>Calendar.HOUR<\/code>\n     *    <li><code>Calendar.HOUR_OF_DAY<\/code>\n     *    <li><code>Calendar.MINUTE<\/code>\n     *    <li><code>Calendar.SECOND<\/code>\n     *    <li><code>Calendar.MILLISECOND<\/code>\n     *   <\/ul>\n     *\n     * @throws IllegalArgumentException if <code>value<\/code> or\n     *    <code>calendarField<\/code> are <code>null<\/code>,\n     *    if <code>calendarField<\/code> isn't valid,\n     *    or if the following expression is\n     *    false: <code>(start &lt;= value &lt;= end)<\/code>.\n     *\n     * @see Calendar#add\n     * @see #setValue\n     * @see #setStart\n     * @see #setEnd\n     * @see #setCalendarField\n     */\n    public SpinnerDateModel(Date value, Comparable start, Comparable end, int calendarField) {\n        if (value == null) {\n            throw new IllegalArgumentException(\"value is null\");\n        }\n        if (!calendarFieldOK(calendarField)) {\n            throw new IllegalArgumentException(\"invalid calendarField\");\n        }\n        if (!(((start == null) || (start.compareTo(value) <= 0)) &&\n              ((end == null) || (end.compareTo(value) >= 0)))) {\n            throw new IllegalArgumentException(\"(start <= value <= end) is false\");\n        }\n        this.value = Calendar.getInstance();\n        this.start = start;\n        this.end = end;\n        this.calendarField = calendarField;\n\n        this.value.setTime(value);\n    }"}
{"Number":"1468","API Relative Path":"javax.swing.SpinnerNumberModel.java-setStepSize(Number)","Corresponding Source":"/**\n     * Changes the size of the value change computed by the\n     * <code>getNextValue<\/code> and <code>getPreviousValue<\/code>\n     * methods.  An <code>IllegalArgumentException<\/code>\n     * is thrown if <code>stepSize<\/code> is <code>null<\/code>.\n     * <p>\n     * This method fires a <code>ChangeEvent<\/code> if the\n     * <code>stepSize<\/code> has changed.\n     *\n     * @param stepSize the size of the value change computed by the\n     *     <code>getNextValue<\/code> and <code>getPreviousValue<\/code> methods\n     * @see #getNextValue\n     * @see #getPreviousValue\n     * @see #getStepSize\n     * @see SpinnerModel#addChangeListener\n     */\n    public void setStepSize(Number stepSize) {\n        if (stepSize == null) {\n            throw new IllegalArgumentException(\"null stepSize\");\n        }\n        if (!stepSize.equals(this.stepSize)) {\n            this.stepSize = stepSize;\n            fireStateChanged();\n        }\n    }"}
{"Number":"1469","API Relative Path":"javax.swing.SpinnerNumberModel.java-setValue(Object)","Corresponding Source":"/**\n     * Sets the current value for this sequence.  If <code>value<\/code> is\n     * <code>null<\/code>, or not a <code>Number<\/code>, an\n     * <code>IllegalArgumentException<\/code> is thrown.  No\n     * bounds checking is done here; the new value may invalidate the\n     * <code>(minimum &lt;= value &lt;= maximum)<\/code>\n     * invariant enforced by the constructors.   It's also possible to set\n     * the value to be something that wouldn't naturally occur in the sequence,\n     * i.e. a value that's not modulo the <code>stepSize<\/code>.\n     * This is to simplify updating the model, and to accommodate\n     * spinners that don't want to restrict values that have been\n     * directly entered by the user. Naturally, one should ensure that the\n     * <code>(minimum &lt;= value &lt;= maximum)<\/code> invariant is true\n     * before calling the <code>next<\/code>, <code>previous<\/code>, or\n     * <code>setValue<\/code> methods.\n     * <p>\n     * This method fires a <code>ChangeEvent<\/code> if the value has changed.\n     *\n     * @param value the current (non <code>null<\/code>) <code>Number<\/code>\n     *         for this sequence\n     * @throws IllegalArgumentException if <code>value<\/code> is\n     *         <code>null<\/code> or not a <code>Number<\/code>\n     * @see #getNumber\n     * @see #getValue\n     * @see SpinnerModel#addChangeListener\n     */\n    public void setValue(Object value) {\n        if ((value == null) || !(value instanceof Number)) {\n            throw new IllegalArgumentException(\"illegal value\");\n        }\n        if (!value.equals(this.value)) {\n            this.value = (Number)value;\n            fireStateChanged();\n        }\n    }"}
{"Number":"1470","API Relative Path":"javax.swing.SpinnerNumberModel.java-SpinnerNumberModel(Number-Comparable-Comparable-Number)","Corresponding Source":"/**\n     * Constructs a <code>SpinnerModel<\/code> that represents\n     * a closed sequence of\n     * numbers from <code>minimum<\/code> to <code>maximum<\/code>.  The\n     * <code>nextValue<\/code> and <code>previousValue<\/code> methods\n     * compute elements of the sequence by adding or subtracting\n     * <code>stepSize<\/code> respectively.  All of the parameters\n     * must be mutually <code>Comparable<\/code>, <code>value<\/code>\n     * and <code>stepSize<\/code> must be instances of <code>Integer<\/code>\n     * <code>Long<\/code>, <code>Float<\/code>, or <code>Double<\/code>.\n     * <p>\n     * The <code>minimum<\/code> and <code>maximum<\/code> parameters\n     * can be <code>null<\/code> to indicate that the range doesn't\n     * have an upper or lower bound.\n     * If <code>value<\/code> or <code>stepSize<\/code> is <code>null<\/code>,\n     * or if both <code>minimum<\/code> and <code>maximum<\/code>\n     * are specified and <code>minimum &gt; maximum<\/code> then an\n     * <code>IllegalArgumentException<\/code> is thrown.\n     * Similarly if <code>(minimum &lt;= value &lt;= maximum<\/code>) is false,\n     * an <code>IllegalArgumentException<\/code> is thrown.\n     *\n     * @param value the current (non <code>null<\/code>) value of the model\n     * @param minimum the first number in the sequence or <code>null<\/code>\n     * @param maximum the last number in the sequence or <code>null<\/code>\n     * @param stepSize the difference between elements of the sequence\n     *\n     * @throws IllegalArgumentException if stepSize or value is\n     *     <code>null<\/code> or if the following expression is false:\n     *     <code>minimum &lt;= value &lt;= maximum<\/code>\n     */\n    public SpinnerNumberModel(Number value, Comparable minimum, Comparable maximum, Number stepSize) {\n        if ((value == null) || (stepSize == null)) {\n            throw new IllegalArgumentException(\"value and stepSize must be non-null\");\n        }\n        if (!(((minimum == null) || (minimum.compareTo(value) <= 0)) &&\n              ((maximum == null) || (maximum.compareTo(value) >= 0)))) {\n            throw new IllegalArgumentException(\"(minimum <= value <= maximum) is false\");\n        }\n        this.value = value;\n        this.minimum = minimum;\n        this.maximum = maximum;\n        this.stepSize = stepSize;\n    }"}
{"Number":"1471","API Relative Path":"javax.swing.SpinnerNumberModel.java-SpinnerNumberModel(Number-Comparable-Comparable-Number)","Corresponding Source":"/**\n     * Constructs a <code>SpinnerModel<\/code> that represents\n     * a closed sequence of\n     * numbers from <code>minimum<\/code> to <code>maximum<\/code>.  The\n     * <code>nextValue<\/code> and <code>previousValue<\/code> methods\n     * compute elements of the sequence by adding or subtracting\n     * <code>stepSize<\/code> respectively.  All of the parameters\n     * must be mutually <code>Comparable<\/code>, <code>value<\/code>\n     * and <code>stepSize<\/code> must be instances of <code>Integer<\/code>\n     * <code>Long<\/code>, <code>Float<\/code>, or <code>Double<\/code>.\n     * <p>\n     * The <code>minimum<\/code> and <code>maximum<\/code> parameters\n     * can be <code>null<\/code> to indicate that the range doesn't\n     * have an upper or lower bound.\n     * If <code>value<\/code> or <code>stepSize<\/code> is <code>null<\/code>,\n     * or if both <code>minimum<\/code> and <code>maximum<\/code>\n     * are specified and <code>minimum &gt; maximum<\/code> then an\n     * <code>IllegalArgumentException<\/code> is thrown.\n     * Similarly if <code>(minimum &lt;= value &lt;= maximum<\/code>) is false,\n     * an <code>IllegalArgumentException<\/code> is thrown.\n     *\n     * @param value the current (non <code>null<\/code>) value of the model\n     * @param minimum the first number in the sequence or <code>null<\/code>\n     * @param maximum the last number in the sequence or <code>null<\/code>\n     * @param stepSize the difference between elements of the sequence\n     *\n     * @throws IllegalArgumentException if stepSize or value is\n     *     <code>null<\/code> or if the following expression is false:\n     *     <code>minimum &lt;= value &lt;= maximum<\/code>\n     */\n    public SpinnerNumberModel(Number value, Comparable minimum, Comparable maximum, Number stepSize) {\n        if ((value == null) || (stepSize == null)) {\n            throw new IllegalArgumentException(\"value and stepSize must be non-null\");\n        }\n        if (!(((minimum == null) || (minimum.compareTo(value) <= 0)) &&\n              ((maximum == null) || (maximum.compareTo(value) >= 0)))) {\n            throw new IllegalArgumentException(\"(minimum <= value <= maximum) is false\");\n        }\n        this.value = value;\n        this.minimum = minimum;\n        this.maximum = maximum;\n        this.stepSize = stepSize;\n    }"}
{"Number":"1472","API Relative Path":"javax.swing.Spring.java-height(Component)","Corresponding Source":"/**\n     * Returns a spring whose <em>minimum<\/em>, <em>preferred<\/em>, <em>maximum<\/em>\n     * and <em>value<\/em> properties are defined by the heights of the <em>minimumSize<\/em>,\n     * <em>preferredSize<\/em>, <em>maximumSize<\/em> and <em>size<\/em> properties\n     * of the supplied component. The returned spring is a 'wrapper' implementation\n     * whose methods call the appropriate size methods of the supplied component.\n     * The minimum, preferred, maximum and value properties of the returned spring\n     * therefore report the current state of the appropriate properties in the\n     * component and track them as they change.\n     *\n     * @param c Component used for calculating size\n     * @return  a spring whose properties are defined by the vertical component\n     * of the component's size methods.\n     * @throws NullPointerException if <code>c<\/code> is null\n     * @since 1.5\n     */\n    public static Spring height(Component c) {\n        checkArg(c);\n        return new HeightSpring(c);\n    }"}
{"Number":"1473","API Relative Path":"javax.swing.Spring.java-scale(Spring-float)","Corresponding Source":"/*\n    public static Spring min(Spring s1, Spring s2) {\n        return minus(max(minus(s1), minus(s2)));\n    }\n    */\n\n    /**\n     * Returns a spring whose <em>minimum<\/em>, <em>preferred<\/em>, <em>maximum<\/em>\n     * and <em>value<\/em> properties are each multiples of the properties of the\n     * argument spring, <code>s<\/code>. Minimum and maximum properties are\n     * swapped when <code>factor<\/code> is negative (in accordance with the\n     * rules of interval arithmetic).\n     * <p>\n     * When factor is, for example, 0.5f the result represents 'the mid-point'\n     * of its input - an operation that is useful for centering components in\n     * a container.\n     *\n     * @param s the spring to scale\n     * @param factor amount to scale by.\n     * @return  a spring whose properties are those of the input spring <code>s<\/code>\n     * multiplied by <code>factor<\/code>\n     * @throws NullPointerException if <code>s<\/code> is null\n     * @since 1.5\n     */\n    public static Spring scale(Spring s, float factor) {\n        checkArg(s);\n        return new ScaleSpring(s, factor);\n    }"}
{"Number":"1474","API Relative Path":"javax.swing.Spring.java-width(Component)","Corresponding Source":"/**\n     * Returns a spring whose <em>minimum<\/em>, <em>preferred<\/em>, <em>maximum<\/em>\n     * and <em>value<\/em> properties are defined by the widths of the <em>minimumSize<\/em>,\n     * <em>preferredSize<\/em>, <em>maximumSize<\/em> and <em>size<\/em> properties\n     * of the supplied component. The returned spring is a 'wrapper' implementation\n     * whose methods call the appropriate size methods of the supplied component.\n     * The minimum, preferred, maximum and value properties of the returned spring\n     * therefore report the current state of the appropriate properties in the\n     * component and track them as they change.\n     *\n     * @param c Component used for calculating size\n     * @return  a spring whose properties are defined by the horizontal component\n     * of the component's size methods.\n     * @throws NullPointerException if <code>c<\/code> is null\n     * @since 1.5\n     */\n    public static Spring width(Component c) {\n        checkArg(c);\n        return new WidthSpring(c);\n    }"}
{"Number":"1475","API Relative Path":"javax.swing.SpringLayout.java-getConstraints(Component)","Corresponding Source":"/**\n     * Returns the constraints for the specified component.\n     * Note that,\n     * unlike the <code>GridBagLayout<\/code>\n     * <code>getConstraints<\/code> method,\n     * this method does not clone constraints.\n     * If no constraints\n     * have been associated with this component,\n     * this method\n     * returns a default constraints object positioned at\n     * 0,0 relative to the parent's Insets and its width/height\n     * constrained to the minimum, maximum, and preferred sizes of the\n     * component. The size characteristics\n     * are not frozen at the time this method is called;\n     * instead this method returns a constraints object\n     * whose characteristics track the characteristics\n     * of the component as they change.\n     *\n     * @param       c the component whose constraints will be returned\n     *\n     * @return      the constraints for the specified component\n     */\n    public Constraints getConstraints(Component c) {\n       Constraints result = componentConstraints.get(c);\n       if (result == null) {\n           if (c instanceof javax.swing.JComponent) {\n                Object cp = ((javax.swing.JComponent)c).getClientProperty(SpringLayout.class);\n                if (cp instanceof Constraints) {\n                    return applyDefaults(c, (Constraints)cp);\n                }\n            }\n            result = new Constraints();\n            putConstraints(c, result);\n       }\n       return result;\n    }"}
{"Number":"1476","API Relative Path":"javax.swing.SpringLayout.java-getConstraints(Component)","Corresponding Source":"/**\n     * Returns the constraints for the specified component.\n     * Note that,\n     * unlike the <code>GridBagLayout<\/code>\n     * <code>getConstraints<\/code> method,\n     * this method does not clone constraints.\n     * If no constraints\n     * have been associated with this component,\n     * this method\n     * returns a default constraints object positioned at\n     * 0,0 relative to the parent's Insets and its width/height\n     * constrained to the minimum, maximum, and preferred sizes of the\n     * component. The size characteristics\n     * are not frozen at the time this method is called;\n     * instead this method returns a constraints object\n     * whose characteristics track the characteristics\n     * of the component as they change.\n     *\n     * @param       c the component whose constraints will be returned\n     *\n     * @return      the constraints for the specified component\n     */\n    public Constraints getConstraints(Component c) {\n       Constraints result = componentConstraints.get(c);\n       if (result == null) {\n           if (c instanceof javax.swing.JComponent) {\n                Object cp = ((javax.swing.JComponent)c).getClientProperty(SpringLayout.class);\n                if (cp instanceof Constraints) {\n                    return applyDefaults(c, (Constraints)cp);\n                }\n            }\n            result = new Constraints();\n            putConstraints(c, result);\n       }\n       return result;\n    }"}
{"Number":"1477","API Relative Path":"javax.swing.SpringLayout.java-getConstraints(Component)","Corresponding Source":"/**\n     * Returns the constraints for the specified component.\n     * Note that,\n     * unlike the <code>GridBagLayout<\/code>\n     * <code>getConstraints<\/code> method,\n     * this method does not clone constraints.\n     * If no constraints\n     * have been associated with this component,\n     * this method\n     * returns a default constraints object positioned at\n     * 0,0 relative to the parent's Insets and its width/height\n     * constrained to the minimum, maximum, and preferred sizes of the\n     * component. The size characteristics\n     * are not frozen at the time this method is called;\n     * instead this method returns a constraints object\n     * whose characteristics track the characteristics\n     * of the component as they change.\n     *\n     * @param       c the component whose constraints will be returned\n     *\n     * @return      the constraints for the specified component\n     */\n    public Constraints getConstraints(Component c) {\n       Constraints result = componentConstraints.get(c);\n       if (result == null) {\n           if (c instanceof javax.swing.JComponent) {\n                Object cp = ((javax.swing.JComponent)c).getClientProperty(SpringLayout.class);\n                if (cp instanceof Constraints) {\n                    return applyDefaults(c, (Constraints)cp);\n                }\n            }\n            result = new Constraints();\n            putConstraints(c, result);\n       }\n       return result;\n    }"}
{"Number":"1478","API Relative Path":"javax.swing.SpringLayout.java-getConstraints(Component)","Corresponding Source":"/**\n     * Returns the constraints for the specified component.\n     * Note that,\n     * unlike the <code>GridBagLayout<\/code>\n     * <code>getConstraints<\/code> method,\n     * this method does not clone constraints.\n     * If no constraints\n     * have been associated with this component,\n     * this method\n     * returns a default constraints object positioned at\n     * 0,0 relative to the parent's Insets and its width/height\n     * constrained to the minimum, maximum, and preferred sizes of the\n     * component. The size characteristics\n     * are not frozen at the time this method is called;\n     * instead this method returns a constraints object\n     * whose characteristics track the characteristics\n     * of the component as they change.\n     *\n     * @param       c the component whose constraints will be returned\n     *\n     * @return      the constraints for the specified component\n     */\n    public Constraints getConstraints(Component c) {\n       Constraints result = componentConstraints.get(c);\n       if (result == null) {\n           if (c instanceof javax.swing.JComponent) {\n                Object cp = ((javax.swing.JComponent)c).getClientProperty(SpringLayout.class);\n                if (cp instanceof Constraints) {\n                    return applyDefaults(c, (Constraints)cp);\n                }\n            }\n            result = new Constraints();\n            putConstraints(c, result);\n       }\n       return result;\n    }"}
{"Number":"1479","API Relative Path":"javax.swing.SwingUtilities.java-calculateInnerArea(JComponent-Rectangle)","Corresponding Source":"/**\n     * Stores the position and size of\n     * the inner painting area of the specified component\n     * in <code>r<\/code> and returns <code>r<\/code>.\n     * The position and size specify the bounds of the component,\n     * adjusted so as not to include the border area (the insets).\n     * This method is useful for classes\n     * that implement painting code.\n     *\n     * @param c  the JComponent in question; if {@code null}, this method returns {@code null}\n     * @param r  the Rectangle instance to be modified;\n     *           may be {@code null}\n     * @return {@code null} if the Component is {@code null};\n     *         otherwise, returns the passed-in rectangle (if non-{@code null})\n     *         or a new rectangle specifying position and size information\n     *\n     * @since 1.4\n     */\n    public static Rectangle calculateInnerArea(JComponent c, Rectangle r) {\n        if (c == null) {\n            return null;\n        }\n        Rectangle rect = r;\n        Insets insets = c.getInsets();\n\n        if (rect == null) {\n            rect = new Rectangle();\n        }\n\n        rect.x = insets.left;\n        rect.y = insets.top;\n        rect.width = c.getWidth() - insets.left - insets.right;\n        rect.height = c.getHeight() - insets.top - insets.bottom;\n\n        return rect;\n    }"}
{"Number":"1480","API Relative Path":"javax.swing.SwingUtilities.java-convertMouseEvent(Component-MouseEvent-Component)","Corresponding Source":"/**\n     * Returns a MouseEvent similar to <code>sourceEvent<\/code> except that its x\n     * and y members have been converted to <code>destination<\/code>'s coordinate\n     * system.  If <code>source<\/code> is {@code null}, <code>sourceEvent<\/code> x and y members\n     * are assumed to be into <code>destination<\/code>'s root component coordinate system.\n     * If <code>destination<\/code> is <code>null<\/code>, the\n     * returned MouseEvent will be in <code>source<\/code>'s coordinate system.\n     * <code>sourceEvent<\/code> will not be changed. A new event is returned.\n     * the <code>source<\/code> field of the returned event will be set\n     * to <code>destination<\/code> if destination is non-{@code null}\n     * use the translateMouseEvent() method to translate a mouse event from\n     * one component to another without changing the source.\n     */\n    public static MouseEvent convertMouseEvent(Component source,\n                                               MouseEvent sourceEvent,\n                                               Component destination) {\n        Point p = convertPoint(source,new Point(sourceEvent.getX(),\n                                                sourceEvent.getY()),\n                               destination);\n        Component newSource;\n\n        if(destination != null)\n            newSource = destination;\n        else\n            newSource = source;\n\n        MouseEvent newEvent;\n        if (sourceEvent instanceof MouseWheelEvent) {\n            MouseWheelEvent sourceWheelEvent = (MouseWheelEvent)sourceEvent;\n            newEvent = new MouseWheelEvent(newSource,\n                                           sourceWheelEvent.getID(),\n                                           sourceWheelEvent.getWhen(),\n                                           sourceWheelEvent.getModifiers()\n                                                   | sourceWheelEvent.getModifiersEx(),\n                                           p.x,p.y,\n                                           sourceWheelEvent.getXOnScreen(),\n                                           sourceWheelEvent.getYOnScreen(),\n                                           sourceWheelEvent.getClickCount(),\n                                           sourceWheelEvent.isPopupTrigger(),\n                                           sourceWheelEvent.getScrollType(),\n                                           sourceWheelEvent.getScrollAmount(),\n                                           sourceWheelEvent.getWheelRotation());\n        }\n        else if (sourceEvent instanceof MenuDragMouseEvent) {\n            MenuDragMouseEvent sourceMenuDragEvent = (MenuDragMouseEvent)sourceEvent;\n            newEvent = new MenuDragMouseEvent(newSource,\n                                              sourceMenuDragEvent.getID(),\n                                              sourceMenuDragEvent.getWhen(),\n                                              sourceMenuDragEvent.getModifiers()\n                                                      | sourceMenuDragEvent.getModifiersEx(),\n                                              p.x,p.y,\n                                              sourceMenuDragEvent.getXOnScreen(),\n                                              sourceMenuDragEvent.getYOnScreen(),\n                                              sourceMenuDragEvent.getClickCount(),\n                                              sourceMenuDragEvent.isPopupTrigger(),\n                                              sourceMenuDragEvent.getPath(),\n                                              sourceMenuDragEvent.getMenuSelectionManager());\n        }\n        else {\n            newEvent = new MouseEvent(newSource,\n                                      sourceEvent.getID(),\n                                      sourceEvent.getWhen(),\n                                      sourceEvent.getModifiers()\n                                              | sourceEvent.getModifiersEx(),\n                                      p.x,p.y,\n                                      sourceEvent.getXOnScreen(),\n                                      sourceEvent.getYOnScreen(),\n                                      sourceEvent.getClickCount(),\n                                      sourceEvent.isPopupTrigger(),\n                                      sourceEvent.getButton());\n        }\n        return newEvent;\n    }"}
{"Number":"1481","API Relative Path":"javax.swing.SwingUtilities.java-convertMouseEvent(Component-MouseEvent-Component)","Corresponding Source":"/**\n     * Returns a MouseEvent similar to <code>sourceEvent<\/code> except that its x\n     * and y members have been converted to <code>destination<\/code>'s coordinate\n     * system.  If <code>source<\/code> is {@code null}, <code>sourceEvent<\/code> x and y members\n     * are assumed to be into <code>destination<\/code>'s root component coordinate system.\n     * If <code>destination<\/code> is <code>null<\/code>, the\n     * returned MouseEvent will be in <code>source<\/code>'s coordinate system.\n     * <code>sourceEvent<\/code> will not be changed. A new event is returned.\n     * the <code>source<\/code> field of the returned event will be set\n     * to <code>destination<\/code> if destination is non-{@code null}\n     * use the translateMouseEvent() method to translate a mouse event from\n     * one component to another without changing the source.\n     */\n    public static MouseEvent convertMouseEvent(Component source,\n                                               MouseEvent sourceEvent,\n                                               Component destination) {\n        Point p = convertPoint(source,new Point(sourceEvent.getX(),\n                                                sourceEvent.getY()),\n                               destination);\n        Component newSource;\n\n        if(destination != null)\n            newSource = destination;\n        else\n            newSource = source;\n\n        MouseEvent newEvent;\n        if (sourceEvent instanceof MouseWheelEvent) {\n            MouseWheelEvent sourceWheelEvent = (MouseWheelEvent)sourceEvent;\n            newEvent = new MouseWheelEvent(newSource,\n                                           sourceWheelEvent.getID(),\n                                           sourceWheelEvent.getWhen(),\n                                           sourceWheelEvent.getModifiers()\n                                                   | sourceWheelEvent.getModifiersEx(),\n                                           p.x,p.y,\n                                           sourceWheelEvent.getXOnScreen(),\n                                           sourceWheelEvent.getYOnScreen(),\n                                           sourceWheelEvent.getClickCount(),\n                                           sourceWheelEvent.isPopupTrigger(),\n                                           sourceWheelEvent.getScrollType(),\n                                           sourceWheelEvent.getScrollAmount(),\n                                           sourceWheelEvent.getWheelRotation());\n        }\n        else if (sourceEvent instanceof MenuDragMouseEvent) {\n            MenuDragMouseEvent sourceMenuDragEvent = (MenuDragMouseEvent)sourceEvent;\n            newEvent = new MenuDragMouseEvent(newSource,\n                                              sourceMenuDragEvent.getID(),\n                                              sourceMenuDragEvent.getWhen(),\n                                              sourceMenuDragEvent.getModifiers()\n                                                      | sourceMenuDragEvent.getModifiersEx(),\n                                              p.x,p.y,\n                                              sourceMenuDragEvent.getXOnScreen(),\n                                              sourceMenuDragEvent.getYOnScreen(),\n                                              sourceMenuDragEvent.getClickCount(),\n                                              sourceMenuDragEvent.isPopupTrigger(),\n                                              sourceMenuDragEvent.getPath(),\n                                              sourceMenuDragEvent.getMenuSelectionManager());\n        }\n        else {\n            newEvent = new MouseEvent(newSource,\n                                      sourceEvent.getID(),\n                                      sourceEvent.getWhen(),\n                                      sourceEvent.getModifiers()\n                                              | sourceEvent.getModifiersEx(),\n                                      p.x,p.y,\n                                      sourceEvent.getXOnScreen(),\n                                      sourceEvent.getYOnScreen(),\n                                      sourceEvent.getClickCount(),\n                                      sourceEvent.isPopupTrigger(),\n                                      sourceEvent.getButton());\n        }\n        return newEvent;\n    }"}
{"Number":"1482","API Relative Path":"javax.swing.SwingUtilities.java-convertPoint(Component-Point-Component)","Corresponding Source":"/**\n     * Convert a <code>aPoint<\/code> in <code>source<\/code> coordinate system to\n     * <code>destination<\/code> coordinate system.\n     * If <code>source<\/code> is {@code null}, <code>aPoint<\/code> is assumed to be in <code>destination<\/code>'s\n     * root component coordinate system.\n     * If <code>destination<\/code> is {@code null}, <code>aPoint<\/code> will be converted to <code>source<\/code>'s\n     * root component coordinate system.\n     * If both <code>source<\/code> and <code>destination<\/code> are {@code null}, return <code>aPoint<\/code>\n     * without any conversion.\n     */\n    public static Point convertPoint(Component source,Point aPoint,Component destination) {\n        Point p;\n\n        if(source == null && destination == null)\n            return aPoint;\n        if(source == null) {\n            source = getWindowAncestor(destination);\n            if(source == null)\n                throw new Error(\"Source component not connected to component tree hierarchy\");\n        }\n        p = new Point(aPoint);\n        convertPointToScreen(p,source);\n        if(destination == null) {\n            destination = getWindowAncestor(source);\n            if(destination == null)\n                throw new Error(\"Destination component not connected to component tree hierarchy\");\n        }\n        convertPointFromScreen(p,destination);\n        return p;\n    }"}
{"Number":"1483","API Relative Path":"javax.swing.SwingUtilities.java-convertPoint(Component-Point-Component)","Corresponding Source":"/**\n     * Convert a <code>aPoint<\/code> in <code>source<\/code> coordinate system to\n     * <code>destination<\/code> coordinate system.\n     * If <code>source<\/code> is {@code null}, <code>aPoint<\/code> is assumed to be in <code>destination<\/code>'s\n     * root component coordinate system.\n     * If <code>destination<\/code> is {@code null}, <code>aPoint<\/code> will be converted to <code>source<\/code>'s\n     * root component coordinate system.\n     * If both <code>source<\/code> and <code>destination<\/code> are {@code null}, return <code>aPoint<\/code>\n     * without any conversion.\n     */\n    public static Point convertPoint(Component source,Point aPoint,Component destination) {\n        Point p;\n\n        if(source == null && destination == null)\n            return aPoint;\n        if(source == null) {\n            source = getWindowAncestor(destination);\n            if(source == null)\n                throw new Error(\"Source component not connected to component tree hierarchy\");\n        }\n        p = new Point(aPoint);\n        convertPointToScreen(p,source);\n        if(destination == null) {\n            destination = getWindowAncestor(source);\n            if(destination == null)\n                throw new Error(\"Destination component not connected to component tree hierarchy\");\n        }\n        convertPointFromScreen(p,destination);\n        return p;\n    }"}
{"Number":"1484","API Relative Path":"javax.swing.SwingUtilities.java-convertRectangle(Component-Rectangle-Component)","Corresponding Source":"/**\n     * Convert the rectangle <code>aRectangle<\/code> in <code>source<\/code> coordinate system to\n     * <code>destination<\/code> coordinate system.\n     * If <code>source<\/code> is {@code null}, <code>aRectangle<\/code> is assumed to be in <code>destination<\/code>'s\n     * root component coordinate system.\n     * If <code>destination<\/code> is {@code null}, <code>aRectangle<\/code> will be converted to <code>source<\/code>'s\n     * root component coordinate system.\n     * If both <code>source<\/code> and <code>destination<\/code> are {@code null}, return <code>aRectangle<\/code>\n     * without any conversion.\n     */\n    public static Rectangle convertRectangle(Component source,Rectangle aRectangle,Component destination) {\n        Point point = new Point(aRectangle.x,aRectangle.y);\n        point =  convertPoint(source,point,destination);\n        return new Rectangle(point.x,point.y,aRectangle.width,aRectangle.height);\n    }"}
{"Number":"1485","API Relative Path":"javax.swing.SwingUtilities.java-convertRectangle(Component-Rectangle-Component)","Corresponding Source":"/**\n     * Convert the rectangle <code>aRectangle<\/code> in <code>source<\/code> coordinate system to\n     * <code>destination<\/code> coordinate system.\n     * If <code>source<\/code> is {@code null}, <code>aRectangle<\/code> is assumed to be in <code>destination<\/code>'s\n     * root component coordinate system.\n     * If <code>destination<\/code> is {@code null}, <code>aRectangle<\/code> will be converted to <code>source<\/code>'s\n     * root component coordinate system.\n     * If both <code>source<\/code> and <code>destination<\/code> are {@code null}, return <code>aRectangle<\/code>\n     * without any conversion.\n     */\n    public static Rectangle convertRectangle(Component source,Rectangle aRectangle,Component destination) {\n        Point point = new Point(aRectangle.x,aRectangle.y);\n        point =  convertPoint(source,point,destination);\n        return new Rectangle(point.x,point.y,aRectangle.width,aRectangle.height);\n    }"}
{"Number":"1486","API Relative Path":"javax.swing.SwingUtilities.java-getAncestorNamed(String-Component)","Corresponding Source":"/**\n     * Convenience method for searching above <code>comp<\/code> in the\n     * component hierarchy and returns the first object of <code>name<\/code> it\n     * finds. Can return {@code null}, if <code>name<\/code> cannot be found.\n     */\n    public static Container getAncestorNamed(String name, Component comp) {\n        if(comp == null || name == null)\n            return null;\n\n        Container parent = comp.getParent();\n        while(parent != null && !(name.equals(parent.getName())))\n            parent = parent.getParent();\n        return parent;\n    }"}
{"Number":"1487","API Relative Path":"javax.swing.SwingUtilities.java-getAncestorOfClass(Class-Component)","Corresponding Source":"/**\n     * Convenience method for searching above <code>comp<\/code> in the\n     * component hierarchy and returns the first object of class <code>c<\/code> it\n     * finds. Can return {@code null}, if a class <code>c<\/code> cannot be found.\n     */\n    public static Container getAncestorOfClass(Class<?> c, Component comp)\n    {\n        if(comp == null || c == null)\n            return null;\n\n        Container parent = comp.getParent();\n        while(parent != null && !(c.isInstance(parent)))\n            parent = parent.getParent();\n        return parent;\n    }"}
{"Number":"1488","API Relative Path":"javax.swing.SwingWorker.java-setProgress(int)","Corresponding Source":"/**\n     * Sets the {@code progress} bound property.\n     * The value should be from 0 to 100.\n     *\n     * <p>\n     * Because {@code PropertyChangeListener}s are notified asynchronously on\n     * the <i>Event Dispatch Thread<\/i> multiple invocations to the\n     * {@code setProgress} method might occur before any\n     * {@code PropertyChangeListeners} are invoked. For performance purposes\n     * all these invocations are coalesced into one invocation with the last\n     * invocation argument only.\n     *\n     * <p>\n     * For example, the following invokations:\n     *\n     * <pre>\n     * setProgress(1);\n     * setProgress(2);\n     * setProgress(3);\n     * <\/pre>\n     *\n     * might result in a single {@code PropertyChangeListener} notification with\n     * the value {@code 3}.\n     *\n     * @param progress the progress value to set\n     * @throws IllegalArgumentException is value not from 0 to 100\n     */\n    protected final void setProgress(int progress) {\n        if (progress < 0 || progress > 100) {\n            throw new IllegalArgumentException(\"the value should be from 0 to 100\");\n        }\n        if (this.progress == progress) {\n            return;\n        }\n        int oldProgress = this.progress;\n        this.progress = progress;\n        if (! getPropertyChangeSupport().hasListeners(\"progress\")) {\n            return;\n        }\n        synchronized (this) {\n            if (doNotifyProgressChange == null) {\n                doNotifyProgressChange =\n                    new AccumulativeRunnable<Integer>() {\n                        @Override\n                        public void run(List<Integer> args) {\n                            firePropertyChange(\"progress\",\n                               args.get(0),\n                               args.get(args.size() - 1));\n                        }\n                        @Override\n                        protected void submit() {\n                            doSubmit.add(this);\n                        }\n                    };\n            }\n        }\n        doNotifyProgressChange.add(oldProgress, progress);\n    }"}
{"Number":"1489","API Relative Path":"javax.swing.table.AbstractTableModel.java-addTableModelListener(TableModelListener)","Corresponding Source":"//\n//  Managing Listeners\n//\n\n    /**\n     * Adds a listener to the list that's notified each time a change\n     * to the data model occurs.\n     *\n     * @param   l               the TableModelListener\n     */\n    public void addTableModelListener(TableModelListener l) {\n        listenerList.add(TableModelListener.class, l);\n    }"}
{"Number":"1490","API Relative Path":"javax.swing.table.AbstractTableModel.java-removeTableModelListener(TableModelListener)","Corresponding Source":"/**\n     * Removes a listener from the list that's notified each time a\n     * change to the data model occurs.\n     *\n     * @param   l               the TableModelListener\n     */\n    public void removeTableModelListener(TableModelListener l) {\n        listenerList.remove(TableModelListener.class, l);\n    }"}
{"Number":"1491","API Relative Path":"javax.swing.table.DefaultTableColumnModel.java-addColumnModelListener(TableColumnModelListener)","Corresponding Source":"//\n// Listener Support Methods\n//\n\n    // implements javax.swing.table.TableColumnModel\n    /**\n     * Adds a listener for table column model events.\n     * @param x  a <code>TableColumnModelListener<\/code> object\n     */\n    public void addColumnModelListener(TableColumnModelListener x) {\n        listenerList.add(TableColumnModelListener.class, x);\n    }"}
{"Number":"1492","API Relative Path":"javax.swing.table.DefaultTableColumnModel.java-moveColumn(int-int)","Corresponding Source":"/**\n     * Moves the column and heading at <code>columnIndex<\/code> to\n     * <code>newIndex<\/code>.  The old column at <code>columnIndex<\/code>\n     * will now be found at <code>newIndex<\/code>.  The column\n     * that used to be at <code>newIndex<\/code> is shifted\n     * left or right to make room.  This will not move any columns if\n     * <code>columnIndex<\/code> equals <code>newIndex<\/code>.  This method\n     * also posts a <code>columnMoved<\/code> event to its listeners.\n     *\n     * @param   columnIndex                     the index of column to be moved\n     * @param   newIndex                        new index to move the column\n     * @exception IllegalArgumentException      if <code>column<\/code> or\n     *                                          <code>newIndex<\/code>\n     *                                          are not in the valid range\n     */\n    public void moveColumn(int columnIndex, int newIndex) {\n        if ((columnIndex < 0) || (columnIndex >= getColumnCount()) ||\n            (newIndex < 0) || (newIndex >= getColumnCount()))\n            throw new IllegalArgumentException(\"moveColumn() - Index out of range\");\n\n        TableColumn aColumn;\n\n        // If the column has not yet moved far enough to change positions\n        // post the event anyway, the \"draggedDistance\" property of the\n        // tableHeader will say how far the column has been dragged.\n        // Here we are really trying to get the best out of an\n        // API that could do with some rethinking. We preserve backward\n        // compatibility by slightly bending the meaning of these methods.\n        if (columnIndex == newIndex) {\n            fireColumnMoved(new TableColumnModelEvent(this, columnIndex, newIndex));\n            return;\n        }\n        aColumn = tableColumns.elementAt(columnIndex);\n\n        tableColumns.removeElementAt(columnIndex);\n        boolean selected = selectionModel.isSelectedIndex(columnIndex);\n        selectionModel.removeIndexInterval(columnIndex,columnIndex);\n\n        tableColumns.insertElementAt(aColumn, newIndex);\n        selectionModel.insertIndexInterval(newIndex, 1, true);\n        if (selected) {\n            selectionModel.addSelectionInterval(newIndex, newIndex);\n        }\n        else {\n            selectionModel.removeSelectionInterval(newIndex, newIndex);\n        }\n\n        fireColumnMoved(new TableColumnModelEvent(this, columnIndex,\n                                                               newIndex));\n    }"}
{"Number":"1493","API Relative Path":"javax.swing.table.DefaultTableColumnModel.java-removeColumnModelListener(TableColumnModelListener)","Corresponding Source":"// implements javax.swing.table.TableColumnModel\n    /**\n     * Removes a listener for table column model events.\n     * @param x  a <code>TableColumnModelListener<\/code> object\n     */\n    public void removeColumnModelListener(TableColumnModelListener x) {\n        listenerList.remove(TableColumnModelListener.class, x);\n    }"}
{"Number":"1494","API Relative Path":"javax.swing.table.DefaultTableModel.java-addColumn(Object-Object[])","Corresponding Source":"/**\n     *  Adds a column to the model.  The new column will have the\n     *  identifier <code>columnName<\/code>.  <code>columnData<\/code> is the\n     *  optional array of data for the column.  If it is <code>null<\/code>\n     *  the column is filled with <code>null<\/code> values.  Otherwise,\n     *  the new data will be added to model starting with the first\n     *  element going to row 0, etc.  This method will send a\n     *  <code>tableChanged<\/code> notification message to all the listeners.\n     *\n     * @see #addColumn(Object, Vector)\n     */\n    public void addColumn(Object columnName, Object[] columnData) {\n        addColumn(columnName, convertToVector(columnData));\n    }"}
{"Number":"1495","API Relative Path":"javax.swing.table.DefaultTableModel.java-addRow(Object[])","Corresponding Source":"/**\n     *  Adds a row to the end of the model.  The new row will contain\n     *  <code>null<\/code> values unless <code>rowData<\/code> is specified.\n     *  Notification of the row being added will be generated.\n     *\n     * @param   rowData          optional data of the row being added\n     */\n    public void addRow(Object[] rowData) {\n        addRow(convertToVector(rowData));\n    }"}
{"Number":"1496","API Relative Path":"javax.swing.table.DefaultTableModel.java-convertToVector(Object[])","Corresponding Source":"/**\n     * Returns a vector of vectors that contains the same objects as the array.\n     * @param anArray  the double array to be converted\n     * @return the new vector of vectors; if <code>anArray<\/code> is\n     *                          <code>null<\/code>, returns <code>null<\/code>\n     */\n    protected static Vector convertToVector(Object[][] anArray) {\n        if (anArray == null) {\n            return null;\n        }\n        Vector<Vector> v = new Vector<Vector>(anArray.length);\n        for (Object[] o : anArray) {\n            v.addElement(convertToVector(o));\n        }\n        return v;\n    }"}
{"Number":"1497","API Relative Path":"javax.swing.table.DefaultTableModel.java-convertToVector(Object[][])","Corresponding Source":"/**\n     * Returns a vector of vectors that contains the same objects as the array.\n     * @param anArray  the double array to be converted\n     * @return the new vector of vectors; if <code>anArray<\/code> is\n     *                          <code>null<\/code>, returns <code>null<\/code>\n     */\n    protected static Vector convertToVector(Object[][] anArray) {\n        if (anArray == null) {\n            return null;\n        }\n        Vector<Vector> v = new Vector<Vector>(anArray.length);\n        for (Object[] o : anArray) {\n            v.addElement(convertToVector(o));\n        }\n        return v;\n    }"}
{"Number":"1498","API Relative Path":"javax.swing.table.DefaultTableModel.java-DefaultTableModel(Object[][]-Object[])","Corresponding Source":"/**\n     *  Constructs a <code>DefaultTableModel<\/code> and initializes the table\n     *  by passing <code>data<\/code> and <code>columnNames<\/code>\n     *  to the <code>setDataVector<\/code>\n     *  method. The first index in the <code>Object[][]<\/code> array is\n     *  the row index and the second is the column index.\n     *\n     * @param data              the data of the table\n     * @param columnNames       the names of the columns\n     * @see #getDataVector\n     * @see #setDataVector\n     */\n    public DefaultTableModel(Object[][] data, Object[] columnNames) {\n        setDataVector(data, columnNames);\n    }"}
{"Number":"1499","API Relative Path":"javax.swing.table.DefaultTableModel.java-DefaultTableModel(Object[][]-Object[])","Corresponding Source":"/**\n     *  Constructs a <code>DefaultTableModel<\/code> and initializes the table\n     *  by passing <code>data<\/code> and <code>columnNames<\/code>\n     *  to the <code>setDataVector<\/code>\n     *  method. The first index in the <code>Object[][]<\/code> array is\n     *  the row index and the second is the column index.\n     *\n     * @param data              the data of the table\n     * @param columnNames       the names of the columns\n     * @see #getDataVector\n     * @see #setDataVector\n     */\n    public DefaultTableModel(Object[][] data, Object[] columnNames) {\n        setDataVector(data, columnNames);\n    }"}
{"Number":"1500","API Relative Path":"javax.swing.table.DefaultTableModel.java-insertRow(int-Object[])","Corresponding Source":"/**\n     *  Inserts a row at <code>row<\/code> in the model.  The new row\n     *  will contain <code>null<\/code> values unless <code>rowData<\/code>\n     *  is specified.  Notification of the row being added will be generated.\n     *\n     * @param   row      the row index of the row to be inserted\n     * @param   rowData          optional data of the row being added\n     * @exception  ArrayIndexOutOfBoundsException  if the row was invalid\n     */\n    public void insertRow(int row, Object[] rowData) {\n        insertRow(row, convertToVector(rowData));\n    }"}
{"Number":"1501","API Relative Path":"javax.swing.table.DefaultTableModel.java-setDataVector(Object[][]-Object[])","Corresponding Source":"/**\n     *  Replaces the value in the <code>dataVector<\/code> instance\n     *  variable with the values in the array <code>dataVector<\/code>.\n     *  The first index in the <code>Object[][]<\/code>\n     *  array is the row index and the second is the column index.\n     *  <code>columnIdentifiers<\/code> are the names of the new columns.\n     *\n     * @param dataVector                the new data vector\n     * @param columnIdentifiers the names of the columns\n     * @see #setDataVector(Vector, Vector)\n     */\n    public void setDataVector(Object[][] dataVector, Object[] columnIdentifiers) {\n        setDataVector(convertToVector(dataVector), convertToVector(columnIdentifiers));\n    }"}
{"Number":"1502","API Relative Path":"javax.swing.table.DefaultTableModel.java-setDataVector(Object[][]-Object[])","Corresponding Source":"/**\n     *  Replaces the value in the <code>dataVector<\/code> instance\n     *  variable with the values in the array <code>dataVector<\/code>.\n     *  The first index in the <code>Object[][]<\/code>\n     *  array is the row index and the second is the column index.\n     *  <code>columnIdentifiers<\/code> are the names of the new columns.\n     *\n     * @param dataVector                the new data vector\n     * @param columnIdentifiers the names of the columns\n     * @see #setDataVector(Vector, Vector)\n     */\n    public void setDataVector(Object[][] dataVector, Object[] columnIdentifiers) {\n        setDataVector(convertToVector(dataVector), convertToVector(columnIdentifiers));\n    }"}
{"Number":"1503","API Relative Path":"javax.swing.table.JTableHeader.java-JTableHeader(TableColumnModel)","Corresponding Source":"/**\n     *  Constructs a <code>JTableHeader<\/code> which is initialized with\n     *  <code>cm<\/code> as the column model.  If <code>cm<\/code> is\n     *  <code>null<\/code> this method will initialize the table header\n     *  with a default <code>TableColumnModel<\/code>.\n     *\n     * @param cm        the column model for the table\n     * @see #createDefaultColumnModel\n     */\n    public JTableHeader(TableColumnModel cm) {\n        super();\n\n        //setFocusable(false); // for strict win/mac compatibility mode,\n                               // this method should be invoked\n\n        if (cm == null)\n            cm = createDefaultColumnModel();\n        setColumnModel(cm);\n\n        // Initialize local ivars\n        initializeLocalVars();\n\n        // Get UI going\n        updateUI();\n    }"}
{"Number":"1504","API Relative Path":"javax.swing.table.JTableHeader.java-setColumnModel(TableColumnModel)","Corresponding Source":"//\n// Managing models\n//\n\n\n    /**\n     *  Sets the column model for this table to <code>newModel<\/code> and registers\n     *  for listener notifications from the new column model.\n     *\n     * @param   columnModel     the new data source for this table\n     * @exception IllegalArgumentException\n     *                          if <code>newModel<\/code> is <code>null<\/code>\n     * @see     #getColumnModel\n     * @beaninfo\n     *  bound: true\n     *  description: The object governing the way columns appear in the view.\n     */\n    public void setColumnModel(TableColumnModel columnModel) {\n        if (columnModel == null) {\n            throw new IllegalArgumentException(\"Cannot set a null ColumnModel\");\n        }\n        TableColumnModel old = this.columnModel;\n        if (columnModel != old) {\n            if (old != null) {\n                old.removeColumnModelListener(this);\n            }\n            this.columnModel = columnModel;\n            columnModel.addColumnModelListener(this);\n\n            firePropertyChange(\"columnModel\", old, columnModel);\n            resizeAndRepaint();\n        }\n    }"}
{"Number":"1505","API Relative Path":"javax.swing.table.TableRowSorter.java-useToString(int)","Corresponding Source":"/**\n     * {@inheritDoc}\n     *\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    protected boolean useToString(int column) {\n        Comparator comparator = super.getComparator(column);\n        if (comparator != null) {\n            return false;\n        }\n        Class columnClass = getModel().getColumnClass(column);\n        if (columnClass == String.class) {\n            return false;\n        }\n        if (Comparable.class.isAssignableFrom(columnClass)) {\n            return false;\n        }\n        return true;\n    }"}
{"Number":"1506","API Relative Path":"javax.swing.text.AbstractDocument.java-addDocumentListener(DocumentListener)","Corresponding Source":"/**\n     * Adds a document listener for notification of any changes.\n     *\n     * @param listener the <code>DocumentListener<\/code> to add\n     * @see Document#addDocumentListener\n     */\n    public void addDocumentListener(DocumentListener listener) {\n        listenerList.add(DocumentListener.class, listener);\n    }"}
{"Number":"1507","API Relative Path":"javax.swing.text.AbstractDocument.java-addUndoableEditListener(UndoableEditListener)","Corresponding Source":"/**\n     * Adds an undo listener for notification of any changes.\n     * Undo/Redo operations performed on the <code>UndoableEdit<\/code>\n     * will cause the appropriate DocumentEvent to be fired to keep\n     * the view(s) in sync with the model.\n     *\n     * @param listener the <code>UndoableEditListener<\/code> to add\n     * @see Document#addUndoableEditListener\n     */\n    public void addUndoableEditListener(UndoableEditListener listener) {\n        listenerList.add(UndoableEditListener.class, listener);\n    }"}
{"Number":"1508","API Relative Path":"javax.swing.text.AbstractDocument.java-handleRemove(int-int)","Corresponding Source":"/**\n     * Performs the actual work of the remove. It is assumed the caller\n     * will have obtained a <code>writeLock<\/code> before invoking this.\n     */\n    void handleRemove(int offs, int len) throws BadLocationException {\n        if (len > 0) {\n            if (offs < 0 || (offs + len) > getLength()) {\n                throw new BadLocationException(\"Invalid remove\",\n                                               getLength() + 1);\n            }\n            DefaultDocumentEvent chng =\n                    new DefaultDocumentEvent(offs, len, DocumentEvent.EventType.REMOVE);\n\n            boolean isComposedTextElement;\n            // Check whether the position of interest is the composed text\n            isComposedTextElement = Utilities.isComposedTextElement(this, offs);\n\n            removeUpdate(chng);\n            UndoableEdit u = data.remove(offs, len);\n            if (u != null) {\n                chng.addEdit(u);\n            }\n            postRemoveUpdate(chng);\n            // Mark the edit as done.\n            chng.end();\n            fireRemoveUpdate(chng);\n            // only fire undo if Content implementation supports it\n            // undo for the composed text is not supported for now\n            if ((u != null) && !isComposedTextElement) {\n                fireUndoableEditUpdate(new UndoableEditEvent(this, chng));\n            }\n        }\n    }"}
{"Number":"1509","API Relative Path":"javax.swing.text.AbstractDocument.java-insertUpdate(DefaultDocumentEvent-AttributeSet)","Corresponding Source":"/**\n     * Updates document structure as a result of text insertion.  This\n     * will happen within a write lock.  If a subclass of\n     * this class reimplements this method, it should delegate to the\n     * superclass as well.\n     *\n     * @param chng a description of the change\n     * @param attr the attributes for the change\n     */\n    protected void insertUpdate(DefaultDocumentEvent chng, AttributeSet attr) {\n        if( getProperty(I18NProperty).equals( Boolean.TRUE ) )\n            updateBidi( chng );\n\n        // Check if a multi byte is encountered in the inserted text.\n        if (chng.type == DocumentEvent.EventType.INSERT &&\n                        chng.getLength() > 0 &&\n                        !Boolean.TRUE.equals(getProperty(MultiByteProperty))) {\n            Segment segment = SegmentCache.getSharedSegment();\n            try {\n                getText(chng.getOffset(), chng.getLength(), segment);\n                segment.first();\n                do {\n                    if ((int)segment.current() > 255) {\n                        putProperty(MultiByteProperty, Boolean.TRUE);\n                        break;\n                    }\n                } while (segment.next() != Segment.DONE);\n            } catch (BadLocationException ble) {\n                // Should never happen\n            }\n            SegmentCache.releaseSharedSegment(segment);\n        }\n    }"}
{"Number":"1510","API Relative Path":"javax.swing.text.AbstractDocument.java-postRemoveUpdate(DefaultDocumentEvent)","Corresponding Source":"/**\n     * Updates any document structure as a result of text removal.  This\n     * method is called after the text has been removed from the Content.\n     * This will happen within a write lock. If a subclass\n     * of this class reimplements this method, it should delegate to the\n     * superclass as well.\n     *\n     * @param chng a description of the change\n     */\n    protected void postRemoveUpdate(DefaultDocumentEvent chng) {\n        if( getProperty(I18NProperty).equals( Boolean.TRUE ) )\n            updateBidi( chng );\n    }"}
{"Number":"1511","API Relative Path":"javax.swing.text.AbstractDocument.java-removeDocumentListener(DocumentListener)","Corresponding Source":"/**\n     * Removes a document listener.\n     *\n     * @param listener the <code>DocumentListener<\/code> to remove\n     * @see Document#removeDocumentListener\n     */\n    public void removeDocumentListener(DocumentListener listener) {\n        listenerList.remove(DocumentListener.class, listener);\n    }"}
{"Number":"1512","API Relative Path":"javax.swing.text.AbstractDocument.java-removeUndoableEditListener(UndoableEditListener)","Corresponding Source":"/**\n     * Removes an undo listener.\n     *\n     * @param listener the <code>UndoableEditListener<\/code> to remove\n     * @see Document#removeDocumentListener\n     */\n    public void removeUndoableEditListener(UndoableEditListener listener) {\n        listenerList.remove(UndoableEditListener.class, listener);\n    }"}
{"Number":"1513","API Relative Path":"javax.swing.text.AbstractDocument.java-replace(int-int-String-AttributeSet)","Corresponding Source":"/**\n     * Deletes the region of text from <code>offset<\/code> to\n     * <code>offset + length<\/code>, and replaces it with <code>text<\/code>.\n     * It is up to the implementation as to how this is implemented, some\n     * implementations may treat this as two distinct operations: a remove\n     * followed by an insert, others may treat the replace as one atomic\n     * operation.\n     *\n     * @param offset index of child element\n     * @param length length of text to delete, may be 0 indicating don't\n     *               delete anything\n     * @param text text to insert, <code>null<\/code> indicates no text to insert\n     * @param attrs AttributeSet indicating attributes of inserted text,\n     *              <code>null<\/code>\n     *              is legal, and typically treated as an empty attributeset,\n     *              but exact interpretation is left to the subclass\n     * @exception BadLocationException the given position is not a valid\n     *            position within the document\n     * @since 1.4\n     */\n    public void replace(int offset, int length, String text,\n                        AttributeSet attrs) throws BadLocationException {\n        if (length == 0 && (text == null || text.length() == 0)) {\n            return;\n        }\n        DocumentFilter filter = getDocumentFilter();\n\n        writeLock();\n        try {\n            if (filter != null) {\n                filter.replace(getFilterBypass(), offset, length, text,\n                               attrs);\n            }\n            else {\n                if (length > 0) {\n                    remove(offset, length);\n                }\n                if (text != null && text.length() > 0) {\n                    insertString(offset, text, attrs);\n                }\n            }\n        } finally {\n            writeUnlock();\n        }\n    }"}
{"Number":"1514","API Relative Path":"javax.swing.text.AbstractDocument.java-updateBidi(DefaultDocumentEvent)","Corresponding Source":"/**\n     * Update the bidi element structure as a result of the given change\n     * to the document.  The given change will be updated to reflect the\n     * changes made to the bidi structure.\n     *\n     * This method assumes that every offset in the model is contained in\n     * exactly one paragraph.  This method also assumes that it is called\n     * after the change is made to the default element structure.\n     */\n    void updateBidi( DefaultDocumentEvent chng ) {\n\n        // Calculate the range of paragraphs affected by the change.\n        int firstPStart;\n        int lastPEnd;\n        if( chng.type == DocumentEvent.EventType.INSERT\n            || chng.type == DocumentEvent.EventType.CHANGE )\n        {\n            int chngStart = chng.getOffset();\n            int chngEnd =  chngStart + chng.getLength();\n            firstPStart = getParagraphElement(chngStart).getStartOffset();\n            lastPEnd = getParagraphElement(chngEnd).getEndOffset();\n        } else if( chng.type == DocumentEvent.EventType.REMOVE ) {\n            Element paragraph = getParagraphElement( chng.getOffset() );\n            firstPStart = paragraph.getStartOffset();\n            lastPEnd = paragraph.getEndOffset();\n        } else {\n            throw new Error(\"Internal error: unknown event type.\");\n        }\n        //System.out.println(\"updateBidi: firstPStart = \" + firstPStart + \" lastPEnd = \" + lastPEnd );\n\n\n        // Calculate the bidi levels for the affected range of paragraphs.  The\n        // levels array will contain a bidi level for each character in the\n        // affected text.\n        byte levels[] = calculateBidiLevels( firstPStart, lastPEnd );\n\n\n        Vector<Element> newElements = new Vector<Element>();\n\n        // Calculate the first span of characters in the affected range with\n        // the same bidi level.  If this level is the same as the level of the\n        // previous bidi element (the existing bidi element containing\n        // firstPStart-1), then merge in the previous element.  If not, but\n        // the previous element overlaps the affected range, truncate the\n        // previous element at firstPStart.\n        int firstSpanStart = firstPStart;\n        int removeFromIndex = 0;\n        if( firstSpanStart > 0 ) {\n            int prevElemIndex = bidiRoot.getElementIndex(firstPStart-1);\n            removeFromIndex = prevElemIndex;\n            Element prevElem = bidiRoot.getElement(prevElemIndex);\n            int prevLevel=StyleConstants.getBidiLevel(prevElem.getAttributes());\n            //System.out.println(\"createbidiElements: prevElem= \" + prevElem  + \" prevLevel= \" + prevLevel + \"level[0] = \" + levels[0]);\n            if( prevLevel==levels[0] ) {\n                firstSpanStart = prevElem.getStartOffset();\n            } else if( prevElem.getEndOffset() > firstPStart ) {\n                newElements.addElement(new BidiElement(bidiRoot,\n                                                       prevElem.getStartOffset(),\n                                                       firstPStart, prevLevel));\n            } else {\n                removeFromIndex++;\n            }\n        }\n\n        int firstSpanEnd = 0;\n        while((firstSpanEnd<levels.length) && (levels[firstSpanEnd]==levels[0]))\n            firstSpanEnd++;\n\n\n        // Calculate the last span of characters in the affected range with\n        // the same bidi level.  If this level is the same as the level of the\n        // next bidi element (the existing bidi element containing lastPEnd),\n        // then merge in the next element.  If not, but the next element\n        // overlaps the affected range, adjust the next element to start at\n        // lastPEnd.\n        int lastSpanEnd = lastPEnd;\n        Element newNextElem = null;\n        int removeToIndex = bidiRoot.getElementCount() - 1;\n        if( lastSpanEnd <= getLength() ) {\n            int nextElemIndex = bidiRoot.getElementIndex( lastPEnd );\n            removeToIndex = nextElemIndex;\n            Element nextElem = bidiRoot.getElement( nextElemIndex );\n            int nextLevel = StyleConstants.getBidiLevel(nextElem.getAttributes());\n            if( nextLevel == levels[levels.length-1] ) {\n                lastSpanEnd = nextElem.getEndOffset();\n            } else if( nextElem.getStartOffset() < lastPEnd ) {\n                newNextElem = new BidiElement(bidiRoot, lastPEnd,\n                                              nextElem.getEndOffset(),\n                                              nextLevel);\n            } else {\n                removeToIndex--;\n            }\n        }\n\n        int lastSpanStart = levels.length;\n        while( (lastSpanStart>firstSpanEnd)\n               && (levels[lastSpanStart-1]==levels[levels.length-1]) )\n            lastSpanStart--;\n\n\n        // If the first and last spans are contiguous and have the same level,\n        // merge them and create a single new element for the entire span.\n        // Otherwise, create elements for the first and last spans as well as\n        // any spans in between.\n        if((firstSpanEnd==lastSpanStart)&&(levels[0]==levels[levels.length-1])){\n            newElements.addElement(new BidiElement(bidiRoot, firstSpanStart,\n                                                   lastSpanEnd, levels[0]));\n        } else {\n            // Create an element for the first span.\n            newElements.addElement(new BidiElement(bidiRoot, firstSpanStart,\n                                                   firstSpanEnd+firstPStart,\n                                                   levels[0]));\n            // Create elements for the spans in between the first and last\n            for( int i=firstSpanEnd; i<lastSpanStart; ) {\n                //System.out.println(\"executed line 872\");\n                int j;\n                for( j=i;  (j<levels.length) && (levels[j] == levels[i]); j++ );\n                newElements.addElement(new BidiElement(bidiRoot, firstPStart+i,\n                                                       firstPStart+j,\n                                                       (int)levels[i]));\n                i=j;\n            }\n            // Create an element for the last span.\n            newElements.addElement(new BidiElement(bidiRoot,\n                                                   lastSpanStart+firstPStart,\n                                                   lastSpanEnd,\n                                                   levels[levels.length-1]));\n        }\n\n        if( newNextElem != null )\n            newElements.addElement( newNextElem );\n\n\n        // Calculate the set of existing bidi elements which must be\n        // removed.\n        int removedElemCount = 0;\n        if( bidiRoot.getElementCount() > 0 ) {\n            removedElemCount = removeToIndex - removeFromIndex + 1;\n        }\n        Element[] removedElems = new Element[removedElemCount];\n        for( int i=0; i<removedElemCount; i++ ) {\n            removedElems[i] = bidiRoot.getElement(removeFromIndex+i);\n        }\n\n        Element[] addedElems = new Element[ newElements.size() ];\n        newElements.copyInto( addedElems );\n\n        // Update the change record.\n        ElementEdit ee = new ElementEdit( bidiRoot, removeFromIndex,\n                                          removedElems, addedElems );\n        chng.addEdit( ee );\n\n        // Update the bidi element structure.\n        bidiRoot.replace( removeFromIndex, removedElems.length, addedElems );\n    }"}
{"Number":"1515","API Relative Path":"javax.swing.text.AbstractWriter.java-write(String)","Corresponding Source":"/**\n     * Writes out a string. This is implemented to invoke the\n     * <code>write<\/code> method that takes a char[].\n     *\n     * @param     content a String.\n     * @exception IOException on any I/O error\n     */\n    protected void write(String content) throws IOException {\n        if (content == null) {\n            return;\n        }\n        int size = content.length();\n        if (tempChars == null || tempChars.length < size) {\n            tempChars = new char[size];\n        }\n        content.getChars(0, size, tempChars, 0);\n        write(tempChars, 0, size);\n    }"}
{"Number":"1516","API Relative Path":"javax.swing.text.AsyncBoxView.java-setParent(View)","Corresponding Source":"// --- View methods ------------------------------------\n\n    /**\n     * Sets the parent of the view.\n     * This is reimplemented to provide the superclass\n     * behavior as well as calling the <code>loadChildren<\/code>\n     * method if this view does not already have children.\n     * The children should not be loaded in the\n     * constructor because the act of setting the parent\n     * may cause them to try to search up the hierarchy\n     * (to get the hosting Container for example).\n     * If this view has children (the view is being moved\n     * from one place in the view hierarchy to another),\n     * the <code>loadChildren<\/code> method will not be called.\n     *\n     * @param parent the parent of the view, null if none\n     */\n    public void setParent(View parent) {\n        super.setParent(parent);\n        if ((parent != null) && (getViewCount() == 0)) {\n            ViewFactory f = getViewFactory();\n            loadChildren(f);\n        }\n    }"}
{"Number":"1517","API Relative Path":"javax.swing.text.BoxView.java-checkRequests(int)","Corresponding Source":"/**\n     * Checks the request cache and update if needed.\n     * @param axis the axis being studied\n     * @exception IllegalArgumentException if <code>axis<\/code> is\n     *  neither <code>View.X_AXIS<\/code> nor <code>View.Y_AXIS<\/code>\n     */\n    void checkRequests(int axis) {\n        if ((axis != X_AXIS) && (axis != Y_AXIS)) {\n            throw new IllegalArgumentException(\"Invalid axis: \" + axis);\n        }\n        if (axis == majorAxis) {\n            if (!majorReqValid) {\n                majorRequest = calculateMajorAxisRequirements(axis,\n                                                              majorRequest);\n                majorReqValid = true;\n            }\n        } else if (! minorReqValid) {\n            minorRequest = calculateMinorAxisRequirements(axis, minorRequest);\n            minorReqValid = true;\n        }\n    }"}
{"Number":"1518","API Relative Path":"javax.swing.text.BoxView.java-getAlignment(int)","Corresponding Source":"/**\n     * Determines the desired alignment for this view along an\n     * axis.  This is implemented to give the total alignment\n     * needed to position the children with the alignment points\n     * lined up along the axis orthogonal to the axis that is\n     * being tiled.  The axis being tiled will request to be\n     * centered (i.e. 0.5f).\n     *\n     * @param axis may be either <code>View.X_AXIS<\/code>\n     *   or <code>View.Y_AXIS<\/code>\n     * @return the desired alignment &gt;= 0.0f &amp;&amp; &lt;= 1.0f; this should\n     *   be a value between 0.0 and 1.0 where 0 indicates alignment at the\n     *   origin and 1.0 indicates alignment to the full span\n     *   away from the origin; an alignment of 0.5 would be the\n     *   center of the view\n     * @exception IllegalArgumentException for an invalid axis\n     */\n    public float getAlignment(int axis) {\n        checkRequests(axis);\n        if (axis == majorAxis) {\n            return majorRequest.alignment;\n        } else {\n            return minorRequest.alignment;\n        }\n    }"}
{"Number":"1519","API Relative Path":"javax.swing.text.BoxView.java-getChildAllocation(int-Shape)","Corresponding Source":"/**\n     * Fetches the allocation for the given child view.\n     * This enables finding out where various views\n     * are located.  This is implemented to return\n     * <code>null<\/code> if the layout is invalid,\n     * otherwise the superclass behavior is executed.\n     *\n     * @param index the index of the child, &gt;= 0 &amp;&amp; &gt; getViewCount()\n     * @param a  the allocation to this view\n     * @return the allocation to the child; or <code>null<\/code>\n     *          if <code>a<\/code> is <code>null<\/code>;\n     *          or <code>null<\/code> if the layout is invalid\n     */\n    public Shape getChildAllocation(int index, Shape a) {\n        if (a != null) {\n            Shape ca = super.getChildAllocation(index, a);\n            if ((ca != null) && (! isAllocationValid())) {\n                // The child allocation may not have been set yet.\n                Rectangle r = (ca instanceof Rectangle) ?\n                    (Rectangle) ca : ca.getBounds();\n                if ((r.width == 0) && (r.height == 0)) {\n                    return null;\n                }\n            }\n            return ca;\n        }\n        return null;\n    }"}
{"Number":"1520","API Relative Path":"javax.swing.text.BoxView.java-getMaximumSpan(int)","Corresponding Source":"/**\n     * Determines the maximum span for this view along an\n     * axis.\n     *\n     * @param axis may be either <code>View.X_AXIS<\/code>\n     *           or <code>View.Y_AXIS<\/code>\n     * @return   the span the view would like to be rendered into &gt;= 0;\n     *           typically the view is told to render into the span\n     *           that is returned, although there is no guarantee;\n     *           the parent may choose to resize or break the view\n     * @exception IllegalArgumentException for an invalid axis type\n     */\n    public float getMaximumSpan(int axis) {\n        checkRequests(axis);\n        float marginSpan = (axis == X_AXIS) ? getLeftInset() + getRightInset() :\n            getTopInset() + getBottomInset();\n        if (axis == majorAxis) {\n            return ((float)majorRequest.maximum) + marginSpan;\n        } else {\n            return ((float)minorRequest.maximum) + marginSpan;\n        }\n    }"}
{"Number":"1521","API Relative Path":"javax.swing.text.BoxView.java-getMinimumSpan(int)","Corresponding Source":"/**\n     * Determines the minimum span for this view along an\n     * axis.\n     *\n     * @param axis may be either <code>View.X_AXIS<\/code>\n     *           or <code>View.Y_AXIS<\/code>\n     * @return  the span the view would like to be rendered into &gt;= 0;\n     *           typically the view is told to render into the span\n     *           that is returned, although there is no guarantee;\n     *           the parent may choose to resize or break the view\n     * @exception IllegalArgumentException for an invalid axis type\n     */\n    public float getMinimumSpan(int axis) {\n        checkRequests(axis);\n        float marginSpan = (axis == X_AXIS) ? getLeftInset() + getRightInset() :\n            getTopInset() + getBottomInset();\n        if (axis == majorAxis) {\n            return ((float)majorRequest.minimum) + marginSpan;\n        } else {\n            return ((float)minorRequest.minimum) + marginSpan;\n        }\n    }"}
{"Number":"1522","API Relative Path":"javax.swing.text.BoxView.java-getPreferredSpan(int)","Corresponding Source":"/**\n     * Determines the preferred span for this view along an\n     * axis.\n     *\n     * @param axis may be either <code>View.X_AXIS<\/code>\n     *           or <code>View.Y_AXIS<\/code>\n     * @return   the span the view would like to be rendered into &gt;= 0;\n     *           typically the view is told to render into the span\n     *           that is returned, although there is no guarantee;\n     *           the parent may choose to resize or break the view\n     * @exception IllegalArgumentException for an invalid axis type\n     */\n    public float getPreferredSpan(int axis) {\n        checkRequests(axis);\n        float marginSpan = (axis == X_AXIS) ? getLeftInset() + getRightInset() :\n            getTopInset() + getBottomInset();\n        if (axis == majorAxis) {\n            return ((float)majorRequest.preferred) + marginSpan;\n        } else {\n            return ((float)minorRequest.preferred) + marginSpan;\n        }\n    }"}
{"Number":"1523","API Relative Path":"javax.swing.text.BoxView.java-getResizeWeight(int)","Corresponding Source":"/**\n     * Gets the resize weight.  A value of 0 or less is not resizable.\n     *\n     * @param axis may be either <code>View.X_AXIS<\/code> or\n     *          <code>View.Y_AXIS<\/code>\n     * @return the weight\n     * @exception IllegalArgumentException for an invalid axis\n     */\n    public int getResizeWeight(int axis) {\n        checkRequests(axis);\n        if (axis == majorAxis) {\n            if ((majorRequest.preferred != majorRequest.minimum) ||\n                (majorRequest.preferred != majorRequest.maximum)) {\n                return 1;\n            }\n        } else {\n            if ((minorRequest.preferred != minorRequest.minimum) ||\n                (minorRequest.preferred != minorRequest.maximum)) {\n                return 1;\n            }\n        }\n        return 0;\n    }"}
{"Number":"1524","API Relative Path":"javax.swing.text.BoxView.java-setSpanOnAxis(int-float)","Corresponding Source":"/**\n     * Sets the size of the view along an axis.  This should cause\n     * layout of the view along the given axis.\n     *\n     * @param axis may be either <code>View.X_AXIS<\/code> or\n     *          <code>View.Y_AXIS<\/code>\n     * @param span the span to layout to >= 0\n     */\n    void setSpanOnAxis(int axis, float span) {\n        if (axis == majorAxis) {\n            if (majorSpan != (int) span) {\n                majorAllocValid = false;\n            }\n            if (! majorAllocValid) {\n                // layout the major axis\n                majorSpan = (int) span;\n                checkRequests(majorAxis);\n                layoutMajorAxis(majorSpan, axis, majorOffsets, majorSpans);\n                majorAllocValid = true;\n\n                // flush changes to the children\n                updateChildSizes();\n            }\n        } else {\n            if (((int) span) != minorSpan) {\n                minorAllocValid = false;\n            }\n            if (! minorAllocValid) {\n                // layout the minor axis\n                minorSpan = (int) span;\n                checkRequests(axis);\n                layoutMinorAxis(minorSpan, axis, minorOffsets, minorSpans);\n                minorAllocValid = true;\n\n                // flush changes to the children\n                updateChildSizes();\n            }\n        }\n    }"}
{"Number":"1525","API Relative Path":"javax.swing.text.ComponentView.java-getMaximumSpan(int)","Corresponding Source":"/**\n     * Determines the maximum span for this view along an\n     * axis.  This is implemented to return the value\n     * returned by Component.getMaximumSize along the\n     * axis of interest.\n     *\n     * @param axis may be either View.X_AXIS or View.Y_AXIS\n     * @return   the span the view would like to be rendered into &gt;=0.\n     *           Typically the view is told to render into the span\n     *           that is returned, although there is no guarantee.\n     *           The parent may choose to resize or break the view.\n     * @exception IllegalArgumentException for an invalid axis\n     */\n    public float getMaximumSpan(int axis) {\n        if ((axis != X_AXIS) && (axis != Y_AXIS)) {\n            throw new IllegalArgumentException(\"Invalid axis: \" + axis);\n        }\n        if (c != null) {\n            Dimension size = c.getMaximumSize();\n            if (axis == View.X_AXIS) {\n                return size.width;\n            } else {\n                return size.height;\n            }\n        }\n        return 0;\n    }"}
{"Number":"1526","API Relative Path":"javax.swing.text.ComponentView.java-getMinimumSpan(int)","Corresponding Source":"/**\n     * Determines the minimum span for this view along an\n     * axis.  This is implemented to return the value\n     * returned by Component.getMinimumSize along the\n     * axis of interest.\n     *\n     * @param axis may be either View.X_AXIS or View.Y_AXIS\n     * @return   the span the view would like to be rendered into &gt;=0.\n     *           Typically the view is told to render into the span\n     *           that is returned, although there is no guarantee.\n     *           The parent may choose to resize or break the view.\n     * @exception IllegalArgumentException for an invalid axis\n     */\n    public float getMinimumSpan(int axis) {\n        if ((axis != X_AXIS) && (axis != Y_AXIS)) {\n            throw new IllegalArgumentException(\"Invalid axis: \" + axis);\n        }\n        if (c != null) {\n            Dimension size = c.getMinimumSize();\n            if (axis == View.X_AXIS) {\n                return size.width;\n            } else {\n                return size.height;\n            }\n        }\n        return 0;\n    }"}
{"Number":"1527","API Relative Path":"javax.swing.text.ComponentView.java-getPreferredSpan(int)","Corresponding Source":"/**\n     * Determines the preferred span for this view along an\n     * axis.  This is implemented to return the value\n     * returned by Component.getPreferredSize along the\n     * axis of interest.\n     *\n     * @param axis may be either View.X_AXIS or View.Y_AXIS\n     * @return   the span the view would like to be rendered into &gt;=0.\n     *           Typically the view is told to render into the span\n     *           that is returned, although there is no guarantee.\n     *           The parent may choose to resize or break the view.\n     * @exception IllegalArgumentException for an invalid axis\n     */\n    public float getPreferredSpan(int axis) {\n        if ((axis != X_AXIS) && (axis != Y_AXIS)) {\n            throw new IllegalArgumentException(\"Invalid axis: \" + axis);\n        }\n        if (c != null) {\n            Dimension size = c.getPreferredSize();\n            if (axis == View.X_AXIS) {\n                return size.width;\n            } else {\n                return size.height;\n            }\n        }\n        return 0;\n    }"}
{"Number":"1528","API Relative Path":"javax.swing.text.CompositeView.java-loadChildren(ViewFactory)","Corresponding Source":"/**\n     * Loads all of the children to initialize the view.\n     * This is called by the {@link #setParent}\n     * method.  Subclasses can reimplement this to initialize\n     * their child views in a different manner.  The default\n     * implementation creates a child view for each\n     * child element.\n     *\n     * @param f the view factory\n     * @see #setParent\n     */\n    protected void loadChildren(ViewFactory f) {\n        if (f == null) {\n            // No factory. This most likely indicates the parent view\n            // has changed out from under us, bail!\n            return;\n        }\n        Element e = getElement();\n        int n = e.getElementCount();\n        if (n > 0) {\n            View[] added = new View[n];\n            for (int i = 0; i < n; i++) {\n                added[i] = f.create(e.getElement(i));\n            }\n            replace(0, 0, added);\n        }\n    }"}
{"Number":"1529","API Relative Path":"javax.swing.text.CompositeView.java-setParent(View)","Corresponding Source":"// --- View methods ---------------------------------------------\n\n    /**\n     * Sets the parent of the view.\n     * This is reimplemented to provide the superclass\n     * behavior as well as calling the <code>loadChildren<\/code>\n     * method if this view does not already have children.\n     * The children should not be loaded in the\n     * constructor because the act of setting the parent\n     * may cause them to try to search up the hierarchy\n     * (to get the hosting <code>Container<\/code> for example).\n     * If this view has children (the view is being moved\n     * from one place in the view hierarchy to another),\n     * the <code>loadChildren<\/code> method will not be called.\n     *\n     * @param parent the parent of the view, <code>null<\/code> if none\n     */\n    public void setParent(View parent) {\n        super.setParent(parent);\n        if ((parent != null) && (nchildren == 0)) {\n            ViewFactory f = getViewFactory();\n            loadChildren(f);\n        }\n    }"}
{"Number":"1530","API Relative Path":"javax.swing.text.DefaultCaret.java-addChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Adds a listener to track whenever the caret position has\n     * been changed.\n     *\n     * @param l the listener\n     * @see Caret#addChangeListener\n     */\n    public void addChangeListener(ChangeListener l) {\n        listenerList.add(ChangeListener.class, l);\n    }"}
{"Number":"1531","API Relative Path":"javax.swing.text.DefaultCaret.java-damage(Rectangle)","Corresponding Source":"/**\n     * Damages the area surrounding the caret to cause\n     * it to be repainted in a new location.  If paint()\n     * is reimplemented, this method should also be\n     * reimplemented.  This method should update the\n     * caret bounds (x, y, width, and height).\n     *\n     * @param r  the current location of the caret\n     * @see #paint\n     */\n    protected synchronized void damage(Rectangle r) {\n        if (r != null) {\n            int damageWidth = getCaretWidth(r.height);\n            x = r.x - 4 - (damageWidth >> 1);\n            y = r.y;\n            width = 9 + damageWidth;\n            height = r.height;\n            repaint();\n        }\n    }"}
{"Number":"1532","API Relative Path":"javax.swing.text.DefaultCaret.java-mouseClicked(MouseEvent)","Corresponding Source":"// --- MouseListener methods -----------------------------------\n\n    /**\n     * Called when the mouse is clicked.  If the click was generated\n     * from button1, a double click selects a word,\n     * and a triple click the current line.\n     *\n     * @param e the mouse event\n     * @see MouseListener#mouseClicked\n     */\n    public void mouseClicked(MouseEvent e) {\n        if (getComponent() == null) {\n            return;\n        }\n\n        int nclicks = SwingUtilities2.getAdjustedClickCount(getComponent(), e);\n\n        if (! e.isConsumed()) {\n            if (SwingUtilities.isLeftMouseButton(e)) {\n                // mouse 1 behavior\n                if(nclicks == 1) {\n                    selectedWordEvent = null;\n                } else if(nclicks == 2\n                          && SwingUtilities2.canEventAccessSystemClipboard(e)) {\n                    selectWord(e);\n                    selectedWordEvent = null;\n                } else if(nclicks == 3\n                          && SwingUtilities2.canEventAccessSystemClipboard(e)) {\n                    Action a = null;\n                    ActionMap map = getComponent().getActionMap();\n                    if (map != null) {\n                        a = map.get(DefaultEditorKit.selectLineAction);\n                    }\n                    if (a == null) {\n                        if (selectLine == null) {\n                            selectLine = new DefaultEditorKit.SelectLineAction();\n                        }\n                        a = selectLine;\n                    }\n                    a.actionPerformed(new ActionEvent(getComponent(),\n                                                      ActionEvent.ACTION_PERFORMED, null, e.getWhen(), e.getModifiers()));\n                }\n            } else if (SwingUtilities.isMiddleMouseButton(e)) {\n                // mouse 2 behavior\n                if (nclicks == 1 && component.isEditable() && component.isEnabled()\n                    && SwingUtilities2.canEventAccessSystemClipboard(e)) {\n                    // paste system selection, if it exists\n                    JTextComponent c = (JTextComponent) e.getSource();\n                    if (c != null) {\n                        try {\n                            Toolkit tk = c.getToolkit();\n                            Clipboard buffer = tk.getSystemSelection();\n                            if (buffer != null) {\n                                // platform supports system selections, update it.\n                                adjustCaret(e);\n                                TransferHandler th = c.getTransferHandler();\n                                if (th != null) {\n                                    Transferable trans = null;\n\n                                    try {\n                                        trans = buffer.getContents(null);\n                                    } catch (IllegalStateException ise) {\n                                        // clipboard was unavailable\n                                        UIManager.getLookAndFeel().provideErrorFeedback(c);\n                                    }\n\n                                    if (trans != null) {\n                                        th.importData(c, trans);\n                                    }\n                                }\n                                adjustFocus(true);\n                            }\n                        } catch (HeadlessException he) {\n                            // do nothing... there is no system clipboard\n                        }\n                    }\n                }\n            }\n        }\n    }"}
{"Number":"1533","API Relative Path":"javax.swing.text.DefaultCaret.java-mousePressed(MouseEvent)","Corresponding Source":"/**\n     * If button 1 is pressed, this is implemented to\n     * request focus on the associated text component,\n     * and to set the caret position. If the shift key is held down,\n     * the caret will be moved, potentially resulting in a selection,\n     * otherwise the\n     * caret position will be set to the new location.  If the component\n     * is not enabled, there will be no request for focus.\n     *\n     * @param e the mouse event\n     * @see MouseListener#mousePressed\n     */\n    public void mousePressed(MouseEvent e) {\n        int nclicks = SwingUtilities2.getAdjustedClickCount(getComponent(), e);\n\n        if (SwingUtilities.isLeftMouseButton(e)) {\n            if (e.isConsumed()) {\n                shouldHandleRelease = true;\n            } else {\n                shouldHandleRelease = false;\n                adjustCaretAndFocus(e);\n                if (nclicks == 2\n                    && SwingUtilities2.canEventAccessSystemClipboard(e)) {\n                    selectWord(e);\n                }\n            }\n        }\n    }"}
{"Number":"1534","API Relative Path":"javax.swing.text.DefaultCaret.java-removeChangeListener(ChangeListener)","Corresponding Source":"/**\n     * Removes a listener that was tracking caret position changes.\n     *\n     * @param l the listener\n     * @see Caret#removeChangeListener\n     */\n    public void removeChangeListener(ChangeListener l) {\n        listenerList.remove(ChangeListener.class, l);\n    }"}
{"Number":"1535","API Relative Path":"javax.swing.text.DefaultCaret.java-setBlinkRate(int)","Corresponding Source":"/**\n     * Sets the caret blink rate.\n     *\n     * @param rate the rate in milliseconds, 0 to stop blinking\n     * @see Caret#setBlinkRate\n     */\n    public void setBlinkRate(int rate) {\n        if (rate != 0) {\n            if (flasher == null) {\n                flasher = new Timer(rate, handler);\n            }\n            flasher.setDelay(rate);\n        } else {\n            if (flasher != null) {\n                flasher.stop();\n                flasher.removeActionListener(handler);\n                flasher = null;\n            }\n        }\n    }"}
{"Number":"1536","API Relative Path":"javax.swing.text.DefaultEditorKit.java-write(Writer-Document-int-int)","Corresponding Source":"/**\n     * Writes content from a document to the given stream\n     * as plain text.\n     *\n     * @param out  The stream to write to\n     * @param doc The source for the write.\n     * @param pos The location in the document to fetch the\n     *   content from &gt;=0.\n     * @param len The amount to write out &gt;=0.\n     * @exception IOException on any I/O error\n     * @exception BadLocationException if pos is not within 0 and\n     *   the length of the document.\n     */\n    public void write(Writer out, Document doc, int pos, int len)\n        throws IOException, BadLocationException {\n\n        if ((pos < 0) || ((pos + len) > doc.getLength())) {\n            throw new BadLocationException(\"DefaultEditorKit.write\", pos);\n        }\n        Segment data = new Segment();\n        int nleft = len;\n        int offs = pos;\n        Object endOfLineProperty = doc.getProperty(EndOfLineStringProperty);\n        if (endOfLineProperty == null) {\n            try {\n                endOfLineProperty = System.getProperty(\"line.separator\");\n            } catch (SecurityException se) { }\n        }\n        String endOfLine;\n        if (endOfLineProperty instanceof String) {\n            endOfLine = (String)endOfLineProperty;\n        }\n        else {\n            endOfLine = null;\n        }\n        if (endOfLineProperty != null && !endOfLine.equals(\"\\n\")) {\n            // There is an end of line string that isn't \\n, have to iterate\n            // through and find all \\n's and translate to end of line string.\n            while (nleft > 0) {\n                int n = Math.min(nleft, 4096);\n                doc.getText(offs, n, data);\n                int last = data.offset;\n                char[] array = data.array;\n                int maxCounter = last + data.count;\n                for (int counter = last; counter < maxCounter; counter++) {\n                    if (array[counter] == '\\n') {\n                        if (counter > last) {\n                            out.write(array, last, counter - last);\n                        }\n                        out.write(endOfLine);\n                        last = counter + 1;\n                    }\n                }\n                if (maxCounter > last) {\n                    out.write(array, last, maxCounter - last);\n                }\n                offs += n;\n                nleft -= n;\n            }\n        }\n        else {\n            // Just write out text, will already have \\n, no mapping to\n            // do.\n            while (nleft > 0) {\n                int n = Math.min(nleft, 4096);\n                doc.getText(offs, n, data);\n                out.write(data.array, data.offset, data.count);\n                offs += n;\n                nleft -= n;\n            }\n        }\n        out.flush();\n    }"}
{"Number":"1537","API Relative Path":"javax.swing.text.DefaultFormatterFactory.java-getFormatter(JFormattedTextField)","Corresponding Source":"/**\n     * Returns either the default formatter, display formatter, editor\n     * formatter or null formatter based on the state of the\n     * JFormattedTextField.\n     *\n     * @param source JFormattedTextField requesting\n     *               JFormattedTextField.AbstractFormatter\n     * @return JFormattedTextField.AbstractFormatter to handle\n     *         formatting duties.\n     */\n    public JFormattedTextField.AbstractFormatter getFormatter(\n                     JFormattedTextField source) {\n        JFormattedTextField.AbstractFormatter format = null;\n\n        if (source == null) {\n            return null;\n        }\n        Object value = source.getValue();\n\n        if (value == null) {\n            format = getNullFormatter();\n        }\n        if (format == null) {\n            if (source.hasFocus()) {\n                format = getEditFormatter();\n            }\n            else {\n                format = getDisplayFormatter();\n            }\n            if (format == null) {\n                format = getDefaultFormatter();\n            }\n        }\n        return format;\n    }"}
{"Number":"1538","API Relative Path":"javax.swing.text.DefaultHighlighter.java-changeHighlight(Object-int-int)","Corresponding Source":"/**\n     * Changes a highlight.\n     *\n     * @param tag the highlight tag\n     * @param p0 the beginning of the range &gt;= 0\n     * @param p1 the end of the range &gt;= p0\n     * @exception BadLocationException if the specified location is invalid\n     */\n    public void changeHighlight(Object tag, int p0, int p1) throws BadLocationException {\n        if (p0 < 0) {\n            throw new BadLocationException(\"Invalid beginning of the range\", p0);\n        }\n\n        if (p1 < p0) {\n            throw new BadLocationException(\"Invalid end of the range\", p1);\n        }\n\n        Document doc = component.getDocument();\n        if (tag instanceof LayeredHighlightInfo) {\n            LayeredHighlightInfo lhi = (LayeredHighlightInfo)tag;\n            if (lhi.width > 0 && lhi.height > 0) {\n                component.repaint(lhi.x, lhi.y, lhi.width, lhi.height);\n            }\n            // Mark the highlights region as invalid, it will reset itself\n            // next time asked to paint.\n            lhi.width = lhi.height = 0;\n            lhi.p0 = doc.createPosition(p0);\n            lhi.p1 = doc.createPosition(p1);\n            safeDamageRange(Math.min(p0, p1), Math.max(p0, p1));\n        }\n        else {\n            HighlightInfo info = (HighlightInfo) tag;\n            int oldP0 = info.p0.getOffset();\n            int oldP1 = info.p1.getOffset();\n            if (p0 == oldP0) {\n                safeDamageRange(Math.min(oldP1, p1),\n                                   Math.max(oldP1, p1));\n            } else if (p1 == oldP1) {\n                safeDamageRange(Math.min(p0, oldP0),\n                                   Math.max(p0, oldP0));\n            } else {\n                safeDamageRange(oldP0, oldP1);\n                safeDamageRange(p0, p1);\n            }\n            info.p0 = doc.createPosition(p0);\n            info.p1 = doc.createPosition(p1);\n        }\n    }"}
{"Number":"1539","API Relative Path":"javax.swing.text.DefaultStyledDocument.java-insert(int-ElementSpec[])","Corresponding Source":"/**\n     * Inserts new elements in bulk.  This is useful to allow\n     * parsing with the document in an unlocked state and\n     * prepare an element structure modification.  This method\n     * takes an array of tokens that describe how to update an\n     * element structure so the time within a write lock can\n     * be greatly reduced in an asynchronous update situation.\n     * <p>\n     * This method is thread safe, although most Swing methods\n     * are not. Please see\n     * <A HREF=\"http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html\">Concurrency\n     * in Swing<\/A> for more information.\n     *\n     * @param offset the starting offset &gt;= 0\n     * @param data the element data\n     * @exception BadLocationException for an invalid starting offset\n     */\n    protected void insert(int offset, ElementSpec[] data) throws BadLocationException {\n        if (data == null || data.length == 0) {\n            return;\n        }\n\n        try {\n            writeLock();\n\n            // install the content\n            Content c = getContent();\n            int n = data.length;\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < n; i++) {\n                ElementSpec es = data[i];\n                if (es.getLength() > 0) {\n                    sb.append(es.getArray(), es.getOffset(),  es.getLength());\n                }\n            }\n            if (sb.length() == 0) {\n                // Nothing to insert, bail.\n                return;\n            }\n            UndoableEdit cEdit = c.insertString(offset, sb.toString());\n\n            // create event and build the element structure\n            int length = sb.length();\n            DefaultDocumentEvent evnt =\n                new DefaultDocumentEvent(offset, length, DocumentEvent.EventType.INSERT);\n            evnt.addEdit(cEdit);\n            buffer.insert(offset, length, data, evnt);\n\n            // update bidi (possibly)\n            super.insertUpdate(evnt, null);\n\n            // notify the listeners\n            evnt.end();\n            fireInsertUpdate(evnt);\n            fireUndoableEditUpdate(new UndoableEditEvent(this, evnt));\n        } finally {\n            writeUnlock();\n        }\n    }"}
{"Number":"1540","API Relative Path":"javax.swing.text.FlowView.java-setParent(View)","Corresponding Source":"/** {@inheritDoc} */\n    public void setParent(View parent) {\n        super.setParent(parent);\n        if (parent == null\n                && layoutPool != null ) {\n            layoutPool.setParent(null);\n        }\n    }"}
{"Number":"1541","API Relative Path":"javax.swing.text.GapContent.java-getChars(int-int-Segment)","Corresponding Source":"/**\n     * Retrieves a portion of the content.  If the desired content spans\n     * the gap, we copy the content.  If the desired content does not\n     * span the gap, the actual store is returned to avoid the copy since\n     * it is contiguous.\n     *\n     * @param where the starting position &gt;= 0, where + len &lt;= length()\n     * @param len the number of characters to retrieve &gt;= 0\n     * @param chars the Segment object to return the characters in\n     * @exception BadLocationException if the specified position is invalid\n     * @see AbstractDocument.Content#getChars\n     */\n    public void getChars(int where, int len, Segment chars) throws BadLocationException {\n        int end = where + len;\n        if (where < 0 || end < 0) {\n            throw new BadLocationException(\"Invalid location\", -1);\n        }\n        if (end > length() || where > length()) {\n            throw new BadLocationException(\"Invalid location\", length() + 1);\n        }\n        int g0 = getGapStart();\n        int g1 = getGapEnd();\n        char[] array = (char[]) getArray();\n        if ((where + len) <= g0) {\n            // below gap\n            chars.array = array;\n            chars.offset = where;\n        } else if (where >= g0) {\n            // above gap\n            chars.array = array;\n            chars.offset = g1 + where - g0;\n        } else {\n            // spans the gap\n            int before = g0 - where;\n            if (chars.isPartialReturn()) {\n                // partial return allowed, return amount before the gap\n                chars.array = array;\n                chars.offset = where;\n                chars.count = before;\n                return;\n            }\n            // partial return not allowed, must copy\n            chars.array = new char[len];\n            chars.offset = 0;\n            System.arraycopy(array, where, chars.array, 0, before);\n            System.arraycopy(array, g1, chars.array, before, len - before);\n        }\n        chars.count = len;\n    }"}
{"Number":"1542","API Relative Path":"javax.swing.text.GapContent.java-insertString(int-String)","Corresponding Source":"/**\n     * Inserts a string into the content.\n     *\n     * @param where the starting position &gt;= 0, &lt; length()\n     * @param str the non-null string to insert\n     * @return an UndoableEdit object for undoing\n     * @exception BadLocationException if the specified position is invalid\n     * @see AbstractDocument.Content#insertString\n     */\n    public UndoableEdit insertString(int where, String str) throws BadLocationException {\n        if (where > length() || where < 0) {\n            throw new BadLocationException(\"Invalid insert\", length());\n        }\n        char[] chars = str.toCharArray();\n        replace(where, 0, chars, chars.length);\n        return new InsertUndo(where, str.length());\n    }"}
{"Number":"1543","API Relative Path":"javax.swing.text.GapContent.java-remove(int-int)","Corresponding Source":"/**\n     * Removes part of the content.\n     *\n     * @param where the starting position &gt;= 0, where + nitems &lt; length()\n     * @param nitems the number of characters to remove &gt;= 0\n     * @return an UndoableEdit object for undoing\n     * @exception BadLocationException if the specified position is invalid\n     * @see AbstractDocument.Content#remove\n     */\n    public UndoableEdit remove(int where, int nitems) throws BadLocationException {\n        if (where + nitems >= length()) {\n            throw new BadLocationException(\"Invalid remove\", length() + 1);\n        }\n        String removedString = getString(where, nitems);\n        UndoableEdit edit = new RemoveUndo(where, removedString);\n        replace(where, nitems, empty, 0);\n        return edit;\n\n    }"}
{"Number":"1544","API Relative Path":"javax.swing.text.GlyphPainter2.java-getBoundedPosition(GlyphView-int-float-float)","Corresponding Source":"/**\n     * Determines the model location that represents the\n     * maximum advance that fits within the given span.\n     * This could be used to break the given view.  The result\n     * should be a location just shy of the given advance.  This\n     * differs from viewToModel which returns the closest\n     * position which might be proud of the maximum advance.\n     *\n     * @param v the view to find the model location to break at.\n     * @param p0 the location in the model where the\n     *  fragment should start it's representation >= 0.\n     * @param pos the graphic location along the axis that the\n     *  broken view would occupy >= 0.  This may be useful for\n     *  things like tab calculations.\n     * @param len specifies the distance into the view\n     *  where a potential break is desired >= 0.\n     * @return the maximum model location possible for a break.\n     * @see View#breakView\n     */\n    public int getBoundedPosition(GlyphView v, int p0, float x, float len) {\n        if( len < 0 )\n            throw new IllegalArgumentException(\"Length must be >= 0.\");\n        // note: this only works because swing uses TextLayouts that are\n        // only pure rtl or pure ltr\n        TextHitInfo hit;\n        if (layout.isLeftToRight()) {\n            hit = layout.hitTestChar(len, 0);\n        } else {\n            hit = layout.hitTestChar(layout.getAdvance() - len, 0);\n        }\n        return v.getStartOffset() + hit.getCharIndex();\n    }"}
{"Number":"1545","API Relative Path":"javax.swing.text.html.BlockView.java-setParent(View)","Corresponding Source":"/**\n     * Establishes the parent view for this view.  This is\n     * guaranteed to be called before any other methods if the\n     * parent view is functioning properly.\n     * <p>\n     * This is implemented\n     * to forward to the superclass as well as call the\n     * {@link #setPropertiesFromAttributes()}\n     * method to set the paragraph properties from the css\n     * attributes.  The call is made at this time to ensure\n     * the ability to resolve upward through the parents\n     * view attributes.\n     *\n     * @param parent the new parent, or null if the view is\n     *  being removed from a parent it was previously added\n     *  to\n     */\n    public void setParent(View parent) {\n        super.setParent(parent);\n        if (parent != null) {\n            setPropertiesFromAttributes();\n        }\n    }"}
{"Number":"1546","API Relative Path":"javax.swing.text.html.CSS.java-getURL(URL-String)","Corresponding Source":"//\n    // Conversion related methods/classes\n    //\n\n    /**\n     * Returns a URL for the given CSS url string. If relative,\n     * <code>base<\/code> is used as the parent. If a valid URL can not\n     * be found, this will not throw a MalformedURLException, instead\n     * null will be returned.\n     */\n    static URL getURL(URL base, String cssString) {\n        if (cssString == null) {\n            return null;\n        }\n        if (cssString.startsWith(\"url(\") &&\n            cssString.endsWith(\")\")) {\n            cssString = cssString.substring(4, cssString.length() - 1);\n        }\n        // Absolute first\n        try {\n            URL url = new URL(cssString);\n            if (url != null) {\n                return url;\n            }\n        } catch (MalformedURLException mue) {\n        }\n        // Then relative\n        if (base != null) {\n            // Relative URL, try from base\n            try {\n                URL url = new URL(base, cssString);\n                return url;\n            }\n            catch (MalformedURLException muee) {\n            }\n        }\n        return null;\n    }"}
{"Number":"1547","API Relative Path":"javax.swing.text.html.CSS.java-setBaseFontSize(String)","Corresponding Source":"/**\n     * Sets the base font size from the passed in string.\n     */\n    void setBaseFontSize(String size) {\n        int relSize, absSize, diff;\n\n        if (size != null) {\n            if (size.startsWith(\"+\")) {\n                relSize = Integer.valueOf(size.substring(1)).intValue();\n                setBaseFontSize(baseFontSize + relSize);\n            } else if (size.startsWith(\"-\")) {\n                relSize = -Integer.valueOf(size.substring(1)).intValue();\n                setBaseFontSize(baseFontSize + relSize);\n            } else {\n                setBaseFontSize(Integer.valueOf(size).intValue());\n            }\n        }\n    }"}
{"Number":"1548","API Relative Path":"javax.swing.text.html.CSS.java-stringToColor(String)","Corresponding Source":"/**\n     * Convert a color string such as \"RED\" or \"#NNNNNN\" or \"rgb(r, g, b)\"\n     * to a Color.\n     */\n    static Color stringToColor(String str) {\n      Color color;\n\n      if (str == null) {\n          return null;\n      }\n      if (str.length() == 0)\n        color = Color.black;\n      else if (str.startsWith(\"rgb(\")) {\n          color = parseRGB(str);\n      }\n      else if (str.charAt(0) == '#')\n        color = hexToColor(str);\n      else if (str.equalsIgnoreCase(\"Black\"))\n        color = hexToColor(\"#000000\");\n      else if(str.equalsIgnoreCase(\"Silver\"))\n        color = hexToColor(\"#C0C0C0\");\n      else if(str.equalsIgnoreCase(\"Gray\"))\n        color = hexToColor(\"#808080\");\n      else if(str.equalsIgnoreCase(\"White\"))\n        color = hexToColor(\"#FFFFFF\");\n      else if(str.equalsIgnoreCase(\"Maroon\"))\n        color = hexToColor(\"#800000\");\n      else if(str.equalsIgnoreCase(\"Red\"))\n        color = hexToColor(\"#FF0000\");\n      else if(str.equalsIgnoreCase(\"Purple\"))\n        color = hexToColor(\"#800080\");\n      else if(str.equalsIgnoreCase(\"Fuchsia\"))\n        color = hexToColor(\"#FF00FF\");\n      else if(str.equalsIgnoreCase(\"Green\"))\n        color = hexToColor(\"#008000\");\n      else if(str.equalsIgnoreCase(\"Lime\"))\n        color = hexToColor(\"#00FF00\");\n      else if(str.equalsIgnoreCase(\"Olive\"))\n        color = hexToColor(\"#808000\");\n      else if(str.equalsIgnoreCase(\"Yellow\"))\n        color = hexToColor(\"#FFFF00\");\n      else if(str.equalsIgnoreCase(\"Navy\"))\n        color = hexToColor(\"#000080\");\n      else if(str.equalsIgnoreCase(\"Blue\"))\n        color = hexToColor(\"#0000FF\");\n      else if(str.equalsIgnoreCase(\"Teal\"))\n        color = hexToColor(\"#008080\");\n      else if(str.equalsIgnoreCase(\"Aqua\"))\n        color = hexToColor(\"#00FFFF\");\n      else if(str.equalsIgnoreCase(\"Orange\"))\n        color = hexToColor(\"#FF8000\");\n      else\n          color = hexToColor(str); // sometimes get specified without leading #\n      return color;\n    }"}
{"Number":"1549","API Relative Path":"javax.swing.text.html.FormView.java-getMaximumSpan(int)","Corresponding Source":"/**\n     * Determines the maximum span for this view along an\n     * axis. For certain components, the maximum and preferred span are the\n     * same. For others this will return the value\n     * returned by Component.getMaximumSize along the\n     * axis of interest.\n     *\n     * @param axis may be either View.X_AXIS or View.Y_AXIS\n     * @return   the span the view would like to be rendered into &gt;= 0.\n     *           Typically the view is told to render into the span\n     *           that is returned, although there is no guarantee.\n     *           The parent may choose to resize or break the view.\n     * @exception IllegalArgumentException for an invalid axis\n     */\n    public float getMaximumSpan(int axis) {\n        switch (axis) {\n        case View.X_AXIS:\n            if ((maxIsPreferred & 1) == 1) {\n                super.getMaximumSpan(axis);\n                return getPreferredSpan(axis);\n            }\n            return super.getMaximumSpan(axis);\n        case View.Y_AXIS:\n            if ((maxIsPreferred & 2) == 2) {\n                super.getMaximumSpan(axis);\n                return getPreferredSpan(axis);\n            }\n            return super.getMaximumSpan(axis);\n        default:\n            break;\n        }\n        return super.getMaximumSpan(axis);\n    }"}
{"Number":"1550","API Relative Path":"javax.swing.text.html.HTMLDocument.java-getElement(String)","Corresponding Source":"/**\n     * Returns the element that has the given id <code>Attribute<\/code>.\n     * If the element can't be found, <code>null<\/code> is returned.\n     * Note that this method works on an <code>Attribute<\/code>,\n     * <i>not<\/i> a character tag.  In the following HTML snippet:\n     * <code>&lt;a id=\"HelloThere\"&gt;<\/code> the attribute is\n     * 'id' and the character tag is 'a'.\n     * This is a convenience method for\n     * <code>getElement(RootElement, HTML.Attribute.id, id)<\/code>.\n     * This is not thread-safe.\n     *\n     * @param id  the string representing the desired <code>Attribute<\/code>\n     * @return the element with the specified <code>Attribute<\/code>\n     *          or <code>null<\/code> if it can't be found,\n     *          or <code>null<\/code> if <code>id<\/code> is <code>null<\/code>\n     * @see javax.swing.text.html.HTML.Attribute\n     * @since 1.3\n     */\n    public Element getElement(String id) {\n        if (id == null) {\n            return null;\n        }\n        return getElement(getDefaultRootElement(), HTML.Attribute.ID, id,\n                          true);\n    }"}
{"Number":"1551","API Relative Path":"javax.swing.text.html.HTMLDocument.java-insertAfterEnd(Element-String)","Corresponding Source":"/**\n     * Inserts the HTML specified as a string after the the end of the\n     * given element.\n     *\n     * <p>Consider the following structure (the <code>elem<\/code>\n     * parameter is <b>in bold<\/b>).<\/p>\n     *\n     * <pre>\n     *     &lt;body&gt;\n     *       |\n     *     <b>&lt;div&gt;<\/b>\n     *      /  \\\n     *    &lt;p&gt;   &lt;p&gt;\n     * <\/pre>\n     *\n     * <p>Invoking <code>insertAfterEnd(elem, \"&lt;ul&gt;&lt;li&gt;\")<\/code>\n     * results in the following structure (new elements are <font\n     * color=\"red\">in red<\/font>).<\/p>\n     *\n     * <pre>\n     *        &lt;body&gt;\n     *         /  \\\n     *      <b>&lt;div&gt;<\/b> <font color=\"red\">&lt;ul&gt;<\/font>\n     *       / \\    \\\n     *     &lt;p&gt; &lt;p&gt;  <font color=\"red\">&lt;li&gt;<\/font>\n     * <\/pre>\n     *\n     * <p>Unlike the <code>insertBeforeEnd<\/code> method, new elements\n     * become <em>siblings<\/em> of the specified element, not\n     * children.<\/p>\n     *\n     * <p>If either <code>elem<\/code> or <code>htmlText<\/code>\n     * parameter is <code>null<\/code>, no changes are made to the\n     * document.<\/p>\n     *\n     * <p>For this to work correctly, the document must have an\n     * <code>HTMLEditorKit.Parser<\/code> set. This will be the case\n     * if the document was created from an HTMLEditorKit via the\n     * <code>createDefaultDocument<\/code> method.<\/p>\n     *\n     * @param elem the element the content is inserted after\n     * @param htmlText the string to be parsed and inserted after <code>elem<\/code>\n     * @throws IllegalStateException if an HTMLEditorKit.Parser has not\n     *         been set on the document\n     * @since 1.3\n     */\n    public void insertAfterEnd(Element elem, String htmlText) throws\n                               BadLocationException, IOException {\n        verifyParser();\n        if (elem != null) {\n            Element parent = elem.getParentElement();\n\n            if (parent != null) {\n                int offset = elem.getEndOffset();\n                if (offset > getLength()) {\n                    offset--;\n                }\n                else if (elem.isLeaf() && getText(offset - 1, 1).\n                    charAt(0) == NEWLINE[0]) {\n                    offset--;\n                }\n                insertHTML(parent, offset, htmlText, false);\n            }\n        }\n    }"}
{"Number":"1552","API Relative Path":"javax.swing.text.html.HTMLDocument.java-insertAfterStart(Element-String)","Corresponding Source":"/**\n     * Inserts the HTML specified as a string at the start\n     * of the element.\n     *\n     * <p>Consider the following structure (the <code>elem<\/code>\n     * parameter is <b>in bold<\/b>).<\/p>\n     *\n     * <pre>\n     *     &lt;body&gt;\n     *       |\n     *     <b>&lt;div&gt;<\/b>\n     *      /  \\\n     *    &lt;p&gt;   &lt;p&gt;\n     * <\/pre>\n     *\n     * <p>Invoking <code>insertAfterStart(elem,\n     * \"&lt;ul&gt;&lt;li&gt;\")<\/code> results in the following structure\n     * (new elements are <font color=\"red\">in red<\/font>).<\/p>\n     *\n     * <pre>\n     *        &lt;body&gt;\n     *          |\n     *        <b>&lt;div&gt;<\/b>\n     *       /  |  \\\n     *    <font color=\"red\">&lt;ul&gt;<\/font> &lt;p&gt; &lt;p&gt;\n     *     /\n     *  <font color=\"red\">&lt;li&gt;<\/font>\n     * <\/pre>\n     *\n     * <p>Unlike the <code>insertBeforeStart<\/code> method, new\n     *  elements become <em>children<\/em> of the specified element,\n     *  not siblings.<\/p>\n     *\n     * <p>Parameter <code>elem<\/code> must not be a leaf element,\n     * otherwise an <code>IllegalArgumentException<\/code> is thrown.\n     * If either <code>elem<\/code> or <code>htmlText<\/code> parameter\n     * is <code>null<\/code>, no changes are made to the document.<\/p>\n     *\n     * <p>For this to work correctly, the document must have an\n     * <code>HTMLEditorKit.Parser<\/code> set. This will be the case\n     * if the document was created from an HTMLEditorKit via the\n     * <code>createDefaultDocument<\/code> method.<\/p>\n     *\n     * @param elem the branch element to be the root for the new text\n     * @param htmlText the string to be parsed and assigned to <code>elem<\/code>\n     * @throws IllegalArgumentException if <code>elem<\/code> is a leaf\n     * @throws IllegalStateException if an HTMLEditorKit.Parser has not\n     *         been set on the document\n     * @since 1.3\n     */\n    public void insertAfterStart(Element elem, String htmlText) throws\n                                 BadLocationException, IOException {\n        verifyParser();\n\n        if (elem == null || htmlText == null) {\n            return;\n        }\n\n        if (elem.isLeaf()) {\n            throw new IllegalArgumentException\n                (\"Can not insert HTML after start of a leaf\");\n        }\n        insertHTML(elem, elem.getStartOffset(), htmlText, false);\n    }"}
{"Number":"1553","API Relative Path":"javax.swing.text.html.HTMLDocument.java-insertBeforeEnd(Element-String)","Corresponding Source":"/**\n     * Inserts the HTML specified as a string at the end of\n     * the element.\n     *\n     * <p> If <code>elem<\/code>'s children are leaves, and the\n     * character at a <code>elem.getEndOffset() - 1<\/code> is a newline,\n     * this will insert before the newline so that there isn't text after\n     * the newline.<\/p>\n     *\n     * <p>Consider the following structure (the <code>elem<\/code>\n     * parameter is <b>in bold<\/b>).<\/p>\n     *\n     * <pre>\n     *     &lt;body&gt;\n     *       |\n     *     <b>&lt;div&gt;<\/b>\n     *      /  \\\n     *    &lt;p&gt;   &lt;p&gt;\n     * <\/pre>\n     *\n     * <p>Invoking <code>insertBeforeEnd(elem, \"&lt;ul&gt;&lt;li&gt;\")<\/code>\n     * results in the following structure (new elements are <font\n     * color=\"red\">in red<\/font>).<\/p>\n     *\n     * <pre>\n     *        &lt;body&gt;\n     *          |\n     *        <b>&lt;div&gt;<\/b>\n     *       /  |  \\\n     *     &lt;p&gt; &lt;p&gt; <font color=\"red\">&lt;ul&gt;<\/font>\n     *               \\\n     *               <font color=\"red\">&lt;li&gt;<\/font>\n     * <\/pre>\n     *\n     * <p>Unlike the <code>insertAfterEnd<\/code> method, new elements\n     * become <em>children<\/em> of the specified element, not\n     * siblings.<\/p>\n     *\n     * <p>Parameter <code>elem<\/code> must not be a leaf element,\n     * otherwise an <code>IllegalArgumentException<\/code> is thrown.\n     * If either <code>elem<\/code> or <code>htmlText<\/code> parameter\n     * is <code>null<\/code>, no changes are made to the document.<\/p>\n     *\n     * <p>For this to work correctly, the document must have an\n     * <code>HTMLEditorKit.Parser<\/code> set. This will be the case\n     * if the document was created from an HTMLEditorKit via the\n     * <code>createDefaultDocument<\/code> method.<\/p>\n     *\n     * @param elem the element to be the root for the new text\n     * @param htmlText the string to be parsed and assigned to <code>elem<\/code>\n     * @throws IllegalArgumentException if <code>elem<\/code> is a leaf\n     * @throws IllegalStateException if an HTMLEditorKit.Parser has not\n     *         been set on the document\n     * @since 1.3\n     */\n    public void insertBeforeEnd(Element elem, String htmlText) throws\n                                BadLocationException, IOException {\n        verifyParser();\n        if (elem != null && elem.isLeaf()) {\n            throw new IllegalArgumentException\n                (\"Can not set inner HTML before end of leaf\");\n        }\n        if (elem != null) {\n            int offset = elem.getEndOffset();\n            if (elem.getElement(elem.getElementIndex(offset - 1)).isLeaf() &&\n                getText(offset - 1, 1).charAt(0) == NEWLINE[0]) {\n                offset--;\n            }\n            insertHTML(elem, offset, htmlText, false);\n        }\n    }"}
{"Number":"1554","API Relative Path":"javax.swing.text.html.HTMLDocument.java-insertBeforeEnd(Element-String)","Corresponding Source":"/**\n     * Inserts the HTML specified as a string at the end of\n     * the element.\n     *\n     * <p> If <code>elem<\/code>'s children are leaves, and the\n     * character at a <code>elem.getEndOffset() - 1<\/code> is a newline,\n     * this will insert before the newline so that there isn't text after\n     * the newline.<\/p>\n     *\n     * <p>Consider the following structure (the <code>elem<\/code>\n     * parameter is <b>in bold<\/b>).<\/p>\n     *\n     * <pre>\n     *     &lt;body&gt;\n     *       |\n     *     <b>&lt;div&gt;<\/b>\n     *      /  \\\n     *    &lt;p&gt;   &lt;p&gt;\n     * <\/pre>\n     *\n     * <p>Invoking <code>insertBeforeEnd(elem, \"&lt;ul&gt;&lt;li&gt;\")<\/code>\n     * results in the following structure (new elements are <font\n     * color=\"red\">in red<\/font>).<\/p>\n     *\n     * <pre>\n     *        &lt;body&gt;\n     *          |\n     *        <b>&lt;div&gt;<\/b>\n     *       /  |  \\\n     *     &lt;p&gt; &lt;p&gt; <font color=\"red\">&lt;ul&gt;<\/font>\n     *               \\\n     *               <font color=\"red\">&lt;li&gt;<\/font>\n     * <\/pre>\n     *\n     * <p>Unlike the <code>insertAfterEnd<\/code> method, new elements\n     * become <em>children<\/em> of the specified element, not\n     * siblings.<\/p>\n     *\n     * <p>Parameter <code>elem<\/code> must not be a leaf element,\n     * otherwise an <code>IllegalArgumentException<\/code> is thrown.\n     * If either <code>elem<\/code> or <code>htmlText<\/code> parameter\n     * is <code>null<\/code>, no changes are made to the document.<\/p>\n     *\n     * <p>For this to work correctly, the document must have an\n     * <code>HTMLEditorKit.Parser<\/code> set. This will be the case\n     * if the document was created from an HTMLEditorKit via the\n     * <code>createDefaultDocument<\/code> method.<\/p>\n     *\n     * @param elem the element to be the root for the new text\n     * @param htmlText the string to be parsed and assigned to <code>elem<\/code>\n     * @throws IllegalArgumentException if <code>elem<\/code> is a leaf\n     * @throws IllegalStateException if an HTMLEditorKit.Parser has not\n     *         been set on the document\n     * @since 1.3\n     */\n    public void insertBeforeEnd(Element elem, String htmlText) throws\n                                BadLocationException, IOException {\n        verifyParser();\n        if (elem != null && elem.isLeaf()) {\n            throw new IllegalArgumentException\n                (\"Can not set inner HTML before end of leaf\");\n        }\n        if (elem != null) {\n            int offset = elem.getEndOffset();\n            if (elem.getElement(elem.getElementIndex(offset - 1)).isLeaf() &&\n                getText(offset - 1, 1).charAt(0) == NEWLINE[0]) {\n                offset--;\n            }\n            insertHTML(elem, offset, htmlText, false);\n        }\n    }"}
{"Number":"1555","API Relative Path":"javax.swing.text.html.HTMLDocument.java-insertBeforeStart(Element-String)","Corresponding Source":"/**\n     * Inserts the HTML specified as a string before the start of\n     * the given element.\n     *\n     * <p>Consider the following structure (the <code>elem<\/code>\n     * parameter is <b>in bold<\/b>).<\/p>\n     *\n     * <pre>\n     *     &lt;body&gt;\n     *       |\n     *     <b>&lt;div&gt;<\/b>\n     *      /  \\\n     *    &lt;p&gt;   &lt;p&gt;\n     * <\/pre>\n     *\n     * <p>Invoking <code>insertBeforeStart(elem,\n     * \"&lt;ul&gt;&lt;li&gt;\")<\/code> results in the following structure\n     * (new elements are <font color=\"red\">in red<\/font>).<\/p>\n     *\n     * <pre>\n     *        &lt;body&gt;\n     *         /  \\\n     *      <font color=\"red\">&lt;ul&gt;<\/font> <b>&lt;div&gt;<\/b>\n     *       /    /  \\\n     *     <font color=\"red\">&lt;li&gt;<\/font> &lt;p&gt;  &lt;p&gt;\n     * <\/pre>\n     *\n     * <p>Unlike the <code>insertAfterStart<\/code> method, new\n     * elements become <em>siblings<\/em> of the specified element, not\n     * children.<\/p>\n     *\n     * <p>If either <code>elem<\/code> or <code>htmlText<\/code>\n     * parameter is <code>null<\/code>, no changes are made to the\n     * document.<\/p>\n     *\n     * <p>For this to work correctly, the document must have an\n     * <code>HTMLEditorKit.Parser<\/code> set. This will be the case\n     * if the document was created from an HTMLEditorKit via the\n     * <code>createDefaultDocument<\/code> method.<\/p>\n     *\n     * @param elem the element the content is inserted before\n     * @param htmlText the string to be parsed and inserted before <code>elem<\/code>\n     * @throws IllegalStateException if an HTMLEditorKit.Parser has not\n     *         been set on the document\n     * @since 1.3\n     */\n    public void insertBeforeStart(Element elem, String htmlText) throws\n                                  BadLocationException, IOException {\n        verifyParser();\n        if (elem != null) {\n            Element parent = elem.getParentElement();\n\n            if (parent != null) {\n                insertHTML(parent, elem.getStartOffset(), htmlText, false);\n            }\n        }\n    }"}
{"Number":"1556","API Relative Path":"javax.swing.text.html.HTMLDocument.java-setInnerHTML(Element-String)","Corresponding Source":"/**\n     * Replaces the children of the given element with the contents\n     * specified as an HTML string.\n     *\n     * <p>This will be seen as at least two events, n inserts followed by\n     * a remove.<\/p>\n     *\n     * <p>Consider the following structure (the <code>elem<\/code>\n     * parameter is <b>in bold<\/b>).<\/p>\n     *\n     * <pre>\n     *     &lt;body&gt;\n     *       |\n     *     <b>&lt;div&gt;<\/b>\n     *      /  \\\n     *    &lt;p&gt;   &lt;p&gt;\n     * <\/pre>\n     *\n     * <p>Invoking <code>setInnerHTML(elem, \"&lt;ul&gt;&lt;li&gt;\")<\/code>\n     * results in the following structure (new elements are <font\n     * color=\"red\">in red<\/font>).<\/p>\n     *\n     * <pre>\n     *     &lt;body&gt;\n     *       |\n     *     <b>&lt;div&gt;<\/b>\n     *         \\\n     *         <font color=\"red\">&lt;ul&gt;<\/font>\n     *           \\\n     *           <font color=\"red\">&lt;li&gt;<\/font>\n     * <\/pre>\n     *\n     * <p>Parameter <code>elem<\/code> must not be a leaf element,\n     * otherwise an <code>IllegalArgumentException<\/code> is thrown.\n     * If either <code>elem<\/code> or <code>htmlText<\/code> parameter\n     * is <code>null<\/code>, no changes are made to the document.<\/p>\n     *\n     * <p>For this to work correctly, the document must have an\n     * <code>HTMLEditorKit.Parser<\/code> set. This will be the case\n     * if the document was created from an HTMLEditorKit via the\n     * <code>createDefaultDocument<\/code> method.<\/p>\n     *\n     * @param elem the branch element whose children will be replaced\n     * @param htmlText the string to be parsed and assigned to <code>elem<\/code>\n     * @throws IllegalArgumentException if <code>elem<\/code> is a leaf\n     * @throws IllegalStateException if an <code>HTMLEditorKit.Parser<\/code>\n     *         has not been defined\n     * @since 1.3\n     */\n    public void setInnerHTML(Element elem, String htmlText) throws\n                             BadLocationException, IOException {\n        verifyParser();\n        if (elem != null && elem.isLeaf()) {\n            throw new IllegalArgumentException\n                (\"Can not set inner HTML of a leaf\");\n        }\n        if (elem != null && htmlText != null) {\n            int oldCount = elem.getElementCount();\n            int insertPosition = elem.getStartOffset();\n            insertHTML(elem, elem.getStartOffset(), htmlText, true);\n            if (elem.getElementCount() > oldCount) {\n                // Elements were inserted, do the cleanup.\n                removeElements(elem, elem.getElementCount() - oldCount,\n                               oldCount);\n            }\n        }\n    }"}
{"Number":"1557","API Relative Path":"javax.swing.text.html.HTMLDocument.java-setInnerHTML(Element-String)","Corresponding Source":"/**\n     * Replaces the children of the given element with the contents\n     * specified as an HTML string.\n     *\n     * <p>This will be seen as at least two events, n inserts followed by\n     * a remove.<\/p>\n     *\n     * <p>Consider the following structure (the <code>elem<\/code>\n     * parameter is <b>in bold<\/b>).<\/p>\n     *\n     * <pre>\n     *     &lt;body&gt;\n     *       |\n     *     <b>&lt;div&gt;<\/b>\n     *      /  \\\n     *    &lt;p&gt;   &lt;p&gt;\n     * <\/pre>\n     *\n     * <p>Invoking <code>setInnerHTML(elem, \"&lt;ul&gt;&lt;li&gt;\")<\/code>\n     * results in the following structure (new elements are <font\n     * color=\"red\">in red<\/font>).<\/p>\n     *\n     * <pre>\n     *     &lt;body&gt;\n     *       |\n     *     <b>&lt;div&gt;<\/b>\n     *         \\\n     *         <font color=\"red\">&lt;ul&gt;<\/font>\n     *           \\\n     *           <font color=\"red\">&lt;li&gt;<\/font>\n     * <\/pre>\n     *\n     * <p>Parameter <code>elem<\/code> must not be a leaf element,\n     * otherwise an <code>IllegalArgumentException<\/code> is thrown.\n     * If either <code>elem<\/code> or <code>htmlText<\/code> parameter\n     * is <code>null<\/code>, no changes are made to the document.<\/p>\n     *\n     * <p>For this to work correctly, the document must have an\n     * <code>HTMLEditorKit.Parser<\/code> set. This will be the case\n     * if the document was created from an HTMLEditorKit via the\n     * <code>createDefaultDocument<\/code> method.<\/p>\n     *\n     * @param elem the branch element whose children will be replaced\n     * @param htmlText the string to be parsed and assigned to <code>elem<\/code>\n     * @throws IllegalArgumentException if <code>elem<\/code> is a leaf\n     * @throws IllegalStateException if an <code>HTMLEditorKit.Parser<\/code>\n     *         has not been defined\n     * @since 1.3\n     */\n    public void setInnerHTML(Element elem, String htmlText) throws\n                             BadLocationException, IOException {\n        verifyParser();\n        if (elem != null && elem.isLeaf()) {\n            throw new IllegalArgumentException\n                (\"Can not set inner HTML of a leaf\");\n        }\n        if (elem != null && htmlText != null) {\n            int oldCount = elem.getElementCount();\n            int insertPosition = elem.getStartOffset();\n            insertHTML(elem, elem.getStartOffset(), htmlText, true);\n            if (elem.getElementCount() > oldCount) {\n                // Elements were inserted, do the cleanup.\n                removeElements(elem, elem.getElementCount() - oldCount,\n                               oldCount);\n            }\n        }\n    }"}
{"Number":"1558","API Relative Path":"javax.swing.text.html.HTMLDocument.java-setOuterHTML(Element-String)","Corresponding Source":"/**\n     * Replaces the given element in the parent with the contents\n     * specified as an HTML string.\n     *\n     * <p>This will be seen as at least two events, n inserts followed by\n     * a remove.<\/p>\n     *\n     * <p>When replacing a leaf this will attempt to make sure there is\n     * a newline present if one is needed. This may result in an additional\n     * element being inserted. Consider, if you were to replace a character\n     * element that contained a newline with &lt;img&gt; this would create\n     * two elements, one for the image, and one for the newline.<\/p>\n     *\n     * <p>If you try to replace the element at length you will most\n     * likely end up with two elements, eg\n     * <code>setOuterHTML(getCharacterElement (getLength()),\n     * \"blah\")<\/code> will result in two leaf elements at the end, one\n     * representing 'blah', and the other representing the end\n     * element.<\/p>\n     *\n     * <p>Consider the following structure (the <code>elem<\/code>\n     * parameter is <b>in bold<\/b>).<\/p>\n     *\n     * <pre>\n     *     &lt;body&gt;\n     *       |\n     *     <b>&lt;div&gt;<\/b>\n     *      /  \\\n     *    &lt;p&gt;   &lt;p&gt;\n     * <\/pre>\n     *\n     * <p>Invoking <code>setOuterHTML(elem, \"&lt;ul&gt;&lt;li&gt;\")<\/code>\n     * results in the following structure (new elements are <font\n     * color=\"red\">in red<\/font>).<\/p>\n     *\n     * <pre>\n     *    &lt;body&gt;\n     *      |\n     *     <font color=\"red\">&lt;ul&gt;<\/font>\n     *       \\\n     *       <font color=\"red\">&lt;li&gt;<\/font>\n     * <\/pre>\n     *\n     * <p>If either <code>elem<\/code> or <code>htmlText<\/code>\n     * parameter is <code>null<\/code>, no changes are made to the\n     * document.<\/p>\n     *\n     * <p>For this to work correctly, the document must have an\n     * HTMLEditorKit.Parser set. This will be the case if the document\n     * was created from an HTMLEditorKit via the\n     * <code>createDefaultDocument<\/code> method.<\/p>\n     *\n     * @param elem the element to replace\n     * @param htmlText the string to be parsed and inserted in place of <code>elem<\/code>\n     * @throws IllegalStateException if an HTMLEditorKit.Parser has not\n     *         been set\n     * @since 1.3\n     */\n    public void setOuterHTML(Element elem, String htmlText) throws\n                            BadLocationException, IOException {\n        verifyParser();\n        if (elem != null && elem.getParentElement() != null &&\n            htmlText != null) {\n            int start = elem.getStartOffset();\n            int end = elem.getEndOffset();\n            int startLength = getLength();\n            // We don't want a newline if elem is a leaf, and doesn't contain\n            // a newline.\n            boolean wantsNewline = !elem.isLeaf();\n            if (!wantsNewline && (end > startLength ||\n                                 getText(end - 1, 1).charAt(0) == NEWLINE[0])){\n                wantsNewline = true;\n            }\n            Element parent = elem.getParentElement();\n            int oldCount = parent.getElementCount();\n            insertHTML(parent, start, htmlText, wantsNewline);\n            // Remove old.\n            int newLength = getLength();\n            if (oldCount != parent.getElementCount()) {\n                int removeIndex = parent.getElementIndex(start + newLength -\n                                                         startLength);\n                removeElements(parent, removeIndex, 1);\n            }\n        }\n    }"}
{"Number":"1559","API Relative Path":"javax.swing.text.html.HTMLWriter.java-closeOutUnwantedEmbeddedTags(AttributeSet)","Corresponding Source":"/**\n     * Searches the attribute set and for each tag\n     * that is stored in the tag vector.  If the tag is not found,\n     * then the tag is removed from the vector and a corresponding\n     * end tag is written out.\n     *\n     * @exception IOException on any I/O error\n     */\n    protected void closeOutUnwantedEmbeddedTags(AttributeSet attr) throws IOException {\n\n        tagsToRemove.removeAllElements();\n\n        // translate css attributes to html\n        attr = convertToHTML(attr, null);\n\n        HTML.Tag t;\n        Object tValue;\n        int firstIndex = -1;\n        int size = tags.size();\n        // First, find all the tags that need to be removed.\n        for (int i = size - 1; i >= 0; i--) {\n            t = tags.elementAt(i);\n            tValue = tagValues.elementAt(i);\n            if ((attr == null) || noMatchForTagInAttributes(attr, t, tValue)) {\n                firstIndex = i;\n                tagsToRemove.addElement(t);\n            }\n        }\n        if (firstIndex != -1) {\n            // Then close them out.\n            boolean removeAll = ((size - firstIndex) == tagsToRemove.size());\n            for (int i = size - 1; i >= firstIndex; i--) {\n                t = tags.elementAt(i);\n                if (removeAll || tagsToRemove.contains(t)) {\n                    tags.removeElementAt(i);\n                    tagValues.removeElementAt(i);\n                }\n                write('<');\n                write('/');\n                write(t.toString());\n                write('>');\n            }\n            // Have to output any tags after firstIndex that still remaing,\n            // as we closed them out, but they should remain open.\n            size = tags.size();\n            for (int i = firstIndex; i < size; i++) {\n                t = tags.elementAt(i);\n                write('<');\n                write(t.toString());\n                Object o = tagValues.elementAt(i);\n                if (o != null && o instanceof AttributeSet) {\n                    writeAttributes((AttributeSet)o);\n                }\n                write('>');\n            }\n        }\n    }"}
{"Number":"1560","API Relative Path":"javax.swing.text.html.HTMLWriter.java-convertToHTML(AttributeSet-MutableAttributeSet)","Corresponding Source":"// --- conversion support ---------------------------\n\n    /**\n     * Convert the give set of attributes to be html for\n     * the purpose of writing them out.  Any keys that\n     * have been converted will not appear in the resultant\n     * set.  Any keys not converted will appear in the\n     * resultant set the same as the received set.<p>\n     * This will put the converted values into <code>to<\/code>, unless\n     * it is null in which case a temporary AttributeSet will be returned.\n     */\n    AttributeSet convertToHTML(AttributeSet from, MutableAttributeSet to) {\n        if (to == null) {\n            to = convAttr;\n        }\n        to.removeAttributes(to);\n        if (writeCSS) {\n            convertToHTML40(from, to);\n        } else {\n            convertToHTML32(from, to);\n        }\n        return to;\n    }"}
{"Number":"1561","API Relative Path":"javax.swing.text.html.HTMLWriter.java-writeAttributes(AttributeSet)","Corresponding Source":"/**\n     * Writes out the attribute set.  Ignores all\n     * attributes with a key of type HTML.Tag,\n     * attributes with a key of type StyleConstants,\n     * and attributes with a key of type\n     * HTML.Attribute.ENDTAG.\n     *\n     * @param attr   an AttributeSet\n     * @exception IOException on any I/O error\n     *\n     */\n    protected void writeAttributes(AttributeSet attr) throws IOException {\n        // translate css attributes to html\n        convAttr.removeAttributes(convAttr);\n        convertToHTML32(attr, convAttr);\n\n        Enumeration names = convAttr.getAttributeNames();\n        while (names.hasMoreElements()) {\n            Object name = names.nextElement();\n            if (name instanceof HTML.Tag ||\n                name instanceof StyleConstants ||\n                name == HTML.Attribute.ENDTAG) {\n                continue;\n            }\n            write(\" \" + name + \"=\\\"\" + convAttr.getAttribute(name) + \"\\\"\");\n        }\n    }"}
{"Number":"1562","API Relative Path":"javax.swing.text.html.HTMLWriter.java-writeComment(String)","Corresponding Source":"/**\n     * Writes out comment string.\n     *\n     * @param string   the comment\n     * @exception IOException on any I/O error\n     * @exception BadLocationException if pos represents an invalid\n     *            location within the document.\n     */\n    void writeComment(String string) throws IOException {\n        write(\"<!--\");\n        if (string != null) {\n            write(string);\n        }\n        write(\"-->\");\n        writeLineSeparator();\n        indentSmart();\n    }"}
{"Number":"1563","API Relative Path":"javax.swing.text.html.HTMLWriter.java-writeEmbeddedTags(AttributeSet)","Corresponding Source":"/**\n     * Searches for embedded tags in the AttributeSet\n     * and writes them out.  It also stores these tags in a vector\n     * so that when appropriate the corresponding end tags can be\n     * written out.\n     *\n     * @exception IOException on any I/O error\n     */\n    protected void writeEmbeddedTags(AttributeSet attr) throws IOException {\n\n        // translate css attributes to html\n        attr = convertToHTML(attr, oConvAttr);\n\n        Enumeration names = attr.getAttributeNames();\n        while (names.hasMoreElements()) {\n            Object name = names.nextElement();\n            if (name instanceof HTML.Tag) {\n                HTML.Tag tag = (HTML.Tag)name;\n                if (tag == HTML.Tag.FORM || tags.contains(tag)) {\n                    continue;\n                }\n                write('<');\n                write(tag.toString());\n                Object o = attr.getAttribute(tag);\n                if (o != null && o instanceof AttributeSet) {\n                    writeAttributes((AttributeSet)o);\n                }\n                write('>');\n                tags.addElement(tag);\n                tagValues.addElement(o);\n            }\n        }\n    }"}
{"Number":"1564","API Relative Path":"javax.swing.text.html.HTMLWriter.java-writeMaps(Enumeration)","Corresponding Source":"/**\n     * Outputs the maps as elements. Maps are not stored as elements in\n     * the document, and as such this is used to output them.\n     */\n    void writeMaps(Enumeration maps) throws IOException {\n        if (maps != null) {\n            while(maps.hasMoreElements()) {\n                Map map = (Map)maps.nextElement();\n                String name = map.getName();\n\n                incrIndent();\n                indentSmart();\n                write(\"<map\");\n                if (name != null) {\n                    write(\" name=\\\"\");\n                    write(name);\n                    write(\"\\\">\");\n                }\n                else {\n                    write('>');\n                }\n                writeLineSeparator();\n                incrIndent();\n\n                // Output the areas\n                AttributeSet[] areas = map.getAreas();\n                if (areas != null) {\n                    for (int counter = 0, maxCounter = areas.length;\n                         counter < maxCounter; counter++) {\n                        indentSmart();\n                        write(\"<area\");\n                        writeAttributes(areas[counter]);\n                        write(\"><\/area>\");\n                        writeLineSeparator();\n                    }\n                }\n                decrIndent();\n                indentSmart();\n                write(\"<\/map>\");\n                writeLineSeparator();\n                decrIndent();\n            }\n        }\n    }"}
{"Number":"1565","API Relative Path":"javax.swing.text.html.HTMLWriter.java-writeStyle(String-Style-boolean)","Corresponding Source":"/**\n     * Outputs the named style. <code>outputStyle<\/code> indicates\n     * whether or not a style has been output yet. This will return\n     * true if a style is written.\n     */\n    boolean writeStyle(String name, Style style, boolean outputStyle)\n                 throws IOException{\n        boolean didOutputStyle = false;\n        Enumeration attributes = style.getAttributeNames();\n        if (attributes != null) {\n            while (attributes.hasMoreElements()) {\n                Object attribute = attributes.nextElement();\n                if (attribute instanceof CSS.Attribute) {\n                    String value = style.getAttribute(attribute).toString();\n                    if (value != null) {\n                        if (!outputStyle) {\n                            writeStyleStartTag();\n                            outputStyle = true;\n                        }\n                        if (!didOutputStyle) {\n                            didOutputStyle = true;\n                            indentSmart();\n                            write(name);\n                            write(\" {\");\n                        }\n                        else {\n                            write(\";\");\n                        }\n                        write(' ');\n                        write(attribute.toString());\n                        write(\": \");\n                        write(value);\n                    }\n                }\n            }\n        }\n        if (didOutputStyle) {\n            write(\" }\");\n            writeLineSeparator();\n        }\n        return didOutputStyle;\n    }"}
{"Number":"1566","API Relative Path":"javax.swing.text.html.HTMLWriter.java-writeStyles(StyleSheet)","Corresponding Source":"/**\n     * Outputs the styles as a single element. Styles are not stored as\n     * elements, but part of the document. For the time being styles are\n     * written out as a comment, inside a style tag.\n     */\n    void writeStyles(StyleSheet sheet) throws IOException {\n        if (sheet != null) {\n            Enumeration styles = sheet.getStyleNames();\n            if (styles != null) {\n                boolean outputStyle = false;\n                while (styles.hasMoreElements()) {\n                    String name = (String)styles.nextElement();\n                    // Don't write out the default style.\n                    if (!StyleContext.DEFAULT_STYLE.equals(name) &&\n                        writeStyle(name, sheet.getStyle(name), outputStyle)) {\n                        outputStyle = true;\n                    }\n                }\n                if (outputStyle) {\n                    writeStyleEndTag();\n                }\n            }\n        }\n    }"}
{"Number":"1567","API Relative Path":"javax.swing.text.html.Map.java-addArea(AttributeSet)","Corresponding Source":"/**\n     * Defines a region of the Map, based on the passed in AttributeSet.\n     */\n    public void addArea(AttributeSet as) {\n        if (as == null) {\n            return;\n        }\n        if (areaAttributes == null) {\n            areaAttributes = new Vector<AttributeSet>(2);\n        }\n        areaAttributes.addElement(as.copyAttributes());\n    }"}
{"Number":"1568","API Relative Path":"javax.swing.text.html.Map.java-extractCoords(Object)","Corresponding Source":"/**\n     * Creates and returns an array of integers from the String\n     * <code>stringCoords<\/code>. If one of the values represents a\n     * % the returned value with be negative. If a parse error results\n     * from trying to parse one of the numbers null is returned.\n     */\n    static protected int[] extractCoords(Object stringCoords) {\n        if (stringCoords == null || !(stringCoords instanceof String)) {\n            return null;\n        }\n\n        StringTokenizer    st = new StringTokenizer((String)stringCoords,\n                                                    \", \\t\\n\\r\");\n        int[]              retValue = null;\n        int                numCoords = 0;\n\n        while(st.hasMoreElements()) {\n            String         token = st.nextToken();\n            int            scale;\n\n            if (token.endsWith(\"%\")) {\n                scale = -1;\n                token = token.substring(0, token.length() - 1);\n            }\n            else {\n                scale = 1;\n            }\n            try {\n                int       intValue = Integer.parseInt(token);\n\n                if (retValue == null) {\n                    retValue = new int[4];\n                }\n                else if(numCoords == retValue.length) {\n                    int[]    temp = new int[retValue.length * 2];\n\n                    System.arraycopy(retValue, 0, temp, 0, retValue.length);\n                    retValue = temp;\n                }\n                retValue[numCoords++] = intValue * scale;\n            } catch (NumberFormatException nfe) {\n                return null;\n            }\n        }\n        if (numCoords > 0 && numCoords != retValue.length) {\n            int[]    temp = new int[numCoords];\n\n            System.arraycopy(retValue, 0, temp, 0, numCoords);\n            retValue = temp;\n        }\n        return retValue;\n    }"}
{"Number":"1569","API Relative Path":"javax.swing.text.html.Map.java-removeArea(AttributeSet)","Corresponding Source":"/**\n     * Removes the previously created area.\n     */\n    public void removeArea(AttributeSet as) {\n        if (as != null && areaAttributes != null) {\n            int numAreas = (areas != null) ? areas.size() : 0;\n            for (int counter = areaAttributes.size() - 1; counter >= 0;\n                 counter--) {\n                if (areaAttributes.elementAt(counter).isEqual(as)){\n                    areaAttributes.removeElementAt(counter);\n                    if (counter < numAreas) {\n                        areas.removeElementAt(counter);\n                    }\n                }\n            }\n        }\n    }"}
{"Number":"1570","API Relative Path":"javax.swing.text.html.MinimalHTMLWriter.java-writeEndTag(String)","Corresponding Source":"/**\n     * Writes out an end tag appropriately\n     * indented.  Also decrements the indent level.\n     *\n     * @exception IOException on any I/O error\n     */\n    protected void writeEndTag(String endTag) throws IOException {\n        decrIndent();\n        indent();\n        write(endTag);\n        write(NEWLINE);\n    }"}
{"Number":"1571","API Relative Path":"javax.swing.text.html.MinimalHTMLWriter.java-writeStartTag(String)","Corresponding Source":"/**\n     * Writes out a start tag appropriately\n     * indented.  Also increments the indent level.\n     *\n     * @exception IOException on any I/O error\n     */\n    protected void writeStartTag(String tag) throws IOException {\n        indent();\n        write(tag);\n        write(NEWLINE);\n        incrIndent();\n    }"}
{"Number":"1572","API Relative Path":"javax.swing.text.html.ParagraphView.java-paint(Graphics-Shape)","Corresponding Source":"/**\n     * Renders using the given rendering surface and area on that\n     * surface.  This is implemented to delegate to the superclass\n     * after stashing the base coordinate for tab calculations.\n     *\n     * @param g the rendering surface to use\n     * @param a the allocated region to render into\n     * @see View#paint\n     */\n    public void paint(Graphics g, Shape a) {\n        if (a == null) {\n            return;\n        }\n\n        Rectangle r;\n        if (a instanceof Rectangle) {\n            r = (Rectangle) a;\n        } else {\n            r = a.getBounds();\n        }\n        painter.paint(g, r.x, r.y, r.width, r.height, this);\n        super.paint(g, a);\n    }"}
{"Number":"1573","API Relative Path":"javax.swing.text.html.ParagraphView.java-setParent(View)","Corresponding Source":"/**\n     * Establishes the parent view for this view.  This is\n     * guaranteed to be called before any other methods if the\n     * parent view is functioning properly.\n     * <p>\n     * This is implemented\n     * to forward to the superclass as well as call the\n     * {@link #setPropertiesFromAttributes setPropertiesFromAttributes}\n     * method to set the paragraph properties from the css\n     * attributes.  The call is made at this time to ensure\n     * the ability to resolve upward through the parents\n     * view attributes.\n     *\n     * @param parent the new parent, or null if the view is\n     *  being removed from a parent it was previously added\n     *  to\n     */\n    public void setParent(View parent) {\n        super.setParent(parent);\n        if (parent != null) {\n            setPropertiesFromAttributes();\n        }\n    }"}
{"Number":"1574","API Relative Path":"javax.swing.text.html.parser.DocumentParser.java-handleText(char)","Corresponding Source":"/**\n     * Handle Text.\n     */\n    protected void handleText(char data[]) {\n        if (data != null) {\n            if (inscript != 0) {\n                callback.handleComment(data, getBlockStartPosition());\n                return;\n            }\n            if (inbody != 0 || ((instyle != 0) ||\n                                ((intitle != 0) && !seentitle))) {\n                if (debugFlag) {\n                    debug(\"text:  ->\" + new String(data) + \"<-\" + \" pos: \" + getCurrentPos());\n                }\n                callback.handleText(data, getBlockStartPosition());\n            }\n        }\n    }"}
{"Number":"1575","API Relative Path":"javax.swing.text.html.StyleSheet.java-addRule(String)","Corresponding Source":"/**\n     * Adds a set of rules to the sheet.  The rules are expected to\n     * be in valid CSS format.  Typically this would be called as\n     * a result of parsing a &lt;style&gt; tag.\n     */\n    public void addRule(String rule) {\n        if (rule != null) {\n            //tweaks to control display properties\n            //see BasicEditorPaneUI\n            final String baseUnitsDisable = \"BASE_SIZE_DISABLE\";\n            final String baseUnits = \"BASE_SIZE \";\n            final String w3cLengthUnitsEnable = \"W3C_LENGTH_UNITS_ENABLE\";\n            final String w3cLengthUnitsDisable = \"W3C_LENGTH_UNITS_DISABLE\";\n            if (rule == baseUnitsDisable) {\n                sizeMap = sizeMapDefault;\n            } else if (rule.startsWith(baseUnits)) {\n                rebaseSizeMap(Integer.\n                              parseInt(rule.substring(baseUnits.length())));\n            } else if (rule == w3cLengthUnitsEnable) {\n                w3cLengthUnits = true;\n            } else if (rule == w3cLengthUnitsDisable) {\n                w3cLengthUnits = false;\n            } else {\n                CssParser parser = new CssParser();\n                try {\n                    parser.parse(getBase(), new StringReader(rule), false, false);\n                } catch (IOException ioe) { }\n            }\n        }\n    }"}
{"Number":"1576","API Relative Path":"javax.swing.text.html.TableView.java-paint(Graphics-Shape)","Corresponding Source":"/**\n     * Renders using the given rendering surface and area on that\n     * surface.  This is implemented to delegate to the css box\n     * painter to paint the border and background prior to the\n     * interior.  The superclass culls rendering the children\n     * that don't directly intersect the clip and the row may\n     * have cells hanging from a row above in it.  The table\n     * does not use the superclass rendering behavior and instead\n     * paints all of the rows and lets the rows cull those\n     * cells not intersecting the clip region.\n     *\n     * @param g the rendering surface to use\n     * @param allocation the allocated region to render into\n     * @see View#paint\n     */\n    public void paint(Graphics g, Shape allocation) {\n        // paint the border\n        Rectangle a = allocation.getBounds();\n        setSize(a.width, a.height);\n        if (captionIndex != -1) {\n            // adjust the border for the caption\n            short top = (short) painter.getInset(TOP, this);\n            short bottom = (short) painter.getInset(BOTTOM, this);\n            if (top != getTopInset()) {\n                int h = getTopInset() - top;\n                a.y += h;\n                a.height -= h;\n            } else {\n                a.height -= getBottomInset() - bottom;\n            }\n        }\n        painter.paint(g, a.x, a.y, a.width, a.height, this);\n        // paint interior\n        int n = getViewCount();\n        for (int i = 0; i < n; i++) {\n            View v = getView(i);\n            v.paint(g, getChildAllocation(i, allocation));\n        }\n        //super.paint(g, a);\n    }"}
{"Number":"1577","API Relative Path":"javax.swing.text.html.TableView.java-setParent(View)","Corresponding Source":"/**\n     * Establishes the parent view for this view.  This is\n     * guaranteed to be called before any other methods if the\n     * parent view is functioning properly.\n     * <p>\n     * This is implemented\n     * to forward to the superclass as well as call the\n     * <a href=\"#setPropertiesFromAttributes\">setPropertiesFromAttributes<\/a>\n     * method to set the paragraph properties from the css\n     * attributes.  The call is made at this time to ensure\n     * the ability to resolve upward through the parents\n     * view attributes.\n     *\n     * @param parent the new parent, or null if the view is\n     *  being removed from a parent it was previously added\n     *  to\n     */\n    public void setParent(View parent) {\n        super.setParent(parent);\n        if (parent != null) {\n            setPropertiesFromAttributes();\n        }\n    }"}
{"Number":"1578","API Relative Path":"javax.swing.text.JTextComponent.java-addCaretListener(CaretListener)","Corresponding Source":"/**\n     * Adds a caret listener for notification of any changes\n     * to the caret.\n     *\n     * @param listener the listener to be added\n     * @see javax.swing.event.CaretEvent\n     */\n    public void addCaretListener(CaretListener listener) {\n        listenerList.add(CaretListener.class, listener);\n    }"}
{"Number":"1579","API Relative Path":"javax.swing.text.JTextComponent.java-moveCaretPosition(int)","Corresponding Source":"/**\n     * Moves the caret to a new position, leaving behind a mark\n     * defined by the last time <code>setCaretPosition<\/code> was\n     * called.  This forms a selection.\n     * If the document is <code>null<\/code>, does nothing. The position\n     * must be between 0 and the length of the component's text or else\n     * an exception is thrown.\n     *\n     * @param pos the position\n     * @exception    IllegalArgumentException if the value supplied\n     *               for <code>position<\/code> is less than zero or greater\n     *               than the component's text length\n     * @see #setCaretPosition\n     */\n    public void moveCaretPosition(int pos) {\n        Document doc = getDocument();\n        if (doc != null) {\n            if (pos > doc.getLength() || pos < 0) {\n                throw new IllegalArgumentException(\"bad position: \" + pos);\n            }\n            caret.moveDot(pos);\n        }\n    }"}
{"Number":"1580","API Relative Path":"javax.swing.text.JTextComponent.java-removeCaretListener(CaretListener)","Corresponding Source":"/**\n     * Removes a caret listener.\n     *\n     * @param listener the listener to be removed\n     * @see javax.swing.event.CaretEvent\n     */\n    public void removeCaretListener(CaretListener listener) {\n        listenerList.remove(CaretListener.class, listener);\n    }"}
{"Number":"1581","API Relative Path":"javax.swing.text.JTextComponent.java-select(int-int)","Corresponding Source":"/**\n     * Selects the text between the specified start and end positions.\n     * <p>\n     * This method sets the start and end positions of the\n     * selected text, enforcing the restriction that the start position\n     * must be greater than or equal to zero.  The end position must be\n     * greater than or equal to the start position, and less than or\n     * equal to the length of the text component's text.\n     * <p>\n     * If the caller supplies values that are inconsistent or out of\n     * bounds, the method enforces these constraints silently, and\n     * without failure. Specifically, if the start position or end\n     * position is greater than the length of the text, it is reset to\n     * equal the text length. If the start position is less than zero,\n     * it is reset to zero, and if the end position is less than the\n     * start position, it is reset to the start position.\n     * <p>\n     * This call is provided for backward compatibility.\n     * It is routed to a call to <code>setCaretPosition<\/code>\n     * followed by a call to <code>moveCaretPosition<\/code>.\n     * The preferred way to manage selection is by calling\n     * those methods directly.\n     *\n     * @param selectionStart the start position of the text\n     * @param selectionEnd the end position of the text\n     * @see #setCaretPosition\n     * @see #moveCaretPosition\n     */\n    public void select(int selectionStart, int selectionEnd) {\n        // argument adjustment done by java.awt.TextComponent\n        int docLength = getDocument().getLength();\n\n        if (selectionStart < 0) {\n            selectionStart = 0;\n        }\n        if (selectionStart > docLength) {\n            selectionStart = docLength;\n        }\n        if (selectionEnd > docLength) {\n            selectionEnd = docLength;\n        }\n        if (selectionEnd < selectionStart) {\n            selectionEnd = selectionStart;\n        }\n\n        setCaretPosition(selectionStart);\n        moveCaretPosition(selectionEnd);\n    }"}
{"Number":"1582","API Relative Path":"javax.swing.text.JTextComponent.java-select(int-int)","Corresponding Source":"/**\n     * Selects the text between the specified start and end positions.\n     * <p>\n     * This method sets the start and end positions of the\n     * selected text, enforcing the restriction that the start position\n     * must be greater than or equal to zero.  The end position must be\n     * greater than or equal to the start position, and less than or\n     * equal to the length of the text component's text.\n     * <p>\n     * If the caller supplies values that are inconsistent or out of\n     * bounds, the method enforces these constraints silently, and\n     * without failure. Specifically, if the start position or end\n     * position is greater than the length of the text, it is reset to\n     * equal the text length. If the start position is less than zero,\n     * it is reset to zero, and if the end position is less than the\n     * start position, it is reset to the start position.\n     * <p>\n     * This call is provided for backward compatibility.\n     * It is routed to a call to <code>setCaretPosition<\/code>\n     * followed by a call to <code>moveCaretPosition<\/code>.\n     * The preferred way to manage selection is by calling\n     * those methods directly.\n     *\n     * @param selectionStart the start position of the text\n     * @param selectionEnd the end position of the text\n     * @see #setCaretPosition\n     * @see #moveCaretPosition\n     */\n    public void select(int selectionStart, int selectionEnd) {\n        // argument adjustment done by java.awt.TextComponent\n        int docLength = getDocument().getLength();\n\n        if (selectionStart < 0) {\n            selectionStart = 0;\n        }\n        if (selectionStart > docLength) {\n            selectionStart = docLength;\n        }\n        if (selectionEnd > docLength) {\n            selectionEnd = docLength;\n        }\n        if (selectionEnd < selectionStart) {\n            selectionEnd = selectionStart;\n        }\n\n        setCaretPosition(selectionStart);\n        moveCaretPosition(selectionEnd);\n    }"}
{"Number":"1583","API Relative Path":"javax.swing.text.JTextComponent.java-setCaretPosition(int)","Corresponding Source":"// --- java.awt.TextComponent methods ------------------------\n\n    /**\n     * Sets the position of the text insertion caret for the\n     * <code>TextComponent<\/code>.  Note that the caret tracks change,\n     * so this may move if the underlying text of the component is changed.\n     * If the document is <code>null<\/code>, does nothing. The position\n     * must be between 0 and the length of the component's text or else\n     * an exception is thrown.\n     *\n     * @param position the position\n     * @exception    IllegalArgumentException if the value supplied\n     *               for <code>position<\/code> is less than zero or greater\n     *               than the component's text length\n     * @beaninfo\n     * description: the caret position\n     */\n    public void setCaretPosition(int position) {\n        Document doc = getDocument();\n        if (doc != null) {\n            if (position > doc.getLength() || position < 0) {\n                throw new IllegalArgumentException(\"bad position: \" + position);\n            }\n            caret.setDot(position);\n        }\n    }"}
{"Number":"1584","API Relative Path":"javax.swing.text.JTextComponent.java-setSelectionEnd(int)","Corresponding Source":"/**\n     * Sets the selection end to the specified position.  The new\n     * end point is constrained to be at or after the current\n     * selection start.\n     * <p>\n     * This is available for backward compatibility to code\n     * that called this method on <code>java.awt.TextComponent<\/code>.\n     * This is implemented to forward to the <code>Caret<\/code>\n     * implementation which is where the actual selection is maintained.\n     *\n     * @param selectionEnd the end position of the text &ge; 0\n     * @beaninfo\n     * description: ending location of the selection.\n     */\n    public void setSelectionEnd(int selectionEnd) {\n        /* Route through select method to enforce consistent policy\n         * between selectionStart and selectionEnd.\n         */\n        select(getSelectionStart(), selectionEnd);\n    }"}
{"Number":"1585","API Relative Path":"javax.swing.text.JTextComponent.java-setSelectionStart(int)","Corresponding Source":"/**\n     * Sets the selection start to the specified position.  The new\n     * starting point is constrained to be before or at the current\n     * selection end.\n     * <p>\n     * This is available for backward compatibility to code\n     * that called this method on <code>java.awt.TextComponent<\/code>.\n     * This is implemented to forward to the <code>Caret<\/code>\n     * implementation which is where the actual selection is maintained.\n     *\n     * @param selectionStart the start position of the text &ge; 0\n     * @beaninfo\n     * description: starting location of the selection.\n     */\n    public void setSelectionStart(int selectionStart) {\n        /* Route through select method to enforce consistent policy\n         * between selectionStart and selectionEnd.\n         */\n        select(selectionStart, getSelectionEnd());\n    }"}
{"Number":"1586","API Relative Path":"javax.swing.text.MaskFormatter.java-install(JFormattedTextField)","Corresponding Source":"/**\n     * Installs the <code>DefaultFormatter<\/code> onto a particular\n     * <code>JFormattedTextField<\/code>.\n     * This will invoke <code>valueToString<\/code> to convert the\n     * current value from the <code>JFormattedTextField<\/code> to\n     * a String. This will then install the <code>Action<\/code>s from\n     * <code>getActions<\/code>, the <code>DocumentFilter<\/code>\n     * returned from <code>getDocumentFilter<\/code> and the\n     * <code>NavigationFilter<\/code> returned from\n     * <code>getNavigationFilter<\/code> onto the\n     * <code>JFormattedTextField<\/code>.\n     * <p>\n     * Subclasses will typically only need to override this if they\n     * wish to install additional listeners on the\n     * <code>JFormattedTextField<\/code>.\n     * <p>\n     * If there is a <code>ParseException<\/code> in converting the\n     * current value to a String, this will set the text to an empty\n     * String, and mark the <code>JFormattedTextField<\/code> as being\n     * in an invalid state.\n     * <p>\n     * While this is a public method, this is typically only useful\n     * for subclassers of <code>JFormattedTextField<\/code>.\n     * <code>JFormattedTextField<\/code> will invoke this method at\n     * the appropriate times when the value changes, or its internal\n     * state changes.\n     *\n     * @param ftf JFormattedTextField to format for, may be null indicating\n     *            uninstall from current JFormattedTextField.\n     */\n    public void install(JFormattedTextField ftf) {\n        super.install(ftf);\n        // valueToString doesn't throw, but stringToValue does, need to\n        // update the editValid state appropriately\n        if (ftf != null) {\n            Object value = ftf.getValue();\n\n            try {\n                stringToValue(valueToString(value));\n            } catch (ParseException pe) {\n                setEditValid(false);\n            }\n        }\n    }"}
{"Number":"1587","API Relative Path":"javax.swing.text.ParagraphView.java-paint(Graphics-Shape)","Corresponding Source":"// ---- View methods ----------------------------------------------------\n\n    /**\n     * Renders using the given rendering surface and area on that\n     * surface.  This is implemented to delegate to the superclass\n     * after stashing the base coordinate for tab calculations.\n     *\n     * @param g the rendering surface to use\n     * @param a the allocated region to render into\n     * @see View#paint\n     */\n    public void paint(Graphics g, Shape a) {\n        Rectangle alloc = (a instanceof Rectangle) ? (Rectangle)a : a.getBounds();\n        tabBase = alloc.x + getLeftInset();\n        super.paint(g, a);\n\n        // line with the negative firstLineIndent value needs\n        // special handling\n        if (firstLineIndent < 0) {\n            Shape sh = getChildAllocation(0, a);\n            if ((sh != null) &&  sh.intersects(alloc)) {\n                int x = alloc.x + getLeftInset() + firstLineIndent;\n                int y = alloc.y + getTopInset();\n\n                Rectangle clip = g.getClipBounds();\n                tempRect.x = x + getOffset(X_AXIS, 0);\n                tempRect.y = y + getOffset(Y_AXIS, 0);\n                tempRect.width = getSpan(X_AXIS, 0) - firstLineIndent;\n                tempRect.height = getSpan(Y_AXIS, 0);\n                if (tempRect.intersects(clip)) {\n                    tempRect.x = tempRect.x - firstLineIndent;\n                    paintChild(g, tempRect, 0);\n                }\n            }\n        }\n    }"}
{"Number":"1588","API Relative Path":"javax.swing.text.PlainView.java-changedUpdate(DocumentEvent-Shape-ViewFactory)","Corresponding Source":"/**\n     * Gives notification from the document that attributes were changed\n     * in a location that this view is responsible for.\n     *\n     * @param changes the change information from the associated document\n     * @param a the current allocation of the view\n     * @param f the factory to use to rebuild if the view has children\n     * @see View#changedUpdate\n     */\n    public void changedUpdate(DocumentEvent changes, Shape a, ViewFactory f) {\n        updateDamage(changes, a, f);\n    }"}
{"Number":"1589","API Relative Path":"javax.swing.text.PlainView.java-damageLineRange(int-int-Shape-Component)","Corresponding Source":"/**\n     * Repaint the given line range.\n     *\n     * @param host the component hosting the view (used to call repaint)\n     * @param a  the region allocated for the view to render into\n     * @param line0 the starting line number to repaint.  This must\n     *   be a valid line number in the model.\n     * @param line1 the ending line number to repaint.  This must\n     *   be a valid line number in the model.\n     * @since 1.4\n     */\n    protected void damageLineRange(int line0, int line1, Shape a, Component host) {\n        if (a != null) {\n            Rectangle area0 = lineToRect(a, line0);\n            Rectangle area1 = lineToRect(a, line1);\n            if ((area0 != null) && (area1 != null)) {\n                Rectangle damage = area0.union(area1);\n                host.repaint(damage.x, damage.y, damage.width, damage.height);\n            } else {\n                host.repaint();\n            }\n        }\n    }"}
{"Number":"1590","API Relative Path":"javax.swing.text.PlainView.java-insertUpdate(DocumentEvent-Shape-ViewFactory)","Corresponding Source":"/**\n     * Gives notification that something was inserted into the document\n     * in a location that this view is responsible for.\n     *\n     * @param changes the change information from the associated document\n     * @param a the current allocation of the view\n     * @param f the factory to use to rebuild if the view has children\n     * @see View#insertUpdate\n     */\n    public void insertUpdate(DocumentEvent changes, Shape a, ViewFactory f) {\n        updateDamage(changes, a, f);\n    }"}
{"Number":"1591","API Relative Path":"javax.swing.text.PlainView.java-removeUpdate(DocumentEvent-Shape-ViewFactory)","Corresponding Source":"/**\n     * Gives notification that something was removed from the document\n     * in a location that this view is responsible for.\n     *\n     * @param changes the change information from the associated document\n     * @param a the current allocation of the view\n     * @param f the factory to use to rebuild if the view has children\n     * @see View#removeUpdate\n     */\n    public void removeUpdate(DocumentEvent changes, Shape a, ViewFactory f) {\n        updateDamage(changes, a, f);\n    }"}
{"Number":"1592","API Relative Path":"javax.swing.text.PlainView.java-updateDamage(DocumentEvent-Shape-ViewFactory)","Corresponding Source":"// --- local methods ------------------------------------------------\n\n    /**\n     * Repaint the region of change covered by the given document\n     * event.  Damages the line that begins the range to cover\n     * the case when the insert/remove is only on one line.\n     * If lines are added or removed, damages the whole\n     * view.  The longest line is checked to see if it has\n     * changed.\n     *\n     * @since 1.4\n     */\n    protected void updateDamage(DocumentEvent changes, Shape a, ViewFactory f) {\n        Component host = getContainer();\n        updateMetrics();\n        Element elem = getElement();\n        DocumentEvent.ElementChange ec = changes.getChange(elem);\n\n        Element[] added = (ec != null) ? ec.getChildrenAdded() : null;\n        Element[] removed = (ec != null) ? ec.getChildrenRemoved() : null;\n        if (((added != null) && (added.length > 0)) ||\n            ((removed != null) && (removed.length > 0))) {\n            // lines were added or removed...\n            if (added != null) {\n                int currWide = getLineWidth(longLine);\n                for (int i = 0; i < added.length; i++) {\n                    int w = getLineWidth(added[i]);\n                    if (w > currWide) {\n                        currWide = w;\n                        longLine = added[i];\n                    }\n                }\n            }\n            if (removed != null) {\n                for (int i = 0; i < removed.length; i++) {\n                    if (removed[i] == longLine) {\n                        calculateLongestLine();\n                        break;\n                    }\n                }\n            }\n            preferenceChanged(null, true, true);\n            host.repaint();\n        } else {\n            Element map = getElement();\n            int line = map.getElementIndex(changes.getOffset());\n            damageLineRange(line, line, a, host);\n            if (changes.getType() == DocumentEvent.EventType.INSERT) {\n                // check to see if the line is longer than current\n                // longest line.\n                int w = getLineWidth(longLine);\n                Element e = map.getElement(line);\n                if (e == longLine) {\n                    preferenceChanged(null, true, false);\n                } else if (getLineWidth(e) > w) {\n                    longLine = e;\n                    preferenceChanged(null, true, false);\n                }\n            } else if (changes.getType() == DocumentEvent.EventType.REMOVE) {\n                if (map.getElement(line) == longLine) {\n                    // removed from longest line... recalc\n                    calculateLongestLine();\n                    preferenceChanged(null, true, false);\n                }\n            }\n        }\n    }"}
{"Number":"1593","API Relative Path":"javax.swing.text.rtf.RTFReader.java-defineCharacterSet(String-char[])","Corresponding Source":"/** Adds a character set to the RTFReader's list\n *  of known character sets */\npublic static void\ndefineCharacterSet(String name, char[] table)\n{\n    if (table.length < 256)\n        throw new IllegalArgumentException(\"Translation table must have 256 entries.\");\n    characterSets.put(name, table);\n}"}
{"Number":"1594","API Relative Path":"javax.swing.text.Segment.java-charAt(int)","Corresponding Source":"// --- CharSequence methods -------------------------------------\n\n    /**\n     * {@inheritDoc}\n     * @since 1.6\n     */\n    public char charAt(int index) {\n        if (index < 0\n            || index >= count) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        return array[offset + index];\n    }"}
{"Number":"1595","API Relative Path":"javax.swing.text.Segment.java-setIndex(int)","Corresponding Source":"/**\n     * Sets the position to the specified position in the text and returns that\n     * character.\n     * @param position the position within the text.  Valid values range from\n     * getBeginIndex() to getEndIndex().  An IllegalArgumentException is thrown\n     * if an invalid value is supplied.\n     * @return the character at the specified position or DONE if the specified position is equal to getEndIndex()\n     * @since 1.3\n     */\n    public char setIndex(int position) {\n        int end = offset + count;\n        if ((position < offset) || (position > end)) {\n            throw new IllegalArgumentException(\"bad position: \" + position);\n        }\n        pos = position;\n        if ((pos != end) && (count != 0)) {\n            return array[pos];\n        }\n        return DONE;\n    }"}
{"Number":"1596","API Relative Path":"javax.swing.text.Segment.java-subSequence(int-int)","Corresponding Source":"/**\n     * {@inheritDoc}\n     * @since 1.6\n     */\n    public CharSequence subSequence(int start, int end) {\n        if (start < 0) {\n            throw new StringIndexOutOfBoundsException(start);\n        }\n        if (end > count) {\n            throw new StringIndexOutOfBoundsException(end);\n        }\n        if (start > end) {\n            throw new StringIndexOutOfBoundsException(end - start);\n        }\n        Segment segment = new Segment();\n        segment.array = this.array;\n        segment.offset = this.offset + start;\n        segment.count = end - start;\n        return segment;\n    }"}
{"Number":"1597","API Relative Path":"javax.swing.text.Segment.java-subSequence(int-int)","Corresponding Source":"/**\n     * {@inheritDoc}\n     * @since 1.6\n     */\n    public CharSequence subSequence(int start, int end) {\n        if (start < 0) {\n            throw new StringIndexOutOfBoundsException(start);\n        }\n        if (end > count) {\n            throw new StringIndexOutOfBoundsException(end);\n        }\n        if (start > end) {\n            throw new StringIndexOutOfBoundsException(end - start);\n        }\n        Segment segment = new Segment();\n        segment.array = this.array;\n        segment.offset = this.offset + start;\n        segment.count = end - start;\n        return segment;\n    }"}
{"Number":"1598","API Relative Path":"javax.swing.text.Segment.java-subSequence(int-int)","Corresponding Source":"/**\n     * {@inheritDoc}\n     * @since 1.6\n     */\n    public CharSequence subSequence(int start, int end) {\n        if (start < 0) {\n            throw new StringIndexOutOfBoundsException(start);\n        }\n        if (end > count) {\n            throw new StringIndexOutOfBoundsException(end);\n        }\n        if (start > end) {\n            throw new StringIndexOutOfBoundsException(end - start);\n        }\n        Segment segment = new Segment();\n        segment.array = this.array;\n        segment.offset = this.offset + start;\n        segment.count = end - start;\n        return segment;\n    }"}
{"Number":"1599","API Relative Path":"javax.swing.text.StringContent.java-getChars(int-int-Segment)","Corresponding Source":"/**\n     * Retrieves a portion of the content.  where + len must be &lt;= length()\n     *\n     * @param where the starting position &gt;= 0\n     * @param len the number of characters to retrieve &gt;= 0\n     * @param chars the Segment object to return the characters in\n     * @exception BadLocationException if the specified position is invalid\n     * @see AbstractDocument.Content#getChars\n     */\n    public void getChars(int where, int len, Segment chars) throws BadLocationException {\n        if (where + len > count) {\n            throw new BadLocationException(\"Invalid location\", count);\n        }\n        chars.array = data;\n        chars.offset = where;\n        chars.count = len;\n    }"}
{"Number":"1600","API Relative Path":"javax.swing.text.StringContent.java-getString(int-int)","Corresponding Source":"/**\n     * Retrieves a portion of the content.  where + len must be &lt;= length().\n     *\n     * @param where the starting position &gt;= 0\n     * @param len the length to retrieve &gt;= 0\n     * @return a string representing the content; may be empty\n     * @exception BadLocationException if the specified position is invalid\n     * @see AbstractDocument.Content#getString\n     */\n    public String getString(int where, int len) throws BadLocationException {\n        if (where + len > count) {\n            throw new BadLocationException(\"Invalid range\", count);\n        }\n        return new String(data, where, len);\n    }"}
{"Number":"1601","API Relative Path":"javax.swing.text.StringContent.java-insertString(int-String)","Corresponding Source":"/**\n     * Inserts a string into the content.\n     *\n     * @param where the starting position &gt;= 0 &amp;&amp; &lt; length()\n     * @param str the non-null string to insert\n     * @return an UndoableEdit object for undoing\n     * @exception BadLocationException if the specified position is invalid\n     * @see AbstractDocument.Content#insertString\n     */\n    public UndoableEdit insertString(int where, String str) throws BadLocationException {\n        if (where >= count || where < 0) {\n            throw new BadLocationException(\"Invalid location\", count);\n        }\n        char[] chars = str.toCharArray();\n        replace(where, 0, chars, 0, chars.length);\n        if (marks != null) {\n            updateMarksForInsert(where, str.length());\n        }\n        return new InsertUndo(where, str.length());\n    }"}
{"Number":"1602","API Relative Path":"javax.swing.text.StringContent.java-remove(int-int)","Corresponding Source":"synchronized void updateMarksForRemove(int offset, int length) {\n        int n = marks.size();\n        for (int i = 0; i < n; i++) {\n            PosRec mark = marks.elementAt(i);\n            if (mark.unused) {\n                // this record is no longer used, get rid of it\n                marks.removeElementAt(i);\n                i -= 1;\n                n -= 1;\n            } else if (mark.offset >= (offset + length)) {\n                mark.offset -= length;\n            } else if (mark.offset >= offset) {\n                mark.offset = offset;\n            }\n        }\n    }"}
{"Number":"1603","API Relative Path":"javax.swing.text.StringContent.java-remove(int-int)","Corresponding Source":"synchronized void updateMarksForRemove(int offset, int length) {\n        int n = marks.size();\n        for (int i = 0; i < n; i++) {\n            PosRec mark = marks.elementAt(i);\n            if (mark.unused) {\n                // this record is no longer used, get rid of it\n                marks.removeElementAt(i);\n                i -= 1;\n                n -= 1;\n            } else if (mark.offset >= (offset + length)) {\n                mark.offset -= length;\n            } else if (mark.offset >= offset) {\n                mark.offset = offset;\n            }\n        }\n    }"}
{"Number":"1604","API Relative Path":"javax.swing.text.StyleContext.java-getStaticAttribute(Object)","Corresponding Source":"/**\n     * Returns the object previously registered with\n     * <code>registerStaticAttributeKey<\/code>.\n     */\n    public static Object getStaticAttribute(Object key) {\n        if (thawKeyMap == null || key == null) {\n            return null;\n        }\n        return thawKeyMap.get(key);\n    }"}
{"Number":"1605","API Relative Path":"javax.swing.text.TabSet.java-getTab(int)","Corresponding Source":"/**\n     * Returns the TabStop at index <code>index<\/code>. This will throw an\n     * IllegalArgumentException if <code>index<\/code> is outside the range\n     * of tabs.\n     */\n    public TabStop getTab(int index) {\n        int          numTabs = getTabCount();\n\n        if(index < 0 || index >= numTabs)\n            throw new IllegalArgumentException(index +\n                                              \" is outside the range of tabs\");\n        return tabs[index];\n    }"}
{"Number":"1606","API Relative Path":"javax.swing.text.Utilities.java-getNextWord(JTextComponent-int)","Corresponding Source":"/**\n     * Determines the start of the next word for the given location.\n     * Uses BreakIterator.getWordInstance() to actually get the words.\n     *\n     * @param c the editor\n     * @param offs the offset in the document &gt;= 0\n     * @return the location in the model of the word start &gt;= 0\n     * @exception BadLocationException if the offset is out of range\n     */\n    public static final int getNextWord(JTextComponent c, int offs) throws BadLocationException {\n        int nextWord;\n        Element line = getParagraphElement(c, offs);\n        for (nextWord = getNextWordInParagraph(c, line, offs, false);\n             nextWord == BreakIterator.DONE;\n             nextWord = getNextWordInParagraph(c, line, offs, true)) {\n\n            // didn't find in this line, try the next line\n            offs = line.getEndOffset();\n            line = getParagraphElement(c, offs);\n        }\n        return nextWord;\n    }"}
{"Number":"1607","API Relative Path":"javax.swing.text.Utilities.java-getNextWordInParagraph(JTextComponent-Element-int-boolean)","Corresponding Source":"/**\n     * Finds the next word in the given elements text.  The first\n     * parameter allows searching multiple paragraphs where even\n     * the first offset is desired.\n     * Returns the offset of the next word, or BreakIterator.DONE\n     * if there are no more words in the element.\n     */\n    static int getNextWordInParagraph(JTextComponent c, Element line, int offs, boolean first) throws BadLocationException {\n        if (line == null) {\n            throw new BadLocationException(\"No more words\", offs);\n        }\n        Document doc = line.getDocument();\n        int lineStart = line.getStartOffset();\n        int lineEnd = Math.min(line.getEndOffset(), doc.getLength());\n        if ((offs >= lineEnd) || (offs < lineStart)) {\n            throw new BadLocationException(\"No more words\", offs);\n        }\n        Segment seg = SegmentCache.getSharedSegment();\n        doc.getText(lineStart, lineEnd - lineStart, seg);\n        BreakIterator words = BreakIterator.getWordInstance(c.getLocale());\n        words.setText(seg);\n        if ((first && (words.first() == (seg.offset + offs - lineStart))) &&\n            (! Character.isWhitespace(seg.array[words.first()]))) {\n\n            return offs;\n        }\n        int wordPosition = words.following(seg.offset + offs - lineStart);\n        if ((wordPosition == BreakIterator.DONE) ||\n            (wordPosition >= seg.offset + seg.count)) {\n                // there are no more words on this line.\n                return BreakIterator.DONE;\n        }\n        // if we haven't shot past the end... check to\n        // see if the current boundary represents whitespace.\n        // if so, we need to try again\n        char ch = seg.array[wordPosition];\n        if (! Character.isWhitespace(ch)) {\n            return lineStart + wordPosition - seg.offset;\n        }\n\n        // it was whitespace, try again.  The assumption\n        // is that it must be a word start if the last\n        // one had whitespace following it.\n        wordPosition = words.next();\n        if (wordPosition != BreakIterator.DONE) {\n            offs = lineStart + wordPosition - seg.offset;\n            if (offs != lineEnd) {\n                return offs;\n            }\n        }\n        SegmentCache.releaseSharedSegment(seg);\n        return BreakIterator.DONE;\n    }"}
{"Number":"1608","API Relative Path":"javax.swing.text.Utilities.java-getNextWordInParagraph(JTextComponent-Element-int-boolean)","Corresponding Source":"/**\n     * Finds the next word in the given elements text.  The first\n     * parameter allows searching multiple paragraphs where even\n     * the first offset is desired.\n     * Returns the offset of the next word, or BreakIterator.DONE\n     * if there are no more words in the element.\n     */\n    static int getNextWordInParagraph(JTextComponent c, Element line, int offs, boolean first) throws BadLocationException {\n        if (line == null) {\n            throw new BadLocationException(\"No more words\", offs);\n        }\n        Document doc = line.getDocument();\n        int lineStart = line.getStartOffset();\n        int lineEnd = Math.min(line.getEndOffset(), doc.getLength());\n        if ((offs >= lineEnd) || (offs < lineStart)) {\n            throw new BadLocationException(\"No more words\", offs);\n        }\n        Segment seg = SegmentCache.getSharedSegment();\n        doc.getText(lineStart, lineEnd - lineStart, seg);\n        BreakIterator words = BreakIterator.getWordInstance(c.getLocale());\n        words.setText(seg);\n        if ((first && (words.first() == (seg.offset + offs - lineStart))) &&\n            (! Character.isWhitespace(seg.array[words.first()]))) {\n\n            return offs;\n        }\n        int wordPosition = words.following(seg.offset + offs - lineStart);\n        if ((wordPosition == BreakIterator.DONE) ||\n            (wordPosition >= seg.offset + seg.count)) {\n                // there are no more words on this line.\n                return BreakIterator.DONE;\n        }\n        // if we haven't shot past the end... check to\n        // see if the current boundary represents whitespace.\n        // if so, we need to try again\n        char ch = seg.array[wordPosition];\n        if (! Character.isWhitespace(ch)) {\n            return lineStart + wordPosition - seg.offset;\n        }\n\n        // it was whitespace, try again.  The assumption\n        // is that it must be a word start if the last\n        // one had whitespace following it.\n        wordPosition = words.next();\n        if (wordPosition != BreakIterator.DONE) {\n            offs = lineStart + wordPosition - seg.offset;\n            if (offs != lineEnd) {\n                return offs;\n            }\n        }\n        SegmentCache.releaseSharedSegment(seg);\n        return BreakIterator.DONE;\n    }"}
{"Number":"1609","API Relative Path":"javax.swing.text.Utilities.java-getPreviousWord(JTextComponent-int)","Corresponding Source":"/**\n     * Determine the start of the prev word for the given location.\n     * Uses BreakIterator.getWordInstance() to actually get the words.\n     *\n     * @param c the editor\n     * @param offs the offset in the document &gt;= 0\n     * @return the location in the model of the word start &gt;= 0\n     * @exception BadLocationException if the offset is out of range\n     */\n    public static final int getPreviousWord(JTextComponent c, int offs) throws BadLocationException {\n        int prevWord;\n        Element line = getParagraphElement(c, offs);\n        for (prevWord = getPrevWordInParagraph(c, line, offs);\n             prevWord == BreakIterator.DONE;\n             prevWord = getPrevWordInParagraph(c, line, offs)) {\n\n            // didn't find in this line, try the prev line\n            offs = line.getStartOffset() - 1;\n            line = getParagraphElement(c, offs);\n        }\n        return prevWord;\n    }"}
{"Number":"1610","API Relative Path":"javax.swing.text.Utilities.java-getPrevWordInParagraph(JTextComponent-Element-int)","Corresponding Source":"/**\n     * Finds the previous word in the given elements text.  The first\n     * parameter allows searching multiple paragraphs where even\n     * the first offset is desired.\n     * Returns the offset of the next word, or BreakIterator.DONE\n     * if there are no more words in the element.\n     */\n    static int getPrevWordInParagraph(JTextComponent c, Element line, int offs) throws BadLocationException {\n        if (line == null) {\n            throw new BadLocationException(\"No more words\", offs);\n        }\n        Document doc = line.getDocument();\n        int lineStart = line.getStartOffset();\n        int lineEnd = line.getEndOffset();\n        if ((offs > lineEnd) || (offs < lineStart)) {\n            throw new BadLocationException(\"No more words\", offs);\n        }\n        Segment seg = SegmentCache.getSharedSegment();\n        doc.getText(lineStart, lineEnd - lineStart, seg);\n        BreakIterator words = BreakIterator.getWordInstance(c.getLocale());\n        words.setText(seg);\n        if (words.following(seg.offset + offs - lineStart) == BreakIterator.DONE) {\n            words.last();\n        }\n        int wordPosition = words.previous();\n        if (wordPosition == (seg.offset + offs - lineStart)) {\n            wordPosition = words.previous();\n        }\n\n        if (wordPosition == BreakIterator.DONE) {\n            // there are no more words on this line.\n            return BreakIterator.DONE;\n        }\n        // if we haven't shot past the end... check to\n        // see if the current boundary represents whitespace.\n        // if so, we need to try again\n        char ch = seg.array[wordPosition];\n        if (! Character.isWhitespace(ch)) {\n            return lineStart + wordPosition - seg.offset;\n        }\n\n        // it was whitespace, try again.  The assumption\n        // is that it must be a word start if the last\n        // one had whitespace following it.\n        wordPosition = words.previous();\n        if (wordPosition != BreakIterator.DONE) {\n            return lineStart + wordPosition - seg.offset;\n        }\n        SegmentCache.releaseSharedSegment(seg);\n        return BreakIterator.DONE;\n    }"}
{"Number":"1611","API Relative Path":"javax.swing.text.Utilities.java-getPrevWordInParagraph(JTextComponent-Element-int)","Corresponding Source":"/**\n     * Finds the previous word in the given elements text.  The first\n     * parameter allows searching multiple paragraphs where even\n     * the first offset is desired.\n     * Returns the offset of the next word, or BreakIterator.DONE\n     * if there are no more words in the element.\n     */\n    static int getPrevWordInParagraph(JTextComponent c, Element line, int offs) throws BadLocationException {\n        if (line == null) {\n            throw new BadLocationException(\"No more words\", offs);\n        }\n        Document doc = line.getDocument();\n        int lineStart = line.getStartOffset();\n        int lineEnd = line.getEndOffset();\n        if ((offs > lineEnd) || (offs < lineStart)) {\n            throw new BadLocationException(\"No more words\", offs);\n        }\n        Segment seg = SegmentCache.getSharedSegment();\n        doc.getText(lineStart, lineEnd - lineStart, seg);\n        BreakIterator words = BreakIterator.getWordInstance(c.getLocale());\n        words.setText(seg);\n        if (words.following(seg.offset + offs - lineStart) == BreakIterator.DONE) {\n            words.last();\n        }\n        int wordPosition = words.previous();\n        if (wordPosition == (seg.offset + offs - lineStart)) {\n            wordPosition = words.previous();\n        }\n\n        if (wordPosition == BreakIterator.DONE) {\n            // there are no more words on this line.\n            return BreakIterator.DONE;\n        }\n        // if we haven't shot past the end... check to\n        // see if the current boundary represents whitespace.\n        // if so, we need to try again\n        char ch = seg.array[wordPosition];\n        if (! Character.isWhitespace(ch)) {\n            return lineStart + wordPosition - seg.offset;\n        }\n\n        // it was whitespace, try again.  The assumption\n        // is that it must be a word start if the last\n        // one had whitespace following it.\n        wordPosition = words.previous();\n        if (wordPosition != BreakIterator.DONE) {\n            return lineStart + wordPosition - seg.offset;\n        }\n        SegmentCache.releaseSharedSegment(seg);\n        return BreakIterator.DONE;\n    }"}
{"Number":"1612","API Relative Path":"javax.swing.Timer.java-addActionListener(ActionListener)","Corresponding Source":"/**\n     * Adds an action listener to the <code>Timer<\/code>.\n     *\n     * @param listener the listener to add\n     *\n     * @see #Timer\n     */\n    public void addActionListener(ActionListener listener) {\n        listenerList.add(ActionListener.class, listener);\n    }"}
{"Number":"1613","API Relative Path":"javax.swing.Timer.java-removeActionListener(ActionListener)","Corresponding Source":"/**\n     * Removes the specified action listener from the <code>Timer<\/code>.\n     *\n     * @param listener the listener to remove\n     */\n    public void removeActionListener(ActionListener listener) {\n        listenerList.remove(ActionListener.class, listener);\n    }"}
{"Number":"1614","API Relative Path":"javax.swing.Timer.java-setDelay(int)","Corresponding Source":"/**\n     * Sets the <code>Timer<\/code>'s between-event delay, the number of milliseconds\n     * between successive action events. This does not affect the initial delay\n     * property, which can be set by the {@code setInitialDelay} method.\n     *\n     * @param delay the delay in milliseconds\n     * @see #setInitialDelay\n     */\n    public void setDelay(int delay) {\n        if (delay < 0) {\n            throw new IllegalArgumentException(\"Invalid delay: \" + delay);\n        }\n        else {\n            this.delay = delay;\n        }\n    }"}
{"Number":"1615","API Relative Path":"javax.swing.Timer.java-setInitialDelay(int)","Corresponding Source":"/**\n     * Sets the <code>Timer<\/code>'s initial delay, the time\n     * in milliseconds to wait after the timer is started\n     * before firing the first event. Upon construction, this\n     * is set to be the same as the between-event delay,\n     * but then its value is independent and remains unaffected\n     * by changes to the between-event delay.\n     *\n     * @param initialDelay the initial delay, in milliseconds\n     * @see #setDelay\n     */\n    public void setInitialDelay(int initialDelay) {\n        if (initialDelay < 0) {\n            throw new IllegalArgumentException(\"Invalid initial delay: \" +\n                                               initialDelay);\n        }\n        else {\n            this.initialDelay = initialDelay;\n        }\n    }"}
{"Number":"1616","API Relative Path":"javax.swing.ToolTipManager.java-setDismissDelay(int)","Corresponding Source":"/**\n     * Specifies the dismissal delay value.\n     *\n     * @param milliseconds  the number of milliseconds to delay\n     *        before taking away the tooltip\n     * @see #getDismissDelay\n     */\n    public void setDismissDelay(int milliseconds) {\n        insideTimer.setInitialDelay(milliseconds);\n    }"}
{"Number":"1617","API Relative Path":"javax.swing.ToolTipManager.java-setReshowDelay(int)","Corresponding Source":"/**\n     * Used to specify the amount of time before the user has to wait\n     * <code>initialDelay<\/code> milliseconds before a tooltip will be\n     * shown. That is, if the tooltip is hidden, and the user moves into\n     * a region of the same Component that has a valid tooltip within\n     * <code>milliseconds<\/code> milliseconds the tooltip will immediately\n     * be shown. Otherwise, if the user moves into a region with a valid\n     * tooltip after <code>milliseconds<\/code> milliseconds, the user\n     * will have to wait an additional <code>initialDelay<\/code>\n     * milliseconds before the tooltip is shown again.\n     *\n     * @param milliseconds time in milliseconds\n     * @see #getReshowDelay\n     */\n    public void setReshowDelay(int milliseconds) {\n        exitTimer.setInitialDelay(milliseconds);\n    }"}
{"Number":"1618","API Relative Path":"javax.swing.tree.AbstractLayoutCache.java-getRowsForPaths(TreePath[])","Corresponding Source":"//\n    // RowMapper\n    //\n\n    /**\n     * Returns the rows that the <code>TreePath<\/code> instances in\n     * <code>path<\/code> are being displayed at.\n     * This method should return an array of the same length as that passed\n     * in, and if one of the <code>TreePaths<\/code>\n     * in <code>path<\/code> is not valid its entry in the array should\n     * be set to -1.\n     *\n     * @param paths the array of <code>TreePath<\/code>s being queried\n     * @return an array of the same length that is passed in containing\n     *          the rows that each corresponding where each\n     *          <code>TreePath<\/code> is displayed; if <code>paths<\/code>\n     *          is <code>null<\/code>, <code>null<\/code> is returned\n     */\n    public int[] getRowsForPaths(TreePath[] paths) {\n        if(paths == null)\n            return null;\n\n        int               numPaths = paths.length;\n        int[]             rows = new int[numPaths];\n\n        for(int counter = 0; counter < numPaths; counter++)\n            rows[counter] = getRowForPath(paths[counter]);\n        return rows;\n    }"}
{"Number":"1619","API Relative Path":"javax.swing.tree.DefaultMutableTreeNode.java-getPathToRoot(TreeNode-int)","Corresponding Source":"/**\n     * Builds the parents of node up to and including the root node,\n     * where the original node is the last element in the returned array.\n     * The length of the returned array gives the node's depth in the\n     * tree.\n     *\n     * @param aNode  the TreeNode to get the path for\n     * @param depth  an int giving the number of steps already taken towards\n     *        the root (on recursive calls), used to size the returned array\n     * @return an array of TreeNodes giving the path from the root to the\n     *         specified node\n     */\n    protected TreeNode[] getPathToRoot(TreeNode aNode, int depth) {\n        TreeNode[]              retNodes;\n\n        /* Check for null, in case someone passed in a null node, or\n           they passed in an element that isn't rooted at root. */\n        if(aNode == null) {\n            if(depth == 0)\n                return null;\n            else\n                retNodes = new TreeNode[depth];\n        }\n        else {\n            depth++;\n            retNodes = getPathToRoot(aNode.getParent(), depth);\n            retNodes[retNodes.length - depth] = aNode;\n        }\n        return retNodes;\n    }"}
{"Number":"1620","API Relative Path":"javax.swing.tree.DefaultMutableTreeNode.java-isNodeSibling(TreeNode)","Corresponding Source":"//\n    //  Sibling Queries\n    //\n\n\n    /**\n     * Returns true if <code>anotherNode<\/code> is a sibling of (has the\n     * same parent as) this node.  A node is its own sibling.  If\n     * <code>anotherNode<\/code> is null, returns false.\n     *\n     * @param   anotherNode     node to test as sibling of this node\n     * @return  true if <code>anotherNode<\/code> is a sibling of this node\n     */\n    public boolean isNodeSibling(TreeNode anotherNode) {\n        boolean retval;\n\n        if (anotherNode == null) {\n            retval = false;\n        } else if (anotherNode == this) {\n            retval = true;\n        } else {\n            TreeNode  myParent = getParent();\n            retval = (myParent != null && myParent == anotherNode.getParent());\n\n            if (retval && !((DefaultMutableTreeNode)getParent())\n                           .isNodeChild(anotherNode)) {\n                throw new Error(\"sibling has different parent\");\n            }\n        }\n\n        return retval;\n    }"}
{"Number":"1621","API Relative Path":"javax.swing.tree.DefaultTreeModel.java-addTreeModelListener(TreeModelListener)","Corresponding Source":"//\n    //  Events\n    //\n\n    /**\n     * Adds a listener for the TreeModelEvent posted after the tree changes.\n     *\n     * @see     #removeTreeModelListener\n     * @param   l       the listener to add\n     */\n    public void addTreeModelListener(TreeModelListener l) {\n        listenerList.add(TreeModelListener.class, l);\n    }"}
{"Number":"1622","API Relative Path":"javax.swing.tree.DefaultTreeModel.java-fireTreeNodesChanged(Object-Object[]-int[]-Object[])","Corresponding Source":"/**\n     * Notifies all listeners that have registered interest for\n     * notification on this event type.  The event instance\n     * is lazily created using the parameters passed into\n     * the fire method.\n     *\n     * @param source the source of the {@code TreeModelEvent};\n     *               typically {@code this}\n     * @param path the path to the parent of the nodes that changed; use\n     *             {@code null} to identify the root has changed\n     * @param childIndices the indices of the changed elements\n     * @param children the changed elements\n     */\n    protected void fireTreeNodesChanged(Object source, Object[] path,\n                                        int[] childIndices,\n                                        Object[] children) {\n        // Guaranteed to return a non-null array\n        Object[] listeners = listenerList.getListenerList();\n        TreeModelEvent e = null;\n        // Process the listeners last to first, notifying\n        // those that are interested in this event\n        for (int i = listeners.length-2; i>=0; i-=2) {\n            if (listeners[i]==TreeModelListener.class) {\n                // Lazily create the event:\n                if (e == null)\n                    e = new TreeModelEvent(source, path,\n                                           childIndices, children);\n                ((TreeModelListener)listeners[i+1]).treeNodesChanged(e);\n            }\n        }\n    }"}
{"Number":"1623","API Relative Path":"javax.swing.tree.DefaultTreeModel.java-fireTreeNodesInserted(Object-Object[]-int[]-Object[])","Corresponding Source":"/**\n     * Notifies all listeners that have registered interest for\n     * notification on this event type.  The event instance\n     * is lazily created using the parameters passed into\n     * the fire method.\n     *\n     * @param source the source of the {@code TreeModelEvent};\n     *               typically {@code this}\n     * @param path the path to the parent the nodes were added to\n     * @param childIndices the indices of the new elements\n     * @param children the new elements\n     */\n    protected void fireTreeNodesInserted(Object source, Object[] path,\n                                        int[] childIndices,\n                                        Object[] children) {\n        // Guaranteed to return a non-null array\n        Object[] listeners = listenerList.getListenerList();\n        TreeModelEvent e = null;\n        // Process the listeners last to first, notifying\n        // those that are interested in this event\n        for (int i = listeners.length-2; i>=0; i-=2) {\n            if (listeners[i]==TreeModelListener.class) {\n                // Lazily create the event:\n                if (e == null)\n                    e = new TreeModelEvent(source, path,\n                                           childIndices, children);\n                ((TreeModelListener)listeners[i+1]).treeNodesInserted(e);\n            }\n        }\n    }"}
{"Number":"1624","API Relative Path":"javax.swing.tree.DefaultTreeModel.java-fireTreeNodesRemoved(Object-Object[]-int[]-Object[])","Corresponding Source":"/**\n     * Notifies all listeners that have registered interest for\n     * notification on this event type.  The event instance\n     * is lazily created using the parameters passed into\n     * the fire method.\n     *\n     * @param source the source of the {@code TreeModelEvent};\n     *               typically {@code this}\n     * @param path the path to the parent the nodes were removed from\n     * @param childIndices the indices of the removed elements\n     * @param children the removed elements\n     */\n    protected void fireTreeNodesRemoved(Object source, Object[] path,\n                                        int[] childIndices,\n                                        Object[] children) {\n        // Guaranteed to return a non-null array\n        Object[] listeners = listenerList.getListenerList();\n        TreeModelEvent e = null;\n        // Process the listeners last to first, notifying\n        // those that are interested in this event\n        for (int i = listeners.length-2; i>=0; i-=2) {\n            if (listeners[i]==TreeModelListener.class) {\n                // Lazily create the event:\n                if (e == null)\n                    e = new TreeModelEvent(source, path,\n                                           childIndices, children);\n                ((TreeModelListener)listeners[i+1]).treeNodesRemoved(e);\n            }\n        }\n    }"}
{"Number":"1625","API Relative Path":"javax.swing.tree.DefaultTreeModel.java-fireTreeStructureChanged(Object-Object[]-int[]-Object[])","Corresponding Source":"/**\n     * Notifies all listeners that have registered interest for\n     * notification on this event type.  The event instance\n     * is lazily created using the parameters passed into\n     * the fire method.\n     *\n     * @param source the source of the {@code TreeModelEvent};\n     *               typically {@code this}\n     * @param path the path to the parent of the structure that has changed;\n     *             use {@code null} to identify the root has changed\n     * @param childIndices the indices of the affected elements\n     * @param children the affected elements\n     */\n    protected void fireTreeStructureChanged(Object source, Object[] path,\n                                        int[] childIndices,\n                                        Object[] children) {\n        // Guaranteed to return a non-null array\n        Object[] listeners = listenerList.getListenerList();\n        TreeModelEvent e = null;\n        // Process the listeners last to first, notifying\n        // those that are interested in this event\n        for (int i = listeners.length-2; i>=0; i-=2) {\n            if (listeners[i]==TreeModelListener.class) {\n                // Lazily create the event:\n                if (e == null)\n                    e = new TreeModelEvent(source, path,\n                                           childIndices, children);\n                ((TreeModelListener)listeners[i+1]).treeStructureChanged(e);\n            }\n        }\n    }"}
{"Number":"1626","API Relative Path":"javax.swing.tree.DefaultTreeModel.java-getPathToRoot(TreeNode-int)","Corresponding Source":"/**\n     * Builds the parents of node up to and including the root node,\n     * where the original node is the last element in the returned array.\n     * The length of the returned array gives the node's depth in the\n     * tree.\n     *\n     * @param aNode  the TreeNode to get the path for\n     * @param depth  an int giving the number of steps already taken towards\n     *        the root (on recursive calls), used to size the returned array\n     * @return an array of TreeNodes giving the path from the root to the\n     *         specified node\n     */\n    protected TreeNode[] getPathToRoot(TreeNode aNode, int depth) {\n        TreeNode[]              retNodes;\n        // This method recurses, traversing towards the root in order\n        // size the array. On the way back, it fills in the nodes,\n        // starting from the root and working back to the original node.\n\n        /* Check for null, in case someone passed in a null node, or\n           they passed in an element that isn't rooted at root. */\n        if(aNode == null) {\n            if(depth == 0)\n                return null;\n            else\n                retNodes = new TreeNode[depth];\n        }\n        else {\n            depth++;\n            if(aNode == root)\n                retNodes = new TreeNode[depth];\n            else\n                retNodes = getPathToRoot(aNode.getParent(), depth);\n            retNodes[retNodes.length - depth] = aNode;\n        }\n        return retNodes;\n    }"}
{"Number":"1627","API Relative Path":"javax.swing.tree.DefaultTreeModel.java-nodeChanged(TreeNode)","Corresponding Source":"/**\n      * Invoke this method after you've changed how node is to be\n      * represented in the tree.\n      */\n    public void nodeChanged(TreeNode node) {\n        if(listenerList != null && node != null) {\n            TreeNode         parent = node.getParent();\n\n            if(parent != null) {\n                int        anIndex = parent.getIndex(node);\n                if(anIndex != -1) {\n                    int[]        cIndexs = new int[1];\n\n                    cIndexs[0] = anIndex;\n                    nodesChanged(parent, cIndexs);\n                }\n            }\n            else if (node == getRoot()) {\n                nodesChanged(node, null);\n            }\n        }\n    }"}
{"Number":"1628","API Relative Path":"javax.swing.tree.DefaultTreeModel.java-nodesChanged(TreeNode-int[])","Corresponding Source":"/**\n      * Invoke this method after you've changed how the children identified by\n      * childIndicies are to be represented in the tree.\n      */\n    public void nodesChanged(TreeNode node, int[] childIndices) {\n        if(node != null) {\n            if (childIndices != null) {\n                int            cCount = childIndices.length;\n\n                if(cCount > 0) {\n                    Object[]       cChildren = new Object[cCount];\n\n                    for(int counter = 0; counter < cCount; counter++)\n                        cChildren[counter] = node.getChildAt\n                            (childIndices[counter]);\n                    fireTreeNodesChanged(this, getPathToRoot(node),\n                                         childIndices, cChildren);\n                }\n            }\n            else if (node == getRoot()) {\n                fireTreeNodesChanged(this, getPathToRoot(node), null, null);\n            }\n        }\n    }"}
{"Number":"1629","API Relative Path":"javax.swing.tree.DefaultTreeModel.java-nodeStructureChanged(TreeNode)","Corresponding Source":"/**\n      * Invoke this method if you've totally changed the children of\n      * node and its children's children...  This will post a\n      * treeStructureChanged event.\n      */\n    public void nodeStructureChanged(TreeNode node) {\n        if(node != null) {\n           fireTreeStructureChanged(this, getPathToRoot(node), null, null);\n        }\n    }"}
{"Number":"1630","API Relative Path":"javax.swing.tree.DefaultTreeModel.java-nodesWereRemoved(TreeNode-int[]-Object[])","Corresponding Source":"/**\n      * Invoke this method after you've removed some TreeNodes from\n      * node.  childIndices should be the index of the removed elements and\n      * must be sorted in ascending order. And removedChildren should be\n      * the array of the children objects that were removed.\n      */\n    public void nodesWereRemoved(TreeNode node, int[] childIndices,\n                                 Object[] removedChildren) {\n        if(node != null && childIndices != null) {\n            fireTreeNodesRemoved(this, getPathToRoot(node), childIndices,\n                                 removedChildren);\n        }\n    }"}
{"Number":"1631","API Relative Path":"javax.swing.tree.DefaultTreeModel.java-reload(TreeNode)","Corresponding Source":"/**\n     * Invoke this method if you've modified the {@code TreeNode}s upon which\n     * this model depends. The model will notify all of its listeners that the\n     * model has changed below the given node.\n     *\n     * @param node the node below which the model has changed\n     */\n    public void reload(TreeNode node) {\n        if(node != null) {\n            fireTreeStructureChanged(this, getPathToRoot(node), null, null);\n        }\n    }"}
{"Number":"1632","API Relative Path":"javax.swing.tree.DefaultTreeModel.java-removeTreeModelListener(TreeModelListener)","Corresponding Source":"/**\n     * Removes a listener previously added with <B>addTreeModelListener()<\/B>.\n     *\n     * @see     #addTreeModelListener\n     * @param   l       the listener to remove\n     */\n    public void removeTreeModelListener(TreeModelListener l) {\n        listenerList.remove(TreeModelListener.class, l);\n    }"}
{"Number":"1633","API Relative Path":"javax.swing.tree.DefaultTreeModel.java-setRoot(TreeNode)","Corresponding Source":"/**\n     * Sets the root to <code>root<\/code>. A null <code>root<\/code> implies\n     * the tree is to display nothing, and is legal.\n     */\n    public void setRoot(TreeNode root) {\n        Object oldRoot = this.root;\n        this.root = root;\n        if (root == null && oldRoot != null) {\n            fireTreeStructureChanged(this, null);\n        }\n        else {\n            nodeStructureChanged(root);\n        }\n    }"}
{"Number":"1634","API Relative Path":"javax.swing.tree.DefaultTreeSelectionModel.java-addSelectionPath(TreePath)","Corresponding Source":"/**\n      * Adds path to the current selection. If path is not currently\n      * in the selection the TreeSelectionListeners are notified. This has\n      * no effect if <code>path<\/code> is null.\n      *\n      * @param path the new path to add to the current selection\n      */\n    public void addSelectionPath(TreePath path) {\n        if(path != null) {\n            TreePath[]            toAdd = new TreePath[1];\n\n            toAdd[0] = path;\n            addSelectionPaths(toAdd);\n        }\n    }"}
{"Number":"1635","API Relative Path":"javax.swing.tree.DefaultTreeSelectionModel.java-addTreeSelectionListener(TreeSelectionListener)","Corresponding Source":"/**\n      * Adds x to the list of listeners that are notified each time the\n      * set of selected TreePaths changes.\n      *\n      * @param x the new listener to be added\n      */\n    public void addTreeSelectionListener(TreeSelectionListener x) {\n        listenerList.add(TreeSelectionListener.class, x);\n    }"}
{"Number":"1636","API Relative Path":"javax.swing.tree.DefaultTreeSelectionModel.java-removeSelectionPath(TreePath)","Corresponding Source":"/**\n      * Removes path from the selection. If path is in the selection\n      * The TreeSelectionListeners are notified. This has no effect if\n      * <code>path<\/code> is null.\n      *\n      * @param path the path to remove from the selection\n      */\n    public void removeSelectionPath(TreePath path) {\n        if(path != null) {\n            TreePath[]             rPath = new TreePath[1];\n\n            rPath[0] = path;\n            removeSelectionPaths(rPath);\n        }\n    }"}
{"Number":"1637","API Relative Path":"javax.swing.tree.DefaultTreeSelectionModel.java-removeSelectionPaths(TreePath[])","Corresponding Source":"/**\n      * Removes paths from the selection.  If any of the paths in paths\n      * are in the selection the TreeSelectionListeners are notified.\n      * This has no effect if <code>paths<\/code> is null.\n      *\n      * @param paths the paths to remove from the selection\n      */\n    public void removeSelectionPaths(TreePath[] paths) {\n        if (paths != null && selection != null && paths.length > 0) {\n            if(!canPathsBeRemoved(paths)) {\n                /* Could probably do something more interesting here! */\n                clearSelection();\n            }\n            else {\n                Vector<PathPlaceHolder> pathsToRemove = null;\n\n                /* Find the paths that can be removed. */\n                for (int removeCounter = paths.length - 1; removeCounter >= 0;\n                     removeCounter--) {\n                    if(paths[removeCounter] != null) {\n                        if (uniquePaths.get(paths[removeCounter]) != null) {\n                            if(pathsToRemove == null)\n                                pathsToRemove = new Vector<PathPlaceHolder>(paths.length);\n                            uniquePaths.remove(paths[removeCounter]);\n                            pathsToRemove.addElement(new PathPlaceHolder\n                                         (paths[removeCounter], false));\n                        }\n                    }\n                }\n                if(pathsToRemove != null) {\n                    int         removeCount = pathsToRemove.size();\n                    TreePath    beginLeadPath = leadPath;\n\n                    if(removeCount == selection.length) {\n                        selection = null;\n                    }\n                    else {\n                        Enumeration<TreePath> pEnum = uniquePaths.keys();\n                        int                  validCount = 0;\n\n                        selection = new TreePath[selection.length -\n                                                removeCount];\n                        while (pEnum.hasMoreElements()) {\n                            selection[validCount++] = pEnum.nextElement();\n                        }\n                    }\n                    if (leadPath != null &&\n                        uniquePaths.get(leadPath) == null) {\n                        if (selection != null) {\n                            leadPath = selection[selection.length - 1];\n                        }\n                        else {\n                            leadPath = null;\n                        }\n                    }\n                    else if (selection != null) {\n                        leadPath = selection[selection.length - 1];\n                    }\n                    else {\n                        leadPath = null;\n                    }\n                    updateLeadIndex();\n\n                    resetRowSelection();\n\n                    notifyPathChange(pathsToRemove, beginLeadPath);\n                }\n            }\n        }\n    }"}
{"Number":"1638","API Relative Path":"javax.swing.tree.DefaultTreeSelectionModel.java-removeTreeSelectionListener(TreeSelectionListener)","Corresponding Source":"/**\n      * Removes x from the list of listeners that are notified each time\n      * the set of selected TreePaths changes.\n      *\n      * @param x the listener to remove\n      */\n    public void removeTreeSelectionListener(TreeSelectionListener x) {\n        listenerList.remove(TreeSelectionListener.class, x);\n    }"}
{"Number":"1639","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-getBounds(TreePath-Rectangle)","Corresponding Source":"/**\n     * Returns a rectangle giving the bounds needed to draw path.\n     *\n     * @param path     a TreePath specifying a node\n     * @param placeIn  a Rectangle object giving the available space\n     * @return a Rectangle object specifying the space to be used\n     */\n    public Rectangle getBounds(TreePath path, Rectangle placeIn) {\n        if(path == null)\n            return null;\n\n        FHTreeStateNode      node = getNodeForPath(path, true, false);\n\n        if(node != null)\n            return getBounds(node, -1, placeIn);\n\n        // node hasn't been created yet.\n        TreePath       parentPath = path.getParentPath();\n\n        node = getNodeForPath(parentPath, true, false);\n        if (node != null && node.isExpanded()) {\n            int              childIndex = treeModel.getIndexOfChild\n                                 (parentPath.getLastPathComponent(),\n                                  path.getLastPathComponent());\n\n            if(childIndex != -1)\n                return getBounds(node, childIndex, placeIn);\n        }\n        return null;\n    }"}
{"Number":"1640","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-getBounds(TreePath-Rectangle)","Corresponding Source":"/**\n     * Returns a rectangle giving the bounds needed to draw path.\n     *\n     * @param path     a TreePath specifying a node\n     * @param placeIn  a Rectangle object giving the available space\n     * @return a Rectangle object specifying the space to be used\n     */\n    public Rectangle getBounds(TreePath path, Rectangle placeIn) {\n        if(path == null)\n            return null;\n\n        FHTreeStateNode      node = getNodeForPath(path, true, false);\n\n        if(node != null)\n            return getBounds(node, -1, placeIn);\n\n        // node hasn't been created yet.\n        TreePath       parentPath = path.getParentPath();\n\n        node = getNodeForPath(parentPath, true, false);\n        if (node != null && node.isExpanded()) {\n            int              childIndex = treeModel.getIndexOfChild\n                                 (parentPath.getLastPathComponent(),\n                                  path.getLastPathComponent());\n\n            if(childIndex != -1)\n                return getBounds(node, childIndex, placeIn);\n        }\n        return null;\n    }"}
{"Number":"1641","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-getBounds(TreePath-Rectangle)","Corresponding Source":"/**\n     * Returns a rectangle giving the bounds needed to draw path.\n     *\n     * @param path     a TreePath specifying a node\n     * @param placeIn  a Rectangle object giving the available space\n     * @return a Rectangle object specifying the space to be used\n     */\n    public Rectangle getBounds(TreePath path, Rectangle placeIn) {\n        if(path == null)\n            return null;\n\n        FHTreeStateNode      node = getNodeForPath(path, true, false);\n\n        if(node != null)\n            return getBounds(node, -1, placeIn);\n\n        // node hasn't been created yet.\n        TreePath       parentPath = path.getParentPath();\n\n        node = getNodeForPath(parentPath, true, false);\n        if (node != null && node.isExpanded()) {\n            int              childIndex = treeModel.getIndexOfChild\n                                 (parentPath.getLastPathComponent(),\n                                  path.getLastPathComponent());\n\n            if(childIndex != -1)\n                return getBounds(node, childIndex, placeIn);\n        }\n        return null;\n    }"}
{"Number":"1642","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-getExpandedState(TreePath)","Corresponding Source":"/**\n     * Returns true if the path is expanded, and visible.\n     */\n    public boolean getExpandedState(TreePath path) {\n        FHTreeStateNode       node = getNodeForPath(path, true, false);\n\n        return (node != null) ? (node.isVisible() && node.isExpanded()) :\n                                 false;\n    }"}
{"Number":"1643","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-getExpandedState(TreePath)","Corresponding Source":"/**\n     * Returns true if the path is expanded, and visible.\n     */\n    public boolean getExpandedState(TreePath path) {\n        FHTreeStateNode       node = getNodeForPath(path, true, false);\n\n        return (node != null) ? (node.isVisible() && node.isExpanded()) :\n                                 false;\n    }"}
{"Number":"1644","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-getRowForPath(TreePath)","Corresponding Source":"/**\n      * Returns the row that the last item identified in path is visible\n      * at.  Will return -1 if any of the elements in path are not\n      * currently visible.\n      */\n    public int getRowForPath(TreePath path) {\n        if(path == null || root == null)\n            return -1;\n\n        FHTreeStateNode         node = getNodeForPath(path, true, false);\n\n        if(node != null)\n            return node.getRow();\n\n        TreePath       parentPath = path.getParentPath();\n\n        node = getNodeForPath(parentPath, true, false);\n        if(node != null && node.isExpanded()) {\n            return node.getRowToModelIndex(treeModel.getIndexOfChild\n                                           (parentPath.getLastPathComponent(),\n                                            path.getLastPathComponent()));\n        }\n        return -1;\n    }"}
{"Number":"1645","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-getRowForPath(TreePath)","Corresponding Source":"/**\n      * Returns the row that the last item identified in path is visible\n      * at.  Will return -1 if any of the elements in path are not\n      * currently visible.\n      */\n    public int getRowForPath(TreePath path) {\n        if(path == null || root == null)\n            return -1;\n\n        FHTreeStateNode         node = getNodeForPath(path, true, false);\n\n        if(node != null)\n            return node.getRow();\n\n        TreePath       parentPath = path.getParentPath();\n\n        node = getNodeForPath(parentPath, true, false);\n        if(node != null && node.isExpanded()) {\n            return node.getRowToModelIndex(treeModel.getIndexOfChild\n                                           (parentPath.getLastPathComponent(),\n                                            path.getLastPathComponent()));\n        }\n        return -1;\n    }"}
{"Number":"1646","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-getVisibleChildCount(TreePath)","Corresponding Source":"/**\n     * Returns the number of visible children for row.\n     */\n    public int getVisibleChildCount(TreePath path) {\n        FHTreeStateNode         node = getNodeForPath(path, true, false);\n\n        if(node == null)\n            return 0;\n        return node.getTotalChildCount();\n    }"}
{"Number":"1647","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-getVisibleChildCount(TreePath)","Corresponding Source":"/**\n     * Returns the number of visible children for row.\n     */\n    public int getVisibleChildCount(TreePath path) {\n        FHTreeStateNode         node = getNodeForPath(path, true, false);\n\n        if(node == null)\n            return 0;\n        return node.getTotalChildCount();\n    }"}
{"Number":"1648","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-getVisiblePathsFrom(TreePath)","Corresponding Source":"/**\n     * Returns an Enumerator that increments over the visible paths\n     * starting at the passed in location. The ordering of the enumeration\n     * is based on how the paths are displayed.\n     */\n    public Enumeration<TreePath> getVisiblePathsFrom(TreePath path) {\n        if(path == null)\n            return null;\n\n        FHTreeStateNode         node = getNodeForPath(path, true, false);\n\n        if(node != null) {\n            return new VisibleFHTreeStateNodeEnumeration(node);\n        }\n        TreePath            parentPath = path.getParentPath();\n\n        node = getNodeForPath(parentPath, true, false);\n        if(node != null && node.isExpanded()) {\n            return new VisibleFHTreeStateNodeEnumeration(node,\n                  treeModel.getIndexOfChild(parentPath.getLastPathComponent(),\n                                            path.getLastPathComponent()));\n        }\n        return null;\n    }"}
{"Number":"1649","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-getVisiblePathsFrom(TreePath)","Corresponding Source":"/**\n     * Returns an Enumerator that increments over the visible paths\n     * starting at the passed in location. The ordering of the enumeration\n     * is based on how the paths are displayed.\n     */\n    public Enumeration<TreePath> getVisiblePathsFrom(TreePath path) {\n        if(path == null)\n            return null;\n\n        FHTreeStateNode         node = getNodeForPath(path, true, false);\n\n        if(node != null) {\n            return new VisibleFHTreeStateNodeEnumeration(node);\n        }\n        TreePath            parentPath = path.getParentPath();\n\n        node = getNodeForPath(parentPath, true, false);\n        if(node != null && node.isExpanded()) {\n            return new VisibleFHTreeStateNodeEnumeration(node,\n                  treeModel.getIndexOfChild(parentPath.getLastPathComponent(),\n                                            path.getLastPathComponent()));\n        }\n        return null;\n    }"}
{"Number":"1650","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-getVisiblePathsFrom(TreePath)","Corresponding Source":"/**\n     * Returns an Enumerator that increments over the visible paths\n     * starting at the passed in location. The ordering of the enumeration\n     * is based on how the paths are displayed.\n     */\n    public Enumeration<TreePath> getVisiblePathsFrom(TreePath path) {\n        if(path == null)\n            return null;\n\n        FHTreeStateNode         node = getNodeForPath(path, true, false);\n\n        if(node != null) {\n            return new VisibleFHTreeStateNodeEnumeration(node);\n        }\n        TreePath            parentPath = path.getParentPath();\n\n        node = getNodeForPath(parentPath, true, false);\n        if(node != null && node.isExpanded()) {\n            return new VisibleFHTreeStateNodeEnumeration(node,\n                  treeModel.getIndexOfChild(parentPath.getLastPathComponent(),\n                                            path.getLastPathComponent()));\n        }\n        return null;\n    }"}
{"Number":"1651","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-isExpanded(TreePath)","Corresponding Source":"/**\n      * Returns true if the value identified by row is currently expanded.\n      */\n    public boolean isExpanded(TreePath path) {\n        if(path != null) {\n            FHTreeStateNode     lastNode = getNodeForPath(path, true, false);\n\n            return (lastNode != null && lastNode.isExpanded());\n        }\n        return false;\n    }"}
{"Number":"1652","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-isExpanded(TreePath)","Corresponding Source":"/**\n      * Returns true if the value identified by row is currently expanded.\n      */\n    public boolean isExpanded(TreePath path) {\n        if(path != null) {\n            FHTreeStateNode     lastNode = getNodeForPath(path, true, false);\n\n            return (lastNode != null && lastNode.isExpanded());\n        }\n        return false;\n    }"}
{"Number":"1653","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-setExpandedState(TreePath-boolean)","Corresponding Source":"/**\n     * Marks the path <code>path<\/code> expanded state to\n     * <code>isExpanded<\/code>.\n     */\n    public void setExpandedState(TreePath path, boolean isExpanded) {\n        if(isExpanded)\n            ensurePathIsExpanded(path, true);\n        else if(path != null) {\n            TreePath              parentPath = path.getParentPath();\n\n            // YECK! Make the parent expanded.\n            if(parentPath != null) {\n                FHTreeStateNode     parentNode = getNodeForPath(parentPath,\n                                                                false, true);\n                if(parentNode != null)\n                    parentNode.makeVisible();\n            }\n            // And collapse the child.\n            FHTreeStateNode         childNode = getNodeForPath(path, true,\n                                                               false);\n\n            if(childNode != null)\n                childNode.collapse(true);\n        }\n    }"}
{"Number":"1654","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-setExpandedState(TreePath-boolean)","Corresponding Source":"/**\n     * Marks the path <code>path<\/code> expanded state to\n     * <code>isExpanded<\/code>.\n     */\n    public void setExpandedState(TreePath path, boolean isExpanded) {\n        if(isExpanded)\n            ensurePathIsExpanded(path, true);\n        else if(path != null) {\n            TreePath              parentPath = path.getParentPath();\n\n            // YECK! Make the parent expanded.\n            if(parentPath != null) {\n                FHTreeStateNode     parentNode = getNodeForPath(parentPath,\n                                                                false, true);\n                if(parentNode != null)\n                    parentNode.makeVisible();\n            }\n            // And collapse the child.\n            FHTreeStateNode         childNode = getNodeForPath(path, true,\n                                                               false);\n\n            if(childNode != null)\n                childNode.collapse(true);\n        }\n    }"}
{"Number":"1655","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-setExpandedState(TreePath-boolean)","Corresponding Source":"/**\n     * Marks the path <code>path<\/code> expanded state to\n     * <code>isExpanded<\/code>.\n     */\n    public void setExpandedState(TreePath path, boolean isExpanded) {\n        if(isExpanded)\n            ensurePathIsExpanded(path, true);\n        else if(path != null) {\n            TreePath              parentPath = path.getParentPath();\n\n            // YECK! Make the parent expanded.\n            if(parentPath != null) {\n                FHTreeStateNode     parentNode = getNodeForPath(parentPath,\n                                                                false, true);\n                if(parentNode != null)\n                    parentNode.makeVisible();\n            }\n            // And collapse the child.\n            FHTreeStateNode         childNode = getNodeForPath(path, true,\n                                                               false);\n\n            if(childNode != null)\n                childNode.collapse(true);\n        }\n    }"}
{"Number":"1656","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-setExpandedState(TreePath-boolean)","Corresponding Source":"/**\n     * Marks the path <code>path<\/code> expanded state to\n     * <code>isExpanded<\/code>.\n     */\n    public void setExpandedState(TreePath path, boolean isExpanded) {\n        if(isExpanded)\n            ensurePathIsExpanded(path, true);\n        else if(path != null) {\n            TreePath              parentPath = path.getParentPath();\n\n            // YECK! Make the parent expanded.\n            if(parentPath != null) {\n                FHTreeStateNode     parentNode = getNodeForPath(parentPath,\n                                                                false, true);\n                if(parentNode != null)\n                    parentNode.makeVisible();\n            }\n            // And collapse the child.\n            FHTreeStateNode         childNode = getNodeForPath(path, true,\n                                                               false);\n\n            if(childNode != null)\n                childNode.collapse(true);\n        }\n    }"}
{"Number":"1657","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-setRowHeight(int)","Corresponding Source":"/**\n     * Sets the height of each cell. If rowHeight is less than or equal to\n     * 0 this will throw an IllegalArgumentException.\n     *\n     * @param rowHeight the height of each cell, in pixels\n     */\n    public void setRowHeight(int rowHeight) {\n        if(rowHeight <= 0)\n            throw new IllegalArgumentException(\"FixedHeightLayoutCache only supports row heights greater than 0\");\n        if(getRowHeight() != rowHeight) {\n            super.setRowHeight(rowHeight);\n            visibleNodesChanged();\n        }\n    }"}
{"Number":"1658","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-treeNodesChanged(TreeModelEvent)","Corresponding Source":"//\n    // TreeModelListener methods\n    //\n\n    /**\n     * <p>Invoked after a node (or a set of siblings) has changed in some\n     * way. The node(s) have not changed locations in the tree or\n     * altered their children arrays, but other attributes have\n     * changed and may affect presentation. Example: the name of a\n     * file has changed, but it is in the same location in the file\n     * system.<\/p>\n     *\n     * <p>e.path() returns the path the parent of the changed node(s).<\/p>\n     *\n     * <p>e.childIndices() returns the index(es) of the changed node(s).<\/p>\n     */\n    public void treeNodesChanged(TreeModelEvent e) {\n        if(e != null) {\n            int                 changedIndexs[];\n            FHTreeStateNode     changedParent = getNodeForPath\n                                  (SwingUtilities2.getTreePath(e, getModel()), false, false);\n            int                 maxCounter;\n\n            changedIndexs = e.getChildIndices();\n            /* Only need to update the children if the node has been\n               expanded once. */\n            // PENDING(scott): make sure childIndexs is sorted!\n            if (changedParent != null) {\n                if (changedIndexs != null &&\n                    (maxCounter = changedIndexs.length) > 0) {\n                    Object       parentValue = changedParent.getUserObject();\n\n                    for(int counter = 0; counter < maxCounter; counter++) {\n                        FHTreeStateNode    child = changedParent.\n                                 getChildAtModelIndex(changedIndexs[counter]);\n\n                        if(child != null) {\n                            child.setUserObject(treeModel.getChild(parentValue,\n                                                     changedIndexs[counter]));\n                        }\n                    }\n                    if(changedParent.isVisible() && changedParent.isExpanded())\n                        visibleNodesChanged();\n                }\n                // Null for root indicates it changed.\n                else if (changedParent == root && changedParent.isVisible() &&\n                         changedParent.isExpanded()) {\n                    visibleNodesChanged();\n                }\n            }\n        }\n    }"}
{"Number":"1659","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-treeNodesInserted(TreeModelEvent)","Corresponding Source":"/**\n     * <p>Invoked after nodes have been inserted into the tree.<\/p>\n     *\n     * <p>e.path() returns the parent of the new nodes\n     * <p>e.childIndices() returns the indices of the new nodes in\n     * ascending order.\n     */\n    public void treeNodesInserted(TreeModelEvent e) {\n        if(e != null) {\n            int                 changedIndexs[];\n            FHTreeStateNode     changedParent = getNodeForPath\n                                  (SwingUtilities2.getTreePath(e, getModel()), false, false);\n            int                 maxCounter;\n\n            changedIndexs = e.getChildIndices();\n            /* Only need to update the children if the node has been\n               expanded once. */\n            // PENDING(scott): make sure childIndexs is sorted!\n            if(changedParent != null && changedIndexs != null &&\n               (maxCounter = changedIndexs.length) > 0) {\n                boolean          isVisible =\n                    (changedParent.isVisible() &&\n                     changedParent.isExpanded());\n\n                for(int counter = 0; counter < maxCounter; counter++) {\n                    changedParent.childInsertedAtModelIndex\n                        (changedIndexs[counter], isVisible);\n                }\n                if(isVisible && treeSelectionModel != null)\n                    treeSelectionModel.resetRowSelection();\n                if(changedParent.isVisible())\n                    this.visibleNodesChanged();\n            }\n        }\n    }"}
{"Number":"1660","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-treeNodesRemoved(TreeModelEvent)","Corresponding Source":"/**\n     * <p>Invoked after nodes have been removed from the tree.  Note that\n     * if a subtree is removed from the tree, this method may only be\n     * invoked once for the root of the removed subtree, not once for\n     * each individual set of siblings removed.<\/p>\n     *\n     * <p>e.path() returns the former parent of the deleted nodes.<\/p>\n     *\n     * <p>e.childIndices() returns the indices the nodes had before they were deleted in ascending order.<\/p>\n     */\n    public void treeNodesRemoved(TreeModelEvent e) {\n        if(e != null) {\n            int                  changedIndexs[];\n            int                  maxCounter;\n            TreePath             parentPath = SwingUtilities2.getTreePath(e, getModel());\n            FHTreeStateNode      changedParentNode = getNodeForPath\n                                       (parentPath, false, false);\n\n            changedIndexs = e.getChildIndices();\n            // PENDING(scott): make sure that changedIndexs are sorted in\n            // ascending order.\n            if(changedParentNode != null && changedIndexs != null &&\n               (maxCounter = changedIndexs.length) > 0) {\n                Object[]           children = e.getChildren();\n                boolean            isVisible =\n                    (changedParentNode.isVisible() &&\n                     changedParentNode.isExpanded());\n\n                for(int counter = maxCounter - 1; counter >= 0; counter--) {\n                    changedParentNode.removeChildAtModelIndex\n                                     (changedIndexs[counter], isVisible);\n                }\n                if(isVisible) {\n                    if(treeSelectionModel != null)\n                        treeSelectionModel.resetRowSelection();\n                    if (treeModel.getChildCount(changedParentNode.\n                                                getUserObject()) == 0 &&\n                                  changedParentNode.isLeaf()) {\n                        // Node has become a leaf, collapse it.\n                        changedParentNode.collapse(false);\n                    }\n                    visibleNodesChanged();\n                }\n                else if(changedParentNode.isVisible())\n                    visibleNodesChanged();\n            }\n        }\n    }"}
{"Number":"1661","API Relative Path":"javax.swing.tree.FixedHeightLayoutCache.java-treeStructureChanged(TreeModelEvent)","Corresponding Source":"/**\n     * <p>Invoked after the tree has drastically changed structure from a\n     * given node down.  If the path returned by e.getPath() is of length\n     * one and the first element does not identify the current root node\n     * the first element should become the new root of the tree.\n     *\n     * <p>e.path() holds the path to the node.<\/p>\n     * <p>e.childIndices() returns null.<\/p>\n     */\n    public void treeStructureChanged(TreeModelEvent e) {\n        if(e != null) {\n            TreePath          changedPath = SwingUtilities2.getTreePath(e, getModel());\n            FHTreeStateNode   changedNode = getNodeForPath\n                                                (changedPath, false, false);\n\n            // Check if root has changed, either to a null root, or\n            // to an entirely new root.\n            if (changedNode == root ||\n                (changedNode == null &&\n                 ((changedPath == null && treeModel != null &&\n                   treeModel.getRoot() == null) ||\n                  (changedPath != null && changedPath.getPathCount() <= 1)))) {\n                rebuild(true);\n            }\n            else if(changedNode != null) {\n                boolean             wasExpanded, wasVisible;\n                FHTreeStateNode     parent = (FHTreeStateNode)\n                                              changedNode.getParent();\n\n                wasExpanded = changedNode.isExpanded();\n                wasVisible = changedNode.isVisible();\n\n                int index = parent.getIndex(changedNode);\n                changedNode.collapse(false);\n                parent.remove(index);\n\n                if(wasVisible && wasExpanded) {\n                    int row = changedNode.getRow();\n                    parent.resetChildrenRowsFrom(row, index,\n                                                 changedNode.getChildIndex());\n                    changedNode = getNodeForPath(changedPath, false, true);\n                    changedNode.expand();\n                }\n                if(treeSelectionModel != null && wasVisible && wasExpanded)\n                    treeSelectionModel.resetRowSelection();\n                if(wasVisible)\n                    this.visibleNodesChanged();\n            }\n        }\n    }"}
{"Number":"1662","API Relative Path":"javax.swing.tree.TreePath.java-getPathComponent(int)","Corresponding Source":"/**\n     * Returns the path element at the specified index.\n     *\n     * @param index the index of the element requested\n     * @return the element at the specified index\n     * @throws IllegalArgumentException if the index is outside the\n     *         range of this path\n     */\n    public Object getPathComponent(int index) {\n        int          pathLength = getPathCount();\n\n        if(index < 0 || index >= pathLength)\n            throw new IllegalArgumentException(\"Index \" + index +\n                                           \" is out of the specified range\");\n\n        TreePath         path = this;\n\n        for(int i = pathLength-1; i != index; i--) {\n            path = path.getParentPath();\n        }\n        return path.getLastPathComponent();\n    }"}
{"Number":"1663","API Relative Path":"javax.swing.tree.TreePath.java-pathByAddingChild(Object)","Corresponding Source":"/**\n     * Returns a new path containing all the elements of this path\n     * plus <code>child<\/code>. <code>child<\/code> is the last element\n     * of the newly created {@code TreePath}.\n     *\n     * @param child the path element to add\n     * @throws NullPointerException if {@code child} is {@code null}\n     */\n    public TreePath pathByAddingChild(Object child) {\n        if(child == null)\n            throw new NullPointerException(\"Null child not allowed\");\n\n        return new TreePath(this, child);\n    }"}
{"Number":"1664","API Relative Path":"javax.swing.tree.VariableHeightLayoutCache.java-getBounds(TreePath-Rectangle)","Corresponding Source":"/**\n      * Returns the <code>Rectangle<\/code> enclosing the label portion\n      * into which the item identified by <code>path<\/code> will be drawn.\n      *\n      * @param path  the path to be drawn\n      * @param placeIn the bounds of the enclosing rectangle\n      * @return the bounds of the enclosing rectangle or <code>null<\/code>\n      *    if the node could not be ascertained\n      */\n    public Rectangle getBounds(TreePath path, Rectangle placeIn) {\n        TreeStateNode       node = getNodeForPath(path, true, false);\n\n        if(node != null) {\n            if(updateNodeSizes)\n                updateNodeSizes(false);\n            return node.getNodeBounds(placeIn);\n        }\n        return null;\n    }"}
{"Number":"1665","API Relative Path":"javax.swing.tree.VariableHeightLayoutCache.java-getExpandedState(TreePath)","Corresponding Source":"/**\n     * Returns true if the path is expanded, and visible.\n     * @return true if the path is expanded and visible, otherwise false\n     */\n    public boolean getExpandedState(TreePath path) {\n        TreeStateNode       node = getNodeForPath(path, true, false);\n\n        return (node != null) ? (node.isVisible() && node.isExpanded()) :\n                                 false;\n    }"}
{"Number":"1666","API Relative Path":"javax.swing.tree.VariableHeightLayoutCache.java-getRowForPath(TreePath)","Corresponding Source":"/**\n      * Returns the row where the last item identified in path is visible.\n      * Will return -1 if any of the elements in path are not\n      * currently visible.\n      *\n      * @param path the <code>TreePath<\/code> of interest\n      * @return the row where the last item in path is visible\n      */\n    public int getRowForPath(TreePath path) {\n        if(path == null)\n            return -1;\n\n        TreeStateNode    visNode = getNodeForPath(path, true, false);\n\n        if(visNode != null)\n            return visNode.getRow();\n        return -1;\n    }"}
{"Number":"1667","API Relative Path":"javax.swing.tree.VariableHeightLayoutCache.java-getVisibleChildCount(TreePath)","Corresponding Source":"/**\n     * Returns the number of visible children for <code>path<\/code>.\n     * @return the number of visible children for <code>path<\/code>\n     */\n    public int getVisibleChildCount(TreePath path) {\n        TreeStateNode         node = getNodeForPath(path, true, false);\n\n        return (node != null) ? node.getVisibleChildCount() : 0;\n    }"}
{"Number":"1668","API Relative Path":"javax.swing.tree.VariableHeightLayoutCache.java-getVisiblePathsFrom(TreePath)","Corresponding Source":"/**\n     * Returns an <code>Enumerator<\/code> that increments over the visible paths\n     * starting at the passed in location. The ordering of the enumeration\n     * is based on how the paths are displayed.\n     *\n     * @param path the location in the <code>TreePath<\/code> to start\n     * @return an <code>Enumerator<\/code> that increments over the visible\n     *     paths\n     */\n    public Enumeration<TreePath> getVisiblePathsFrom(TreePath path) {\n        TreeStateNode       node = getNodeForPath(path, true, false);\n\n        if(node != null) {\n            return new VisibleTreeStateNodeEnumeration(node);\n        }\n        return null;\n    }"}
{"Number":"1669","API Relative Path":"javax.swing.tree.VariableHeightLayoutCache.java-invalidatePathBounds(TreePath)","Corresponding Source":"/**\n     * Instructs the <code>LayoutCache<\/code> that the bounds for\n     * <code>path<\/code> are invalid, and need to be updated.\n     *\n     * @param path the <code>TreePath<\/code> which is now invalid\n     */\n    public void invalidatePathBounds(TreePath path) {\n        TreeStateNode       node = getNodeForPath(path, true, false);\n\n        if(node != null) {\n            node.markSizeInvalid();\n            if(node.isVisible())\n                updateYLocationsFrom(node.getRow());\n        }\n    }"}
{"Number":"1670","API Relative Path":"javax.swing.tree.VariableHeightLayoutCache.java-isExpanded(TreePath)","Corresponding Source":"/**\n      * Returns true if the value identified by <code>path<\/code> is\n      * currently expanded.\n      * @return true if the value identified by <code>path<\/code> is\n      *    currently expanded\n      */\n    public boolean isExpanded(TreePath path) {\n        if(path != null) {\n            TreeStateNode     lastNode = getNodeForPath(path, true, false);\n\n            return (lastNode != null && lastNode.isExpanded());\n        }\n        return false;\n    }"}
{"Number":"1671","API Relative Path":"javax.swing.tree.VariableHeightLayoutCache.java-setExpandedState(TreePath-boolean)","Corresponding Source":"/**\n     * Marks the path <code>path<\/code> expanded state to\n     * <code>isExpanded<\/code>.\n     * @param path the <code>TreePath<\/code> of interest\n     * @param isExpanded true if the path should be expanded, otherwise false\n     */\n    public void setExpandedState(TreePath path, boolean isExpanded) {\n        if(path != null) {\n            if(isExpanded)\n                ensurePathIsExpanded(path, true);\n            else {\n                TreeStateNode        node = getNodeForPath(path, false, true);\n\n                if(node != null) {\n                    node.makeVisible();\n                    node.collapse();\n                }\n            }\n        }\n    }"}
{"Number":"1672","API Relative Path":"javax.swing.tree.VariableHeightLayoutCache.java-setExpandedState(TreePath-boolean)","Corresponding Source":"/**\n     * Marks the path <code>path<\/code> expanded state to\n     * <code>isExpanded<\/code>.\n     * @param path the <code>TreePath<\/code> of interest\n     * @param isExpanded true if the path should be expanded, otherwise false\n     */\n    public void setExpandedState(TreePath path, boolean isExpanded) {\n        if(path != null) {\n            if(isExpanded)\n                ensurePathIsExpanded(path, true);\n            else {\n                TreeStateNode        node = getNodeForPath(path, false, true);\n\n                if(node != null) {\n                    node.makeVisible();\n                    node.collapse();\n                }\n            }\n        }\n    }"}
{"Number":"1673","API Relative Path":"javax.swing.tree.VariableHeightLayoutCache.java-setExpandedState(TreePath-boolean)","Corresponding Source":"/**\n     * Marks the path <code>path<\/code> expanded state to\n     * <code>isExpanded<\/code>.\n     * @param path the <code>TreePath<\/code> of interest\n     * @param isExpanded true if the path should be expanded, otherwise false\n     */\n    public void setExpandedState(TreePath path, boolean isExpanded) {\n        if(path != null) {\n            if(isExpanded)\n                ensurePathIsExpanded(path, true);\n            else {\n                TreeStateNode        node = getNodeForPath(path, false, true);\n\n                if(node != null) {\n                    node.makeVisible();\n                    node.collapse();\n                }\n            }\n        }\n    }"}
{"Number":"1674","API Relative Path":"javax.swing.tree.VariableHeightLayoutCache.java-setExpandedState(TreePath-boolean)","Corresponding Source":"/**\n     * Marks the path <code>path<\/code> expanded state to\n     * <code>isExpanded<\/code>.\n     * @param path the <code>TreePath<\/code> of interest\n     * @param isExpanded true if the path should be expanded, otherwise false\n     */\n    public void setExpandedState(TreePath path, boolean isExpanded) {\n        if(path != null) {\n            if(isExpanded)\n                ensurePathIsExpanded(path, true);\n            else {\n                TreeStateNode        node = getNodeForPath(path, false, true);\n\n                if(node != null) {\n                    node.makeVisible();\n                    node.collapse();\n                }\n            }\n        }\n    }"}
{"Number":"1675","API Relative Path":"javax.swing.tree.VariableHeightLayoutCache.java-treeNodesChanged(TreeModelEvent)","Corresponding Source":"//\n    // TreeModelListener methods\n    //\n\n    /**\n     * Invoked after a node (or a set of siblings) has changed in some\n     * way. The node(s) have not changed locations in the tree or\n     * altered their children arrays, but other attributes have\n     * changed and may affect presentation. Example: the name of a\n     * file has changed, but it is in the same location in the file\n     * system.\n     *\n     * <p><code>e.path<\/code> returns the path the parent of the\n     * changed node(s).\n     *\n     * <p><code>e.childIndices<\/code> returns the index(es) of the\n     * changed node(s).\n     *\n     * @param e the <code>TreeModelEvent<\/code> of interest\n     */\n    public void treeNodesChanged(TreeModelEvent e) {\n        if(e != null) {\n            int               changedIndexs[];\n            TreeStateNode     changedNode;\n\n            changedIndexs = e.getChildIndices();\n            changedNode = getNodeForPath(SwingUtilities2.getTreePath(e, getModel()), false, false);\n            if(changedNode != null) {\n                Object            changedValue = changedNode.getValue();\n\n                /* Update the size of the changed node, as well as all the\n                   child indexs that are passed in. */\n                changedNode.updatePreferredSize();\n                if(changedNode.hasBeenExpanded() && changedIndexs != null) {\n                    int                counter;\n                    TreeStateNode      changedChildNode;\n\n                    for(counter = 0; counter < changedIndexs.length;\n                        counter++) {\n                        changedChildNode = (TreeStateNode)changedNode\n                                    .getChildAt(changedIndexs[counter]);\n                        /* Reset the user object. */\n                        changedChildNode.setUserObject\n                                    (treeModel.getChild(changedValue,\n                                                     changedIndexs[counter]));\n                        changedChildNode.updatePreferredSize();\n                    }\n                }\n                else if (changedNode == root) {\n                    // Null indicies for root indicates it changed.\n                    changedNode.updatePreferredSize();\n                }\n                if(!isFixedRowHeight()) {\n                    int          aRow = changedNode.getRow();\n\n                    if(aRow != -1)\n                        this.updateYLocationsFrom(aRow);\n                }\n                this.visibleNodesChanged();\n            }\n        }\n    }"}
{"Number":"1676","API Relative Path":"javax.swing.tree.VariableHeightLayoutCache.java-treeNodesInserted(TreeModelEvent)","Corresponding Source":"/**\n     * Invoked after nodes have been inserted into the tree.\n     *\n     * <p><code>e.path<\/code> returns the parent of the new nodes.\n     * <p><code>e.childIndices<\/code> returns the indices of the new nodes in\n     * ascending order.\n     *\n     * @param e the <code>TreeModelEvent<\/code> of interest\n     */\n    public void treeNodesInserted(TreeModelEvent e) {\n        if(e != null) {\n            int               changedIndexs[];\n            TreeStateNode     changedParentNode;\n\n            changedIndexs = e.getChildIndices();\n            changedParentNode = getNodeForPath(SwingUtilities2.getTreePath(e, getModel()), false, false);\n            /* Only need to update the children if the node has been\n               expanded once. */\n            // PENDING(scott): make sure childIndexs is sorted!\n            if(changedParentNode != null && changedIndexs != null &&\n               changedIndexs.length > 0) {\n                if(changedParentNode.hasBeenExpanded()) {\n                    boolean            makeVisible;\n                    int                counter;\n                    Object             changedParent;\n                    TreeStateNode      newNode;\n                    int                oldChildCount = changedParentNode.\n                                          getChildCount();\n\n                    changedParent = changedParentNode.getValue();\n                    makeVisible = ((changedParentNode == root &&\n                                    !rootVisible) ||\n                                   (changedParentNode.getRow() != -1 &&\n                                    changedParentNode.isExpanded()));\n                    for(counter = 0;counter < changedIndexs.length;counter++)\n                    {\n                        newNode = this.createNodeAt(changedParentNode,\n                                                    changedIndexs[counter]);\n                    }\n                    if(oldChildCount == 0) {\n                        // Update the size of the parent.\n                        changedParentNode.updatePreferredSize();\n                    }\n                    if(treeSelectionModel != null)\n                        treeSelectionModel.resetRowSelection();\n                    /* Update the y origins from the index of the parent\n                       to the end of the visible rows. */\n                    if(!isFixedRowHeight() && (makeVisible ||\n                                               (oldChildCount == 0 &&\n                                        changedParentNode.isVisible()))) {\n                        if(changedParentNode == root)\n                            this.updateYLocationsFrom(0);\n                        else\n                            this.updateYLocationsFrom(changedParentNode.\n                                                      getRow());\n                        this.visibleNodesChanged();\n                    }\n                    else if(makeVisible)\n                        this.visibleNodesChanged();\n                }\n                else if(treeModel.getChildCount(changedParentNode.getValue())\n                        - changedIndexs.length == 0) {\n                    changedParentNode.updatePreferredSize();\n                    if(!isFixedRowHeight() && changedParentNode.isVisible())\n                        updateYLocationsFrom(changedParentNode.getRow());\n                }\n            }\n        }\n    }"}
{"Number":"1677","API Relative Path":"javax.swing.tree.VariableHeightLayoutCache.java-treeNodesRemoved(TreeModelEvent)","Corresponding Source":"/**\n     * Invoked after nodes have been removed from the tree.  Note that\n     * if a subtree is removed from the tree, this method may only be\n     * invoked once for the root of the removed subtree, not once for\n     * each individual set of siblings removed.\n     *\n     * <p><code>e.path<\/code> returns the former parent of the deleted nodes.\n     *\n     * <p><code>e.childIndices<\/code> returns the indices the nodes had\n     * before they were deleted in ascending order.\n     *\n     * @param e the <code>TreeModelEvent<\/code> of interest\n     */\n    public void treeNodesRemoved(TreeModelEvent e) {\n        if(e != null) {\n            int               changedIndexs[];\n            TreeStateNode     changedParentNode;\n\n            changedIndexs = e.getChildIndices();\n            changedParentNode = getNodeForPath(SwingUtilities2.getTreePath(e, getModel()), false, false);\n            // PENDING(scott): make sure that changedIndexs are sorted in\n            // ascending order.\n            if(changedParentNode != null && changedIndexs != null &&\n               changedIndexs.length > 0) {\n                if(changedParentNode.hasBeenExpanded()) {\n                    boolean            makeInvisible;\n                    int                counter;\n                    int                removedRow;\n                    TreeStateNode      removedNode;\n\n                    makeInvisible = ((changedParentNode == root &&\n                                      !rootVisible) ||\n                                     (changedParentNode.getRow() != -1 &&\n                                      changedParentNode.isExpanded()));\n                    for(counter = changedIndexs.length - 1;counter >= 0;\n                        counter--) {\n                        removedNode = (TreeStateNode)changedParentNode.\n                                getChildAt(changedIndexs[counter]);\n                        if(removedNode.isExpanded()) {\n                            removedNode.collapse(false);\n                        }\n\n                        /* Let the selection model now. */\n                        if(makeInvisible) {\n                            removedRow = removedNode.getRow();\n                            if(removedRow != -1) {\n                                visibleNodes.removeElementAt(removedRow);\n                            }\n                        }\n                        changedParentNode.remove(changedIndexs[counter]);\n                    }\n                    if(changedParentNode.getChildCount() == 0) {\n                        // Update the size of the parent.\n                        changedParentNode.updatePreferredSize();\n                        if (changedParentNode.isExpanded() &&\n                                   changedParentNode.isLeaf()) {\n                            // Node has become a leaf, collapse it.\n                            changedParentNode.collapse(false);\n                        }\n                    }\n                    if(treeSelectionModel != null)\n                        treeSelectionModel.resetRowSelection();\n                    /* Update the y origins from the index of the parent\n                       to the end of the visible rows. */\n                    if(!isFixedRowHeight() && (makeInvisible ||\n                               (changedParentNode.getChildCount() == 0 &&\n                                changedParentNode.isVisible()))) {\n                        if(changedParentNode == root) {\n                            /* It is possible for first row to have been\n                               removed if the root isn't visible, in which\n                               case ylocations will be off! */\n                            if(getRowCount() > 0)\n                                getNode(0).setYOrigin(0);\n                            updateYLocationsFrom(0);\n                        }\n                        else\n                            updateYLocationsFrom(changedParentNode.getRow());\n                        this.visibleNodesChanged();\n                    }\n                    else if(makeInvisible)\n                        this.visibleNodesChanged();\n                }\n                else if(treeModel.getChildCount(changedParentNode.getValue())\n                        == 0) {\n                    changedParentNode.updatePreferredSize();\n                    if(!isFixedRowHeight() && changedParentNode.isVisible())\n                        this.updateYLocationsFrom(changedParentNode.getRow());\n                }\n            }\n        }\n    }"}
{"Number":"1678","API Relative Path":"javax.swing.tree.VariableHeightLayoutCache.java-treeStructureChanged(TreeModelEvent)","Corresponding Source":"/**\n     * Invoked after the tree has drastically changed structure from a\n     * given node down.  If the path returned by <code>e.getPath<\/code>\n     * is of length one and the first element does not identify the\n     * current root node the first element should become the new root\n     * of the tree.\n     *\n     * <p><code>e.path<\/code> holds the path to the node.\n     * <p><code>e.childIndices<\/code> returns <code>null<\/code>.\n     *\n     * @param e the <code>TreeModelEvent<\/code> of interest\n     */\n    public void treeStructureChanged(TreeModelEvent e) {\n        if(e != null)\n        {\n            TreePath          changedPath = SwingUtilities2.getTreePath(e, getModel());\n            TreeStateNode     changedNode;\n\n            changedNode = getNodeForPath(changedPath, false, false);\n\n            // Check if root has changed, either to a null root, or\n            // to an entirely new root.\n            if(changedNode == root ||\n               (changedNode == null &&\n                ((changedPath == null && treeModel != null &&\n                  treeModel.getRoot() == null) ||\n                 (changedPath != null && changedPath.getPathCount() == 1)))) {\n                rebuild(true);\n            }\n            else if(changedNode != null) {\n                int                              nodeIndex, oldRow;\n                TreeStateNode                    newNode, parent;\n                boolean                          wasExpanded, wasVisible;\n                int                              newIndex;\n\n                wasExpanded = changedNode.isExpanded();\n                wasVisible = (changedNode.getRow() != -1);\n                /* Remove the current node and recreate a new one. */\n                parent = (TreeStateNode)changedNode.getParent();\n                nodeIndex = parent.getIndex(changedNode);\n                if(wasVisible && wasExpanded) {\n                    changedNode.collapse(false);\n                }\n                if(wasVisible)\n                    visibleNodes.removeElement(changedNode);\n                changedNode.removeFromParent();\n                createNodeAt(parent, nodeIndex);\n                newNode = (TreeStateNode)parent.getChildAt(nodeIndex);\n                if(wasVisible && wasExpanded)\n                    newNode.expand(false);\n                newIndex = newNode.getRow();\n                if(!isFixedRowHeight() && wasVisible) {\n                    if(newIndex == 0)\n                        updateYLocationsFrom(newIndex);\n                    else\n                        updateYLocationsFrom(newIndex - 1);\n                    this.visibleNodesChanged();\n                }\n                else if(wasVisible)\n                    this.visibleNodesChanged();\n            }\n        }\n    }"}
{"Number":"1679","API Relative Path":"javax.swing.UIDefaults.java-addResourceBundle(String)","Corresponding Source":"/**\n     * Adds a resource bundle to the list of resource bundles that are\n     * searched for localized values.  Resource bundles are searched in the\n     * reverse order they were added.  In other words, the most recently added\n     * bundle is searched first.\n     *\n     * @param bundleName  the base name of the resource bundle to be added\n     * @see java.util.ResourceBundle\n     * @see #removeResourceBundle\n     * @since 1.4\n     */\n    public synchronized void addResourceBundle( String bundleName ) {\n        if( bundleName == null ) {\n            return;\n        }\n        if( resourceBundles == null ) {\n            resourceBundles = new Vector<String>(5);\n        }\n        if (!resourceBundles.contains(bundleName)) {\n            resourceBundles.add( bundleName );\n            resourceCache.clear();\n        }\n    }"}
{"Number":"1680","API Relative Path":"javax.swing.UIDefaults.java-get(Object-Locale)","Corresponding Source":"/**\n     * Returns the value for key associated with the given locale.\n     * If the value is a <code>UIDefaults.LazyValue<\/code> then the real\n     * value is computed with <code>LazyValue.createValue()<\/code>,\n     * the table entry is replaced, and the real value is returned.\n     * If the value is an <code>UIDefaults.ActiveValue<\/code>\n     * the table entry is not replaced - the value is computed\n     * with <code>ActiveValue.createValue()<\/code> for each\n     * <code>get()<\/code> call.\n     *\n     * If the key is not found in the table then it is searched for in the list\n     * of resource bundles maintained by this object.  The resource bundles are\n     * searched most recently added first using the given locale.\n     * <code>LazyValues<\/code> and <code>ActiveValues<\/code> are not supported\n     * in the resource bundles.\n     *\n     * @param key the desired key\n     * @param l the desired <code>locale<\/code>\n     * @return the value for <code>key<\/code>\n     * @see LazyValue\n     * @see ActiveValue\n     * @see java.util.Hashtable#get\n     * @see #addResourceBundle\n     * @since 1.4\n     */\n    public Object get(Object key, Locale l) {\n        Object value = getFromHashtable( key );\n        return (value != null) ? value : getFromResourceBundle(key, l);\n    }"}
{"Number":"1681","API Relative Path":"javax.swing.UIDefaults.java-getBoolean(Object-Locale)","Corresponding Source":"/**\n     * If the value of <code>key<\/code> for the given <code>Locale<\/code>\n     * is boolean, return the boolean value, otherwise return false.\n     *\n     * @param key an <code>Object<\/code> specifying the key for the desired boolean value\n     * @param l the desired locale\n     * @return if the value for <code>key<\/code> and <code>Locale<\/code>\n     *         is boolean, return the\n     *         boolean value, otherwise return false.\n     * @since 1.4\n     */\n    public boolean getBoolean(Object key, Locale l) {\n        Object value = get(key,l);\n        return (value instanceof Boolean) ? ((Boolean)value).booleanValue() : false;\n    }"}
{"Number":"1682","API Relative Path":"javax.swing.UIDefaults.java-getBorder(Object-Locale)","Corresponding Source":"/**\n     * If the value of <code>key<\/code> for the given <code>Locale<\/code>\n     * is a <code>Border<\/code> return it, otherwise return <code>null<\/code>.\n     * @param key the desired key\n     * @param l the desired locale\n     * @return if the value for <code>key<\/code> and <code>Locale<\/code>\n     *          is a <code>Border<\/code>,\n     *          return the <code>Border<\/code> object; otherwise return\n     *          <code>null<\/code>\n     * @since 1.4\n     */\n    public Border getBorder(Object key, Locale l)  {\n        Object value = get(key,l);\n        return (value instanceof Border) ? (Border)value : null;\n    }"}
{"Number":"1683","API Relative Path":"javax.swing.UIDefaults.java-getColor(Object-Locale)","Corresponding Source":"/**\n     * If the value of <code>key<\/code> for the given <code>Locale<\/code>\n     * is a <code>Color<\/code> return it, otherwise return <code>null<\/code>.\n     * @param key the desired key\n     * @param l the desired locale\n     * @return if the value for <code>key<\/code> and <code>Locale<\/code>\n     *          is a <code>Color<\/code>,\n     *          return the <code>Color<\/code> object; otherwise return\n     *          <code>null<\/code>\n     * @since 1.4\n     */\n    public Color getColor(Object key, Locale l) {\n        Object value = get(key,l);\n        return (value instanceof Color) ? (Color)value : null;\n    }"}
{"Number":"1684","API Relative Path":"javax.swing.UIDefaults.java-getDimension(Object-Locale)","Corresponding Source":"/**\n     * If the value of <code>key<\/code> for the given <code>Locale<\/code>\n     * is a <code>Dimension<\/code> return it, otherwise return <code>null<\/code>.\n     * @param key the desired key\n     * @param l the desired locale\n     * @return if the value for <code>key<\/code> and <code>Locale<\/code>\n     *          is a <code>Dimension<\/code>,\n     *          return the <code>Dimension<\/code> object; otherwise return\n     *          <code>null<\/code>\n     * @since 1.4\n     */\n    public Dimension getDimension(Object key, Locale l) {\n        Object value = get(key,l);\n        return (value instanceof Dimension) ? (Dimension)value : null;\n    }"}
{"Number":"1685","API Relative Path":"javax.swing.UIDefaults.java-getFont(Object-Locale)","Corresponding Source":"/**\n     * If the value of <code>key<\/code> for the given <code>Locale<\/code>\n     * is a <code>Font<\/code> return it, otherwise return <code>null<\/code>.\n     * @param key the desired key\n     * @param l the desired locale\n     * @return if the value for <code>key<\/code> and <code>Locale<\/code>\n     *          is a <code>Font<\/code>,\n     *          return the <code>Font<\/code> object; otherwise return\n     *          <code>null<\/code>\n     * @since 1.4\n     */\n    public Font getFont(Object key, Locale l) {\n        Object value = get(key,l);\n        return (value instanceof Font) ? (Font)value : null;\n    }"}
{"Number":"1686","API Relative Path":"javax.swing.UIDefaults.java-getIcon(Object-Locale)","Corresponding Source":"/**\n     * If the value of <code>key<\/code> for the given <code>Locale<\/code>\n     * is an <code>Icon<\/code> return it, otherwise return <code>null<\/code>.\n     * @param key the desired key\n     * @param l the desired locale\n     * @return if the value for <code>key<\/code> and <code>Locale<\/code>\n     *          is an <code>Icon<\/code>,\n     *          return the <code>Icon<\/code> object; otherwise return\n     *          <code>null<\/code>\n     * @since 1.4\n     */\n    public Icon getIcon(Object key, Locale l) {\n        Object value = get(key,l);\n        return (value instanceof Icon) ? (Icon)value : null;\n    }"}
{"Number":"1687","API Relative Path":"javax.swing.UIDefaults.java-getInsets(Object-Locale)","Corresponding Source":"/**\n     * If the value of <code>key<\/code> for the given <code>Locale<\/code>\n     * is an <code>Insets<\/code> return it, otherwise return <code>null<\/code>.\n     * @param key the desired key\n     * @param l the desired locale\n     * @return if the value for <code>key<\/code> and <code>Locale<\/code>\n     *          is an <code>Insets<\/code>,\n     *          return the <code>Insets<\/code> object; otherwise return\n     *          <code>null<\/code>\n     * @since 1.4\n     */\n    public Insets getInsets(Object key, Locale l) {\n        Object value = get(key,l);\n        return (value instanceof Insets) ? (Insets)value : null;\n    }"}
{"Number":"1688","API Relative Path":"javax.swing.UIDefaults.java-getInt(Object-Locale)","Corresponding Source":"/**\n     * If the value of <code>key<\/code> for the given <code>Locale<\/code>\n     * is an <code>Integer<\/code> return its integer value, otherwise return 0.\n     * @param key the desired key\n     * @param l the desired locale\n     * @return if the value for <code>key<\/code> and <code>Locale<\/code>\n     *          is an <code>Integer<\/code>,\n     *          return its value, otherwise return 0\n     * @since 1.4\n     */\n    public int getInt(Object key, Locale l) {\n        Object value = get(key,l);\n        return (value instanceof Integer) ? ((Integer)value).intValue() : 0;\n    }"}
{"Number":"1689","API Relative Path":"javax.swing.UIDefaults.java-getString(Object-Locale)","Corresponding Source":"/**\n     * If the value of <code>key<\/code> for the given <code>Locale<\/code>\n     * is a <code>String<\/code> return it, otherwise return <code>null<\/code>.\n     * @param key the desired key\n     * @param l the desired <code>Locale<\/code>\n     * @return if the value for <code>key<\/code> for the given\n     *          <code>Locale<\/code> is a <code>String<\/code>,\n     *          return the <code>String<\/code> object; otherwise return\n     *          <code>null<\/code>\n     * @since 1.4\n     */\n    public String getString(Object key, Locale l) {\n        Object value = get(key,l);\n        return (value instanceof String) ? (String)value : null;\n    }"}
