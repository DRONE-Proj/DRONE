{"Number":"1","API Relative Path":"src.android.accounts.AccountManager.java-addAccountAsUser(String-String-String[]-Bundle-Activity-AccountManagerCallback-Handler-UserHandle)","Corresponding Source":"/**\n     * @see #addAccount(String, String, String[], Bundle, Activity, AccountManagerCallback, Handler)\n     * @hide\n     */\n    public AccountManagerFuture<Bundle> addAccountAsUser(final String accountType,\n            final String authTokenType, final String[] requiredFeatures,\n            final Bundle addAccountOptions, final Activity activity,\n            AccountManagerCallback<Bundle> callback, Handler handler, final UserHandle userHandle) {\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n        if (userHandle == null) throw new IllegalArgumentException(\"userHandle is null\");\n        final Bundle optionsIn = new Bundle();\n        if (addAccountOptions != null) {\n            optionsIn.putAll(addAccountOptions);\n        }\n        optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());\n\n        return new AmsTask(activity, handler, callback) {\n            @Override\n            public void doWork() throws RemoteException {\n                mService.addAccountAsUser(mResponse, accountType, authTokenType,\n                        requiredFeatures, activity != null, optionsIn, userHandle.getIdentifier());\n            }\n        }.start();\n    }"}
{"Number":"2","API Relative Path":"src.android.accounts.AccountManager.java-addAccountAsUser(String-String-String[]-Bundle-Activity-AccountManagerCallback-Handler-UserHandle)","Corresponding Source":"/**\n     * @see #addAccount(String, String, String[], Bundle, Activity, AccountManagerCallback, Handler)\n     * @hide\n     */\n    public AccountManagerFuture<Bundle> addAccountAsUser(final String accountType,\n            final String authTokenType, final String[] requiredFeatures,\n            final Bundle addAccountOptions, final Activity activity,\n            AccountManagerCallback<Bundle> callback, Handler handler, final UserHandle userHandle) {\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n        if (userHandle == null) throw new IllegalArgumentException(\"userHandle is null\");\n        final Bundle optionsIn = new Bundle();\n        if (addAccountOptions != null) {\n            optionsIn.putAll(addAccountOptions);\n        }\n        optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());\n\n        return new AmsTask(activity, handler, callback) {\n            @Override\n            public void doWork() throws RemoteException {\n                mService.addAccountAsUser(mResponse, accountType, authTokenType,\n                        requiredFeatures, activity != null, optionsIn, userHandle.getIdentifier());\n            }\n        }.start();\n    }"}
{"Number":"3","API Relative Path":"src.android.accounts.AccountManager.java-addAccountExplicitly(Account-String-Bundle)","Corresponding Source":"/**\n     * Adds an account directly to the AccountManager. Normally used by sign-up\n     * wizards associated with authenticators, not directly by applications.\n     * <p>Calling this method does not update the last authenticated timestamp,\n     * referred by {@link #KEY_LAST_AUTHENTICATED_TIME}. To update it, call\n     * {@link #notifyAccountAuthenticated(Account)} after getting success.\n     * However, if this method is called when it is triggered by addAccount() or\n     * addAccountAsUser() or similar functions, then there is no need to update\n     * timestamp manually as it is updated automatically by framework on\n     * successful completion of the mentioned functions.\n     * <p>It is safe to call this method from the main thread.\n     * <p>This method requires the caller to have a signature match with the\n     * authenticator that owns the specified account.\n     *\n     * <p><b>NOTE:<\/b> If targeting your app to work on API level 22 and before,\n     * AUTHENTICATE_ACCOUNTS permission is needed for those platforms. See docs\n     * for this function in API level 22.\n     *\n     * @param account The {@link Account} to add\n     * @param password The password to associate with the account, null for none\n     * @param userdata String values to use for the account's userdata, null for\n     *            none\n     * @return True if the account was successfully added, false if the account\n     *         already exists, the account is null, or another error occurs.\n     */\n    public boolean addAccountExplicitly(Account account, String password, Bundle userdata) {\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        try {\n            return mService.addAccountExplicitly(account, password, userdata);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"4","API Relative Path":"src.android.accounts.AccountManager.java-blockingGetAuthToken(Account-String-boolean)","Corresponding Source":"/**\n     * This convenience helper synchronously gets an auth token with\n     * {@link #getAuthToken(Account, String, boolean, AccountManagerCallback, Handler)}.\n     *\n     * <p>This method may block while a network request completes, and must\n     * never be made from the main thread.\n     *\n     * <p><b>NOTE:<\/b> If targeting your app to work on API level 22 and before,\n     * USE_CREDENTIALS permission is needed for those platforms. See docs for\n     * this function in API level 22.\n     *\n     * @param account The account to fetch an auth token for\n     * @param authTokenType The auth token type, see {@link #getAuthToken getAuthToken()}\n     * @param notifyAuthFailure If true, display a notification and return null\n     *     if authentication fails; if false, prompt and wait for the user to\n     *     re-enter correct credentials before returning\n     * @return An auth token of the specified type for this account, or null\n     *     if authentication fails or none can be fetched.\n     * @throws AuthenticatorException if the authenticator failed to respond\n     * @throws OperationCanceledException if the request was canceled for any\n     *     reason, including the user canceling a credential request\n     * @throws java.io.IOException if the authenticator experienced an I/O problem\n     *     creating a new auth token, usually because of network trouble\n     */\n    public String blockingGetAuthToken(Account account, String authTokenType,\n            boolean notifyAuthFailure)\n            throws OperationCanceledException, IOException, AuthenticatorException {\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        if (authTokenType == null) throw new IllegalArgumentException(\"authTokenType is null\");\n        Bundle bundle = getAuthToken(account, authTokenType, notifyAuthFailure, null /* callback */,\n                null /* handler */).getResult();\n        if (bundle == null) {\n            // This should never happen, but it does, occasionally. If it does return null to\n            // signify that we were not able to get the authtoken.\n            // TODO: remove this when the bug is found that sometimes causes a null bundle to be\n            // returned\n            Log.e(TAG, \"blockingGetAuthToken: null was returned from getResult() for \"\n                    + account + \", authTokenType \" + authTokenType);\n            return null;\n        }\n        return bundle.getString(KEY_AUTHTOKEN);\n    }"}
{"Number":"5","API Relative Path":"src.android.accounts.AccountManager.java-blockingGetAuthToken(Account-String-boolean)","Corresponding Source":"/**\n     * This convenience helper synchronously gets an auth token with\n     * {@link #getAuthToken(Account, String, boolean, AccountManagerCallback, Handler)}.\n     *\n     * <p>This method may block while a network request completes, and must\n     * never be made from the main thread.\n     *\n     * <p><b>NOTE:<\/b> If targeting your app to work on API level 22 and before,\n     * USE_CREDENTIALS permission is needed for those platforms. See docs for\n     * this function in API level 22.\n     *\n     * @param account The account to fetch an auth token for\n     * @param authTokenType The auth token type, see {@link #getAuthToken getAuthToken()}\n     * @param notifyAuthFailure If true, display a notification and return null\n     *     if authentication fails; if false, prompt and wait for the user to\n     *     re-enter correct credentials before returning\n     * @return An auth token of the specified type for this account, or null\n     *     if authentication fails or none can be fetched.\n     * @throws AuthenticatorException if the authenticator failed to respond\n     * @throws OperationCanceledException if the request was canceled for any\n     *     reason, including the user canceling a credential request\n     * @throws java.io.IOException if the authenticator experienced an I/O problem\n     *     creating a new auth token, usually because of network trouble\n     */\n    public String blockingGetAuthToken(Account account, String authTokenType,\n            boolean notifyAuthFailure)\n            throws OperationCanceledException, IOException, AuthenticatorException {\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        if (authTokenType == null) throw new IllegalArgumentException(\"authTokenType is null\");\n        Bundle bundle = getAuthToken(account, authTokenType, notifyAuthFailure, null /* callback */,\n                null /* handler */).getResult();\n        if (bundle == null) {\n            // This should never happen, but it does, occasionally. If it does return null to\n            // signify that we were not able to get the authtoken.\n            // TODO: remove this when the bug is found that sometimes causes a null bundle to be\n            // returned\n            Log.e(TAG, \"blockingGetAuthToken: null was returned from getResult() for \"\n                    + account + \", authTokenType \" + authTokenType);\n            return null;\n        }\n        return bundle.getString(KEY_AUTHTOKEN);\n    }"}
{"Number":"6","API Relative Path":"src.android.accounts.AccountManager.java-clearPassword(Account)","Corresponding Source":"/**\n     * Forgets a saved password.  This erases the local copy of the password;\n     * it does not change the user's account password on the server.\n     * Has the same effect as setPassword(account, null) but requires fewer\n     * permissions, and may be used by applications or management interfaces\n     * to \"sign out\" from an account.\n     *\n     * <p>This method only successfully clear the account's password when the\n     * caller has the same signature as the authenticator that owns the\n     * specified account. Otherwise, this method will silently fail.\n     *\n     * <p>It is safe to call this method from the main thread.\n     *\n     * <p><b>NOTE:<\/b> If targeting your app to work on API level 22 and before,\n     * MANAGE_ACCOUNTS permission is needed for those platforms. See docs for\n     * this function in API level 22.\n     *\n     * @param account The account whose password to clear\n     */\n    public void clearPassword(final Account account) {\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        try {\n            mService.clearPassword(account);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"7","API Relative Path":"src.android.accounts.AccountManager.java-confirmCredentialsAsUser(Account-Bundle-Activity-AccountManagerCallback-Handler-UserHandle)","Corresponding Source":"/**\n     * @hide\n     * Same as {@link #confirmCredentials(Account, Bundle, Activity, AccountManagerCallback, Handler)}\n     * but for the specified user.\n     */\n    public AccountManagerFuture<Bundle> confirmCredentialsAsUser(final Account account,\n            final Bundle options,\n            final Activity activity,\n            final AccountManagerCallback<Bundle> callback,\n            final Handler handler, UserHandle userHandle) {\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        final int userId = userHandle.getIdentifier();\n        return new AmsTask(activity, handler, callback) {\n            @Override\n            public void doWork() throws RemoteException {\n                mService.confirmCredentialsAsUser(mResponse, account, options, activity != null,\n                        userId);\n            }\n        }.start();\n    }"}
{"Number":"8","API Relative Path":"src.android.accounts.AccountManager.java-copyAccountToUser(Account-UserHandle-UserHandle-AccountManagerCallback-Handler)","Corresponding Source":"/**\n     * Copies an account from one user to another user.\n     * @param account the account to copy\n     * @param fromUser the user to copy the account from\n     * @param toUser the target user\n     * @param callback Callback to invoke when the request completes,\n     *     null for no callback\n     * @param handler {@link Handler} identifying the callback thread,\n     *     null for the main thread\n     * @return An {@link AccountManagerFuture} which resolves to a Boolean indicated wether it\n     * succeeded.\n     * @hide\n     */\n    public AccountManagerFuture<Boolean> copyAccountToUser(\n            final Account account, final UserHandle fromUser, final UserHandle toUser,\n            AccountManagerCallback<Boolean> callback, Handler handler) {\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        if (toUser == null || fromUser == null) {\n            throw new IllegalArgumentException(\"fromUser and toUser cannot be null\");\n        }\n\n        return new Future2Task<Boolean>(handler, callback) {\n            @Override\n            public void doWork() throws RemoteException {\n                mService.copyAccountToUser(\n                        mResponse, account, fromUser.getIdentifier(), toUser.getIdentifier());\n            }\n            @Override\n            public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {\n                if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {\n                    throw new AuthenticatorException(\"no result in response\");\n                }\n                return bundle.getBoolean(KEY_BOOLEAN_RESULT);\n            }\n        }.start();\n    }"}
{"Number":"9","API Relative Path":"src.android.accounts.AccountManager.java-copyAccountToUser(Account-UserHandle-UserHandle-AccountManagerCallback-Handler)","Corresponding Source":"/**\n     * Copies an account from one user to another user.\n     * @param account the account to copy\n     * @param fromUser the user to copy the account from\n     * @param toUser the target user\n     * @param callback Callback to invoke when the request completes,\n     *     null for no callback\n     * @param handler {@link Handler} identifying the callback thread,\n     *     null for the main thread\n     * @return An {@link AccountManagerFuture} which resolves to a Boolean indicated wether it\n     * succeeded.\n     * @hide\n     */\n    public AccountManagerFuture<Boolean> copyAccountToUser(\n            final Account account, final UserHandle fromUser, final UserHandle toUser,\n            AccountManagerCallback<Boolean> callback, Handler handler) {\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        if (toUser == null || fromUser == null) {\n            throw new IllegalArgumentException(\"fromUser and toUser cannot be null\");\n        }\n\n        return new Future2Task<Boolean>(handler, callback) {\n            @Override\n            public void doWork() throws RemoteException {\n                mService.copyAccountToUser(\n                        mResponse, account, fromUser.getIdentifier(), toUser.getIdentifier());\n            }\n            @Override\n            public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {\n                if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {\n                    throw new AuthenticatorException(\"no result in response\");\n                }\n                return bundle.getBoolean(KEY_BOOLEAN_RESULT);\n            }\n        }.start();\n    }"}
{"Number":"10","API Relative Path":"src.android.accounts.AccountManager.java-editProperties(String-Activity-AccountManagerCallback-Handler)","Corresponding Source":"/**\n     * Offers the user an opportunity to change an authenticator's settings.\n     * These properties are for the authenticator in general, not a particular\n     * account.  Not all authenticators support this method.\n     *\n     * <p>This method may be called from any thread, but the returned\n     * {@link AccountManagerFuture} must not be used on the main thread.\n     *\n     * <p>This method requires the caller to have the same signature as the\n     * authenticator associated with the specified account type.\n     *\n     * <p><b>NOTE:<\/b> If targeting your app to work on API level 22 and before,\n     * MANAGE_ACCOUNTS permission is needed for those platforms. See docs\n     * for this function in API level 22.\n     *\n     * @param accountType The account type associated with the authenticator\n     *     to adjust\n     * @param activity The {@link Activity} context to use for launching a new\n     *     authenticator-defined sub-Activity to adjust authenticator settings;\n     *     used only to call startActivity(); if null, the settings dialog will\n     *     not be launched directly, but the necessary {@link Intent} will be\n     *     returned to the caller instead\n     * @param callback Callback to invoke when the request completes,\n     *     null for no callback\n     * @param handler {@link Handler} identifying the callback thread,\n     *     null for the main thread\n     * @return An {@link AccountManagerFuture} which resolves to a Bundle\n     *     which is empty if properties were edited successfully, or\n     *     if no activity was specified, contains only {@link #KEY_INTENT}\n     *     needed to launch the authenticator's settings dialog.\n     *     If an error occurred, {@link AccountManagerFuture#getResult()}\n     *     throws:\n     * <ul>\n     * <li> {@link AuthenticatorException} if no authenticator was registered for\n     *      this account type or the authenticator failed to respond\n     * <li> {@link OperationCanceledException} if the operation was canceled for\n     *      any reason, including the user canceling the settings dialog\n     * <li> {@link IOException} if the authenticator experienced an I/O problem\n     *      updating settings, usually because of network trouble\n     * <\/ul>\n     */\n    public AccountManagerFuture<Bundle> editProperties(final String accountType,\n            final Activity activity, final AccountManagerCallback<Bundle> callback,\n            final Handler handler) {\n        if (accountType == null) throw new IllegalArgumentException(\"accountType is null\");\n        return new AmsTask(activity, handler, callback) {\n            @Override\n            public void doWork() throws RemoteException {\n                mService.editProperties(mResponse, accountType, activity != null);\n            }\n        }.start();\n    }"}
{"Number":"11","API Relative Path":"src.android.accounts.AccountManager.java-finishSessionAsUser(Bundle-Activity-UserHandle-AccountManagerCallback-Handler)","Corresponding Source":"/**\n     * @see #finishSession\n     * @hide\n     */\n    @SystemApi\n    public AccountManagerFuture<Bundle> finishSessionAsUser(\n            final Bundle sessionBundle,\n            final Activity activity,\n            final UserHandle userHandle,\n            AccountManagerCallback<Bundle> callback,\n            Handler handler) {\n        if (sessionBundle == null) {\n            throw new IllegalArgumentException(\"sessionBundle is null\");\n        }\n\n        /* Add information required by add account flow */\n        final Bundle appInfo = new Bundle();\n        appInfo.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());\n\n        return new AmsTask(activity, handler, callback) {\n            @Override\n            public void doWork() throws RemoteException {\n                mService.finishSessionAsUser(\n                        mResponse,\n                        sessionBundle,\n                        activity != null,\n                        appInfo,\n                        userHandle.getIdentifier());\n            }\n        }.start();\n    }"}
{"Number":"12","API Relative Path":"src.android.accounts.AccountManager.java-get(Context)","Corresponding Source":"/**\n     * Gets an AccountManager instance associated with a Context.\n     * The {@link Context} will be used as long as the AccountManager is\n     * active, so make sure to use a {@link Context} whose lifetime is\n     * commensurate with any listeners registered to\n     * {@link #addOnAccountsUpdatedListener} or similar methods.\n     *\n     * <p>It is safe to call this method from the main thread.\n     *\n     * <p>No permission is required to call this method.\n     *\n     * @param context The {@link Context} to use when necessary\n     * @return An {@link AccountManager} instance\n     */\n    public static AccountManager get(Context context) {\n        if (context == null) throw new IllegalArgumentException(\"context is null\");\n        return (AccountManager) context.getSystemService(Context.ACCOUNT_SERVICE);\n    }"}
{"Number":"13","API Relative Path":"src.android.accounts.AccountManager.java-getAuthToken(Account-String-Bundle-Activity-AccountManagerCallback-Handler)","Corresponding Source":"/**\n     * Gets an auth token of the specified type for a particular account,\n     * prompting the user for credentials if necessary.  This method is\n     * intended for applications running in the foreground where it makes\n     * sense to ask the user directly for a password.\n     *\n     * <p>If a previously generated auth token is cached for this account and\n     * type, then it is returned.  Otherwise, if a saved password is\n     * available, it is sent to the server to generate a new auth token.\n     * Otherwise, the user is prompted to enter a password.\n     *\n     * <p>Some authenticators have auth token <em>types<\/em>, whose value\n     * is authenticator-dependent.  Some services use different token types to\n     * access different functionality -- for example, Google uses different auth\n     * tokens to access Gmail and Google Calendar for the same account.\n     *\n     * <p><b>NOTE:<\/b> If targeting your app to work on API level 22 and before,\n     * USE_CREDENTIALS permission is needed for those platforms. See docs for\n     * this function in API level 22.\n     *\n     * <p>This method may be called from any thread, but the returned\n     * {@link AccountManagerFuture} must not be used on the main thread.\n     *\n     * @param account The account to fetch an auth token for\n     * @param authTokenType The auth token type, an authenticator-dependent\n     *     string token, must not be null\n     * @param options Authenticator-specific options for the request,\n     *     may be null or empty\n     * @param activity The {@link Activity} context to use for launching a new\n     *     authenticator-defined sub-Activity to prompt the user for a password\n     *     if necessary; used only to call startActivity(); must not be null.\n     * @param callback Callback to invoke when the request completes,\n     *     null for no callback\n     * @param handler {@link Handler} identifying the callback thread,\n     *     null for the main thread\n     * @return An {@link AccountManagerFuture} which resolves to a Bundle with\n     *     at least the following fields:\n     * <ul>\n     * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account you supplied\n     * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account\n     * <li> {@link #KEY_AUTHTOKEN} - the auth token you wanted\n     * <\/ul>\n     *\n     * (Other authenticator-specific values may be returned.)  If an auth token\n     * could not be fetched, {@link AccountManagerFuture#getResult()} throws:\n     * <ul>\n     * <li> {@link AuthenticatorException} if the authenticator failed to respond\n     * <li> {@link OperationCanceledException} if the operation is canceled for\n     *      any reason, incluidng the user canceling a credential request\n     * <li> {@link IOException} if the authenticator experienced an I/O problem\n     *      creating a new auth token, usually because of network trouble\n     * <\/ul>\n     * If the account is no longer present on the device, the return value is\n     * authenticator-dependent.  The caller should verify the validity of the\n     * account before requesting an auth token.\n     */\n    public AccountManagerFuture<Bundle> getAuthToken(\n            final Account account, final String authTokenType, final Bundle options,\n            final Activity activity, AccountManagerCallback<Bundle> callback, Handler handler) {\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        if (authTokenType == null) throw new IllegalArgumentException(\"authTokenType is null\");\n        final Bundle optionsIn = new Bundle();\n        if (options != null) {\n            optionsIn.putAll(options);\n        }\n        optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());\n        return new AmsTask(activity, handler, callback) {\n            @Override\n            public void doWork() throws RemoteException {\n                mService.getAuthToken(mResponse, account, authTokenType,\n                        false /* notifyOnAuthFailure */, true /* expectActivityLaunch */,\n                        optionsIn);\n            }\n        }.start();\n    }"}
{"Number":"14","API Relative Path":"src.android.accounts.AccountManager.java-getAuthToken(Account-String-Bundle-boolean-AccountManagerCallback-Handler)","Corresponding Source":"/**\n     * Gets an auth token of the specified type for a particular account,\n     * optionally raising a notification if the user must enter credentials.\n     * This method is intended for background tasks and services where the\n     * user should not be immediately interrupted with a password prompt.\n     *\n     * <p>If a previously generated auth token is cached for this account and\n     * type, then it is returned.  Otherwise, if a saved password is\n     * available, it is sent to the server to generate a new auth token.\n     * Otherwise, an {@link Intent} is returned which, when started, will\n     * prompt the user for a password.  If the notifyAuthFailure parameter is\n     * set, a status bar notification is also created with the same Intent,\n     * alerting the user that they need to enter a password at some point.\n     *\n     * <p>In that case, you may need to wait until the user responds, which\n     * could take hours or days or forever.  When the user does respond and\n     * supply a new password, the account manager will broadcast the\n     * {@link #LOGIN_ACCOUNTS_CHANGED_ACTION} Intent, which applications can\n     * use to try again.\n     *\n     * <p>If notifyAuthFailure is not set, it is the application's\n     * responsibility to launch the returned Intent at some point.\n     * Either way, the result from this call will not wait for user action.\n     *\n     * <p>Some authenticators have auth token <em>types<\/em>, whose value\n     * is authenticator-dependent.  Some services use different token types to\n     * access different functionality -- for example, Google uses different auth\n     * tokens to access Gmail and Google Calendar for the same account.\n     *\n     * <p>This method may be called from any thread, but the returned\n     * {@link AccountManagerFuture} must not be used on the main thread.\n     *\n     * <p><b>NOTE:<\/b> If targeting your app to work on API level 22 and before,\n     * USE_CREDENTIALS permission is needed for those platforms. See docs for\n     * this function in API level 22.\n     *\n     * @param account The account to fetch an auth token for\n     * @param authTokenType The auth token type, an authenticator-dependent\n     *     string token, must not be null\n     * @param options Authenticator-specific options for the request,\n     *     may be null or empty\n     * @param notifyAuthFailure True to add a notification to prompt the\n     *     user for a password if necessary, false to leave that to the caller\n     * @param callback Callback to invoke when the request completes,\n     *     null for no callback\n     * @param handler {@link Handler} identifying the callback thread,\n     *     null for the main thread\n     * @return An {@link AccountManagerFuture} which resolves to a Bundle with\n     *     at least the following fields on success:\n     * <ul>\n     * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account you supplied\n     * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account\n     * <li> {@link #KEY_AUTHTOKEN} - the auth token you wanted\n     * <\/ul>\n     *\n     * (Other authenticator-specific values may be returned.)  If the user\n     * must enter credentials, the returned Bundle contains only\n     * {@link #KEY_INTENT} with the {@link Intent} needed to launch a prompt.\n     *\n     * If an error occurred, {@link AccountManagerFuture#getResult()} throws:\n     * <ul>\n     * <li> {@link AuthenticatorException} if the authenticator failed to respond\n     * <li> {@link OperationCanceledException} if the operation is canceled for\n     *      any reason, incluidng the user canceling a credential request\n     * <li> {@link IOException} if the authenticator experienced an I/O problem\n     *      creating a new auth token, usually because of network trouble\n     * <\/ul>\n     * If the account is no longer present on the device, the return value is\n     * authenticator-dependent.  The caller should verify the validity of the\n     * account before requesting an auth token.\n     */\n    public AccountManagerFuture<Bundle> getAuthToken(\n            final Account account, final String authTokenType, final Bundle options,\n            final boolean notifyAuthFailure,\n            AccountManagerCallback<Bundle> callback, Handler handler) {\n\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        if (authTokenType == null) throw new IllegalArgumentException(\"authTokenType is null\");\n        final Bundle optionsIn = new Bundle();\n        if (options != null) {\n            optionsIn.putAll(options);\n        }\n        optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());\n        return new AmsTask(null, handler, callback) {\n            @Override\n            public void doWork() throws RemoteException {\n                mService.getAuthToken(mResponse, account, authTokenType,\n                        notifyAuthFailure, false /* expectActivityLaunch */, optionsIn);\n            }\n        }.start();\n    }"}
{"Number":"15","API Relative Path":"src.android.accounts.AccountManager.java-getPreviousName(Account)","Corresponding Source":"/**\n     * Gets the previous name associated with the account or {@code null}, if\n     * none. This is intended so that clients of {@link\n     * #LOGIN_ACCOUNTS_CHANGED_ACTION} broadcasts can determine if an\n     * authenticator has renamed an account.\n     *\n     * <p>It is safe to call this method from the main thread.\n     *\n     * @param account The account to query for a previous name.\n     * @return The account's previous name, null if the account has never been\n     *         renamed.\n     */\n    public String getPreviousName(final Account account) {\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        try {\n            return mService.getPreviousName(account);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"16","API Relative Path":"src.android.accounts.AccountManager.java-getUserData(Account-String)","Corresponding Source":"/**\n     * Gets the user data named by \"key\" associated with the account.\n     * This is intended for authenticators and related code to store\n     * arbitrary metadata along with accounts.  The meaning of the keys\n     * and values is up to the authenticator for the account.\n     *\n     * <p>It is safe to call this method from the main thread.\n     *\n     * <p>This method requires the caller to have a signature match with the\n     * authenticator that owns the specified account.\n     *\n     * <p><b>NOTE:<\/b> If targeting your app to work on API level 22 and before,\n     * AUTHENTICATE_ACCOUNTS permission is needed for those platforms. See docs\n     * for this function in API level 22.\n     *\n     * @param account The account to query for user data\n     * @return The user data, null if the account or key doesn't exist\n     */\n    public String getUserData(final Account account, final String key) {\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        if (key == null) throw new IllegalArgumentException(\"key is null\");\n        try {\n            return mService.getUserData(account, key);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"17","API Relative Path":"src.android.accounts.AccountManager.java-getUserData(Account-String)","Corresponding Source":"/**\n     * Gets the user data named by \"key\" associated with the account.\n     * This is intended for authenticators and related code to store\n     * arbitrary metadata along with accounts.  The meaning of the keys\n     * and values is up to the authenticator for the account.\n     *\n     * <p>It is safe to call this method from the main thread.\n     *\n     * <p>This method requires the caller to have a signature match with the\n     * authenticator that owns the specified account.\n     *\n     * <p><b>NOTE:<\/b> If targeting your app to work on API level 22 and before,\n     * AUTHENTICATE_ACCOUNTS permission is needed for those platforms. See docs\n     * for this function in API level 22.\n     *\n     * @param account The account to query for user data\n     * @return The user data, null if the account or key doesn't exist\n     */\n    public String getUserData(final Account account, final String key) {\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        if (key == null) throw new IllegalArgumentException(\"key is null\");\n        try {\n            return mService.getUserData(account, key);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"18","API Relative Path":"src.android.accounts.AccountManager.java-hasFeatures(Account-String[]-AccountManagerCallback-Handler)","Corresponding Source":"/**\n     * Finds out whether a particular account has all the specified features.\n     * Account features are authenticator-specific string tokens identifying\n     * boolean account properties.  For example, features are used to tell\n     * whether Google accounts have a particular service (such as Google\n     * Calendar or Google Talk) enabled.  The feature names and their meanings\n     * are published somewhere associated with the authenticator in question.\n     *\n     * <p>This method may be called from any thread, but the returned\n     * {@link AccountManagerFuture} must not be used on the main thread.\n     *\n     * <p>This method requires the caller to hold the permission\n     * {@link android.Manifest.permission#GET_ACCOUNTS} or be a signature\n     * match with the AbstractAccountAuthenticator that manages the account.\n     *\n     * @param account The {@link Account} to test\n     * @param features An array of the account features to check\n     * @param callback Callback to invoke when the request completes,\n     *     null for no callback\n     * @param handler {@link Handler} identifying the callback thread,\n     *     null for the main thread\n     * @return An {@link AccountManagerFuture} which resolves to a Boolean,\n     * true if the account exists and has all of the specified features.\n     */\n    @RequiresPermission(GET_ACCOUNTS)\n    public AccountManagerFuture<Boolean> hasFeatures(final Account account,\n            final String[] features,\n            AccountManagerCallback<Boolean> callback, Handler handler) {\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        if (features == null) throw new IllegalArgumentException(\"features is null\");\n        return new Future2Task<Boolean>(handler, callback) {\n            @Override\n            public void doWork() throws RemoteException {\n                mService.hasFeatures(mResponse, account, features, mContext.getOpPackageName());\n            }\n            @Override\n            public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {\n                if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {\n                    throw new AuthenticatorException(\"no result in response\");\n                }\n                return bundle.getBoolean(KEY_BOOLEAN_RESULT);\n            }\n        }.start();\n    }"}
{"Number":"19","API Relative Path":"src.android.accounts.AccountManager.java-hasFeatures(Account-String[]-AccountManagerCallback-Handler)","Corresponding Source":"/**\n     * Finds out whether a particular account has all the specified features.\n     * Account features are authenticator-specific string tokens identifying\n     * boolean account properties.  For example, features are used to tell\n     * whether Google accounts have a particular service (such as Google\n     * Calendar or Google Talk) enabled.  The feature names and their meanings\n     * are published somewhere associated with the authenticator in question.\n     *\n     * <p>This method may be called from any thread, but the returned\n     * {@link AccountManagerFuture} must not be used on the main thread.\n     *\n     * <p>This method requires the caller to hold the permission\n     * {@link android.Manifest.permission#GET_ACCOUNTS} or be a signature\n     * match with the AbstractAccountAuthenticator that manages the account.\n     *\n     * @param account The {@link Account} to test\n     * @param features An array of the account features to check\n     * @param callback Callback to invoke when the request completes,\n     *     null for no callback\n     * @param handler {@link Handler} identifying the callback thread,\n     *     null for the main thread\n     * @return An {@link AccountManagerFuture} which resolves to a Boolean,\n     * true if the account exists and has all of the specified features.\n     */\n    @RequiresPermission(GET_ACCOUNTS)\n    public AccountManagerFuture<Boolean> hasFeatures(final Account account,\n            final String[] features,\n            AccountManagerCallback<Boolean> callback, Handler handler) {\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        if (features == null) throw new IllegalArgumentException(\"features is null\");\n        return new Future2Task<Boolean>(handler, callback) {\n            @Override\n            public void doWork() throws RemoteException {\n                mService.hasFeatures(mResponse, account, features, mContext.getOpPackageName());\n            }\n            @Override\n            public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {\n                if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {\n                    throw new AuthenticatorException(\"no result in response\");\n                }\n                return bundle.getBoolean(KEY_BOOLEAN_RESULT);\n            }\n        }.start();\n    }"}
{"Number":"20","API Relative Path":"src.android.accounts.AccountManager.java-isCredentialsUpdateSuggested(Account-String-AccountManagerCallback-Handler)","Corresponding Source":"/**\n     * Checks whether {@link #updateCredentials} or {@link #startUpdateCredentialsSession} should be\n     * called with respect to the specified account.\n     * <p>\n     * This method may be called from any thread, but the returned {@link AccountManagerFuture} must\n     * not be used on the main thread.\n     *\n     * @param account The {@link Account} to be checked whether {@link #updateCredentials} or\n     * {@link #startUpdateCredentialsSession} should be called\n     * @param statusToken a String of token to check account staus\n     * @param callback Callback to invoke when the request completes, null for no callback\n     * @param handler {@link Handler} identifying the callback thread, null for the main thread\n     * @return An {@link AccountManagerFuture} which resolves to a Boolean, true if the credentials\n     *         of the account should be updated.\n     * @hide\n     */\n    @SystemApi\n    public AccountManagerFuture<Boolean> isCredentialsUpdateSuggested(\n            final Account account,\n            final String statusToken,\n            AccountManagerCallback<Boolean> callback,\n            Handler handler) {\n        if (account == null) {\n            throw new IllegalArgumentException(\"account is null\");\n        }\n\n        if (TextUtils.isEmpty(statusToken)) {\n            throw new IllegalArgumentException(\"status token is empty\");\n        }\n\n        return new Future2Task<Boolean>(handler, callback) {\n            @Override\n            public void doWork() throws RemoteException {\n                mService.isCredentialsUpdateSuggested(\n                        mResponse,\n                        account,\n                        statusToken);\n            }\n            @Override\n            public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {\n                if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {\n                    throw new AuthenticatorException(\"no result in response\");\n                }\n                return bundle.getBoolean(KEY_BOOLEAN_RESULT);\n            }\n        }.start();\n    }"}
{"Number":"21","API Relative Path":"src.android.accounts.AccountManager.java-notifyAccountAuthenticated(Account)","Corresponding Source":"/**\n     * Notifies the system that the account has just been authenticated. This\n     * information may be used by other applications to verify the account. This\n     * should be called only when the user has entered correct credentials for\n     * the account.\n     * <p>\n     * It is not safe to call this method from the main thread. As such, call it\n     * from another thread.\n     * <p>This method requires the caller to have a signature match with the\n     * authenticator that owns the specified account.\n     *\n     * @param account The {@link Account} to be updated.\n     * @return boolean {@code true} if the authentication of the account has been successfully\n     *         acknowledged. Otherwise {@code false}.\n     */\n    public boolean notifyAccountAuthenticated(Account account) {\n        if (account == null)\n            throw new IllegalArgumentException(\"account is null\");\n        try {\n            return mService.accountAuthenticated(account);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"22","API Relative Path":"src.android.accounts.AccountManager.java-removeAccount(Account-AccountManagerCallback-Handler)","Corresponding Source":"/**\n     * Removes an account from the AccountManager.  Does nothing if the account\n     * does not exist.  Does not delete the account from the server.\n     * The authenticator may have its own policies preventing account\n     * deletion, in which case the account will not be deleted.\n     *\n     * <p>This method requires the caller to have a signature match with the\n     * authenticator that manages the specified account.\n     *\n     * <p><b>NOTE:<\/b> If targeting your app to work on API level 22 and before,\n     * MANAGE_ACCOUNTS permission is needed for those platforms. See docs for\n     * this function in API level 22.\n     *\n     * @param account The {@link Account} to remove\n     * @param callback Callback to invoke when the request completes,\n     *     null for no callback\n     * @param handler {@link Handler} identifying the callback thread,\n     *     null for the main thread\n     * @return An {@link AccountManagerFuture} which resolves to a Boolean,\n     *     true if the account has been successfully removed\n     * @deprecated use\n     *     {@link #removeAccount(Account, Activity, AccountManagerCallback, Handler)}\n     *     instead\n     */\n    @Deprecated\n    public AccountManagerFuture<Boolean> removeAccount(final Account account,\n            AccountManagerCallback<Boolean> callback, Handler handler) {\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        return new Future2Task<Boolean>(handler, callback) {\n            @Override\n            public void doWork() throws RemoteException {\n                mService.removeAccount(mResponse, account, false);\n            }\n            @Override\n            public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {\n                if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {\n                    throw new AuthenticatorException(\"no result in response\");\n                }\n                return bundle.getBoolean(KEY_BOOLEAN_RESULT);\n            }\n        }.start();\n    }"}
{"Number":"23","API Relative Path":"src.android.accounts.AccountManager.java-removeAccount(Account-Activity-AccountManagerCallback-Handler)","Corresponding Source":"/**\n     * Removes an account from the AccountManager. Does nothing if the account\n     * does not exist.  Does not delete the account from the server.\n     * The authenticator may have its own policies preventing account\n     * deletion, in which case the account will not be deleted.\n     *\n     * <p>This method may be called from any thread, but the returned\n     * {@link AccountManagerFuture} must not be used on the main thread.\n     *\n     * <p>This method requires the caller to have a signature match with the\n     * authenticator that manages the specified account.\n     *\n     * <p><b>NOTE:<\/b> If targeting your app to work on API level 22 and before,\n     * MANAGE_ACCOUNTS permission is needed for those platforms. See docs for\n     * this function in API level 22.\n     *\n     * @param account The {@link Account} to remove\n     * @param activity The {@link Activity} context to use for launching a new\n     *     authenticator-defined sub-Activity to prompt the user to delete an\n     *     account; used only to call startActivity(); if null, the prompt\n     *     will not be launched directly, but the {@link Intent} may be\n     *     returned to the caller instead\n     * @param callback Callback to invoke when the request completes,\n     *     null for no callback\n     * @param handler {@link Handler} identifying the callback thread,\n     *     null for the main thread\n     * @return An {@link AccountManagerFuture} which resolves to a Bundle with\n     *     {@link #KEY_BOOLEAN_RESULT} if activity was specified and an account\n     *     was removed or if active. If no activity was specified, the returned\n     *     Bundle contains only {@link #KEY_INTENT} with the {@link Intent}\n     *     needed to launch the actual account removal process, if authenticator\n     *     needs the activity launch. If an error occurred,\n     *     {@link AccountManagerFuture#getResult()} throws:\n     * <ul>\n     * <li> {@link AuthenticatorException} if no authenticator was registered for\n     *      this account type or the authenticator failed to respond\n     * <li> {@link OperationCanceledException} if the operation was canceled for\n     *      any reason, including the user canceling the creation process or\n     *      adding accounts (of this type) has been disabled by policy\n     * <\/ul>\n     */\n    public AccountManagerFuture<Bundle> removeAccount(final Account account,\n            final Activity activity, AccountManagerCallback<Bundle> callback, Handler handler) {\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        return new AmsTask(activity, handler, callback) {\n            @Override\n            public void doWork() throws RemoteException {\n                mService.removeAccount(mResponse, account, activity != null);\n            }\n        }.start();\n    }"}
{"Number":"24","API Relative Path":"src.android.accounts.AccountManager.java-removeAccountAsUser(Account-AccountManagerCallback-Handler-UserHandle)","Corresponding Source":"/**\n     * @see #removeAccount(Account, AccountManagerCallback, Handler)\n     * @hide\n     * @deprecated use\n     *     {@link #removeAccountAsUser(Account, Activity, AccountManagerCallback, Handler)}\n     *     instead\n     */\n    @Deprecated\n    public AccountManagerFuture<Boolean> removeAccountAsUser(final Account account,\n            AccountManagerCallback<Boolean> callback, Handler handler,\n            final UserHandle userHandle) {\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        if (userHandle == null) throw new IllegalArgumentException(\"userHandle is null\");\n        return new Future2Task<Boolean>(handler, callback) {\n            @Override\n            public void doWork() throws RemoteException {\n                mService.removeAccountAsUser(mResponse, account, false, userHandle.getIdentifier());\n            }\n            @Override\n            public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {\n                if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {\n                    throw new AuthenticatorException(\"no result in response\");\n                }\n                return bundle.getBoolean(KEY_BOOLEAN_RESULT);\n            }\n        }.start();\n    }"}
{"Number":"25","API Relative Path":"src.android.accounts.AccountManager.java-removeAccountAsUser(Account-AccountManagerCallback-Handler-UserHandle)","Corresponding Source":"/**\n     * @see #removeAccount(Account, AccountManagerCallback, Handler)\n     * @hide\n     * @deprecated use\n     *     {@link #removeAccountAsUser(Account, Activity, AccountManagerCallback, Handler)}\n     *     instead\n     */\n    @Deprecated\n    public AccountManagerFuture<Boolean> removeAccountAsUser(final Account account,\n            AccountManagerCallback<Boolean> callback, Handler handler,\n            final UserHandle userHandle) {\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        if (userHandle == null) throw new IllegalArgumentException(\"userHandle is null\");\n        return new Future2Task<Boolean>(handler, callback) {\n            @Override\n            public void doWork() throws RemoteException {\n                mService.removeAccountAsUser(mResponse, account, false, userHandle.getIdentifier());\n            }\n            @Override\n            public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {\n                if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {\n                    throw new AuthenticatorException(\"no result in response\");\n                }\n                return bundle.getBoolean(KEY_BOOLEAN_RESULT);\n            }\n        }.start();\n    }"}
{"Number":"26","API Relative Path":"src.android.accounts.AccountManager.java-removeAccountAsUser(Account-Activity-AccountManagerCallback-Handler-UserHandle)","Corresponding Source":"/**\n     * @see #removeAccount(Account, Activity, AccountManagerCallback, Handler)\n     * @hide\n     */\n    public AccountManagerFuture<Bundle> removeAccountAsUser(final Account account,\n            final Activity activity, AccountManagerCallback<Bundle> callback, Handler handler,\n            final UserHandle userHandle) {\n        if (account == null)\n            throw new IllegalArgumentException(\"account is null\");\n        if (userHandle == null)\n            throw new IllegalArgumentException(\"userHandle is null\");\n        return new AmsTask(activity, handler, callback) {\n            @Override\n            public void doWork() throws RemoteException {\n                mService.removeAccountAsUser(mResponse, account, activity != null,\n                        userHandle.getIdentifier());\n            }\n        }.start();\n    }"}
{"Number":"27","API Relative Path":"src.android.accounts.AccountManager.java-removeAccountAsUser(Account-Activity-AccountManagerCallback-Handler-UserHandle)","Corresponding Source":"/**\n     * @see #removeAccount(Account, Activity, AccountManagerCallback, Handler)\n     * @hide\n     */\n    public AccountManagerFuture<Bundle> removeAccountAsUser(final Account account,\n            final Activity activity, AccountManagerCallback<Bundle> callback, Handler handler,\n            final UserHandle userHandle) {\n        if (account == null)\n            throw new IllegalArgumentException(\"account is null\");\n        if (userHandle == null)\n            throw new IllegalArgumentException(\"userHandle is null\");\n        return new AmsTask(activity, handler, callback) {\n            @Override\n            public void doWork() throws RemoteException {\n                mService.removeAccountAsUser(mResponse, account, activity != null,\n                        userHandle.getIdentifier());\n            }\n        }.start();\n    }"}
{"Number":"28","API Relative Path":"src.android.accounts.AccountManager.java-removeAccountExplicitly(Account)","Corresponding Source":"/**\n     * Removes an account directly. Normally used by authenticators, not\n     * directly by applications. Does not delete the account from the server.\n     * The authenticator may have its own policies preventing account deletion,\n     * in which case the account will not be deleted.\n     * <p>\n     * It is safe to call this method from the main thread.\n     * <p>This method requires the caller to have a signature match with the\n     * authenticator that manages the specified account.\n     *\n     * <p><b>NOTE:<\/b> If targeting your app to work on API level 22 and before,\n     * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator\n     * is needed for those platforms. See docs for this function in API level 22.\n     *\n     * @param account The {@link Account} to delete.\n     * @return True if the account was successfully deleted, false if the\n     *         account did not exist, the account is null, or another error\n     *         occurs.\n     */\n    public boolean removeAccountExplicitly(Account account) {\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        try {\n            return mService.removeAccountExplicitly(account);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"29","API Relative Path":"src.android.accounts.AccountManager.java-renameAccount(Account-String-AccountManagerCallback-Handler)","Corresponding Source":"/**\n     * Rename the specified {@link Account}.  This is equivalent to removing\n     * the existing account and adding a new renamed account with the old\n     * account's user data.\n     *\n     * <p>It is safe to call this method from the main thread.\n     *\n     * <p>This method requires the caller to have a signature match with the\n     * authenticator that manages the specified account.\n     *\n     * <p><b>NOTE:<\/b> If targeting your app to work on API level 22 and before,\n     * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator\n     * is needed for those platforms. See docs for this function in API level 22.\n     *\n     * @param account The {@link Account} to rename\n     * @param newName String name to be associated with the account.\n     * @param callback Callback to invoke when the request completes, null for\n     *     no callback\n     * @param handler {@link Handler} identifying the callback thread, null for\n     *     the main thread\n     * @return An {@link AccountManagerFuture} which resolves to the Account\n     *     after the name change. If successful the account's name will be the\n     *     specified new name.\n     */\n    public AccountManagerFuture<Account> renameAccount(\n            final Account account,\n            @Size(min = 1) final String newName,\n            AccountManagerCallback<Account> callback,\n            Handler handler) {\n        if (account == null) throw new IllegalArgumentException(\"account is null.\");\n        if (TextUtils.isEmpty(newName)) {\n              throw new IllegalArgumentException(\"newName is empty or null.\");\n        }\n        return new Future2Task<Account>(handler, callback) {\n            @Override\n            public void doWork() throws RemoteException {\n                mService.renameAccount(mResponse, account, newName);\n            }\n            @Override\n            public Account bundleToResult(Bundle bundle) throws AuthenticatorException {\n                String name = bundle.getString(KEY_ACCOUNT_NAME);\n                String type = bundle.getString(KEY_ACCOUNT_TYPE);\n                return new Account(name, type);\n            }\n        }.start();\n    }"}
{"Number":"30","API Relative Path":"src.android.accounts.AccountManager.java-setAuthToken(Account-String-String)","Corresponding Source":"/**\n     * Adds an auth token to the AccountManager cache for an account.\n     * If the account does not exist then this call has no effect.\n     * Replaces any previous auth token for this account and auth token type.\n     * Intended for use by the authenticator, not directly by applications.\n     *\n     * <p>It is safe to call this method from the main thread.\n     *\n     * <p>This method requires the caller to have a signature match with the\n     * authenticator that manages the specified account.\n     *\n     * <p><b>NOTE:<\/b> If targeting your app to work on API level 22 and before,\n     * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator\n     * is needed for those platforms. See docs for this function in API level 22.\n     *\n     * @param account The account to set an auth token for\n     * @param authTokenType The type of the auth token, see {#getAuthToken}\n     * @param authToken The auth token to add to the cache\n     */\n    public void setAuthToken(Account account, final String authTokenType, final String authToken) {\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        if (authTokenType == null) throw new IllegalArgumentException(\"authTokenType is null\");\n        try {\n            mService.setAuthToken(account, authTokenType, authToken);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"31","API Relative Path":"src.android.accounts.AccountManager.java-setAuthToken(Account-String-String)","Corresponding Source":"/**\n     * Adds an auth token to the AccountManager cache for an account.\n     * If the account does not exist then this call has no effect.\n     * Replaces any previous auth token for this account and auth token type.\n     * Intended for use by the authenticator, not directly by applications.\n     *\n     * <p>It is safe to call this method from the main thread.\n     *\n     * <p>This method requires the caller to have a signature match with the\n     * authenticator that manages the specified account.\n     *\n     * <p><b>NOTE:<\/b> If targeting your app to work on API level 22 and before,\n     * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator\n     * is needed for those platforms. See docs for this function in API level 22.\n     *\n     * @param account The account to set an auth token for\n     * @param authTokenType The type of the auth token, see {#getAuthToken}\n     * @param authToken The auth token to add to the cache\n     */\n    public void setAuthToken(Account account, final String authTokenType, final String authToken) {\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        if (authTokenType == null) throw new IllegalArgumentException(\"authTokenType is null\");\n        try {\n            mService.setAuthToken(account, authTokenType, authToken);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"32","API Relative Path":"src.android.accounts.AccountManager.java-startUpdateCredentialsSession(Account-String-Bundle-Activity-AccountManagerCallback-Handler)","Corresponding Source":"/**\n     * Asks the user to enter a new password for an account but not updating the\n     * saved credentials for the account until {@link #finishSession} is called.\n     * <p>\n     * This method may be called from any thread, but the returned\n     * {@link AccountManagerFuture} must not be used on the main thread.\n     * <p>\n     * <b>NOTE:<\/b> The saved credentials for the account alone will not be\n     * updated by calling this API alone. #finishSession should be called after\n     * this to update local credentials\n     *\n     * @param account The account to update credentials for\n     * @param authTokenType The credentials entered must allow an auth token of\n     *            this type to be created (but no actual auth token is\n     *            returned); may be null\n     * @param options Authenticator-specific options for the request; may be\n     *            null or empty\n     * @param activity The {@link Activity} context to use for launching a new\n     *            authenticator-defined sub-Activity to prompt the user to enter\n     *            a password; used only to call startActivity(); if null, the\n     *            prompt will not be launched directly, but the necessary\n     *            {@link Intent} will be returned to the caller instead\n     * @param callback Callback to invoke when the request completes, null for\n     *            no callback\n     * @param handler {@link Handler} identifying the callback thread, null for\n     *            the main thread\n     * @return An {@link AccountManagerFuture} which resolves to a Bundle with\n     *         these fields if an activity was supplied and user was\n     *         successfully re-authenticated to the account:\n     *         <ul>\n     *         <li>{@link #KEY_ACCOUNT_SESSION_BUNDLE} - encrypted Bundle for\n     *         updating the local credentials on device later.\n     *         <li>{@link #KEY_PASSWORD} - optional, the password or password\n     *         hash of the account\n     *         <li>{@link #KEY_ACCOUNT_STATUS_TOKEN} - optional, token to check\n     *         status of the account\n     *         <\/ul>\n     *         If no activity was specified, the returned Bundle contains\n     *         {@link #KEY_INTENT} with the {@link Intent} needed to launch the\n     *         password prompt. If an error occurred,\n     *         {@link AccountManagerFuture#getResult()} throws:\n     *         <ul>\n     *         <li>{@link AuthenticatorException} if the authenticator failed to\n     *         respond\n     *         <li>{@link OperationCanceledException} if the operation was\n     *         canceled for any reason, including the user canceling the\n     *         password prompt\n     *         <li>{@link IOException} if the authenticator experienced an I/O\n     *         problem verifying the password, usually because of network\n     *         trouble\n     *         <\/ul>\n     * @see #finishSession\n     * @hide\n     */\n    @SystemApi\n    public AccountManagerFuture<Bundle> startUpdateCredentialsSession(\n            final Account account,\n            final String authTokenType,\n            final Bundle options,\n            final Activity activity,\n            final AccountManagerCallback<Bundle> callback,\n            final Handler handler) {\n        if (account == null) {\n            throw new IllegalArgumentException(\"account is null\");\n        }\n\n        // Always include the calling package name. This just makes life easier\n        // down stream.\n        final Bundle optionsIn = new Bundle();\n        if (options != null) {\n            optionsIn.putAll(options);\n        }\n        optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());\n\n        return new AmsTask(activity, handler, callback) {\n            @Override\n            public void doWork() throws RemoteException {\n                mService.startUpdateCredentialsSession(\n                        mResponse,\n                        account,\n                        authTokenType,\n                        activity != null,\n                        optionsIn);\n            }\n        }.start();\n    }"}
{"Number":"33","API Relative Path":"src.android.accounts.AccountManager.java-updateCredentials(Account-String-Bundle-Activity-AccountManagerCallback-Handler)","Corresponding Source":"/**\n     * Asks the user to enter a new password for an account, updating the\n     * saved credentials for the account.  Normally this happens automatically\n     * when the server rejects credentials during an auth token fetch, but this\n     * can be invoked directly to ensure we have the correct credentials stored.\n     *\n     * <p>This method may be called from any thread, but the returned\n     * {@link AccountManagerFuture} must not be used on the main thread.\n     *\n     * <p><b>NOTE:<\/b> If targeting your app to work on API level 22 and before,\n     * MANAGE_ACCOUNTS permission is needed for those platforms. See docs for\n     * this function in API level 22.\n     *\n     * @param account The account to update credentials for\n     * @param authTokenType The credentials entered must allow an auth token\n     *     of this type to be created (but no actual auth token is returned);\n     *     may be null\n     * @param options Authenticator-specific options for the request;\n     *     may be null or empty\n     * @param activity The {@link Activity} context to use for launching a new\n     *     authenticator-defined sub-Activity to prompt the user to enter a\n     *     password; used only to call startActivity(); if null, the prompt\n     *     will not be launched directly, but the necessary {@link Intent}\n     *     will be returned to the caller instead\n     * @param callback Callback to invoke when the request completes,\n     *     null for no callback\n     * @param handler {@link Handler} identifying the callback thread,\n     *     null for the main thread\n     * @return An {@link AccountManagerFuture} which resolves to a Bundle\n     *     with these fields if an activity was supplied and the account\n     *     credentials were successfully updated:\n     * <ul>\n     * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account\n     * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account\n     * <\/ul>\n     *\n     * If no activity was specified, the returned Bundle contains\n     * {@link #KEY_INTENT} with the {@link Intent} needed to launch the\n     * password prompt. If an error occurred,\n     * {@link AccountManagerFuture#getResult()} throws:\n     * <ul>\n     * <li> {@link AuthenticatorException} if the authenticator failed to respond\n     * <li> {@link OperationCanceledException} if the operation was canceled for\n     *      any reason, including the user canceling the password prompt\n     * <li> {@link IOException} if the authenticator experienced an I/O problem\n     *      verifying the password, usually because of network trouble\n     * <\/ul>\n     */\n    public AccountManagerFuture<Bundle> updateCredentials(final Account account,\n            final String authTokenType,\n            final Bundle options, final Activity activity,\n            final AccountManagerCallback<Bundle> callback,\n            final Handler handler) {\n        if (account == null) throw new IllegalArgumentException(\"account is null\");\n        return new AmsTask(activity, handler, callback) {\n            @Override\n            public void doWork() throws RemoteException {\n                mService.updateCredentials(mResponse, account, authTokenType, activity != null,\n                        options);\n            }\n        }.start();\n    }"}
{"Number":"34","API Relative Path":"src.android.accounts.AuthenticatorDescription.java-AuthenticatorDescription(String-String-int-int-int-int-boolean)","Corresponding Source":"/** A constructor for a full AuthenticatorDescription */\n    public AuthenticatorDescription(String type, String packageName, int labelId, int iconId,\n            int smallIconId, int prefId, boolean customTokens) {\n        if (type == null) throw new IllegalArgumentException(\"type cannot be null\");\n        if (packageName == null) throw new IllegalArgumentException(\"packageName cannot be null\");\n        this.type = type;\n        this.packageName = packageName;\n        this.labelId = labelId;\n        this.iconId = iconId;\n        this.smallIconId = smallIconId;\n        this.accountPreferencesId = prefId;\n        this.customTokens = customTokens;\n    }"}
{"Number":"35","API Relative Path":"src.android.accounts.AuthenticatorDescription.java-AuthenticatorDescription(String-String-int-int-int-int-boolean)","Corresponding Source":"/** A constructor for a full AuthenticatorDescription */\n    public AuthenticatorDescription(String type, String packageName, int labelId, int iconId,\n            int smallIconId, int prefId, boolean customTokens) {\n        if (type == null) throw new IllegalArgumentException(\"type cannot be null\");\n        if (packageName == null) throw new IllegalArgumentException(\"packageName cannot be null\");\n        this.type = type;\n        this.packageName = packageName;\n        this.labelId = labelId;\n        this.iconId = iconId;\n        this.smallIconId = smallIconId;\n        this.accountPreferencesId = prefId;\n        this.customTokens = customTokens;\n    }"}
{"Number":"36","API Relative Path":"src.android.accounts.AuthenticatorDescription.java-newKey(String)","Corresponding Source":"/**\n     * A factory method for creating an AuthenticatorDescription that can be used as a key\n     * to identify the authenticator by its type.\n     */\n\n    public static AuthenticatorDescription newKey(String type) {\n        if (type == null) throw new IllegalArgumentException(\"type cannot be null\");\n        return new AuthenticatorDescription(type);\n    }"}
{"Number":"37","API Relative Path":"src.android.bluetooth.BluetoothAdapter.java-BluetoothAdapter(IBluetoothManager)","Corresponding Source":"/**\n     * Use {@link #getDefaultAdapter} to get the BluetoothAdapter instance.\n     */\n    BluetoothAdapter(IBluetoothManager managerService) {\n\n        if (managerService == null) {\n            throw new IllegalArgumentException(\"bluetooth manager service is null\");\n        }\n        try {\n            mServiceLock.writeLock().lock();\n            mService = managerService.registerAdapter(mManagerCallback);\n        } catch (RemoteException e) {\n            Log.e(TAG, \"\", e);\n        } finally {\n            mServiceLock.writeLock().unlock();\n        }\n        mManagerService = managerService;\n        mLeScanClients = new HashMap<LeScanCallback, ScanCallback>();\n        mToken = new Binder();\n    }"}
{"Number":"38","API Relative Path":"src.android.bluetooth.BluetoothAdapter.java-closeProfileProxy(int-BluetoothProfile)","Corresponding Source":"/**\n     * Close the connection of the profile proxy to the Service.\n     *\n     * <p> Clients should call this when they are no longer using\n     * the proxy obtained from {@link #getProfileProxy}.\n     * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or\n     * {@link BluetoothProfile#A2DP}\n     *\n     * @param profile\n     * @param proxy Profile proxy object\n     */\n    public void closeProfileProxy(int profile, BluetoothProfile proxy) {\n        if (proxy == null) return;\n\n        switch (profile) {\n            case BluetoothProfile.HEADSET:\n                BluetoothHeadset headset = (BluetoothHeadset)proxy;\n                headset.close();\n                break;\n            case BluetoothProfile.A2DP:\n                BluetoothA2dp a2dp = (BluetoothA2dp)proxy;\n                a2dp.close();\n                break;\n            case BluetoothProfile.A2DP_SINK:\n                BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink)proxy;\n                a2dpSink.close();\n                break;\n            case BluetoothProfile.AVRCP_CONTROLLER:\n                BluetoothAvrcpController avrcp = (BluetoothAvrcpController)proxy;\n                avrcp.close();\n                break;\n            case BluetoothProfile.INPUT_DEVICE:\n                BluetoothInputDevice iDev = (BluetoothInputDevice)proxy;\n                iDev.close();\n                break;\n            case BluetoothProfile.PAN:\n                BluetoothPan pan = (BluetoothPan)proxy;\n                pan.close();\n                break;\n            case BluetoothProfile.HEALTH:\n                BluetoothHealth health = (BluetoothHealth)proxy;\n                health.close();\n                break;\n           case BluetoothProfile.GATT:\n                BluetoothGatt gatt = (BluetoothGatt)proxy;\n                gatt.close();\n                break;\n            case BluetoothProfile.GATT_SERVER:\n                BluetoothGattServer gattServer = (BluetoothGattServer)proxy;\n                gattServer.close();\n                break;\n            case BluetoothProfile.MAP:\n                BluetoothMap map = (BluetoothMap)proxy;\n                map.close();\n                break;\n            case BluetoothProfile.HEADSET_CLIENT:\n                BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient)proxy;\n                headsetClient.close();\n                break;\n            case BluetoothProfile.SAP:\n                BluetoothSap sap = (BluetoothSap)proxy;\n                sap.close();\n                break;\n            case BluetoothProfile.PBAP_CLIENT:\n                BluetoothPbapClient pbapClient = (BluetoothPbapClient)proxy;\n                pbapClient.close();\n                break;\n        }\n    }"}
{"Number":"39","API Relative Path":"src.android.bluetooth.BluetoothAdapter.java-getRemoteDevice(byte[])","Corresponding Source":"/**\n     * Get a {@link BluetoothDevice} object for the given Bluetooth hardware\n     * address.\n     * <p>Valid Bluetooth hardware addresses must be 6 bytes. This method\n     * expects the address in network byte order (MSB first).\n     * <p>A {@link BluetoothDevice} will always be returned for a valid\n     * hardware address, even if this adapter has never seen that device.\n     *\n     * @param address Bluetooth MAC address (6 bytes)\n     * @throws IllegalArgumentException if address is invalid\n     */\n    public BluetoothDevice getRemoteDevice(byte[] address) {\n        if (address == null || address.length != 6) {\n            throw new IllegalArgumentException(\"Bluetooth address must have 6 bytes\");\n        }\n        return new BluetoothDevice(String.format(Locale.US, \"%02X:%02X:%02X:%02X:%02X:%02X\",\n                address[0], address[1], address[2], address[3], address[4], address[5]));\n    }"}
{"Number":"40","API Relative Path":"src.android.bluetooth.BluetoothAvrcpPlayerSettings.java-addSettingValue(int-int)","Corresponding Source":"/**\n     * Add a setting value.\n     *\n     * The setting must be part of possible settings in {@link getSettings()}.\n     * @param setting setting config.\n     * @param value value for the setting.\n     * @throws IllegalStateException if the setting is not supported.\n     */\n    public void addSettingValue(int setting, int value) {\n        if ((setting & mSettings) == 0) {\n            Log.e(TAG, \"Setting not supported: \" + setting + \" \" + mSettings);\n            throw new IllegalStateException(\"Setting not supported: \" + setting);\n        }\n        mSettingsValue.put(setting, value);\n    }"}
{"Number":"41","API Relative Path":"src.android.bluetooth.BluetoothAvrcpPlayerSettings.java-getSettingValue(int)","Corresponding Source":"/**\n     * Get a setting value.\n     *\n     * The setting must be part of possible settings in {@link getSettings()}.\n     * @param setting setting config.\n     * @return value value for the setting.\n     * @throws IllegalStateException if the setting is not supported.\n     */\n    public int getSettingValue(int setting) {\n        if ((setting & mSettings) == 0) {\n            Log.e(TAG, \"Setting not supported: \" + setting + \" \" + mSettings);\n            throw new IllegalStateException(\"Setting not supported: \" + setting);\n        }\n        Integer i = mSettingsValue.get(setting);\n        if (i == null) return -1;\n        return i;\n    }"}
{"Number":"42","API Relative Path":"src.android.bluetooth.BluetoothDevice.java-convertPinToBytes(String)","Corresponding Source":"/**\n     * Check that a pin is valid and convert to byte array.\n     *\n     * Bluetooth pin's are 1 to 16 bytes of UTF-8 characters.\n     * @param pin pin as java String\n     * @return the pin code as a UTF-8 byte array, or null if it is an invalid\n     *         Bluetooth pin.\n     * @hide\n     */\n    public static byte[] convertPinToBytes(String pin) {\n        if (pin == null) {\n            return null;\n        }\n        byte[] pinBytes;\n        try {\n            pinBytes = pin.getBytes(\"UTF-8\");\n        } catch (UnsupportedEncodingException uee) {\n            Log.e(TAG, \"UTF-8 not supported?!?\");  // this should not happen\n            return null;\n        }\n        if (pinBytes.length <= 0 || pinBytes.length > 16) {\n            return null;\n        }\n        return pinBytes;\n    }"}
{"Number":"43","API Relative Path":"src.android.bluetooth.BluetoothDevice.java-createBond(int)","Corresponding Source":"/**\n     * Start the bonding (pairing) process with the remote device using the\n     * specified transport.\n     *\n     * <p>This is an asynchronous call, it will return immediately. Register\n     * for {@link #ACTION_BOND_STATE_CHANGED} intents to be notified when\n     * the bonding process completes, and its result.\n     * <p>Android system services will handle the necessary user interactions\n     * to confirm and complete the bonding process.\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.\n     *\n     * @param transport The transport to use for the pairing procedure.\n     * @return false on immediate error, true if bonding will begin\n     * @throws IllegalArgumentException if an invalid transport was specified\n     * @hide\n     */\n    public boolean createBond(int transport) {\n        if (sService == null) {\n            Log.e(TAG, \"BT not enabled. Cannot create bond to Remote Device\");\n            return false;\n        }\n        if (TRANSPORT_AUTO > transport || transport > TRANSPORT_LE)\n        {\n            throw new IllegalArgumentException(transport + \" is not a valid Bluetooth transport\");\n        }\n        try {\n            Log.i(TAG, \"createBond() for device \" + getAddress() +\n                    \" called by pid: \" + Process.myPid() +\n                    \" tid: \" + Process.myTid());\n            return sService.createBond(this, transport);\n        } catch (RemoteException e) {Log.e(TAG, \"\", e);}\n        return false;\n    }"}
{"Number":"44","API Relative Path":"src.android.bluetooth.BluetoothGatt.java-requestConnectionPriority(int)","Corresponding Source":"/**\n     * Request a connection parameter update.\n     *\n     * <p>This function will send a connection parameter update request to the\n     * remote device.\n     *\n     * @param connectionPriority Request a specific connection priority. Must be one of\n     *          {@link BluetoothGatt#CONNECTION_PRIORITY_BALANCED},\n     *          {@link BluetoothGatt#CONNECTION_PRIORITY_HIGH}\n     *          or {@link BluetoothGatt#CONNECTION_PRIORITY_LOW_POWER}.\n     * @throws IllegalArgumentException If the parameters are outside of their\n     *                                  specified range.\n     */\n    public boolean requestConnectionPriority(int connectionPriority) {\n        if (connectionPriority < CONNECTION_PRIORITY_BALANCED ||\n            connectionPriority > CONNECTION_PRIORITY_LOW_POWER) {\n            throw new IllegalArgumentException(\"connectionPriority not within valid range\");\n        }\n\n        if (DBG) Log.d(TAG, \"requestConnectionPriority() - params: \" + connectionPriority);\n        if (mService == null || mClientIf == 0) return false;\n\n        try {\n            mService.connectionParameterUpdate(mClientIf, mDevice.getAddress(), connectionPriority);\n        } catch (RemoteException e) {\n            Log.e(TAG,\"\",e);\n            return false;\n        }\n\n        return true;\n    }"}
{"Number":"45","API Relative Path":"src.android.bluetooth.BluetoothInputStream.java-read(byte[]-int-int)","Corresponding Source":"/**\n     * Reads at most {@code length} bytes from this stream and stores them in\n     * the byte array {@code b} starting at {@code offset}.\n     *\n     * @param b\n     *            the byte array in which to store the bytes read.\n     * @param offset\n     *            the initial position in {@code buffer} to store the bytes\n     *            read from this stream.\n     * @param length\n     *            the maximum number of bytes to store in {@code b}.\n     * @return the number of bytes actually read or -1 if the end of the stream\n     *         has been reached.\n     * @throws IndexOutOfBoundsException\n     *             if {@code offset < 0} or {@code length < 0}, or if\n     *             {@code offset + length} is greater than the length of\n     *             {@code b}.\n     * @throws IOException\n     *             if the stream is closed or another IOException occurs.\n     * @since Android 1.5\n     */\n    public int read(byte[] b, int offset, int length) throws IOException {\n        if (b == null) {\n            throw new NullPointerException(\"byte array is null\");\n        }\n        if ((offset | length) < 0 || length > b.length - offset) {\n            throw new ArrayIndexOutOfBoundsException(\"invalid offset or length\");\n        }\n        return mSocket.read(b, offset, length);\n    }"}
{"Number":"46","API Relative Path":"src.android.bluetooth.BluetoothInputStream.java-read(byte[]-int-int)","Corresponding Source":"/**\n     * Reads at most {@code length} bytes from this stream and stores them in\n     * the byte array {@code b} starting at {@code offset}.\n     *\n     * @param b\n     *            the byte array in which to store the bytes read.\n     * @param offset\n     *            the initial position in {@code buffer} to store the bytes\n     *            read from this stream.\n     * @param length\n     *            the maximum number of bytes to store in {@code b}.\n     * @return the number of bytes actually read or -1 if the end of the stream\n     *         has been reached.\n     * @throws IndexOutOfBoundsException\n     *             if {@code offset < 0} or {@code length < 0}, or if\n     *             {@code offset + length} is greater than the length of\n     *             {@code b}.\n     * @throws IOException\n     *             if the stream is closed or another IOException occurs.\n     * @since Android 1.5\n     */\n    public int read(byte[] b, int offset, int length) throws IOException {\n        if (b == null) {\n            throw new NullPointerException(\"byte array is null\");\n        }\n        if ((offset | length) < 0 || length > b.length - offset) {\n            throw new ArrayIndexOutOfBoundsException(\"invalid offset or length\");\n        }\n        return mSocket.read(b, offset, length);\n    }"}
{"Number":"47","API Relative Path":"src.android.bluetooth.BluetoothManager.java-BluetoothManager(Context)","Corresponding Source":"/**\n     * @hide\n     */\n    public BluetoothManager(Context context) {\n        context = context.getApplicationContext();\n        if (context == null) {\n            throw new IllegalArgumentException(\n                    \"context not associated with any application (using a mock context?)\");\n        }\n        // Legacy api - getDefaultAdapter does not take in the context\n        mAdapter = BluetoothAdapter.getDefaultAdapter();\n    }"}
{"Number":"48","API Relative Path":"src.android.bluetooth.BluetoothManager.java-getConnectedDevices(int)","Corresponding Source":"/**\n     * Get connected devices for the specified profile.\n     *\n     * <p> Return the set of devices which are in state {@link BluetoothProfile#STATE_CONNECTED}\n     *\n     * <p>This is not specific to any application configuration but represents\n     * the connection state of Bluetooth for this profile.\n     * This can be used by applications like status bar which would just like\n     * to know the state of Bluetooth.\n     *\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.\n     *\n     * @param profile GATT or GATT_SERVER\n     * @return List of devices. The list will be empty on error.\n     */\n    @RequiresPermission(Manifest.permission.BLUETOOTH)\n    public List<BluetoothDevice> getConnectedDevices(int profile) {\n        if (DBG) Log.d(TAG,\"getConnectedDevices\");\n        if (profile != BluetoothProfile.GATT && profile != BluetoothProfile.GATT_SERVER) {\n            throw new IllegalArgumentException(\"Profile not supported: \" + profile);\n        }\n\n        List<BluetoothDevice> connectedDevices = new ArrayList<BluetoothDevice>();\n\n        try {\n            IBluetoothManager managerService = mAdapter.getBluetoothManager();\n            IBluetoothGatt iGatt = managerService.getBluetoothGatt();\n            if (iGatt == null) return connectedDevices;\n\n            connectedDevices = iGatt.getDevicesMatchingConnectionStates(\n                new int[] { BluetoothProfile.STATE_CONNECTED });\n        } catch (RemoteException e) {\n            Log.e(TAG,\"\",e);\n        }\n\n        return connectedDevices;\n    }"}
{"Number":"49","API Relative Path":"src.android.bluetooth.BluetoothManager.java-getDevicesMatchingConnectionStates(int-int[])","Corresponding Source":"/**\n     *\n     * Get a list of devices that match any of the given connection\n     * states.\n     *\n     * <p> If none of the devices match any of the given states,\n     * an empty list will be returned.\n     *\n     * <p>This is not specific to any application configuration but represents\n     * the connection state of the local Bluetooth adapter for this profile.\n     * This can be used by applications like status bar which would just like\n     * to know the state of the local adapter.\n     *\n     * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.\n     *\n     * @param profile GATT or GATT_SERVER\n     * @param states Array of states. States can be one of\n     *        {@link BluetoothProfile#STATE_CONNECTED}, {@link BluetoothProfile#STATE_CONNECTING},\n     *        {@link BluetoothProfile#STATE_DISCONNECTED},\n     *        {@link BluetoothProfile#STATE_DISCONNECTING},\n     * @return List of devices. The list will be empty on error.\n     */\n    @RequiresPermission(Manifest.permission.BLUETOOTH)\n    public List<BluetoothDevice> getDevicesMatchingConnectionStates(int profile, int[] states) {\n        if (DBG) Log.d(TAG,\"getDevicesMatchingConnectionStates\");\n\n        if (profile != BluetoothProfile.GATT && profile != BluetoothProfile.GATT_SERVER) {\n            throw new IllegalArgumentException(\"Profile not supported: \" + profile);\n        }\n\n        List<BluetoothDevice> devices = new ArrayList<BluetoothDevice>();\n\n        try {\n            IBluetoothManager managerService = mAdapter.getBluetoothManager();\n            IBluetoothGatt iGatt = managerService.getBluetoothGatt();\n            if (iGatt == null) return devices;\n            devices = iGatt.getDevicesMatchingConnectionStates(states);\n        } catch (RemoteException e) {\n            Log.e(TAG,\"\",e);\n        }\n\n        return devices;\n    }"}
{"Number":"50","API Relative Path":"src.android.bluetooth.BluetoothManager.java-openGattServer(Context-BluetoothGattServerCallback-int)","Corresponding Source":"/**\n     * Open a GATT Server\n     * The callback is used to deliver results to Caller, such as connection status as well\n     * as the results of any other GATT server operations.\n     * The method returns a BluetoothGattServer instance. You can use BluetoothGattServer\n     * to conduct GATT server operations.\n     * @param context App context\n     * @param callback GATT server callback handler that will receive asynchronous callbacks.\n     * @param transport preferred transport for GATT connections to remote dual-mode devices\n     *             {@link BluetoothDevice#TRANSPORT_AUTO} or\n     *             {@link BluetoothDevice#TRANSPORT_BREDR} or {@link BluetoothDevice#TRANSPORT_LE}\n     * @return BluetoothGattServer instance\n     * @hide\n     */\n    public BluetoothGattServer openGattServer(Context context,\n                                              BluetoothGattServerCallback callback,int transport) {\n        if (context == null || callback == null) {\n            throw new IllegalArgumentException(\"null parameter: \" + context + \" \" + callback);\n        }\n\n        // TODO(Bluetooth) check whether platform support BLE\n        //     Do the check here or in GattServer?\n\n        try {\n            IBluetoothManager managerService = mAdapter.getBluetoothManager();\n            IBluetoothGatt iGatt = managerService.getBluetoothGatt();\n            if (iGatt == null) {\n                Log.e(TAG, \"Fail to get GATT Server connection\");\n                return null;\n            }\n            BluetoothGattServer mGattServer = new BluetoothGattServer(context, iGatt,transport);\n            Boolean regStatus = mGattServer.registerCallback(callback);\n            return regStatus? mGattServer : null;\n        } catch (RemoteException e) {\n            Log.e(TAG,\"\",e);\n            return null;\n        }\n    }"}
{"Number":"51","API Relative Path":"src.android.bluetooth.BluetoothOutputStream.java-write(byte[]-int-int)","Corresponding Source":"/**\n     * Writes {@code count} bytes from the byte array {@code buffer} starting\n     * at position {@code offset} to this stream.\n     *\n     * @param b\n     *            the buffer to be written.\n     * @param offset\n     *            the start position in {@code buffer} from where to get bytes.\n     * @param count\n     *            the number of bytes from {@code buffer} to write to this\n     *            stream.\n     * @throws IOException\n     *             if an error occurs while writing to this stream.\n     * @throws IndexOutOfBoundsException\n     *             if {@code offset < 0} or {@code count < 0}, or if\n     *             {@code offset + count} is bigger than the length of\n     *             {@code buffer}.\n     * @since Android 1.0\n     */\n    public void write(byte[] b, int offset, int count) throws IOException {\n        if (b == null) {\n            throw new NullPointerException(\"buffer is null\");\n        }\n        if ((offset | count) < 0 || count > b.length - offset) {\n            throw new IndexOutOfBoundsException(\"invalid offset or length\");\n        }\n        mSocket.write(b, offset, count);\n    }"}
{"Number":"52","API Relative Path":"src.android.bluetooth.BluetoothOutputStream.java-write(byte[]-int-int)","Corresponding Source":"/**\n     * Writes {@code count} bytes from the byte array {@code buffer} starting\n     * at position {@code offset} to this stream.\n     *\n     * @param b\n     *            the buffer to be written.\n     * @param offset\n     *            the start position in {@code buffer} from where to get bytes.\n     * @param count\n     *            the number of bytes from {@code buffer} to write to this\n     *            stream.\n     * @throws IOException\n     *             if an error occurs while writing to this stream.\n     * @throws IndexOutOfBoundsException\n     *             if {@code offset < 0} or {@code count < 0}, or if\n     *             {@code offset + count} is bigger than the length of\n     *             {@code buffer}.\n     * @since Android 1.0\n     */\n    public void write(byte[] b, int offset, int count) throws IOException {\n        if (b == null) {\n            throw new NullPointerException(\"buffer is null\");\n        }\n        if ((offset | count) < 0 || count > b.length - offset) {\n            throw new IndexOutOfBoundsException(\"invalid offset or length\");\n        }\n        mSocket.write(b, offset, count);\n    }"}
{"Number":"53","API Relative Path":"src.android.bluetooth.BluetoothSocket.java-BluetoothSocket(int-int-boolean-boolean-BluetoothDevice-int-ParcelUuid-boolean-boolean)","Corresponding Source":"/**\n     * Construct a BluetoothSocket.\n     * @param type    type of socket\n     * @param fd      fd to use for connected socket, or -1 for a new socket\n     * @param auth    require the remote device to be authenticated\n     * @param encrypt require the connection to be encrypted\n     * @param device  remote device that this socket can connect to\n     * @param port    remote port\n     * @param uuid    SDP uuid\n     * @param mitm    enforce man-in-the-middle protection.\n     * @param min16DigitPin enforce a minimum length of 16 digits for a sec mode 2 connection\n     * @throws IOException On error, for example Bluetooth not available, or\n     *                     insufficient privileges\n     */\n    /*package*/ BluetoothSocket(int type, int fd, boolean auth, boolean encrypt,\n            BluetoothDevice device, int port, ParcelUuid uuid, boolean mitm, boolean min16DigitPin)\n                    throws IOException {\n        if (VDBG) Log.d(TAG, \"Creating new BluetoothSocket of type: \" + type);\n        if (type == BluetoothSocket.TYPE_RFCOMM && uuid == null && fd == -1\n                && port != BluetoothAdapter.SOCKET_CHANNEL_AUTO_STATIC_NO_SDP) {\n            if (port < 1 || port > MAX_RFCOMM_CHANNEL) {\n                throw new IOException(\"Invalid RFCOMM channel: \" + port);\n            }\n        }\n        if (uuid != null)\n            mUuid = uuid;\n        else mUuid = new ParcelUuid(new UUID(0, 0));\n        mType = type;\n        mAuth = auth;\n        mAuthMitm = mitm;\n        mMin16DigitPin = min16DigitPin;\n        mEncrypt = encrypt;\n        mDevice = device;\n        mPort = port;\n        mFd = fd;\n\n        mSocketState = SocketState.INIT;\n\n        if (device == null) {\n            // Server socket\n            mAddress = BluetoothAdapter.getDefaultAdapter().getAddress();\n        } else {\n            // Remote socket\n            mAddress = device.getAddress();\n        }\n        mInputStream = new BluetoothInputStream(this);\n        mOutputStream = new BluetoothOutputStream(this);\n    }"}
{"Number":"54","API Relative Path":"src.android.bluetooth.BluetoothUuid.java-parseUuidFrom(byte[])","Corresponding Source":"/**\n     * Parse UUID from bytes. The {@code uuidBytes} can represent a 16-bit, 32-bit or 128-bit UUID,\n     * but the returned UUID is always in 128-bit format.\n     * Note UUID is little endian in Bluetooth.\n     *\n     * @param uuidBytes Byte representation of uuid.\n     * @return {@link ParcelUuid} parsed from bytes.\n     * @throws IllegalArgumentException If the {@code uuidBytes} cannot be parsed.\n     */\n    public static ParcelUuid parseUuidFrom(byte[] uuidBytes) {\n        if (uuidBytes == null) {\n            throw new IllegalArgumentException(\"uuidBytes cannot be null\");\n        }\n        int length = uuidBytes.length;\n        if (length != UUID_BYTES_16_BIT && length != UUID_BYTES_32_BIT &&\n                length != UUID_BYTES_128_BIT) {\n            throw new IllegalArgumentException(\"uuidBytes length invalid - \" + length);\n        }\n\n        // Construct a 128 bit UUID.\n        if (length == UUID_BYTES_128_BIT) {\n            ByteBuffer buf = ByteBuffer.wrap(uuidBytes).order(ByteOrder.LITTLE_ENDIAN);\n            long msb = buf.getLong(8);\n            long lsb = buf.getLong(0);\n            return new ParcelUuid(new UUID(msb, lsb));\n        }\n\n        // For 16 bit and 32 bit UUID we need to convert them to 128 bit value.\n        // 128_bit_value = uuid * 2^96 + BASE_UUID\n        long shortUuid;\n        if (length == UUID_BYTES_16_BIT) {\n            shortUuid = uuidBytes[0] & 0xFF;\n            shortUuid += (uuidBytes[1] & 0xFF) << 8;\n        } else {\n            shortUuid = uuidBytes[0] & 0xFF ;\n            shortUuid += (uuidBytes[1] & 0xFF) << 8;\n            shortUuid += (uuidBytes[2] & 0xFF) << 16;\n            shortUuid += (uuidBytes[3] & 0xFF) << 24;\n        }\n        long msb = BASE_UUID.getUuid().getMostSignificantBits() + (shortUuid << 32);\n        long lsb = BASE_UUID.getUuid().getLeastSignificantBits();\n        return new ParcelUuid(new UUID(msb, lsb));\n    }"}
{"Number":"55","API Relative Path":"src.android.bluetooth.le.BluetoothLeAdvertiser.java-startAdvertising(AdvertiseSettings-AdvertiseData-AdvertiseData-AdvertiseCallback)","Corresponding Source":"/**\n     * Start Bluetooth LE Advertising. The {@code advertiseData} will be broadcasted if the\n     * operation succeeds. The {@code scanResponse} is returned when a scanning device sends an\n     * active scan request. This method returns immediately, the operation status is delivered\n     * through {@code callback}.\n     * <p>\n     * Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}\n     *\n     * @param settings Settings for Bluetooth LE advertising.\n     * @param advertiseData Advertisement data to be advertised in advertisement packet.\n     * @param scanResponse Scan response associated with the advertisement data.\n     * @param callback Callback for advertising status.\n     */\n    public void startAdvertising(AdvertiseSettings settings,\n            AdvertiseData advertiseData, AdvertiseData scanResponse,\n            final AdvertiseCallback callback) {\n        synchronized (mLeAdvertisers) {\n            BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);\n            if (callback == null) {\n                throw new IllegalArgumentException(\"callback cannot be null\");\n            }\n            if (!mBluetoothAdapter.isMultipleAdvertisementSupported() &&\n                    !mBluetoothAdapter.isPeripheralModeSupported()) {\n                postStartFailure(callback,\n                        AdvertiseCallback.ADVERTISE_FAILED_FEATURE_UNSUPPORTED);\n                return;\n            }\n            boolean isConnectable = settings.isConnectable();\n            if (totalBytes(advertiseData, isConnectable) > MAX_ADVERTISING_DATA_BYTES ||\n                    totalBytes(scanResponse, false) > MAX_ADVERTISING_DATA_BYTES) {\n                postStartFailure(callback, AdvertiseCallback.ADVERTISE_FAILED_DATA_TOO_LARGE);\n                return;\n            }\n            if (mLeAdvertisers.containsKey(callback)) {\n                postStartFailure(callback, AdvertiseCallback.ADVERTISE_FAILED_ALREADY_STARTED);\n                return;\n            }\n\n            IBluetoothGatt gatt;\n            try {\n                gatt = mBluetoothManager.getBluetoothGatt();\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Failed to get Bluetooth gatt - \", e);\n                postStartFailure(callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);\n                return;\n            }\n            AdvertiseCallbackWrapper wrapper = new AdvertiseCallbackWrapper(callback, advertiseData,\n                    scanResponse, settings, gatt);\n            wrapper.startRegisteration();\n        }\n    }"}
{"Number":"56","API Relative Path":"src.android.bluetooth.le.BluetoothLeAdvertiser.java-stopAdvertising(AdvertiseCallback)","Corresponding Source":"/**\n     * Stop Bluetooth LE advertising. The {@code callback} must be the same one use in\n     * {@link BluetoothLeAdvertiser#startAdvertising}.\n     * <p>\n     * Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.\n     *\n     * @param callback {@link AdvertiseCallback} identifies the advertising instance to stop.\n     */\n    public void stopAdvertising(final AdvertiseCallback callback) {\n        synchronized (mLeAdvertisers) {\n            if (callback == null) {\n                throw new IllegalArgumentException(\"callback cannot be null\");\n            }\n            AdvertiseCallbackWrapper wrapper = mLeAdvertisers.get(callback);\n            if (wrapper == null) return;\n            wrapper.stopAdvertising();\n        }\n    }"}
{"Number":"57","API Relative Path":"src.android.bluetooth.le.BluetoothLeScanner.java-flushPendingScanResults(ScanCallback)","Corresponding Source":"/**\n     * Flush pending batch scan results stored in Bluetooth controller. This will return Bluetooth\n     * LE scan results batched on bluetooth controller. Returns immediately, batch scan results data\n     * will be delivered through the {@code callback}.\n     *\n     * @param callback Callback of the Bluetooth LE Scan, it has to be the same instance as the one\n     *            used to start scan.\n     */\n    public void flushPendingScanResults(ScanCallback callback) {\n        BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);\n        if (callback == null) {\n            throw new IllegalArgumentException(\"callback cannot be null!\");\n        }\n        synchronized (mLeScanClients) {\n            BleScanCallbackWrapper wrapper = mLeScanClients.get(callback);\n            if (wrapper == null) {\n                return;\n            }\n            wrapper.flushPendingBatchResults();\n        }\n    }"}
{"Number":"58","API Relative Path":"src.android.bluetooth.le.BluetoothLeUtils.java-checkAdapterStateOn(BluetoothAdapter)","Corresponding Source":"/**\n     * Ensure Bluetooth is turned on.\n     *\n     * @throws IllegalStateException If {@code adapter} is null or Bluetooth state is not\n     *             {@link BluetoothAdapter#STATE_ON}.\n     */\n    static void checkAdapterStateOn(BluetoothAdapter adapter) {\n        if (adapter == null || !adapter.isLeEnabled()) {//adapter.getState() != BluetoothAdapter.STATE_ON) {\n            throw new IllegalStateException(\"BT Adapter is not turned ON\");\n        }\n    }"}
{"Number":"59","API Relative Path":"src.android.bluetooth.le.ScanRecord.java-getServiceData(ParcelUuid)","Corresponding Source":"/**\n     * Returns the service data byte array associated with the {@code serviceUuid}. Returns\n     * {@code null} if the {@code serviceDataUuid} is not found.\n     */\n    @Nullable\n    public byte[] getServiceData(ParcelUuid serviceDataUuid) {\n        if (serviceDataUuid == null) {\n            return null;\n        }\n        return mServiceData.get(serviceDataUuid);\n    }"}
{"Number":"60","API Relative Path":"src.android.bluetooth.le.ScanRecord.java-parseFromBytes(byte[])","Corresponding Source":"/**\n     * Parse scan record bytes to {@link ScanRecord}.\n     * <p>\n     * The format is defined in Bluetooth 4.1 specification, Volume 3, Part C, Section 11 and 18.\n     * <p>\n     * All numerical multi-byte entities and values shall use little-endian <strong>byte<\/strong>\n     * order.\n     *\n     * @param scanRecord The scan record of Bluetooth LE advertisement and/or scan response.\n     * @hide\n     */\n    public static ScanRecord parseFromBytes(byte[] scanRecord) {\n        if (scanRecord == null) {\n            return null;\n        }\n\n        int currentPos = 0;\n        int advertiseFlag = -1;\n        List<ParcelUuid> serviceUuids = new ArrayList<ParcelUuid>();\n        String localName = null;\n        int txPowerLevel = Integer.MIN_VALUE;\n\n        SparseArray<byte[]> manufacturerData = new SparseArray<byte[]>();\n        Map<ParcelUuid, byte[]> serviceData = new ArrayMap<ParcelUuid, byte[]>();\n\n        try {\n            while (currentPos < scanRecord.length) {\n                // length is unsigned int.\n                int length = scanRecord[currentPos++] & 0xFF;\n                if (length == 0) {\n                    break;\n                }\n                // Note the length includes the length of the field type itself.\n                int dataLength = length - 1;\n                // fieldType is unsigned int.\n                int fieldType = scanRecord[currentPos++] & 0xFF;\n                switch (fieldType) {\n                    case DATA_TYPE_FLAGS:\n                        advertiseFlag = scanRecord[currentPos] & 0xFF;\n                        break;\n                    case DATA_TYPE_SERVICE_UUIDS_16_BIT_PARTIAL:\n                    case DATA_TYPE_SERVICE_UUIDS_16_BIT_COMPLETE:\n                        parseServiceUuid(scanRecord, currentPos,\n                                dataLength, BluetoothUuid.UUID_BYTES_16_BIT, serviceUuids);\n                        break;\n                    case DATA_TYPE_SERVICE_UUIDS_32_BIT_PARTIAL:\n                    case DATA_TYPE_SERVICE_UUIDS_32_BIT_COMPLETE:\n                        parseServiceUuid(scanRecord, currentPos, dataLength,\n                                BluetoothUuid.UUID_BYTES_32_BIT, serviceUuids);\n                        break;\n                    case DATA_TYPE_SERVICE_UUIDS_128_BIT_PARTIAL:\n                    case DATA_TYPE_SERVICE_UUIDS_128_BIT_COMPLETE:\n                        parseServiceUuid(scanRecord, currentPos, dataLength,\n                                BluetoothUuid.UUID_BYTES_128_BIT, serviceUuids);\n                        break;\n                    case DATA_TYPE_LOCAL_NAME_SHORT:\n                    case DATA_TYPE_LOCAL_NAME_COMPLETE:\n                        localName = new String(\n                                extractBytes(scanRecord, currentPos, dataLength));\n                        break;\n                    case DATA_TYPE_TX_POWER_LEVEL:\n                        txPowerLevel = scanRecord[currentPos];\n                        break;\n                    case DATA_TYPE_SERVICE_DATA:\n                        // The first two bytes of the service data are service data UUID in little\n                        // endian. The rest bytes are service data.\n                        int serviceUuidLength = BluetoothUuid.UUID_BYTES_16_BIT;\n                        byte[] serviceDataUuidBytes = extractBytes(scanRecord, currentPos,\n                                serviceUuidLength);\n                        ParcelUuid serviceDataUuid = BluetoothUuid.parseUuidFrom(\n                                serviceDataUuidBytes);\n                        byte[] serviceDataArray = extractBytes(scanRecord,\n                                currentPos + serviceUuidLength, dataLength - serviceUuidLength);\n                        serviceData.put(serviceDataUuid, serviceDataArray);\n                        break;\n                    case DATA_TYPE_MANUFACTURER_SPECIFIC_DATA:\n                        // The first two bytes of the manufacturer specific data are\n                        // manufacturer ids in little endian.\n                        int manufacturerId = ((scanRecord[currentPos + 1] & 0xFF) << 8) +\n                                (scanRecord[currentPos] & 0xFF);\n                        byte[] manufacturerDataBytes = extractBytes(scanRecord, currentPos + 2,\n                                dataLength - 2);\n                        manufacturerData.put(manufacturerId, manufacturerDataBytes);\n                        break;\n                    default:\n                        // Just ignore, we don't handle such data type.\n                        break;\n                }\n                currentPos += dataLength;\n            }\n\n            if (serviceUuids.isEmpty()) {\n                serviceUuids = null;\n            }\n            return new ScanRecord(serviceUuids, manufacturerData, serviceData,\n                    advertiseFlag, txPowerLevel, localName, scanRecord);\n        } catch (Exception e) {\n            Log.e(TAG, \"unable to parse scan record: \" + Arrays.toString(scanRecord));\n            // As the record is invalid, ignore all the parsed results for this packet\n            // and return an empty record with raw scanRecord bytes in results\n            return new ScanRecord(null, null, null, -1, Integer.MIN_VALUE, null, scanRecord);\n        }\n    }"}
{"Number":"61","API Relative Path":"src.android.database.BulkCursorNative.java-asInterface(IBinder)","Corresponding Source":"/**\n     * Cast a Binder object into a content resolver interface, generating\n     * a proxy if needed.\n     */\n    static public IBulkCursor asInterface(IBinder obj)\n    {\n        if (obj == null) {\n            return null;\n        }\n        IBulkCursor in = (IBulkCursor)obj.queryLocalInterface(descriptor);\n        if (in != null) {\n            return in;\n        }\n\n        return new BulkCursorProxy(obj);\n    }"}
{"Number":"62","API Relative Path":"src.android.database.CursorJoiner.java-CursorJoiner(Cursor-String[]-Cursor-String[])","Corresponding Source":"/**\n     * Initializes the CursorJoiner and resets the cursors to the first row. The left and right\n     * column name arrays must have the same number of columns.\n     * @param cursorLeft The left cursor to compare\n     * @param columnNamesLeft The column names to compare from the left cursor\n     * @param cursorRight The right cursor to compare\n     * @param columnNamesRight The column names to compare from the right cursor\n     */\n    public CursorJoiner(\n            Cursor cursorLeft, String[] columnNamesLeft,\n            Cursor cursorRight, String[] columnNamesRight) {\n        if (columnNamesLeft.length != columnNamesRight.length) {\n            throw new IllegalArgumentException(\n                    \"you must have the same number of columns on the left and right, \"\n                            + columnNamesLeft.length + \" != \" + columnNamesRight.length);\n        }\n\n        mCursorLeft = cursorLeft;\n        mCursorRight = cursorRight;\n\n        mCursorLeft.moveToFirst();\n        mCursorRight.moveToFirst();\n\n        mCompareResultIsValid = false;\n\n        mColumnsLeft = buildColumnIndiciesArray(cursorLeft, columnNamesLeft);\n        mColumnsRight = buildColumnIndiciesArray(cursorRight, columnNamesRight);\n\n        mValues = new String[mColumnsLeft.length * 2];\n    }"}
{"Number":"63","API Relative Path":"src.android.database.CursorWindow.java-copyStringToBuffer(int-int-CharArrayBuffer)","Corresponding Source":"/**\n     * Copies the text of the field at the specified row and column index into\n     * a {@link CharArrayBuffer}.\n     * <p>\n     * The buffer is populated as follows:\n     * <ul>\n     * <li>If the buffer is too small for the value to be copied, then it is\n     * automatically resized.<\/li>\n     * <li>If the field is of type {@link Cursor#FIELD_TYPE_NULL}, then the buffer\n     * is set to an empty string.<\/li>\n     * <li>If the field is of type {@link Cursor#FIELD_TYPE_STRING}, then the buffer\n     * is set to the contents of the string.<\/li>\n     * <li>If the field is of type {@link Cursor#FIELD_TYPE_INTEGER}, then the buffer\n     * is set to a string representation of the integer in decimal, obtained by formatting the\n     * value with the <code>printf<\/code> family of functions using\n     * format specifier <code>%lld<\/code>.<\/li>\n     * <li>If the field is of type {@link Cursor#FIELD_TYPE_FLOAT}, then the buffer is\n     * set to a string representation of the floating-point value in decimal, obtained by\n     * formatting the value with the <code>printf<\/code> family of functions using\n     * format specifier <code>%g<\/code>.<\/li>\n     * <li>If the field is of type {@link Cursor#FIELD_TYPE_BLOB}, then a\n     * {@link SQLiteException} is thrown.<\/li>\n     * <\/ul>\n     * <\/p>\n     *\n     * @param row The zero-based row index.\n     * @param column The zero-based column index.\n     * @param buffer The {@link CharArrayBuffer} to hold the string.  It is automatically\n     * resized if the requested string is larger than the buffer's current capacity.\n      */\n    public void copyStringToBuffer(int row, int column, CharArrayBuffer buffer) {\n        if (buffer == null) {\n            throw new IllegalArgumentException(\"CharArrayBuffer should not be null\");\n        }\n        acquireReference();\n        try {\n            nativeCopyStringToBuffer(mWindowPtr, row - mStartPos, column, buffer);\n        } finally {\n            releaseReference();\n        }\n    }"}
{"Number":"64","API Relative Path":"src.android.database.MatrixCursor.java-addRow(Object[])","Corresponding Source":"/**\n     * Adds a new row to the end with the given column values. Not safe\n     * for concurrent use.\n     *\n     * @throws IllegalArgumentException if {@code columnValues.length !=\n     *  columnNames.length}\n     * @param columnValues in the same order as the the column names specified\n     *  at cursor construction time\n     */\n    public void addRow(Object[] columnValues) {\n        if (columnValues.length != columnCount) {\n            throw new IllegalArgumentException(\"columnNames.length = \"\n                    + columnCount + \", columnValues.length = \"\n                    + columnValues.length);\n        }\n\n        int start = rowCount++ * columnCount;\n        ensureCapacity(start + columnCount);\n        System.arraycopy(columnValues, 0, data, start, columnCount);\n    }"}
{"Number":"65","API Relative Path":"src.android.database.sqlite.SQLiteConnection.java-execute(String-Object[]-CancellationSignal)","Corresponding Source":"/**\n     * Executes a statement that does not return a result.\n     *\n     * @param sql The SQL statement to execute.\n     * @param bindArgs The arguments to bind, or null if none.\n     * @param cancellationSignal A signal to cancel the operation in progress, or null if none.\n     *\n     * @throws SQLiteException if an error occurs, such as a syntax error\n     * or invalid number of bind arguments.\n     * @throws OperationCanceledException if the operation was canceled.\n     */\n    public void execute(String sql, Object[] bindArgs,\n            CancellationSignal cancellationSignal) {\n        if (sql == null) {\n            throw new IllegalArgumentException(\"sql must not be null.\");\n        }\n\n        final int cookie = mRecentOperations.beginOperation(\"execute\", sql, bindArgs);\n        try {\n            final PreparedStatement statement = acquirePreparedStatement(sql);\n            try {\n                throwIfStatementForbidden(statement);\n                bindArguments(statement, bindArgs);\n                applyBlockGuardPolicy(statement);\n                attachCancellationSignal(cancellationSignal);\n                try {\n                    nativeExecute(mConnectionPtr, statement.mStatementPtr);\n                } finally {\n                    detachCancellationSignal(cancellationSignal);\n                }\n            } finally {\n                releasePreparedStatement(statement);\n            }\n        } catch (RuntimeException ex) {\n            mRecentOperations.failOperation(cookie, ex);\n            throw ex;\n        } finally {\n            mRecentOperations.endOperation(cookie);\n        }\n    }"}
{"Number":"66","API Relative Path":"src.android.database.sqlite.SQLiteConnection.java-executeForBlobFileDescriptor(String-Object[]-CancellationSignal)","Corresponding Source":"/**\n     * Executes a statement that returns a single BLOB result as a\n     * file descriptor to a shared memory region.\n     *\n     * @param sql The SQL statement to execute.\n     * @param bindArgs The arguments to bind, or null if none.\n     * @param cancellationSignal A signal to cancel the operation in progress, or null if none.\n     * @return The file descriptor for a shared memory region that contains\n     * the value of the first column in the first row of the result set as a BLOB,\n     * or null if none.\n     *\n     * @throws SQLiteException if an error occurs, such as a syntax error\n     * or invalid number of bind arguments.\n     * @throws OperationCanceledException if the operation was canceled.\n     */\n    public ParcelFileDescriptor executeForBlobFileDescriptor(String sql, Object[] bindArgs,\n            CancellationSignal cancellationSignal) {\n        if (sql == null) {\n            throw new IllegalArgumentException(\"sql must not be null.\");\n        }\n\n        final int cookie = mRecentOperations.beginOperation(\"executeForBlobFileDescriptor\",\n                sql, bindArgs);\n        try {\n            final PreparedStatement statement = acquirePreparedStatement(sql);\n            try {\n                throwIfStatementForbidden(statement);\n                bindArguments(statement, bindArgs);\n                applyBlockGuardPolicy(statement);\n                attachCancellationSignal(cancellationSignal);\n                try {\n                    int fd = nativeExecuteForBlobFileDescriptor(\n                            mConnectionPtr, statement.mStatementPtr);\n                    return fd >= 0 ? ParcelFileDescriptor.adoptFd(fd) : null;\n                } finally {\n                    detachCancellationSignal(cancellationSignal);\n                }\n            } finally {\n                releasePreparedStatement(statement);\n            }\n        } catch (RuntimeException ex) {\n            mRecentOperations.failOperation(cookie, ex);\n            throw ex;\n        } finally {\n            mRecentOperations.endOperation(cookie);\n        }\n    }"}
{"Number":"67","API Relative Path":"src.android.database.sqlite.SQLiteConnection.java-executeForChangedRowCount(String-Object[]-CancellationSignal)","Corresponding Source":"/**\n     * Executes a statement that returns a count of the number of rows\n     * that were changed.  Use for UPDATE or DELETE SQL statements.\n     *\n     * @param sql The SQL statement to execute.\n     * @param bindArgs The arguments to bind, or null if none.\n     * @param cancellationSignal A signal to cancel the operation in progress, or null if none.\n     * @return The number of rows that were changed.\n     *\n     * @throws SQLiteException if an error occurs, such as a syntax error\n     * or invalid number of bind arguments.\n     * @throws OperationCanceledException if the operation was canceled.\n     */\n    public int executeForChangedRowCount(String sql, Object[] bindArgs,\n            CancellationSignal cancellationSignal) {\n        if (sql == null) {\n            throw new IllegalArgumentException(\"sql must not be null.\");\n        }\n\n        int changedRows = 0;\n        final int cookie = mRecentOperations.beginOperation(\"executeForChangedRowCount\",\n                sql, bindArgs);\n        try {\n            final PreparedStatement statement = acquirePreparedStatement(sql);\n            try {\n                throwIfStatementForbidden(statement);\n                bindArguments(statement, bindArgs);\n                applyBlockGuardPolicy(statement);\n                attachCancellationSignal(cancellationSignal);\n                try {\n                    changedRows = nativeExecuteForChangedRowCount(\n                            mConnectionPtr, statement.mStatementPtr);\n                    return changedRows;\n                } finally {\n                    detachCancellationSignal(cancellationSignal);\n                }\n            } finally {\n                releasePreparedStatement(statement);\n            }\n        } catch (RuntimeException ex) {\n            mRecentOperations.failOperation(cookie, ex);\n            throw ex;\n        } finally {\n            if (mRecentOperations.endOperationDeferLog(cookie)) {\n                mRecentOperations.logOperation(cookie, \"changedRows=\" + changedRows);\n            }\n        }\n    }"}
{"Number":"68","API Relative Path":"src.android.database.sqlite.SQLiteConnection.java-executeForCursorWindow(String-Object[]-CursorWindow-int-int-boolean-CancellationSignal)","Corresponding Source":"/**\n     * Executes a statement and populates the specified {@link CursorWindow}\n     * with a range of results.  Returns the number of rows that were counted\n     * during query execution.\n     *\n     * @param sql The SQL statement to execute.\n     * @param bindArgs The arguments to bind, or null if none.\n     * @param window The cursor window to clear and fill.\n     * @param startPos The start position for filling the window.\n     * @param requiredPos The position of a row that MUST be in the window.\n     * If it won't fit, then the query should discard part of what it filled\n     * so that it does.  Must be greater than or equal to <code>startPos<\/code>.\n     * @param countAllRows True to count all rows that the query would return\n     * regagless of whether they fit in the window.\n     * @param cancellationSignal A signal to cancel the operation in progress, or null if none.\n     * @return The number of rows that were counted during query execution.  Might\n     * not be all rows in the result set unless <code>countAllRows<\/code> is true.\n     *\n     * @throws SQLiteException if an error occurs, such as a syntax error\n     * or invalid number of bind arguments.\n     * @throws OperationCanceledException if the operation was canceled.\n     */\n    public int executeForCursorWindow(String sql, Object[] bindArgs,\n            CursorWindow window, int startPos, int requiredPos, boolean countAllRows,\n            CancellationSignal cancellationSignal) {\n        if (sql == null) {\n            throw new IllegalArgumentException(\"sql must not be null.\");\n        }\n        if (window == null) {\n            throw new IllegalArgumentException(\"window must not be null.\");\n        }\n\n        window.acquireReference();\n        try {\n            int actualPos = -1;\n            int countedRows = -1;\n            int filledRows = -1;\n            final int cookie = mRecentOperations.beginOperation(\"executeForCursorWindow\",\n                    sql, bindArgs);\n            try {\n                final PreparedStatement statement = acquirePreparedStatement(sql);\n                try {\n                    throwIfStatementForbidden(statement);\n                    bindArguments(statement, bindArgs);\n                    applyBlockGuardPolicy(statement);\n                    attachCancellationSignal(cancellationSignal);\n                    try {\n                        final long result = nativeExecuteForCursorWindow(\n                                mConnectionPtr, statement.mStatementPtr, window.mWindowPtr,\n                                startPos, requiredPos, countAllRows);\n                        actualPos = (int)(result >> 32);\n                        countedRows = (int)result;\n                        filledRows = window.getNumRows();\n                        window.setStartPosition(actualPos);\n                        return countedRows;\n                    } finally {\n                        detachCancellationSignal(cancellationSignal);\n                    }\n                } finally {\n                    releasePreparedStatement(statement);\n                }\n            } catch (RuntimeException ex) {\n                mRecentOperations.failOperation(cookie, ex);\n                throw ex;\n            } finally {\n                if (mRecentOperations.endOperationDeferLog(cookie)) {\n                    mRecentOperations.logOperation(cookie, \"window='\" + window\n                            + \"', startPos=\" + startPos\n                            + \", actualPos=\" + actualPos\n                            + \", filledRows=\" + filledRows\n                            + \", countedRows=\" + countedRows);\n                }\n            }\n        } finally {\n            window.releaseReference();\n        }\n    }"}
{"Number":"69","API Relative Path":"src.android.database.sqlite.SQLiteConnection.java-executeForCursorWindow(String-Object[]-CursorWindow-int-int-boolean-CancellationSignal)","Corresponding Source":"/**\n     * Executes a statement and populates the specified {@link CursorWindow}\n     * with a range of results.  Returns the number of rows that were counted\n     * during query execution.\n     *\n     * @param sql The SQL statement to execute.\n     * @param bindArgs The arguments to bind, or null if none.\n     * @param window The cursor window to clear and fill.\n     * @param startPos The start position for filling the window.\n     * @param requiredPos The position of a row that MUST be in the window.\n     * If it won't fit, then the query should discard part of what it filled\n     * so that it does.  Must be greater than or equal to <code>startPos<\/code>.\n     * @param countAllRows True to count all rows that the query would return\n     * regagless of whether they fit in the window.\n     * @param cancellationSignal A signal to cancel the operation in progress, or null if none.\n     * @return The number of rows that were counted during query execution.  Might\n     * not be all rows in the result set unless <code>countAllRows<\/code> is true.\n     *\n     * @throws SQLiteException if an error occurs, such as a syntax error\n     * or invalid number of bind arguments.\n     * @throws OperationCanceledException if the operation was canceled.\n     */\n    public int executeForCursorWindow(String sql, Object[] bindArgs,\n            CursorWindow window, int startPos, int requiredPos, boolean countAllRows,\n            CancellationSignal cancellationSignal) {\n        if (sql == null) {\n            throw new IllegalArgumentException(\"sql must not be null.\");\n        }\n        if (window == null) {\n            throw new IllegalArgumentException(\"window must not be null.\");\n        }\n\n        window.acquireReference();\n        try {\n            int actualPos = -1;\n            int countedRows = -1;\n            int filledRows = -1;\n            final int cookie = mRecentOperations.beginOperation(\"executeForCursorWindow\",\n                    sql, bindArgs);\n            try {\n                final PreparedStatement statement = acquirePreparedStatement(sql);\n                try {\n                    throwIfStatementForbidden(statement);\n                    bindArguments(statement, bindArgs);\n                    applyBlockGuardPolicy(statement);\n                    attachCancellationSignal(cancellationSignal);\n                    try {\n                        final long result = nativeExecuteForCursorWindow(\n                                mConnectionPtr, statement.mStatementPtr, window.mWindowPtr,\n                                startPos, requiredPos, countAllRows);\n                        actualPos = (int)(result >> 32);\n                        countedRows = (int)result;\n                        filledRows = window.getNumRows();\n                        window.setStartPosition(actualPos);\n                        return countedRows;\n                    } finally {\n                        detachCancellationSignal(cancellationSignal);\n                    }\n                } finally {\n                    releasePreparedStatement(statement);\n                }\n            } catch (RuntimeException ex) {\n                mRecentOperations.failOperation(cookie, ex);\n                throw ex;\n            } finally {\n                if (mRecentOperations.endOperationDeferLog(cookie)) {\n                    mRecentOperations.logOperation(cookie, \"window='\" + window\n                            + \"', startPos=\" + startPos\n                            + \", actualPos=\" + actualPos\n                            + \", filledRows=\" + filledRows\n                            + \", countedRows=\" + countedRows);\n                }\n            }\n        } finally {\n            window.releaseReference();\n        }\n    }"}
{"Number":"70","API Relative Path":"src.android.database.sqlite.SQLiteConnection.java-executeForLastInsertedRowId(String-Object[]-CancellationSignal)","Corresponding Source":"/**\n     * Executes a statement that returns the row id of the last row inserted\n     * by the statement.  Use for INSERT SQL statements.\n     *\n     * @param sql The SQL statement to execute.\n     * @param bindArgs The arguments to bind, or null if none.\n     * @param cancellationSignal A signal to cancel the operation in progress, or null if none.\n     * @return The row id of the last row that was inserted, or 0 if none.\n     *\n     * @throws SQLiteException if an error occurs, such as a syntax error\n     * or invalid number of bind arguments.\n     * @throws OperationCanceledException if the operation was canceled.\n     */\n    public long executeForLastInsertedRowId(String sql, Object[] bindArgs,\n            CancellationSignal cancellationSignal) {\n        if (sql == null) {\n            throw new IllegalArgumentException(\"sql must not be null.\");\n        }\n\n        final int cookie = mRecentOperations.beginOperation(\"executeForLastInsertedRowId\",\n                sql, bindArgs);\n        try {\n            final PreparedStatement statement = acquirePreparedStatement(sql);\n            try {\n                throwIfStatementForbidden(statement);\n                bindArguments(statement, bindArgs);\n                applyBlockGuardPolicy(statement);\n                attachCancellationSignal(cancellationSignal);\n                try {\n                    return nativeExecuteForLastInsertedRowId(\n                            mConnectionPtr, statement.mStatementPtr);\n                } finally {\n                    detachCancellationSignal(cancellationSignal);\n                }\n            } finally {\n                releasePreparedStatement(statement);\n            }\n        } catch (RuntimeException ex) {\n            mRecentOperations.failOperation(cookie, ex);\n            throw ex;\n        } finally {\n            mRecentOperations.endOperation(cookie);\n        }\n    }"}
{"Number":"71","API Relative Path":"src.android.database.sqlite.SQLiteConnection.java-executeForLong(String-Object[]-CancellationSignal)","Corresponding Source":"/**\n     * Executes a statement that returns a single <code>long<\/code> result.\n     *\n     * @param sql The SQL statement to execute.\n     * @param bindArgs The arguments to bind, or null if none.\n     * @param cancellationSignal A signal to cancel the operation in progress, or null if none.\n     * @return The value of the first column in the first row of the result set\n     * as a <code>long<\/code>, or zero if none.\n     *\n     * @throws SQLiteException if an error occurs, such as a syntax error\n     * or invalid number of bind arguments.\n     * @throws OperationCanceledException if the operation was canceled.\n     */\n    public long executeForLong(String sql, Object[] bindArgs,\n            CancellationSignal cancellationSignal) {\n        if (sql == null) {\n            throw new IllegalArgumentException(\"sql must not be null.\");\n        }\n\n        final int cookie = mRecentOperations.beginOperation(\"executeForLong\", sql, bindArgs);\n        try {\n            final PreparedStatement statement = acquirePreparedStatement(sql);\n            try {\n                throwIfStatementForbidden(statement);\n                bindArguments(statement, bindArgs);\n                applyBlockGuardPolicy(statement);\n                attachCancellationSignal(cancellationSignal);\n                try {\n                    return nativeExecuteForLong(mConnectionPtr, statement.mStatementPtr);\n                } finally {\n                    detachCancellationSignal(cancellationSignal);\n                }\n            } finally {\n                releasePreparedStatement(statement);\n            }\n        } catch (RuntimeException ex) {\n            mRecentOperations.failOperation(cookie, ex);\n            throw ex;\n        } finally {\n            mRecentOperations.endOperation(cookie);\n        }\n    }"}
{"Number":"72","API Relative Path":"src.android.database.sqlite.SQLiteConnection.java-executeForString(String-Object[]-CancellationSignal)","Corresponding Source":"/**\n     * Executes a statement that returns a single {@link String} result.\n     *\n     * @param sql The SQL statement to execute.\n     * @param bindArgs The arguments to bind, or null if none.\n     * @param cancellationSignal A signal to cancel the operation in progress, or null if none.\n     * @return The value of the first column in the first row of the result set\n     * as a <code>String<\/code>, or null if none.\n     *\n     * @throws SQLiteException if an error occurs, such as a syntax error\n     * or invalid number of bind arguments.\n     * @throws OperationCanceledException if the operation was canceled.\n     */\n    public String executeForString(String sql, Object[] bindArgs,\n            CancellationSignal cancellationSignal) {\n        if (sql == null) {\n            throw new IllegalArgumentException(\"sql must not be null.\");\n        }\n\n        final int cookie = mRecentOperations.beginOperation(\"executeForString\", sql, bindArgs);\n        try {\n            final PreparedStatement statement = acquirePreparedStatement(sql);\n            try {\n                throwIfStatementForbidden(statement);\n                bindArguments(statement, bindArgs);\n                applyBlockGuardPolicy(statement);\n                attachCancellationSignal(cancellationSignal);\n                try {\n                    return nativeExecuteForString(mConnectionPtr, statement.mStatementPtr);\n                } finally {\n                    detachCancellationSignal(cancellationSignal);\n                }\n            } finally {\n                releasePreparedStatement(statement);\n            }\n        } catch (RuntimeException ex) {\n            mRecentOperations.failOperation(cookie, ex);\n            throw ex;\n        } finally {\n            mRecentOperations.endOperation(cookie);\n        }\n    }"}
{"Number":"73","API Relative Path":"src.android.database.sqlite.SQLiteConnection.java-prepare(String-SQLiteStatementInfo)","Corresponding Source":"/**\n     * Prepares a statement for execution but does not bind its parameters or execute it.\n     * <p>\n     * This method can be used to check for syntax errors during compilation\n     * prior to execution of the statement.  If the {@code outStatementInfo} argument\n     * is not null, the provided {@link SQLiteStatementInfo} object is populated\n     * with information about the statement.\n     * <\/p><p>\n     * A prepared statement makes no reference to the arguments that may eventually\n     * be bound to it, consequently it it possible to cache certain prepared statements\n     * such as SELECT or INSERT/UPDATE statements.  If the statement is cacheable,\n     * then it will be stored in the cache for later.\n     * <\/p><p>\n     * To take advantage of this behavior as an optimization, the connection pool\n     * provides a method to acquire a connection that already has a given SQL statement\n     * in its prepared statement cache so that it is ready for execution.\n     * <\/p>\n     *\n     * @param sql The SQL statement to prepare.\n     * @param outStatementInfo The {@link SQLiteStatementInfo} object to populate\n     * with information about the statement, or null if none.\n     *\n     * @throws SQLiteException if an error occurs, such as a syntax error.\n     */\n    public void prepare(String sql, SQLiteStatementInfo outStatementInfo) {\n        if (sql == null) {\n            throw new IllegalArgumentException(\"sql must not be null.\");\n        }\n\n        final int cookie = mRecentOperations.beginOperation(\"prepare\", sql, null);\n        try {\n            final PreparedStatement statement = acquirePreparedStatement(sql);\n            try {\n                if (outStatementInfo != null) {\n                    outStatementInfo.numParameters = statement.mNumParameters;\n                    outStatementInfo.readOnly = statement.mReadOnly;\n\n                    final int columnCount = nativeGetColumnCount(\n                            mConnectionPtr, statement.mStatementPtr);\n                    if (columnCount == 0) {\n                        outStatementInfo.columnNames = EMPTY_STRING_ARRAY;\n                    } else {\n                        outStatementInfo.columnNames = new String[columnCount];\n                        for (int i = 0; i < columnCount; i++) {\n                            outStatementInfo.columnNames[i] = nativeGetColumnName(\n                                    mConnectionPtr, statement.mStatementPtr, i);\n                        }\n                    }\n                }\n            } finally {\n                releasePreparedStatement(statement);\n            }\n        } catch (RuntimeException ex) {\n            mRecentOperations.failOperation(cookie, ex);\n            throw ex;\n        } finally {\n            mRecentOperations.endOperation(cookie);\n        }\n    }"}
{"Number":"74","API Relative Path":"src.android.database.sqlite.SQLiteConnectionPool.java-open(SQLiteDatabaseConfiguration)","Corresponding Source":"/**\n     * Opens a connection pool for the specified database.\n     *\n     * @param configuration The database configuration.\n     * @return The connection pool.\n     *\n     * @throws SQLiteException if a database error occurs.\n     */\n    public static SQLiteConnectionPool open(SQLiteDatabaseConfiguration configuration) {\n        if (configuration == null) {\n            throw new IllegalArgumentException(\"configuration must not be null.\");\n        }\n\n        // Create the pool.\n        SQLiteConnectionPool pool = new SQLiteConnectionPool(configuration);\n        pool.open(); // might throw\n        return pool;\n    }"}
{"Number":"75","API Relative Path":"src.android.database.sqlite.SQLiteConnectionPool.java-reconfigure(SQLiteDatabaseConfiguration)","Corresponding Source":"/**\n     * Reconfigures the database configuration of the connection pool and all of its\n     * connections.\n     * <p>\n     * Configuration changes are propagated down to connections immediately if\n     * they are available or as soon as they are released.  This includes changes\n     * that affect the size of the pool.\n     * <\/p>\n     *\n     * @param configuration The new configuration.\n     *\n     * @throws IllegalStateException if the pool has been closed.\n     */\n    public void reconfigure(SQLiteDatabaseConfiguration configuration) {\n        if (configuration == null) {\n            throw new IllegalArgumentException(\"configuration must not be null.\");\n        }\n\n        synchronized (mLock) {\n            throwIfClosedLocked();\n\n            boolean walModeChanged = ((configuration.openFlags ^ mConfiguration.openFlags)\n                    & SQLiteDatabase.ENABLE_WRITE_AHEAD_LOGGING) != 0;\n            if (walModeChanged) {\n                // WAL mode can only be changed if there are no acquired connections\n                // because we need to close all but the primary connection first.\n                if (!mAcquiredConnections.isEmpty()) {\n                    throw new IllegalStateException(\"Write Ahead Logging (WAL) mode cannot \"\n                            + \"be enabled or disabled while there are transactions in \"\n                            + \"progress.  Finish all transactions and release all active \"\n                            + \"database connections first.\");\n                }\n\n                // Close all non-primary connections.  This should happen immediately\n                // because none of them are in use.\n                closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked();\n                assert mAvailableNonPrimaryConnections.isEmpty();\n            }\n\n            boolean foreignKeyModeChanged = configuration.foreignKeyConstraintsEnabled\n                    != mConfiguration.foreignKeyConstraintsEnabled;\n            if (foreignKeyModeChanged) {\n                // Foreign key constraints can only be changed if there are no transactions\n                // in progress.  To make this clear, we throw an exception if there are\n                // any acquired connections.\n                if (!mAcquiredConnections.isEmpty()) {\n                    throw new IllegalStateException(\"Foreign Key Constraints cannot \"\n                            + \"be enabled or disabled while there are transactions in \"\n                            + \"progress.  Finish all transactions and release all active \"\n                            + \"database connections first.\");\n                }\n            }\n\n            if (mConfiguration.openFlags != configuration.openFlags) {\n                // If we are changing open flags and WAL mode at the same time, then\n                // we have no choice but to close the primary connection beforehand\n                // because there can only be one connection open when we change WAL mode.\n                if (walModeChanged) {\n                    closeAvailableConnectionsAndLogExceptionsLocked();\n                }\n\n                // Try to reopen the primary connection using the new open flags then\n                // close and discard all existing connections.\n                // This might throw if the database is corrupt or cannot be opened in\n                // the new mode in which case existing connections will remain untouched.\n                SQLiteConnection newPrimaryConnection = openConnectionLocked(configuration,\n                        true /*primaryConnection*/); // might throw\n\n                closeAvailableConnectionsAndLogExceptionsLocked();\n                discardAcquiredConnectionsLocked();\n\n                mAvailablePrimaryConnection = newPrimaryConnection;\n                mConfiguration.updateParametersFrom(configuration);\n                setMaxConnectionPoolSizeLocked();\n            } else {\n                // Reconfigure the database connections in place.\n                mConfiguration.updateParametersFrom(configuration);\n                setMaxConnectionPoolSizeLocked();\n\n                closeExcessConnectionsAndLogExceptionsLocked();\n                reconfigureAllConnectionsLocked();\n            }\n\n            wakeConnectionWaitersLocked();\n        }\n    }"}
{"Number":"76","API Relative Path":"src.android.database.sqlite.SQLiteCursor.java-SQLiteCursor(SQLiteCursorDriver-String-SQLiteQuery)","Corresponding Source":"/**\n     * Execute a query and provide access to its result set through a Cursor\n     * interface. For a query such as: {@code SELECT name, birth, phone FROM\n     * myTable WHERE ... LIMIT 1,20 ORDER BY...} the column names (name, birth,\n     * phone) would be in the projection argument and everything from\n     * {@code FROM} onward would be in the params argument.\n     *\n     * @param editTable the name of the table used for this query\n     * @param query the {@link SQLiteQuery} object associated with this cursor object.\n     */\n    public SQLiteCursor(SQLiteCursorDriver driver, String editTable, SQLiteQuery query) {\n        if (query == null) {\n            throw new IllegalArgumentException(\"query object cannot be null\");\n        }\n        if (StrictMode.vmSqliteObjectLeaksEnabled()) {\n            mStackTrace = new DatabaseObjectNotClosedException().fillInStackTrace();\n        } else {\n            mStackTrace = null;\n        }\n        mDriver = driver;\n        mEditTable = editTable;\n        mColumnNameMap = null;\n        mQuery = query;\n\n        mColumns = query.getColumnNames();\n    }"}
{"Number":"77","API Relative Path":"src.android.database.sqlite.SQLiteDatabase.java-deleteDatabase(File)","Corresponding Source":"/**\n     * Deletes a database including its journal file and other auxiliary files\n     * that may have been created by the database engine.\n     *\n     * @param file The database file path.\n     * @return True if the database was successfully deleted.\n     */\n    public static boolean deleteDatabase(File file) {\n        if (file == null) {\n            throw new IllegalArgumentException(\"file must not be null\");\n        }\n\n        boolean deleted = false;\n        deleted |= file.delete();\n        deleted |= new File(file.getPath() + \"-journal\").delete();\n        deleted |= new File(file.getPath() + \"-shm\").delete();\n        deleted |= new File(file.getPath() + \"-wal\").delete();\n\n        File dir = file.getParentFile();\n        if (dir != null) {\n            final String prefix = file.getName() + \"-mj\";\n            File[] files = dir.listFiles(new FileFilter() {\n                @Override\n                public boolean accept(File candidate) {\n                    return candidate.getName().startsWith(prefix);\n                }\n            });\n            if (files != null) {\n                for (File masterJournal : files) {\n                    deleted |= masterJournal.delete();\n                }\n            }\n        }\n        return deleted;\n    }"}
{"Number":"78","API Relative Path":"src.android.database.sqlite.SQLiteDatabase.java-execSQL(String-Object[])","Corresponding Source":"/**\n     * Execute a single SQL statement that is NOT a SELECT/INSERT/UPDATE/DELETE.\n     * <p>\n     * For INSERT statements, use any of the following instead.\n     * <ul>\n     *   <li>{@link #insert(String, String, ContentValues)}<\/li>\n     *   <li>{@link #insertOrThrow(String, String, ContentValues)}<\/li>\n     *   <li>{@link #insertWithOnConflict(String, String, ContentValues, int)}<\/li>\n     * <\/ul>\n     * <p>\n     * For UPDATE statements, use any of the following instead.\n     * <ul>\n     *   <li>{@link #update(String, ContentValues, String, String[])}<\/li>\n     *   <li>{@link #updateWithOnConflict(String, ContentValues, String, String[], int)}<\/li>\n     * <\/ul>\n     * <p>\n     * For DELETE statements, use any of the following instead.\n     * <ul>\n     *   <li>{@link #delete(String, String, String[])}<\/li>\n     * <\/ul>\n     * <p>\n     * For example, the following are good candidates for using this method:\n     * <ul>\n     *   <li>ALTER TABLE<\/li>\n     *   <li>CREATE or DROP table / trigger / view / index / virtual table<\/li>\n     *   <li>REINDEX<\/li>\n     *   <li>RELEASE<\/li>\n     *   <li>SAVEPOINT<\/li>\n     *   <li>PRAGMA that returns no data<\/li>\n     * <\/ul>\n     * <\/p>\n     * <p>\n     * When using {@link #enableWriteAheadLogging()}, journal_mode is\n     * automatically managed by this class. So, do not set journal_mode\n     * using \"PRAGMA journal_mode'<value>\" statement if your app is using\n     * {@link #enableWriteAheadLogging()}\n     * <\/p>\n     *\n     * @param sql the SQL statement to be executed. Multiple statements separated by semicolons are\n     * not supported.\n     * @param bindArgs only byte[], String, Long and Double are supported in bindArgs.\n     * @throws SQLException if the SQL string is invalid\n     */\n    public void execSQL(String sql, Object[] bindArgs) throws SQLException {\n        if (bindArgs == null) {\n            throw new IllegalArgumentException(\"Empty bindArgs\");\n        }\n        executeSql(sql, bindArgs);\n    }"}
{"Number":"79","API Relative Path":"src.android.database.sqlite.SQLiteDatabase.java-setLocale(Locale)","Corresponding Source":"/**\n     * Sets the locale for this database.  Does nothing if this database has\n     * the {@link #NO_LOCALIZED_COLLATORS} flag set or was opened read only.\n     *\n     * @param locale The new locale.\n     *\n     * @throws SQLException if the locale could not be set.  The most common reason\n     * for this is that there is no collator available for the locale you requested.\n     * In this case the database remains unchanged.\n     */\n    public void setLocale(Locale locale) {\n        if (locale == null) {\n            throw new IllegalArgumentException(\"locale must not be null.\");\n        }\n\n        synchronized (mLock) {\n            throwIfNotOpenLocked();\n\n            final Locale oldLocale = mConfigurationLocked.locale;\n            mConfigurationLocked.locale = locale;\n            try {\n                mConnectionPoolLocked.reconfigure(mConfigurationLocked);\n            } catch (RuntimeException ex) {\n                mConfigurationLocked.locale = oldLocale;\n                throw ex;\n            }\n        }\n    }"}
{"Number":"80","API Relative Path":"src.android.database.sqlite.SQLiteDatabase.java-setMaxSqlCacheSize(int)","Corresponding Source":"/**\n     * Sets the maximum size of the prepared-statement cache for this database.\n     * (size of the cache = number of compiled-sql-statements stored in the cache).\n     *<p>\n     * Maximum cache size can ONLY be increased from its current size (default = 10).\n     * If this method is called with smaller size than the current maximum value,\n     * then IllegalStateException is thrown.\n     *<p>\n     * This method is thread-safe.\n     *\n     * @param cacheSize the size of the cache. can be (0 to {@link #MAX_SQL_CACHE_SIZE})\n     * @throws IllegalStateException if input cacheSize > {@link #MAX_SQL_CACHE_SIZE}.\n     */\n    public void setMaxSqlCacheSize(int cacheSize) {\n        if (cacheSize > MAX_SQL_CACHE_SIZE || cacheSize < 0) {\n            throw new IllegalStateException(\n                    \"expected value between 0 and \" + MAX_SQL_CACHE_SIZE);\n        }\n\n        synchronized (mLock) {\n            throwIfNotOpenLocked();\n\n            final int oldMaxSqlCacheSize = mConfigurationLocked.maxSqlCacheSize;\n            mConfigurationLocked.maxSqlCacheSize = cacheSize;\n            try {\n                mConnectionPoolLocked.reconfigure(mConfigurationLocked);\n            } catch (RuntimeException ex) {\n                mConfigurationLocked.maxSqlCacheSize = oldMaxSqlCacheSize;\n                throw ex;\n            }\n        }\n    }"}
{"Number":"81","API Relative Path":"src.android.database.sqlite.SQLiteDatabase.java-updateWithOnConflict(String-ContentValues-String-String[]-int)","Corresponding Source":"/**\n     * Convenience method for updating rows in the database.\n     *\n     * @param table the table to update in\n     * @param values a map from column names to new column values. null is a\n     *            valid value that will be translated to NULL.\n     * @param whereClause the optional WHERE clause to apply when updating.\n     *            Passing null will update all rows.\n     * @param whereArgs You may include ?s in the where clause, which\n     *            will be replaced by the values from whereArgs. The values\n     *            will be bound as Strings.\n     * @param conflictAlgorithm for update conflict resolver\n     * @return the number of rows affected\n     */\n    public int updateWithOnConflict(String table, ContentValues values,\n            String whereClause, String[] whereArgs, int conflictAlgorithm) {\n        if (values == null || values.size() == 0) {\n            throw new IllegalArgumentException(\"Empty values\");\n        }\n\n        acquireReference();\n        try {\n            StringBuilder sql = new StringBuilder(120);\n            sql.append(\"UPDATE \");\n            sql.append(CONFLICT_VALUES[conflictAlgorithm]);\n            sql.append(table);\n            sql.append(\" SET \");\n\n            // move all bind args to one array\n            int setValuesSize = values.size();\n            int bindArgsSize = (whereArgs == null) ? setValuesSize : (setValuesSize + whereArgs.length);\n            Object[] bindArgs = new Object[bindArgsSize];\n            int i = 0;\n            for (String colName : values.keySet()) {\n                sql.append((i > 0) ? \",\" : \"\");\n                sql.append(colName);\n                bindArgs[i++] = values.get(colName);\n                sql.append(\"=?\");\n            }\n            if (whereArgs != null) {\n                for (i = setValuesSize; i < bindArgsSize; i++) {\n                    bindArgs[i] = whereArgs[i - setValuesSize];\n                }\n            }\n            if (!TextUtils.isEmpty(whereClause)) {\n                sql.append(\" WHERE \");\n                sql.append(whereClause);\n            }\n\n            SQLiteStatement statement = new SQLiteStatement(this, sql.toString(), bindArgs);\n            try {\n                return statement.executeUpdateDelete();\n            } finally {\n                statement.close();\n            }\n        } finally {\n            releaseReference();\n        }\n    }"}
{"Number":"82","API Relative Path":"src.android.database.sqlite.SQLiteDatabaseConfiguration.java-SQLiteDatabaseConfiguration(SQLiteDatabaseConfiguration)","Corresponding Source":"/**\n     * Creates a database configuration as a copy of another configuration.\n     *\n     * @param other The other configuration.\n     */\n    public SQLiteDatabaseConfiguration(SQLiteDatabaseConfiguration other) {\n        if (other == null) {\n            throw new IllegalArgumentException(\"other must not be null.\");\n        }\n\n        this.path = other.path;\n        this.label = other.label;\n        updateParametersFrom(other);\n    }"}
{"Number":"83","API Relative Path":"src.android.database.sqlite.SQLiteDatabaseConfiguration.java-SQLiteDatabaseConfiguration(String-int)","Corresponding Source":"/**\n     * Creates a database configuration with the required parameters for opening a\n     * database and default values for all other parameters.\n     *\n     * @param path The database path.\n     * @param openFlags Open flags for the database, such as {@link SQLiteDatabase#OPEN_READWRITE}.\n     */\n    public SQLiteDatabaseConfiguration(String path, int openFlags) {\n        if (path == null) {\n            throw new IllegalArgumentException(\"path must not be null.\");\n        }\n\n        this.path = path;\n        label = stripPathForLogs(path);\n        this.openFlags = openFlags;\n\n        // Set default values for optional parameters.\n        maxSqlCacheSize = 25;\n        locale = Locale.getDefault();\n    }"}
{"Number":"84","API Relative Path":"src.android.database.sqlite.SQLiteDatabaseConfiguration.java-updateParametersFrom(SQLiteDatabaseConfiguration)","Corresponding Source":"/**\n     * Updates the non-immutable parameters of this configuration object\n     * from the other configuration object.\n     *\n     * @param other The object from which to copy the parameters.\n     */\n    public void updateParametersFrom(SQLiteDatabaseConfiguration other) {\n        if (other == null) {\n            throw new IllegalArgumentException(\"other must not be null.\");\n        }\n        if (!path.equals(other.path)) {\n            throw new IllegalArgumentException(\"other configuration must refer to \"\n                    + \"the same database.\");\n        }\n\n        openFlags = other.openFlags;\n        maxSqlCacheSize = other.maxSqlCacheSize;\n        locale = other.locale;\n        foreignKeyConstraintsEnabled = other.foreignKeyConstraintsEnabled;\n        customFunctions.clear();\n        customFunctions.addAll(other.customFunctions);\n    }"}
{"Number":"85","API Relative Path":"src.android.database.sqlite.SQLiteOpenHelper.java-SQLiteOpenHelper(Context-String-CursorFactory-int-DatabaseErrorHandler)","Corresponding Source":"/**\n     * Create a helper object to create, open, and/or manage a database.\n     * The database is not actually created or opened until one of\n     * {@link #getWritableDatabase} or {@link #getReadableDatabase} is called.\n     *\n     * <p>Accepts input param: a concrete instance of {@link DatabaseErrorHandler} to be\n     * used to handle corruption when sqlite reports database corruption.<\/p>\n     *\n     * @param context to use to open or create the database\n     * @param name of the database file, or null for an in-memory database\n     * @param factory to use for creating cursor objects, or null for the default\n     * @param version number of the database (starting at 1); if the database is older,\n     *     {@link #onUpgrade} will be used to upgrade the database; if the database is\n     *     newer, {@link #onDowngrade} will be used to downgrade the database\n     * @param errorHandler the {@link DatabaseErrorHandler} to be used when sqlite reports database\n     * corruption, or null to use the default error handler.\n     */\n    public SQLiteOpenHelper(Context context, String name, CursorFactory factory, int version,\n            DatabaseErrorHandler errorHandler) {\n        if (version < 1) throw new IllegalArgumentException(\"Version must be >= 1, was \" + version);\n\n        mContext = context;\n        mName = name;\n        mFactory = factory;\n        mNewVersion = version;\n        mErrorHandler = errorHandler;\n    }"}
{"Number":"86","API Relative Path":"src.android.database.sqlite.SQLiteProgram.java-bindAllArgsAsStrings(String[])","Corresponding Source":"/**\n     * Given an array of String bindArgs, this method binds all of them in one single call.\n     *\n     * @param bindArgs the String array of bind args, none of which must be null.\n     */\n    public void bindAllArgsAsStrings(String[] bindArgs) {\n        if (bindArgs != null) {\n            for (int i = bindArgs.length; i != 0; i--) {\n                bindString(i, bindArgs[i - 1]);\n            }\n        }\n    }"}
{"Number":"87","API Relative Path":"src.android.database.sqlite.SQLiteSession.java-execute(String-Object[]-int-CancellationSignal)","Corresponding Source":"/**\n     * Executes a statement that does not return a result.\n     *\n     * @param sql The SQL statement to execute.\n     * @param bindArgs The arguments to bind, or null if none.\n     * @param connectionFlags The connection flags to use if a connection must be\n     * acquired by this operation.  Refer to {@link SQLiteConnectionPool}.\n     * @param cancellationSignal A signal to cancel the operation in progress, or null if none.\n     *\n     * @throws SQLiteException if an error occurs, such as a syntax error\n     * or invalid number of bind arguments.\n     * @throws OperationCanceledException if the operation was canceled.\n     */\n    public void execute(String sql, Object[] bindArgs, int connectionFlags,\n            CancellationSignal cancellationSignal) {\n        if (sql == null) {\n            throw new IllegalArgumentException(\"sql must not be null.\");\n        }\n\n        if (executeSpecial(sql, bindArgs, connectionFlags, cancellationSignal)) {\n            return;\n        }\n\n        acquireConnection(sql, connectionFlags, cancellationSignal); // might throw\n        try {\n            mConnection.execute(sql, bindArgs, cancellationSignal); // might throw\n        } finally {\n            releaseConnection(); // might throw\n        }\n    }"}
{"Number":"88","API Relative Path":"src.android.database.sqlite.SQLiteSession.java-executeForBlobFileDescriptor(String-Object[]-int-CancellationSignal)","Corresponding Source":"/**\n     * Executes a statement that returns a single BLOB result as a\n     * file descriptor to a shared memory region.\n     *\n     * @param sql The SQL statement to execute.\n     * @param bindArgs The arguments to bind, or null if none.\n     * @param connectionFlags The connection flags to use if a connection must be\n     * acquired by this operation.  Refer to {@link SQLiteConnectionPool}.\n     * @param cancellationSignal A signal to cancel the operation in progress, or null if none.\n     * @return The file descriptor for a shared memory region that contains\n     * the value of the first column in the first row of the result set as a BLOB,\n     * or null if none.\n     *\n     * @throws SQLiteException if an error occurs, such as a syntax error\n     * or invalid number of bind arguments.\n     * @throws OperationCanceledException if the operation was canceled.\n     */\n    public ParcelFileDescriptor executeForBlobFileDescriptor(String sql, Object[] bindArgs,\n            int connectionFlags, CancellationSignal cancellationSignal) {\n        if (sql == null) {\n            throw new IllegalArgumentException(\"sql must not be null.\");\n        }\n\n        if (executeSpecial(sql, bindArgs, connectionFlags, cancellationSignal)) {\n            return null;\n        }\n\n        acquireConnection(sql, connectionFlags, cancellationSignal); // might throw\n        try {\n            return mConnection.executeForBlobFileDescriptor(sql, bindArgs,\n                    cancellationSignal); // might throw\n        } finally {\n            releaseConnection(); // might throw\n        }\n    }"}
{"Number":"89","API Relative Path":"src.android.database.sqlite.SQLiteSession.java-executeForChangedRowCount(String-Object[]-int-CancellationSignal)","Corresponding Source":"/**\n     * Executes a statement that returns a count of the number of rows\n     * that were changed.  Use for UPDATE or DELETE SQL statements.\n     *\n     * @param sql The SQL statement to execute.\n     * @param bindArgs The arguments to bind, or null if none.\n     * @param connectionFlags The connection flags to use if a connection must be\n     * acquired by this operation.  Refer to {@link SQLiteConnectionPool}.\n     * @param cancellationSignal A signal to cancel the operation in progress, or null if none.\n     * @return The number of rows that were changed.\n     *\n     * @throws SQLiteException if an error occurs, such as a syntax error\n     * or invalid number of bind arguments.\n     * @throws OperationCanceledException if the operation was canceled.\n     */\n    public int executeForChangedRowCount(String sql, Object[] bindArgs, int connectionFlags,\n            CancellationSignal cancellationSignal) {\n        if (sql == null) {\n            throw new IllegalArgumentException(\"sql must not be null.\");\n        }\n\n        if (executeSpecial(sql, bindArgs, connectionFlags, cancellationSignal)) {\n            return 0;\n        }\n\n        acquireConnection(sql, connectionFlags, cancellationSignal); // might throw\n        try {\n            return mConnection.executeForChangedRowCount(sql, bindArgs,\n                    cancellationSignal); // might throw\n        } finally {\n            releaseConnection(); // might throw\n        }\n    }"}
{"Number":"90","API Relative Path":"src.android.database.sqlite.SQLiteSession.java-executeForCursorWindow(String-Object[]-CursorWindow-int-int-boolean-int-CancellationSignal)","Corresponding Source":"/**\n     * Executes a statement and populates the specified {@link CursorWindow}\n     * with a range of results.  Returns the number of rows that were counted\n     * during query execution.\n     *\n     * @param sql The SQL statement to execute.\n     * @param bindArgs The arguments to bind, or null if none.\n     * @param window The cursor window to clear and fill.\n     * @param startPos The start position for filling the window.\n     * @param requiredPos The position of a row that MUST be in the window.\n     * If it won't fit, then the query should discard part of what it filled\n     * so that it does.  Must be greater than or equal to <code>startPos<\/code>.\n     * @param countAllRows True to count all rows that the query would return\n     * regagless of whether they fit in the window.\n     * @param connectionFlags The connection flags to use if a connection must be\n     * acquired by this operation.  Refer to {@link SQLiteConnectionPool}.\n     * @param cancellationSignal A signal to cancel the operation in progress, or null if none.\n     * @return The number of rows that were counted during query execution.  Might\n     * not be all rows in the result set unless <code>countAllRows<\/code> is true.\n     *\n     * @throws SQLiteException if an error occurs, such as a syntax error\n     * or invalid number of bind arguments.\n     * @throws OperationCanceledException if the operation was canceled.\n     */\n    public int executeForCursorWindow(String sql, Object[] bindArgs,\n            CursorWindow window, int startPos, int requiredPos, boolean countAllRows,\n            int connectionFlags, CancellationSignal cancellationSignal) {\n        if (sql == null) {\n            throw new IllegalArgumentException(\"sql must not be null.\");\n        }\n        if (window == null) {\n            throw new IllegalArgumentException(\"window must not be null.\");\n        }\n\n        if (executeSpecial(sql, bindArgs, connectionFlags, cancellationSignal)) {\n            window.clear();\n            return 0;\n        }\n\n        acquireConnection(sql, connectionFlags, cancellationSignal); // might throw\n        try {\n            return mConnection.executeForCursorWindow(sql, bindArgs,\n                    window, startPos, requiredPos, countAllRows,\n                    cancellationSignal); // might throw\n        } finally {\n            releaseConnection(); // might throw\n        }\n    }"}
{"Number":"91","API Relative Path":"src.android.database.sqlite.SQLiteSession.java-executeForCursorWindow(String-Object[]-CursorWindow-int-int-boolean-int-CancellationSignal)","Corresponding Source":"/**\n     * Executes a statement and populates the specified {@link CursorWindow}\n     * with a range of results.  Returns the number of rows that were counted\n     * during query execution.\n     *\n     * @param sql The SQL statement to execute.\n     * @param bindArgs The arguments to bind, or null if none.\n     * @param window The cursor window to clear and fill.\n     * @param startPos The start position for filling the window.\n     * @param requiredPos The position of a row that MUST be in the window.\n     * If it won't fit, then the query should discard part of what it filled\n     * so that it does.  Must be greater than or equal to <code>startPos<\/code>.\n     * @param countAllRows True to count all rows that the query would return\n     * regagless of whether they fit in the window.\n     * @param connectionFlags The connection flags to use if a connection must be\n     * acquired by this operation.  Refer to {@link SQLiteConnectionPool}.\n     * @param cancellationSignal A signal to cancel the operation in progress, or null if none.\n     * @return The number of rows that were counted during query execution.  Might\n     * not be all rows in the result set unless <code>countAllRows<\/code> is true.\n     *\n     * @throws SQLiteException if an error occurs, such as a syntax error\n     * or invalid number of bind arguments.\n     * @throws OperationCanceledException if the operation was canceled.\n     */\n    public int executeForCursorWindow(String sql, Object[] bindArgs,\n            CursorWindow window, int startPos, int requiredPos, boolean countAllRows,\n            int connectionFlags, CancellationSignal cancellationSignal) {\n        if (sql == null) {\n            throw new IllegalArgumentException(\"sql must not be null.\");\n        }\n        if (window == null) {\n            throw new IllegalArgumentException(\"window must not be null.\");\n        }\n\n        if (executeSpecial(sql, bindArgs, connectionFlags, cancellationSignal)) {\n            window.clear();\n            return 0;\n        }\n\n        acquireConnection(sql, connectionFlags, cancellationSignal); // might throw\n        try {\n            return mConnection.executeForCursorWindow(sql, bindArgs,\n                    window, startPos, requiredPos, countAllRows,\n                    cancellationSignal); // might throw\n        } finally {\n            releaseConnection(); // might throw\n        }\n    }"}
{"Number":"92","API Relative Path":"src.android.database.sqlite.SQLiteSession.java-executeForLastInsertedRowId(String-Object[]-int-CancellationSignal)","Corresponding Source":"/**\n     * Executes a statement that returns the row id of the last row inserted\n     * by the statement.  Use for INSERT SQL statements.\n     *\n     * @param sql The SQL statement to execute.\n     * @param bindArgs The arguments to bind, or null if none.\n     * @param connectionFlags The connection flags to use if a connection must be\n     * acquired by this operation.  Refer to {@link SQLiteConnectionPool}.\n     * @param cancellationSignal A signal to cancel the operation in progress, or null if none.\n     * @return The row id of the last row that was inserted, or 0 if none.\n     *\n     * @throws SQLiteException if an error occurs, such as a syntax error\n     * or invalid number of bind arguments.\n     * @throws OperationCanceledException if the operation was canceled.\n     */\n    public long executeForLastInsertedRowId(String sql, Object[] bindArgs, int connectionFlags,\n            CancellationSignal cancellationSignal) {\n        if (sql == null) {\n            throw new IllegalArgumentException(\"sql must not be null.\");\n        }\n\n        if (executeSpecial(sql, bindArgs, connectionFlags, cancellationSignal)) {\n            return 0;\n        }\n\n        acquireConnection(sql, connectionFlags, cancellationSignal); // might throw\n        try {\n            return mConnection.executeForLastInsertedRowId(sql, bindArgs,\n                    cancellationSignal); // might throw\n        } finally {\n            releaseConnection(); // might throw\n        }\n    }"}
{"Number":"93","API Relative Path":"src.android.database.sqlite.SQLiteSession.java-executeForLong(String-Object[]-int-CancellationSignal)","Corresponding Source":"/**\n     * Executes a statement that returns a single <code>long<\/code> result.\n     *\n     * @param sql The SQL statement to execute.\n     * @param bindArgs The arguments to bind, or null if none.\n     * @param connectionFlags The connection flags to use if a connection must be\n     * acquired by this operation.  Refer to {@link SQLiteConnectionPool}.\n     * @param cancellationSignal A signal to cancel the operation in progress, or null if none.\n     * @return The value of the first column in the first row of the result set\n     * as a <code>long<\/code>, or zero if none.\n     *\n     * @throws SQLiteException if an error occurs, such as a syntax error\n     * or invalid number of bind arguments.\n     * @throws OperationCanceledException if the operation was canceled.\n     */\n    public long executeForLong(String sql, Object[] bindArgs, int connectionFlags,\n            CancellationSignal cancellationSignal) {\n        if (sql == null) {\n            throw new IllegalArgumentException(\"sql must not be null.\");\n        }\n\n        if (executeSpecial(sql, bindArgs, connectionFlags, cancellationSignal)) {\n            return 0;\n        }\n\n        acquireConnection(sql, connectionFlags, cancellationSignal); // might throw\n        try {\n            return mConnection.executeForLong(sql, bindArgs, cancellationSignal); // might throw\n        } finally {\n            releaseConnection(); // might throw\n        }\n    }"}
{"Number":"94","API Relative Path":"src.android.database.sqlite.SQLiteSession.java-executeForString(String-Object[]-int-CancellationSignal)","Corresponding Source":"/**\n     * Executes a statement that returns a single {@link String} result.\n     *\n     * @param sql The SQL statement to execute.\n     * @param bindArgs The arguments to bind, or null if none.\n     * @param connectionFlags The connection flags to use if a connection must be\n     * acquired by this operation.  Refer to {@link SQLiteConnectionPool}.\n     * @param cancellationSignal A signal to cancel the operation in progress, or null if none.\n     * @return The value of the first column in the first row of the result set\n     * as a <code>String<\/code>, or null if none.\n     *\n     * @throws SQLiteException if an error occurs, such as a syntax error\n     * or invalid number of bind arguments.\n     * @throws OperationCanceledException if the operation was canceled.\n     */\n    public String executeForString(String sql, Object[] bindArgs, int connectionFlags,\n            CancellationSignal cancellationSignal) {\n        if (sql == null) {\n            throw new IllegalArgumentException(\"sql must not be null.\");\n        }\n\n        if (executeSpecial(sql, bindArgs, connectionFlags, cancellationSignal)) {\n            return null;\n        }\n\n        acquireConnection(sql, connectionFlags, cancellationSignal); // might throw\n        try {\n            return mConnection.executeForString(sql, bindArgs, cancellationSignal); // might throw\n        } finally {\n            releaseConnection(); // might throw\n        }\n    }"}
{"Number":"95","API Relative Path":"src.android.database.sqlite.SQLiteSession.java-prepare(String-int-CancellationSignal-SQLiteStatementInfo)","Corresponding Source":"/**\n     * Prepares a statement for execution but does not bind its parameters or execute it.\n     * <p>\n     * This method can be used to check for syntax errors during compilation\n     * prior to execution of the statement.  If the {@code outStatementInfo} argument\n     * is not null, the provided {@link SQLiteStatementInfo} object is populated\n     * with information about the statement.\n     * <\/p><p>\n     * A prepared statement makes no reference to the arguments that may eventually\n     * be bound to it, consequently it it possible to cache certain prepared statements\n     * such as SELECT or INSERT/UPDATE statements.  If the statement is cacheable,\n     * then it will be stored in the cache for later and reused if possible.\n     * <\/p>\n     *\n     * @param sql The SQL statement to prepare.\n     * @param connectionFlags The connection flags to use if a connection must be\n     * acquired by this operation.  Refer to {@link SQLiteConnectionPool}.\n     * @param cancellationSignal A signal to cancel the operation in progress, or null if none.\n     * @param outStatementInfo The {@link SQLiteStatementInfo} object to populate\n     * with information about the statement, or null if none.\n     *\n     * @throws SQLiteException if an error occurs, such as a syntax error.\n     * @throws OperationCanceledException if the operation was canceled.\n     */\n    public void prepare(String sql, int connectionFlags, CancellationSignal cancellationSignal,\n            SQLiteStatementInfo outStatementInfo) {\n        if (sql == null) {\n            throw new IllegalArgumentException(\"sql must not be null.\");\n        }\n\n        if (cancellationSignal != null) {\n            cancellationSignal.throwIfCanceled();\n        }\n\n        acquireConnection(sql, connectionFlags, cancellationSignal); // might throw\n        try {\n            mConnection.prepare(sql, outStatementInfo); // might throw\n        } finally {\n            releaseConnection(); // might throw\n        }\n    }"}
{"Number":"96","API Relative Path":"src.android.database.sqlite.SQLiteSession.java-SQLiteSession(SQLiteConnectionPool)","Corresponding Source":"/**\n     * Creates a session bound to the specified connection pool.\n     *\n     * @param connectionPool The connection pool.\n     */\n    public SQLiteSession(SQLiteConnectionPool connectionPool) {\n        if (connectionPool == null) {\n            throw new IllegalArgumentException(\"connectionPool must not be null\");\n        }\n\n        mConnectionPool = connectionPool;\n    }"}
{"Number":"97","API Relative Path":"src.android.gesture.GestureStore.java-addGesture(String-Gesture)","Corresponding Source":"/**\n     * Add a gesture for the entry\n     * \n     * @param entryName entry name\n     * @param gesture\n     */\n    public void addGesture(String entryName, Gesture gesture) {\n        if (entryName == null || entryName.length() == 0) {\n            return;\n        }\n        ArrayList<Gesture> gestures = mNamedGestures.get(entryName);\n        if (gestures == null) {\n            gestures = new ArrayList<Gesture>();\n            mNamedGestures.put(entryName, gestures);\n        }\n        gestures.add(gesture);\n        mClassifier.addInstance(\n                Instance.createInstance(mSequenceType, mOrientationStyle, gesture, entryName));\n        mChanged = true;\n    }"}
{"Number":"98","API Relative Path":"src.android.gesture.GestureUtils.java-closeStream(Closeable)","Corresponding Source":"/**\n     * Closes the specified stream.\n     *\n     * @param stream The stream to close.\n     */\n    static void closeStream(Closeable stream) {\n        if (stream != null) {\n            try {\n                stream.close();\n            } catch (IOException e) {\n                Log.e(LOG_TAG, \"Could not close stream\", e);\n            }\n        }\n    }"}
{"Number":"99","API Relative Path":"src.android.graphics.AvoidXfermode.java-AvoidXfermode(int-int-Mode)","Corresponding Source":"/** This xfermode draws, or doesn't draw, based on the destination's\n     * distance from an op-color.\n     *\n     * There are two modes, and each mode interprets a tolerance value.\n     *\n     * Avoid: In this mode, drawing is allowed only on destination pixels that\n     * are different from the op-color.\n     * Tolerance near 0: avoid any colors even remotely similar to the op-color\n     * Tolerance near 255: avoid only colors nearly identical to the op-color\n     \n     * Target: In this mode, drawing only occurs on destination pixels that\n     * are similar to the op-color\n     * Tolerance near 0: draw only on colors that are nearly identical to the op-color\n     * Tolerance near 255: draw on any colors even remotely similar to the op-color\n     */\n    public AvoidXfermode(int opColor, int tolerance, Mode mode) {\n        if (tolerance < 0 || tolerance > 255) {\n            throw new IllegalArgumentException(\"tolerance must be 0..255\");\n        }\n    }"}
{"Number":"100","API Relative Path":"src.android.graphics.Bitmap.java-compress(CompressFormat-int-OutputStream)","Corresponding Source":"/**\n     * Write a compressed version of the bitmap to the specified outputstream.\n     * If this returns true, the bitmap can be reconstructed by passing a\n     * corresponding inputstream to BitmapFactory.decodeStream(). Note: not\n     * all Formats support all bitmap configs directly, so it is possible that\n     * the returned bitmap from BitmapFactory could be in a different bitdepth,\n     * and/or may have lost per-pixel alpha (e.g. JPEG only supports opaque\n     * pixels).\n     *\n     * @param format   The format of the compressed image\n     * @param quality  Hint to the compressor, 0-100. 0 meaning compress for\n     *                 small size, 100 meaning compress for max quality. Some\n     *                 formats, like PNG which is lossless, will ignore the\n     *                 quality setting\n     * @param stream   The outputstream to write the compressed data.\n     * @return true if successfully compressed to the specified stream.\n     */\n    public boolean compress(CompressFormat format, int quality, OutputStream stream) {\n        checkRecycled(\"Can't compress a recycled bitmap\");\n        // do explicit check before calling the native method\n        if (stream == null) {\n            throw new NullPointerException();\n        }\n        if (quality < 0 || quality > 100) {\n            throw new IllegalArgumentException(\"quality must be 0..100\");\n        }\n        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, \"Bitmap.compress\");\n        boolean result = nativeCompress(mNativePtr, format.nativeInt,\n                quality, stream, new byte[WORKING_COMPRESS_STORAGE]);\n        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);\n        return result;\n    }"}
{"Number":"101","API Relative Path":"src.android.graphics.Bitmap.java-compress(CompressFormat-int-OutputStream)","Corresponding Source":"/**\n     * Write a compressed version of the bitmap to the specified outputstream.\n     * If this returns true, the bitmap can be reconstructed by passing a\n     * corresponding inputstream to BitmapFactory.decodeStream(). Note: not\n     * all Formats support all bitmap configs directly, so it is possible that\n     * the returned bitmap from BitmapFactory could be in a different bitdepth,\n     * and/or may have lost per-pixel alpha (e.g. JPEG only supports opaque\n     * pixels).\n     *\n     * @param format   The format of the compressed image\n     * @param quality  Hint to the compressor, 0-100. 0 meaning compress for\n     *                 small size, 100 meaning compress for max quality. Some\n     *                 formats, like PNG which is lossless, will ignore the\n     *                 quality setting\n     * @param stream   The outputstream to write the compressed data.\n     * @return true if successfully compressed to the specified stream.\n     */\n    public boolean compress(CompressFormat format, int quality, OutputStream stream) {\n        checkRecycled(\"Can't compress a recycled bitmap\");\n        // do explicit check before calling the native method\n        if (stream == null) {\n            throw new NullPointerException();\n        }\n        if (quality < 0 || quality > 100) {\n            throw new IllegalArgumentException(\"quality must be 0..100\");\n        }\n        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, \"Bitmap.compress\");\n        boolean result = nativeCompress(mNativePtr, format.nativeInt,\n                quality, stream, new byte[WORKING_COMPRESS_STORAGE]);\n        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);\n        return result;\n    }"}
{"Number":"102","API Relative Path":"src.android.graphics.Bitmap.java-copyPixelsFromBuffer(Buffer)","Corresponding Source":"/**\n     * <p>Copy the pixels from the buffer, beginning at the current position,\n     * overwriting the bitmap's pixels. The data in the buffer is not changed\n     * in any way (unlike setPixels(), which converts from unpremultipled 32bit\n     * to whatever the bitmap's native format is.<\/p>\n     * <p>After this method returns, the current position of the buffer is\n     * updated: the position is incremented by the number of elements read from\n     * the buffer. If you need to read the bitmap from the buffer again you must\n     * first rewind the buffer.<\/p>\n     */\n    public void copyPixelsFromBuffer(Buffer src) {\n        checkRecycled(\"copyPixelsFromBuffer called on recycled bitmap\");\n\n        int elements = src.remaining();\n        int shift;\n        if (src instanceof ByteBuffer) {\n            shift = 0;\n        } else if (src instanceof ShortBuffer) {\n            shift = 1;\n        } else if (src instanceof IntBuffer) {\n            shift = 2;\n        } else {\n            throw new RuntimeException(\"unsupported Buffer subclass\");\n        }\n\n        long bufferBytes = (long) elements << shift;\n        long bitmapBytes = getByteCount();\n\n        if (bufferBytes < bitmapBytes) {\n            throw new RuntimeException(\"Buffer not large enough for pixels\");\n        }\n\n        nativeCopyPixelsFromBuffer(mNativePtr, src);\n\n        // now update the buffer's position\n        int position = src.position();\n        position += bitmapBytes >> shift;\n        src.position(position);\n    }"}
{"Number":"103","API Relative Path":"src.android.graphics.Bitmap.java-copyPixelsToBuffer(Buffer)","Corresponding Source":"/**\n     * <p>Copy the bitmap's pixels into the specified buffer (allocated by the\n     * caller). An exception is thrown if the buffer is not large enough to\n     * hold all of the pixels (taking into account the number of bytes per\n     * pixel) or if the Buffer subclass is not one of the support types\n     * (ByteBuffer, ShortBuffer, IntBuffer).<\/p>\n     * <p>The content of the bitmap is copied into the buffer as-is. This means\n     * that if this bitmap stores its pixels pre-multiplied\n     * (see {@link #isPremultiplied()}, the values in the buffer will also be\n     * pre-multiplied.<\/p>\n     * <p>After this method returns, the current position of the buffer is\n     * updated: the position is incremented by the number of elements written\n     * in the buffer.<\/p>\n     */\n    public void copyPixelsToBuffer(Buffer dst) {\n        int elements = dst.remaining();\n        int shift;\n        if (dst instanceof ByteBuffer) {\n            shift = 0;\n        } else if (dst instanceof ShortBuffer) {\n            shift = 1;\n        } else if (dst instanceof IntBuffer) {\n            shift = 2;\n        } else {\n            throw new RuntimeException(\"unsupported Buffer subclass\");\n        }\n\n        long bufferSize = (long)elements << shift;\n        long pixelSize = getByteCount();\n\n        if (bufferSize < pixelSize) {\n            throw new RuntimeException(\"Buffer not large enough for pixels\");\n        }\n\n        nativeCopyPixelsToBuffer(mNativePtr, dst);\n\n        // now update the buffer's position\n        int position = dst.position();\n        position += pixelSize >> shift;\n        dst.position(position);\n    }"}
{"Number":"104","API Relative Path":"src.android.graphics.Bitmap.java-createBitmap(DisplayMetrics-int-int-int-int-int-Config)","Corresponding Source":"/**\n     * Returns a immutable bitmap with the specified width and height, with each\n     * pixel value set to the corresponding value in the colors array.  Its\n     * initial density is determined from the given {@link DisplayMetrics}.\n     *\n     * @param display  Display metrics for the display this bitmap will be\n     *                 drawn on.\n     * @param colors   Array of {@link Color} used to initialize the pixels.\n     * @param offset   Number of values to skip before the first color in the\n     *                 array of colors.\n     * @param stride   Number of colors in the array between rows (must be >=\n     *                 width or <= -width).\n     * @param width    The width of the bitmap\n     * @param height   The height of the bitmap\n     * @param config   The bitmap config to create. If the config does not\n     *                 support per-pixel alpha (e.g. RGB_565), then the alpha\n     *                 bytes in the colors[] will be ignored (assumed to be FF)\n     * @throws IllegalArgumentException if the width or height are <= 0, or if\n     *         the color array's length is less than the number of pixels.\n     */\n    public static Bitmap createBitmap(DisplayMetrics display, int colors[],\n            int offset, int stride, int width, int height, Config config) {\n\n        checkWidthHeight(width, height);\n        if (Math.abs(stride) < width) {\n            throw new IllegalArgumentException(\"abs(stride) must be >= width\");\n        }\n        int lastScanline = offset + (height - 1) * stride;\n        int length = colors.length;\n        if (offset < 0 || (offset + width > length) || lastScanline < 0 ||\n                (lastScanline + width > length)) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        if (width <= 0 || height <= 0) {\n            throw new IllegalArgumentException(\"width and height must be > 0\");\n        }\n        Bitmap bm = nativeCreate(colors, offset, stride, width, height,\n                            config.nativeInt, false);\n        if (display != null) {\n            bm.mDensity = display.densityDpi;\n        }\n        return bm;\n    }"}
{"Number":"105","API Relative Path":"src.android.graphics.Bitmap.java-reconfigure(int-int-Config)","Corresponding Source":"/**\n     * <p>Modifies the bitmap to have a specified width, height, and {@link\n     * Config}, without affecting the underlying allocation backing the bitmap.\n     * Bitmap pixel data is not re-initialized for the new configuration.<\/p>\n     *\n     * <p>This method can be used to avoid allocating a new bitmap, instead\n     * reusing an existing bitmap's allocation for a new configuration of equal\n     * or lesser size. If the Bitmap's allocation isn't large enough to support\n     * the new configuration, an IllegalArgumentException will be thrown and the\n     * bitmap will not be modified.<\/p>\n     *\n     * <p>The result of {@link #getByteCount()} will reflect the new configuration,\n     * while {@link #getAllocationByteCount()} will reflect that of the initial\n     * configuration.<\/p>\n     *\n     * <p>Note: This may change this result of hasAlpha(). When converting to 565,\n     * the new bitmap will always be considered opaque. When converting from 565,\n     * the new bitmap will be considered non-opaque, and will respect the value\n     * set by setPremultiplied().<\/p>\n     *\n     * <p>WARNING: This method should NOT be called on a bitmap currently in use\n     * by the view system, Canvas, or the AndroidBitmap NDK API. It does not\n     * make guarantees about how the underlying pixel buffer is remapped to the\n     * new config, just that the allocation is reused. Additionally, the view\n     * system does not account for bitmap properties being modifying during use,\n     * e.g. while attached to drawables.<\/p>\n     *\n     * <p>In order to safely ensure that a Bitmap is no longer in use by the\n     * View system it is necessary to wait for a draw pass to occur after\n     * invalidate()'ing any view that had previously drawn the Bitmap in the last\n     * draw pass due to hardware acceleration's caching of draw commands. As\n     * an example, here is how this can be done for an ImageView:\n     * <pre class=\"prettyprint\">\n     *      ImageView myImageView = ...;\n     *      final Bitmap myBitmap = ...;\n     *      myImageView.setImageDrawable(null);\n     *      myImageView.post(new Runnable() {\n     *          public void run() {\n     *              // myBitmap is now no longer in use by the ImageView\n     *              // and can be safely reconfigured.\n     *              myBitmap.reconfigure(...);\n     *          }\n     *      });\n     * <\/pre><\/p>\n     *\n     * @see #setWidth(int)\n     * @see #setHeight(int)\n     * @see #setConfig(Config)\n     */\n    public void reconfigure(int width, int height, Config config) {\n        checkRecycled(\"Can't call reconfigure() on a recycled bitmap\");\n        if (width <= 0 || height <= 0) {\n            throw new IllegalArgumentException(\"width and height must be > 0\");\n        }\n        if (!isMutable()) {\n            throw new IllegalStateException(\"only mutable bitmaps may be reconfigured\");\n        }\n        if (mBuffer == null) {\n            throw new IllegalStateException(\"native-backed bitmaps may not be reconfigured\");\n        }\n\n        nativeReconfigure(mNativePtr, width, height, config.nativeInt,\n                mBuffer.length, mRequestPremultiplied);\n        mWidth = width;\n        mHeight = height;\n    }"}
{"Number":"106","API Relative Path":"src.android.graphics.BitmapFactory.java-decodeByteArray(byte[]-int-int-Options)","Corresponding Source":"private static native Bitmap nativeDecodeByteArray(byte[] data, int offset,\n            int length, Options opts);"}
{"Number":"107","API Relative Path":"src.android.graphics.BitmapFactory.java-decodeStream(InputStream-Rect-Options)","Corresponding Source":"/**\n     * Decode an input stream into a bitmap. If the input stream is null, or\n     * cannot be used to decode a bitmap, the function returns null.\n     * The stream's position will be where ever it was after the encoded data\n     * was read.\n     *\n     * @param is The input stream that holds the raw data to be decoded into a\n     *           bitmap.\n     * @param outPadding If not null, return the padding rect for the bitmap if\n     *                   it exists, otherwise set padding to [-1,-1,-1,-1]. If\n     *                   no bitmap is returned (null) then padding is\n     *                   unchanged.\n     * @param opts null-ok; Options that control downsampling and whether the\n     *             image should be completely decoded, or just is size returned.\n     * @return The decoded bitmap, or null if the image data could not be\n     *         decoded, or, if opts is non-null, if opts requested only the\n     *         size be returned (in opts.outWidth and opts.outHeight)\n     *\n     * <p class=\"note\">Prior to {@link android.os.Build.VERSION_CODES#KITKAT},\n     * if {@link InputStream#markSupported is.markSupported()} returns true,\n     * <code>is.mark(1024)<\/code> would be called. As of\n     * {@link android.os.Build.VERSION_CODES#KITKAT}, this is no longer the case.<\/p>\n     */\n    public static Bitmap decodeStream(InputStream is, Rect outPadding, Options opts) {\n        // we don't throw in this case, thus allowing the caller to only check\n        // the cache, and not force the image to be decoded.\n        if (is == null) {\n            return null;\n        }\n\n        Bitmap bm = null;\n\n        Trace.traceBegin(Trace.TRACE_TAG_GRAPHICS, \"decodeBitmap\");\n        try {\n            if (is instanceof AssetManager.AssetInputStream) {\n                final long asset = ((AssetManager.AssetInputStream) is).getNativeAsset();\n                bm = nativeDecodeAsset(asset, outPadding, opts);\n            } else {\n                bm = decodeStreamInternal(is, outPadding, opts);\n            }\n\n            if (bm == null && opts != null && opts.inBitmap != null) {\n                throw new IllegalArgumentException(\"Problem decoding into existing bitmap\");\n            }\n\n            setDensityFromOptions(bm, opts);\n        } finally {\n            Trace.traceEnd(Trace.TRACE_TAG_GRAPHICS);\n        }\n\n        return bm;\n    }"}
{"Number":"108","API Relative Path":"src.android.graphics.BitmapRegionDecoder.java-newInstance(byte[]-int-int-boolean)","Corresponding Source":"private static native BitmapRegionDecoder nativeNewInstance(\n            byte[] data, int offset, int length, boolean isShareable);"}
{"Number":"109","API Relative Path":"src.android.graphics.Canvas.java-Canvas(long)","Corresponding Source":"/** @hide */\n    public Canvas(long nativeCanvas) {\n        if (nativeCanvas == 0) {\n            throw new IllegalStateException();\n        }\n        mNativeCanvasWrapper = nativeCanvas;\n        mFinalizer = NoImagePreloadHolder.sRegistry.registerNativeAllocation(\n                this, mNativeCanvasWrapper);\n        mDensity = Bitmap.getDefaultDensity();\n    }"}
{"Number":"110","API Relative Path":"src.android.graphics.Canvas.java-checkRange(int-int-int)","Corresponding Source":"/**\n     * @hide\n     */\n    protected static void checkRange(int length, int offset, int count) {\n        if ((offset | count) < 0 || offset + count > length) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n    }"}
{"Number":"111","API Relative Path":"src.android.graphics.Canvas.java-concat(Matrix)","Corresponding Source":"/**\n     * Preconcat the current matrix with the specified matrix. If the specified\n     * matrix is null, this method does nothing.\n     *\n     * @param matrix The matrix to preconcatenate with the current matrix\n     */\n    public void concat(@Nullable Matrix matrix) {\n        if (matrix != null) native_concat(mNativeCanvasWrapper, matrix.native_instance);\n    }"}
{"Number":"112","API Relative Path":"src.android.graphics.Canvas.java-drawBitmap(Bitmap-Rect-Rect-Paint)","Corresponding Source":"/**\n     * Draw the specified bitmap, scaling/translating automatically to fill\n     * the destination rectangle. If the source rectangle is not null, it\n     * specifies the subset of the bitmap to draw.\n     *\n     * <p>Note: if the paint contains a maskfilter that generates a mask which\n     * extends beyond the bitmap's original width/height (e.g. BlurMaskFilter),\n     * then the bitmap will be drawn as if it were in a Shader with CLAMP mode.\n     * Thus the color outside of the original width/height will be the edge\n     * color replicated.\n     *\n     * <p>This function <em>ignores the density associated with the bitmap<\/em>.\n     * This is because the source and destination rectangle coordinate\n     * spaces are in their respective densities, so must already have the\n     * appropriate scaling factor applied.\n     *\n     * @param bitmap The bitmap to be drawn\n     * @param src    May be null. The subset of the bitmap to be drawn\n     * @param dst    The rectangle that the bitmap will be scaled/translated\n     *               to fit into\n     * @param paint  May be null. The paint used to draw the bitmap\n     */\n    public void drawBitmap(@NonNull Bitmap bitmap, @Nullable Rect src, @NonNull Rect dst,\n            @Nullable Paint paint) {\n        if (dst == null) {\n            throw new NullPointerException();\n        }\n        throwIfCannotDraw(bitmap);\n        final long nativePaint = paint == null ? 0 : paint.getNativeInstance();\n\n        int left, top, right, bottom;\n        if (src == null) {\n            left = top = 0;\n            right = bitmap.getWidth();\n            bottom = bitmap.getHeight();\n        } else {\n            left = src.left;\n            right = src.right;\n            top = src.top;\n            bottom = src.bottom;\n        }\n\n        native_drawBitmap(mNativeCanvasWrapper, bitmap, left, top, right, bottom,\n            dst.left, dst.top, dst.right, dst.bottom, nativePaint, mScreenDensity,\n            bitmap.mDensity);\n    }"}
{"Number":"113","API Relative Path":"src.android.graphics.Canvas.java-drawBitmap(Bitmap-Rect-RectF-Paint)","Corresponding Source":"/**\n     * Draw the specified bitmap, scaling/translating automatically to fill\n     * the destination rectangle. If the source rectangle is not null, it\n     * specifies the subset of the bitmap to draw.\n     *\n     * <p>Note: if the paint contains a maskfilter that generates a mask which\n     * extends beyond the bitmap's original width/height (e.g. BlurMaskFilter),\n     * then the bitmap will be drawn as if it were in a Shader with CLAMP mode.\n     * Thus the color outside of the original width/height will be the edge\n     * color replicated.\n     *\n     * <p>This function <em>ignores the density associated with the bitmap<\/em>.\n     * This is because the source and destination rectangle coordinate\n     * spaces are in their respective densities, so must already have the\n     * appropriate scaling factor applied.\n     *\n     * @param bitmap The bitmap to be drawn\n     * @param src    May be null. The subset of the bitmap to be drawn\n     * @param dst    The rectangle that the bitmap will be scaled/translated\n     *               to fit into\n     * @param paint  May be null. The paint used to draw the bitmap\n     */\n    public void drawBitmap(@NonNull Bitmap bitmap, @Nullable Rect src, @NonNull RectF dst,\n            @Nullable Paint paint) {\n      if (dst == null) {\n          throw new NullPointerException();\n      }\n      throwIfCannotDraw(bitmap);\n      final long nativePaint = paint == null ? 0 : paint.getNativeInstance();\n\n      float left, top, right, bottom;\n      if (src == null) {\n          left = top = 0;\n          right = bitmap.getWidth();\n          bottom = bitmap.getHeight();\n      } else {\n          left = src.left;\n          right = src.right;\n          top = src.top;\n          bottom = src.bottom;\n      }\n\n      native_drawBitmap(mNativeCanvasWrapper, bitmap, left, top, right, bottom,\n              dst.left, dst.top, dst.right, dst.bottom, nativePaint, mScreenDensity,\n              bitmap.mDensity);\n  }"}
{"Number":"114","API Relative Path":"src.android.graphics.Canvas.java-drawBitmap(int[]-int-int-float-float-int-int-boolean-Paint)","Corresponding Source":"/**\n     * Treat the specified array of colors as a bitmap, and draw it. This gives\n     * the same result as first creating a bitmap from the array, and then\n     * drawing it, but this method avoids explicitly creating a bitmap object\n     * which can be more efficient if the colors are changing often.\n     *\n     * @param colors Array of colors representing the pixels of the bitmap\n     * @param offset Offset into the array of colors for the first pixel\n     * @param stride The number of colors in the array between rows (must be\n     *               >= width or <= -width).\n     * @param x The X coordinate for where to draw the bitmap\n     * @param y The Y coordinate for where to draw the bitmap\n     * @param width The width of the bitmap\n     * @param height The height of the bitmap\n     * @param hasAlpha True if the alpha channel of the colors contains valid\n     *                 values. If false, the alpha byte is ignored (assumed to\n     *                 be 0xFF for every pixel).\n     * @param paint  May be null. The paint used to draw the bitmap\n     *\n     * @deprecated Usage with a {@link #isHardwareAccelerated() hardware accelerated} canvas\n     * requires an internal copy of color buffer contents every time this method is called. Using a\n     * Bitmap avoids this copy, and allows the application to more explicitly control the lifetime\n     * and copies of pixel data.\n     */\n    @Deprecated\n    public void drawBitmap(@NonNull int[] colors, int offset, int stride, float x, float y,\n            int width, int height, boolean hasAlpha, @Nullable Paint paint) {\n        // check for valid input\n        if (width < 0) {\n            throw new IllegalArgumentException(\"width must be >= 0\");\n        }\n        if (height < 0) {\n            throw new IllegalArgumentException(\"height must be >= 0\");\n        }\n        if (Math.abs(stride) < width) {\n            throw new IllegalArgumentException(\"abs(stride) must be >= width\");\n        }\n        int lastScanline = offset + (height - 1) * stride;\n        int length = colors.length;\n        if (offset < 0 || (offset + width > length) || lastScanline < 0\n                || (lastScanline + width > length)) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        // quick escape if there's nothing to draw\n        if (width == 0 || height == 0) {\n            return;\n        }\n        // punch down to native for the actual draw\n        native_drawBitmap(mNativeCanvasWrapper, colors, offset, stride, x, y, width, height, hasAlpha,\n                paint != null ? paint.getNativeInstance() : 0);\n    }"}
{"Number":"115","API Relative Path":"src.android.graphics.Canvas.java-drawBitmap(int[]-int-int-float-float-int-int-boolean-Paint)","Corresponding Source":"/**\n     * Treat the specified array of colors as a bitmap, and draw it. This gives\n     * the same result as first creating a bitmap from the array, and then\n     * drawing it, but this method avoids explicitly creating a bitmap object\n     * which can be more efficient if the colors are changing often.\n     *\n     * @param colors Array of colors representing the pixels of the bitmap\n     * @param offset Offset into the array of colors for the first pixel\n     * @param stride The number of colors in the array between rows (must be\n     *               >= width or <= -width).\n     * @param x The X coordinate for where to draw the bitmap\n     * @param y The Y coordinate for where to draw the bitmap\n     * @param width The width of the bitmap\n     * @param height The height of the bitmap\n     * @param hasAlpha True if the alpha channel of the colors contains valid\n     *                 values. If false, the alpha byte is ignored (assumed to\n     *                 be 0xFF for every pixel).\n     * @param paint  May be null. The paint used to draw the bitmap\n     *\n     * @deprecated Usage with a {@link #isHardwareAccelerated() hardware accelerated} canvas\n     * requires an internal copy of color buffer contents every time this method is called. Using a\n     * Bitmap avoids this copy, and allows the application to more explicitly control the lifetime\n     * and copies of pixel data.\n     */\n    @Deprecated\n    public void drawBitmap(@NonNull int[] colors, int offset, int stride, float x, float y,\n            int width, int height, boolean hasAlpha, @Nullable Paint paint) {\n        // check for valid input\n        if (width < 0) {\n            throw new IllegalArgumentException(\"width must be >= 0\");\n        }\n        if (height < 0) {\n            throw new IllegalArgumentException(\"height must be >= 0\");\n        }\n        if (Math.abs(stride) < width) {\n            throw new IllegalArgumentException(\"abs(stride) must be >= width\");\n        }\n        int lastScanline = offset + (height - 1) * stride;\n        int length = colors.length;\n        if (offset < 0 || (offset + width > length) || lastScanline < 0\n                || (lastScanline + width > length)) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        // quick escape if there's nothing to draw\n        if (width == 0 || height == 0) {\n            return;\n        }\n        // punch down to native for the actual draw\n        native_drawBitmap(mNativeCanvasWrapper, colors, offset, stride, x, y, width, height, hasAlpha,\n                paint != null ? paint.getNativeInstance() : 0);\n    }"}
{"Number":"116","API Relative Path":"src.android.graphics.Canvas.java-drawBitmap(int[]-int-int-float-float-int-int-boolean-Paint)","Corresponding Source":"/**\n     * Treat the specified array of colors as a bitmap, and draw it. This gives\n     * the same result as first creating a bitmap from the array, and then\n     * drawing it, but this method avoids explicitly creating a bitmap object\n     * which can be more efficient if the colors are changing often.\n     *\n     * @param colors Array of colors representing the pixels of the bitmap\n     * @param offset Offset into the array of colors for the first pixel\n     * @param stride The number of colors in the array between rows (must be\n     *               >= width or <= -width).\n     * @param x The X coordinate for where to draw the bitmap\n     * @param y The Y coordinate for where to draw the bitmap\n     * @param width The width of the bitmap\n     * @param height The height of the bitmap\n     * @param hasAlpha True if the alpha channel of the colors contains valid\n     *                 values. If false, the alpha byte is ignored (assumed to\n     *                 be 0xFF for every pixel).\n     * @param paint  May be null. The paint used to draw the bitmap\n     *\n     * @deprecated Usage with a {@link #isHardwareAccelerated() hardware accelerated} canvas\n     * requires an internal copy of color buffer contents every time this method is called. Using a\n     * Bitmap avoids this copy, and allows the application to more explicitly control the lifetime\n     * and copies of pixel data.\n     */\n    @Deprecated\n    public void drawBitmap(@NonNull int[] colors, int offset, int stride, float x, float y,\n            int width, int height, boolean hasAlpha, @Nullable Paint paint) {\n        // check for valid input\n        if (width < 0) {\n            throw new IllegalArgumentException(\"width must be >= 0\");\n        }\n        if (height < 0) {\n            throw new IllegalArgumentException(\"height must be >= 0\");\n        }\n        if (Math.abs(stride) < width) {\n            throw new IllegalArgumentException(\"abs(stride) must be >= width\");\n        }\n        int lastScanline = offset + (height - 1) * stride;\n        int length = colors.length;\n        if (offset < 0 || (offset + width > length) || lastScanline < 0\n                || (lastScanline + width > length)) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        // quick escape if there's nothing to draw\n        if (width == 0 || height == 0) {\n            return;\n        }\n        // punch down to native for the actual draw\n        native_drawBitmap(mNativeCanvasWrapper, colors, offset, stride, x, y, width, height, hasAlpha,\n                paint != null ? paint.getNativeInstance() : 0);\n    }"}
{"Number":"117","API Relative Path":"src.android.graphics.Canvas.java-drawBitmapMesh(Bitmap-int-int-float[]-int-int[]-int-Paint)","Corresponding Source":"/**\n     * Draw the bitmap through the mesh, where mesh vertices are evenly\n     * distributed across the bitmap. There are meshWidth+1 vertices across, and\n     * meshHeight+1 vertices down. The verts array is accessed in row-major\n     * order, so that the first meshWidth+1 vertices are distributed across the\n     * top of the bitmap from left to right. A more general version of this\n     * method is drawVertices().\n     *\n     * @param bitmap The bitmap to draw using the mesh\n     * @param meshWidth The number of columns in the mesh. Nothing is drawn if\n     *                  this is 0\n     * @param meshHeight The number of rows in the mesh. Nothing is drawn if\n     *                   this is 0\n     * @param verts Array of x,y pairs, specifying where the mesh should be\n     *              drawn. There must be at least\n     *              (meshWidth+1) * (meshHeight+1) * 2 + vertOffset values\n     *              in the array\n     * @param vertOffset Number of verts elements to skip before drawing\n     * @param colors May be null. Specifies a color at each vertex, which is\n     *               interpolated across the cell, and whose values are\n     *               multiplied by the corresponding bitmap colors. If not null,\n     *               there must be at least (meshWidth+1) * (meshHeight+1) +\n     *               colorOffset values in the array.\n     * @param colorOffset Number of color elements to skip before drawing\n     * @param paint  May be null. The paint used to draw the bitmap\n     */\n    public void drawBitmapMesh(@NonNull Bitmap bitmap, int meshWidth, int meshHeight,\n            @NonNull float[] verts, int vertOffset, @Nullable int[] colors, int colorOffset,\n            @Nullable Paint paint) {\n        if ((meshWidth | meshHeight | vertOffset | colorOffset) < 0) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        if (meshWidth == 0 || meshHeight == 0) {\n            return;\n        }\n        int count = (meshWidth + 1) * (meshHeight + 1);\n        // we mul by 2 since we need two floats per vertex\n        checkRange(verts.length, vertOffset, count * 2);\n        if (colors != null) {\n            // no mul by 2, since we need only 1 color per vertex\n            checkRange(colors.length, colorOffset, count);\n        }\n        nativeDrawBitmapMesh(mNativeCanvasWrapper, bitmap, meshWidth, meshHeight,\n                verts, vertOffset, colors, colorOffset,\n                paint != null ? paint.getNativeInstance() : 0);\n    }"}
{"Number":"118","API Relative Path":"src.android.graphics.Canvas.java-drawOval(RectF-Paint)","Corresponding Source":"/**\n     * Draw the specified oval using the specified paint. The oval will be\n     * filled or framed based on the Style in the paint.\n     *\n     * @param oval The rectangle bounds of the oval to be drawn\n     */\n    public void drawOval(@NonNull RectF oval, @NonNull Paint paint) {\n        if (oval == null) {\n            throw new NullPointerException();\n        }\n        drawOval(oval.left, oval.top, oval.right, oval.bottom, paint);\n    }"}
{"Number":"119","API Relative Path":"src.android.graphics.Canvas.java-drawPosText(char[]-int-int-float[]-Paint)","Corresponding Source":"/**\n     * Draw the text in the array, with each character's origin specified by\n     * the pos array.\n     *\n     * @param text     The text to be drawn\n     * @param index    The index of the first character to draw\n     * @param count    The number of characters to draw, starting from index.\n     * @param pos      Array of [x,y] positions, used to position each\n     *                 character\n     * @param paint    The paint used for the text (e.g. color, size, style)\n     *\n     * @deprecated This method does not support glyph composition and decomposition and\n     * should therefore not be used to render complex scripts. It also doesn't\n     * handle supplementary characters (eg emoji).\n     */\n    @Deprecated\n    public void drawPosText(@NonNull char[] text, int index, int count,\n            @NonNull @Size(multiple=2) float[] pos,\n            @NonNull Paint paint) {\n        if (index < 0 || index + count > text.length || count*2 > pos.length) {\n            throw new IndexOutOfBoundsException();\n        }\n        for (int i = 0; i < count; i++) {\n            drawText(text, index + i, 1, pos[i * 2], pos[i * 2 + 1], paint);\n        }\n    }"}
{"Number":"120","API Relative Path":"src.android.graphics.Canvas.java-drawText(char[]-int-int-float-float-Paint)","Corresponding Source":"/**\n     * Draw the specified range of text, specified by start/end, with its\n     * origin at (x,y), in the specified Paint. The origin is interpreted\n     * based on the Align setting in the Paint.\n     *\n     * @param text     The text to be drawn\n     * @param start    The index of the first character in text to draw\n     * @param end      (end - 1) is the index of the last character in text\n     *                 to draw\n     * @param x        The x-coordinate of origin for where to draw the text\n     * @param y        The y-coordinate of origin for where to draw the text\n     * @param paint The paint used for the text (e.g. color, size, style)\n     */\n    public void drawText(@NonNull CharSequence text, int start, int end, float x, float y,\n            @NonNull Paint paint) {\n        if ((start | end | (end - start) | (text.length() - end)) < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (text instanceof String || text instanceof SpannedString ||\n            text instanceof SpannableString) {\n            native_drawText(mNativeCanvasWrapper, text.toString(), start, end, x, y,\n                    paint.mBidiFlags, paint.getNativeInstance(), paint.mNativeTypeface);\n        } else if (text instanceof GraphicsOperations) {\n            ((GraphicsOperations) text).drawText(this, start, end, x, y,\n                    paint);\n        } else {\n            char[] buf = TemporaryBuffer.obtain(end - start);\n            TextUtils.getChars(text, start, end, buf, 0);\n            native_drawText(mNativeCanvasWrapper, buf, 0, end - start, x, y,\n                    paint.mBidiFlags, paint.getNativeInstance(), paint.mNativeTypeface);\n            TemporaryBuffer.recycle(buf);\n        }\n    }"}
{"Number":"121","API Relative Path":"src.android.graphics.Canvas.java-drawTextOnPath(char[]-int-int-Path-float-float-Paint)","Corresponding Source":"/**\n     * Draw the text, with origin at (x,y), using the specified paint, along\n     * the specified path. The paint's Align setting determins where along the\n     * path to start the text.\n     *\n     * @param text     The text to be drawn\n     * @param path     The path the text should follow for its baseline\n     * @param hOffset  The distance along the path to add to the text's\n     *                 starting position\n     * @param vOffset  The distance above(-) or below(+) the path to position\n     *                 the text\n     * @param paint    The paint used for the text (e.g. color, size, style)\n     */\n    public void drawTextOnPath(@NonNull char[] text, int index, int count, @NonNull Path path,\n            float hOffset, float vOffset, @NonNull Paint paint) {\n        if (index < 0 || index + count > text.length) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        native_drawTextOnPath(mNativeCanvasWrapper, text, index, count,\n                path.ni(), hOffset, vOffset,\n                paint.mBidiFlags, paint.getNativeInstance(), paint.mNativeTypeface);\n    }"}
{"Number":"122","API Relative Path":"src.android.graphics.Canvas.java-drawTextRun(CharSequence-int-int-int-int-float-float-boolean-Paint)","Corresponding Source":"/**\n     * Draw a run of text, all in a single direction, with optional context for complex text\n     * shaping.\n     *\n     * <p>The run of text includes the characters from {@code start} to {@code end} in the text. In\n     * addition, the range {@code contextStart} to {@code contextEnd} is used as context for the\n     * purpose of complex text shaping, such as Arabic text potentially shaped differently based on\n     * the text next to it.\n     *\n     * <p>All text outside the range {@code contextStart..contextEnd} is ignored. The text between\n     * {@code start} and {@code end} will be laid out and drawn.\n     *\n     * <p>The direction of the run is explicitly specified by {@code isRtl}. Thus, this method is\n     * suitable only for runs of a single direction. Alignment of the text is as determined by the\n     * Paint's TextAlign value. Further, {@code 0 <= contextStart <= start <= end <= contextEnd\n     * <= text.length} must hold on entry.\n     *\n     * <p>Also see {@link android.graphics.Paint#getRunAdvance} for a corresponding method to\n     * measure the text; the advance width of the text drawn matches the value obtained from that\n     * method.\n     *\n     * @param text the text to render\n     * @param start the start of the text to render. Data before this position\n     *            can be used for shaping context.\n     * @param end the end of the text to render. Data at or after this\n     *            position can be used for shaping context.\n     * @param contextStart the index of the start of the shaping context\n     * @param contextEnd the index of the end of the shaping context\n     * @param x the x position at which to draw the text\n     * @param y the y position at which to draw the text\n     * @param isRtl whether the run is in RTL direction\n     * @param paint the paint\n     *\n     * @see #drawTextRun(char[], int, int, int, int, float, float, boolean, Paint)\n     */\n    public void drawTextRun(@NonNull CharSequence text, int start, int end, int contextStart,\n            int contextEnd, float x, float y, boolean isRtl, @NonNull Paint paint) {\n\n        if (text == null) {\n            throw new NullPointerException(\"text is null\");\n        }\n        if (paint == null) {\n            throw new NullPointerException(\"paint is null\");\n        }\n        if ((start | end | contextStart | contextEnd | start - contextStart | end - start\n                | contextEnd - end | text.length() - contextEnd) < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        if (text instanceof String || text instanceof SpannedString ||\n                text instanceof SpannableString) {\n            native_drawTextRun(mNativeCanvasWrapper, text.toString(), start, end, contextStart,\n                    contextEnd, x, y, isRtl, paint.getNativeInstance(), paint.mNativeTypeface);\n        } else if (text instanceof GraphicsOperations) {\n            ((GraphicsOperations) text).drawTextRun(this, start, end,\n                    contextStart, contextEnd, x, y, isRtl, paint);\n        } else {\n            int contextLen = contextEnd - contextStart;\n            int len = end - start;\n            char[] buf = TemporaryBuffer.obtain(contextLen);\n            TextUtils.getChars(text, contextStart, contextEnd, buf, 0);\n            native_drawTextRun(mNativeCanvasWrapper, buf, start - contextStart, len,\n                    0, contextLen, x, y, isRtl, paint.getNativeInstance(), paint.mNativeTypeface);\n            TemporaryBuffer.recycle(buf);\n        }\n    }"}
{"Number":"123","API Relative Path":"src.android.graphics.Canvas.java-drawTextRun(CharSequence-int-int-int-int-float-float-boolean-Paint)","Corresponding Source":"/**\n     * Draw a run of text, all in a single direction, with optional context for complex text\n     * shaping.\n     *\n     * <p>The run of text includes the characters from {@code start} to {@code end} in the text. In\n     * addition, the range {@code contextStart} to {@code contextEnd} is used as context for the\n     * purpose of complex text shaping, such as Arabic text potentially shaped differently based on\n     * the text next to it.\n     *\n     * <p>All text outside the range {@code contextStart..contextEnd} is ignored. The text between\n     * {@code start} and {@code end} will be laid out and drawn.\n     *\n     * <p>The direction of the run is explicitly specified by {@code isRtl}. Thus, this method is\n     * suitable only for runs of a single direction. Alignment of the text is as determined by the\n     * Paint's TextAlign value. Further, {@code 0 <= contextStart <= start <= end <= contextEnd\n     * <= text.length} must hold on entry.\n     *\n     * <p>Also see {@link android.graphics.Paint#getRunAdvance} for a corresponding method to\n     * measure the text; the advance width of the text drawn matches the value obtained from that\n     * method.\n     *\n     * @param text the text to render\n     * @param start the start of the text to render. Data before this position\n     *            can be used for shaping context.\n     * @param end the end of the text to render. Data at or after this\n     *            position can be used for shaping context.\n     * @param contextStart the index of the start of the shaping context\n     * @param contextEnd the index of the end of the shaping context\n     * @param x the x position at which to draw the text\n     * @param y the y position at which to draw the text\n     * @param isRtl whether the run is in RTL direction\n     * @param paint the paint\n     *\n     * @see #drawTextRun(char[], int, int, int, int, float, float, boolean, Paint)\n     */\n    public void drawTextRun(@NonNull CharSequence text, int start, int end, int contextStart,\n            int contextEnd, float x, float y, boolean isRtl, @NonNull Paint paint) {\n\n        if (text == null) {\n            throw new NullPointerException(\"text is null\");\n        }\n        if (paint == null) {\n            throw new NullPointerException(\"paint is null\");\n        }\n        if ((start | end | contextStart | contextEnd | start - contextStart | end - start\n                | contextEnd - end | text.length() - contextEnd) < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        if (text instanceof String || text instanceof SpannedString ||\n                text instanceof SpannableString) {\n            native_drawTextRun(mNativeCanvasWrapper, text.toString(), start, end, contextStart,\n                    contextEnd, x, y, isRtl, paint.getNativeInstance(), paint.mNativeTypeface);\n        } else if (text instanceof GraphicsOperations) {\n            ((GraphicsOperations) text).drawTextRun(this, start, end,\n                    contextStart, contextEnd, x, y, isRtl, paint);\n        } else {\n            int contextLen = contextEnd - contextStart;\n            int len = end - start;\n            char[] buf = TemporaryBuffer.obtain(contextLen);\n            TextUtils.getChars(text, contextStart, contextEnd, buf, 0);\n            native_drawTextRun(mNativeCanvasWrapper, buf, start - contextStart, len,\n                    0, contextLen, x, y, isRtl, paint.getNativeInstance(), paint.mNativeTypeface);\n            TemporaryBuffer.recycle(buf);\n        }\n    }"}
{"Number":"124","API Relative Path":"src.android.graphics.Canvas.java-drawTextRun(char[]-int-int-int-int-float-float-boolean-Paint)","Corresponding Source":"/**\n     * Draw a run of text, all in a single direction, with optional context for complex text\n     * shaping.\n     *\n     * <p>The run of text includes the characters from {@code start} to {@code end} in the text. In\n     * addition, the range {@code contextStart} to {@code contextEnd} is used as context for the\n     * purpose of complex text shaping, such as Arabic text potentially shaped differently based on\n     * the text next to it.\n     *\n     * <p>All text outside the range {@code contextStart..contextEnd} is ignored. The text between\n     * {@code start} and {@code end} will be laid out and drawn.\n     *\n     * <p>The direction of the run is explicitly specified by {@code isRtl}. Thus, this method is\n     * suitable only for runs of a single direction. Alignment of the text is as determined by the\n     * Paint's TextAlign value. Further, {@code 0 <= contextStart <= start <= end <= contextEnd\n     * <= text.length} must hold on entry.\n     *\n     * <p>Also see {@link android.graphics.Paint#getRunAdvance} for a corresponding method to\n     * measure the text; the advance width of the text drawn matches the value obtained from that\n     * method.\n     *\n     * @param text the text to render\n     * @param start the start of the text to render. Data before this position\n     *            can be used for shaping context.\n     * @param end the end of the text to render. Data at or after this\n     *            position can be used for shaping context.\n     * @param contextStart the index of the start of the shaping context\n     * @param contextEnd the index of the end of the shaping context\n     * @param x the x position at which to draw the text\n     * @param y the y position at which to draw the text\n     * @param isRtl whether the run is in RTL direction\n     * @param paint the paint\n     *\n     * @see #drawTextRun(char[], int, int, int, int, float, float, boolean, Paint)\n     */\n    public void drawTextRun(@NonNull CharSequence text, int start, int end, int contextStart,\n            int contextEnd, float x, float y, boolean isRtl, @NonNull Paint paint) {\n\n        if (text == null) {\n            throw new NullPointerException(\"text is null\");\n        }\n        if (paint == null) {\n            throw new NullPointerException(\"paint is null\");\n        }\n        if ((start | end | contextStart | contextEnd | start - contextStart | end - start\n                | contextEnd - end | text.length() - contextEnd) < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        if (text instanceof String || text instanceof SpannedString ||\n                text instanceof SpannableString) {\n            native_drawTextRun(mNativeCanvasWrapper, text.toString(), start, end, contextStart,\n                    contextEnd, x, y, isRtl, paint.getNativeInstance(), paint.mNativeTypeface);\n        } else if (text instanceof GraphicsOperations) {\n            ((GraphicsOperations) text).drawTextRun(this, start, end,\n                    contextStart, contextEnd, x, y, isRtl, paint);\n        } else {\n            int contextLen = contextEnd - contextStart;\n            int len = end - start;\n            char[] buf = TemporaryBuffer.obtain(contextLen);\n            TextUtils.getChars(text, contextStart, contextEnd, buf, 0);\n            native_drawTextRun(mNativeCanvasWrapper, buf, start - contextStart, len,\n                    0, contextLen, x, y, isRtl, paint.getNativeInstance(), paint.mNativeTypeface);\n            TemporaryBuffer.recycle(buf);\n        }\n    }"}
{"Number":"125","API Relative Path":"src.android.graphics.Canvas.java-drawTextRun(char[]-int-int-int-int-float-float-boolean-Paint)","Corresponding Source":"/**\n     * Draw a run of text, all in a single direction, with optional context for complex text\n     * shaping.\n     *\n     * <p>The run of text includes the characters from {@code start} to {@code end} in the text. In\n     * addition, the range {@code contextStart} to {@code contextEnd} is used as context for the\n     * purpose of complex text shaping, such as Arabic text potentially shaped differently based on\n     * the text next to it.\n     *\n     * <p>All text outside the range {@code contextStart..contextEnd} is ignored. The text between\n     * {@code start} and {@code end} will be laid out and drawn.\n     *\n     * <p>The direction of the run is explicitly specified by {@code isRtl}. Thus, this method is\n     * suitable only for runs of a single direction. Alignment of the text is as determined by the\n     * Paint's TextAlign value. Further, {@code 0 <= contextStart <= start <= end <= contextEnd\n     * <= text.length} must hold on entry.\n     *\n     * <p>Also see {@link android.graphics.Paint#getRunAdvance} for a corresponding method to\n     * measure the text; the advance width of the text drawn matches the value obtained from that\n     * method.\n     *\n     * @param text the text to render\n     * @param start the start of the text to render. Data before this position\n     *            can be used for shaping context.\n     * @param end the end of the text to render. Data at or after this\n     *            position can be used for shaping context.\n     * @param contextStart the index of the start of the shaping context\n     * @param contextEnd the index of the end of the shaping context\n     * @param x the x position at which to draw the text\n     * @param y the y position at which to draw the text\n     * @param isRtl whether the run is in RTL direction\n     * @param paint the paint\n     *\n     * @see #drawTextRun(char[], int, int, int, int, float, float, boolean, Paint)\n     */\n    public void drawTextRun(@NonNull CharSequence text, int start, int end, int contextStart,\n            int contextEnd, float x, float y, boolean isRtl, @NonNull Paint paint) {\n\n        if (text == null) {\n            throw new NullPointerException(\"text is null\");\n        }\n        if (paint == null) {\n            throw new NullPointerException(\"paint is null\");\n        }\n        if ((start | end | contextStart | contextEnd | start - contextStart | end - start\n                | contextEnd - end | text.length() - contextEnd) < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        if (text instanceof String || text instanceof SpannedString ||\n                text instanceof SpannableString) {\n            native_drawTextRun(mNativeCanvasWrapper, text.toString(), start, end, contextStart,\n                    contextEnd, x, y, isRtl, paint.getNativeInstance(), paint.mNativeTypeface);\n        } else if (text instanceof GraphicsOperations) {\n            ((GraphicsOperations) text).drawTextRun(this, start, end,\n                    contextStart, contextEnd, x, y, isRtl, paint);\n        } else {\n            int contextLen = contextEnd - contextStart;\n            int len = end - start;\n            char[] buf = TemporaryBuffer.obtain(contextLen);\n            TextUtils.getChars(text, contextStart, contextEnd, buf, 0);\n            native_drawTextRun(mNativeCanvasWrapper, buf, start - contextStart, len,\n                    0, contextLen, x, y, isRtl, paint.getNativeInstance(), paint.mNativeTypeface);\n            TemporaryBuffer.recycle(buf);\n        }\n    }"}
{"Number":"126","API Relative Path":"src.android.graphics.Canvas.java-drawTextRun(char[]-int-int-int-int-float-float-boolean-Paint)","Corresponding Source":"/**\n     * Draw a run of text, all in a single direction, with optional context for complex text\n     * shaping.\n     *\n     * <p>The run of text includes the characters from {@code start} to {@code end} in the text. In\n     * addition, the range {@code contextStart} to {@code contextEnd} is used as context for the\n     * purpose of complex text shaping, such as Arabic text potentially shaped differently based on\n     * the text next to it.\n     *\n     * <p>All text outside the range {@code contextStart..contextEnd} is ignored. The text between\n     * {@code start} and {@code end} will be laid out and drawn.\n     *\n     * <p>The direction of the run is explicitly specified by {@code isRtl}. Thus, this method is\n     * suitable only for runs of a single direction. Alignment of the text is as determined by the\n     * Paint's TextAlign value. Further, {@code 0 <= contextStart <= start <= end <= contextEnd\n     * <= text.length} must hold on entry.\n     *\n     * <p>Also see {@link android.graphics.Paint#getRunAdvance} for a corresponding method to\n     * measure the text; the advance width of the text drawn matches the value obtained from that\n     * method.\n     *\n     * @param text the text to render\n     * @param start the start of the text to render. Data before this position\n     *            can be used for shaping context.\n     * @param end the end of the text to render. Data at or after this\n     *            position can be used for shaping context.\n     * @param contextStart the index of the start of the shaping context\n     * @param contextEnd the index of the end of the shaping context\n     * @param x the x position at which to draw the text\n     * @param y the y position at which to draw the text\n     * @param isRtl whether the run is in RTL direction\n     * @param paint the paint\n     *\n     * @see #drawTextRun(char[], int, int, int, int, float, float, boolean, Paint)\n     */\n    public void drawTextRun(@NonNull CharSequence text, int start, int end, int contextStart,\n            int contextEnd, float x, float y, boolean isRtl, @NonNull Paint paint) {\n\n        if (text == null) {\n            throw new NullPointerException(\"text is null\");\n        }\n        if (paint == null) {\n            throw new NullPointerException(\"paint is null\");\n        }\n        if ((start | end | contextStart | contextEnd | start - contextStart | end - start\n                | contextEnd - end | text.length() - contextEnd) < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        if (text instanceof String || text instanceof SpannedString ||\n                text instanceof SpannableString) {\n            native_drawTextRun(mNativeCanvasWrapper, text.toString(), start, end, contextStart,\n                    contextEnd, x, y, isRtl, paint.getNativeInstance(), paint.mNativeTypeface);\n        } else if (text instanceof GraphicsOperations) {\n            ((GraphicsOperations) text).drawTextRun(this, start, end,\n                    contextStart, contextEnd, x, y, isRtl, paint);\n        } else {\n            int contextLen = contextEnd - contextStart;\n            int len = end - start;\n            char[] buf = TemporaryBuffer.obtain(contextLen);\n            TextUtils.getChars(text, contextStart, contextEnd, buf, 0);\n            native_drawTextRun(mNativeCanvasWrapper, buf, start - contextStart, len,\n                    0, contextLen, x, y, isRtl, paint.getNativeInstance(), paint.mNativeTypeface);\n            TemporaryBuffer.recycle(buf);\n        }\n    }"}
{"Number":"127","API Relative Path":"src.android.graphics.Color.java-HSVToColor(int-float)","Corresponding Source":"private static native int nativeHSVToColor(int alpha, float hsv[]);"}
{"Number":"128","API Relative Path":"src.android.graphics.Color.java-RGBToHSV(int-int-int-float)","Corresponding Source":"private static native void nativeRGBToHSV(int red, int greed, int blue, float hsv[]);"}
{"Number":"129","API Relative Path":"src.android.graphics.ColorMatrixColorFilter.java-ColorMatrixColorFilter(float[])","Corresponding Source":"/**\n     * Create a color filter that transforms colors through a 4x5 color matrix.\n     *\n     * @param array Array of floats used to transform colors, treated as a 4x5\n     *              matrix. The first 20 entries of the array are copied into\n     *              the filter. See ColorMatrix.\n     */\n    public ColorMatrixColorFilter(float[] array) {\n        if (array.length < 20) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        mMatrix.set(array);\n        update();\n    }"}
{"Number":"130","API Relative Path":"src.android.graphics.ColorMatrixColorFilter.java-setColorMatrix(float[])","Corresponding Source":"/**\n     * Specifies the color matrix used by this filter. If the specified\n     * color matrix is null, this filter's color matrix will be reset to\n     * the identity matrix.\n     *\n     * @param array Array of floats used to transform colors, treated as a 4x5\n     *              matrix. The first 20 entries of the array are copied into\n     *              the filter. See {@link ColorMatrix}.\n     *\n     * @see #getColorMatrix()\n     * @see android.graphics.ColorMatrix#reset()\n     * @see #setColorMatrix(ColorMatrix)\n     *\n     * @throws ArrayIndexOutOfBoundsException if the specified array's\n     *         length is < 20\n     *\n     * @hide\n     */\n    public void setColorMatrix(float[] array) {\n        if (array == null) {\n            mMatrix.reset();\n        } else {\n            if (array.length < 20) {\n                throw new ArrayIndexOutOfBoundsException();\n            }\n\n            mMatrix.set(array);\n        }\n        update();\n    }"}
{"Number":"131","API Relative Path":"src.android.graphics.DashPathEffect.java-DashPathEffect(float-float)","Corresponding Source":"/**\n     * The intervals array must contain an even number of entries (>=2), with\n     * the even indices specifying the \"on\" intervals, and the odd indices\n     * specifying the \"off\" intervals. phase is an offset into the intervals\n     * array (mod the sum of all of the intervals). The intervals array\n     * controls the length of the dashes. The paint's strokeWidth controls the\n     * thickness of the dashes.\n     * Note: this patheffect only affects drawing with the paint's style is set\n     * to STROKE or FILL_AND_STROKE. It is ignored if the drawing is done with\n     * style == FILL.\n     * @param intervals array of ON and OFF distances\n     * @param phase offset into the intervals array\n     */\n    public DashPathEffect(float intervals[], float phase) {\n        if (intervals.length < 2) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        native_instance = nativeCreate(intervals, phase);\n    }"}
{"Number":"132","API Relative Path":"src.android.graphics.drawable.AnimatedStateListDrawable.java-addState(int[]-Drawable-int)","Corresponding Source":"/**\n     * Add a new drawable to the set of keyframes.\n     *\n     * @param stateSet An array of resource IDs to associate with the keyframe\n     * @param drawable The drawable to show when in the specified state, may not be null\n     * @param id The unique identifier for the keyframe\n     */\n    public void addState(@NonNull int[] stateSet, @NonNull Drawable drawable, int id) {\n        if (drawable == null) {\n            throw new IllegalArgumentException(\"Drawable must not be null\");\n        }\n\n        mState.addStateSet(stateSet, drawable, id);\n        onStateChange(getState());\n    }"}
{"Number":"133","API Relative Path":"src.android.graphics.drawable.AnimatedStateListDrawable.java-addTransition(int-int-T-boolean)","Corresponding Source":"/**\n     * Adds a new transition between keyframes.\n     *\n     * @param fromId Unique identifier of the starting keyframe\n     * @param toId Unique identifier of the ending keyframe\n     * @param transition An {@link Animatable} drawable to use as a transition, may not be null\n     * @param reversible Whether the transition can be reversed\n     */\n    public <T extends Drawable & Animatable> void addTransition(int fromId, int toId,\n            @NonNull T transition, boolean reversible) {\n        if (transition == null) {\n            throw new IllegalArgumentException(\"Transition drawable must not be null\");\n        }\n\n        mState.addTransition(fromId, toId, transition, reversible);\n    }"}
{"Number":"134","API Relative Path":"src.android.graphics.drawable.Drawable.java-createFromPath(String)","Corresponding Source":"/**\n     * Create a drawable from file path name.\n     */\n    public static Drawable createFromPath(String pathName) {\n        if (pathName == null) {\n            return null;\n        }\n\n        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, pathName);\n        try {\n            Bitmap bm = BitmapFactory.decodeFile(pathName);\n            if (bm != null) {\n                return drawableFromBitmap(null, bm, null, null, null, pathName);\n            }\n        } finally {\n            Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);\n        }\n\n        return null;\n    }"}
{"Number":"135","API Relative Path":"src.android.graphics.drawable.DrawableInflater.java-inflateFromXml(String-XmlPullParser-AttributeSet-Theme)","Corresponding Source":"/**\n     * Inflates a drawable from inside an XML document using an optional\n     * {@link Theme}.\n     * <p>\n     * This method should be called on a parser positioned at a tag in an XML\n     * document defining a drawable resource. It will attempt to create a\n     * Drawable from the tag at the current position.\n     *\n     * @param name the name of the tag at the current position\n     * @param parser an XML parser positioned at the drawable tag\n     * @param attrs an attribute set that wraps the parser\n     * @param theme the theme against which the drawable should be inflated, or\n     *              {@code null} to not inflate against a theme\n     * @return a drawable\n     *\n     * @throws XmlPullParserException\n     * @throws IOException\n     */\n    @NonNull\n    public Drawable inflateFromXml(@NonNull String name, @NonNull XmlPullParser parser,\n            @NonNull AttributeSet attrs, @Nullable Theme theme)\n            throws XmlPullParserException, IOException {\n        // Inner classes must be referenced as Outer$Inner, but XML tag names\n        // can't contain $, so the <drawable> tag allows developers to specify\n        // the class in an attribute. We'll still run it through inflateFromTag\n        // to stay consistent with how LayoutInflater works.\n        if (name.equals(\"drawable\")) {\n            name = attrs.getAttributeValue(null, \"class\");\n            if (name == null) {\n                throw new InflateException(\"<drawable> tag must specify class attribute\");\n            }\n        }\n\n        Drawable drawable = inflateFromTag(name);\n        if (drawable == null) {\n            drawable = inflateFromClass(name);\n        }\n        drawable.inflate(mRes, parser, attrs, theme);\n        return drawable;\n    }"}
{"Number":"136","API Relative Path":"src.android.graphics.drawable.Icon.java-createWithBitmap(Bitmap)","Corresponding Source":"/**\n     * Create an Icon pointing to a bitmap in memory.\n     * @param bits A valid {@link android.graphics.Bitmap} object\n     */\n    public static Icon createWithBitmap(Bitmap bits) {\n        if (bits == null) {\n            throw new IllegalArgumentException(\"Bitmap must not be null.\");\n        }\n        final Icon rep = new Icon(TYPE_BITMAP);\n        rep.setBitmap(bits);\n        return rep;\n    }"}
{"Number":"137","API Relative Path":"src.android.graphics.drawable.Icon.java-createWithContentUri(String)","Corresponding Source":"/**\n     * Create an Icon pointing to an image file specified by URI.\n     *\n     * @param uri A uri referring to local content:// or file:// image data.\n     */\n    public static Icon createWithContentUri(String uri) {\n        if (uri == null) {\n            throw new IllegalArgumentException(\"Uri must not be null.\");\n        }\n        final Icon rep = new Icon(TYPE_URI);\n        rep.mString1 = uri;\n        return rep;\n    }"}
{"Number":"138","API Relative Path":"src.android.graphics.drawable.Icon.java-createWithContentUri(Uri)","Corresponding Source":"/**\n     * Create an Icon pointing to an image file specified by URI.\n     *\n     * @param uri A uri referring to local content:// or file:// image data.\n     */\n    public static Icon createWithContentUri(Uri uri) {\n        if (uri == null) {\n            throw new IllegalArgumentException(\"Uri must not be null.\");\n        }\n        final Icon rep = new Icon(TYPE_URI);\n        rep.mString1 = uri.toString();\n        return rep;\n    }"}
{"Number":"139","API Relative Path":"src.android.graphics.drawable.Icon.java-createWithData(byte[]-int-int)","Corresponding Source":"/**\n     * Create an Icon pointing to a compressed bitmap stored in a byte array.\n     * @param data Byte array storing compressed bitmap data of a type that\n     *             {@link android.graphics.BitmapFactory}\n     *             can decode (see {@link android.graphics.Bitmap.CompressFormat}).\n     * @param offset Offset into <code>data<\/code> at which the bitmap data starts\n     * @param length Length of the bitmap data\n     */\n    public static Icon createWithData(byte[] data, int offset, int length) {\n        if (data == null) {\n            throw new IllegalArgumentException(\"Data must not be null.\");\n        }\n        final Icon rep = new Icon(TYPE_DATA);\n        rep.mObj1 = data;\n        rep.mInt1 = length;\n        rep.mInt2 = offset;\n        return rep;\n    }"}
{"Number":"140","API Relative Path":"src.android.graphics.drawable.Icon.java-createWithFilePath(String)","Corresponding Source":"/**\n     * Create an Icon pointing to an image file specified by path.\n     *\n     * @param path A path to a file that contains compressed bitmap data of\n     *           a type that {@link android.graphics.BitmapFactory} can decode.\n     */\n    public static Icon createWithFilePath(String path) {\n        if (path == null) {\n            throw new IllegalArgumentException(\"Path must not be null.\");\n        }\n        final Icon rep = new Icon(TYPE_URI);\n        rep.mString1 = path;\n        return rep;\n    }"}
{"Number":"141","API Relative Path":"src.android.graphics.drawable.Icon.java-createWithResource(Context-int)","Corresponding Source":"/**\n     * Create an Icon pointing to a drawable resource.\n     * @param context The context for the application whose resources should be used to resolve the\n     *                given resource ID.\n     * @param resId ID of the drawable resource\n     */\n    public static Icon createWithResource(Context context, @DrawableRes int resId) {\n        if (context == null) {\n            throw new IllegalArgumentException(\"Context must not be null.\");\n        }\n        final Icon rep = new Icon(TYPE_RESOURCE);\n        rep.mInt1 = resId;\n        rep.mString1 = context.getPackageName();\n        return rep;\n    }"}
{"Number":"142","API Relative Path":"src.android.graphics.drawable.Icon.java-createWithResource(Resources-int)","Corresponding Source":"/**\n     * Version of createWithResource that takes Resources. Do not use.\n     * @hide\n     */\n    public static Icon createWithResource(Resources res, @DrawableRes int resId) {\n        if (res == null) {\n            throw new IllegalArgumentException(\"Resource must not be null.\");\n        }\n        final Icon rep = new Icon(TYPE_RESOURCE);\n        rep.mInt1 = resId;\n        rep.mString1 = res.getResourcePackageName(resId);\n        return rep;\n    }"}
{"Number":"143","API Relative Path":"src.android.graphics.drawable.Icon.java-createWithResource(String-int)","Corresponding Source":"/**\n     * Create an Icon pointing to a drawable resource.\n     * @param resPackage Name of the package containing the resource in question\n     * @param resId ID of the drawable resource\n     */\n    public static Icon createWithResource(String resPackage, @DrawableRes int resId) {\n        if (resPackage == null) {\n            throw new IllegalArgumentException(\"Resource package name must not be null.\");\n        }\n        final Icon rep = new Icon(TYPE_RESOURCE);\n        rep.mInt1 = resId;\n        rep.mString1 = resPackage;\n        return rep;\n    }"}
{"Number":"144","API Relative Path":"src.android.graphics.drawable.LayerDrawable.java-getDrawable(int)","Corresponding Source":"/**\n     * Returns the drawable for the layer at the specified index.\n     *\n     * @param index The index of the layer, must be in the range\n     *              {@code 0...getNumberOfLayers()-1}.\n     * @return The {@link Drawable} at the specified layer index.\n     *\n     * @see #setDrawable(int, Drawable)\n     * @attr ref android.R.styleable#LayerDrawableItem_drawable\n     */\n    public Drawable getDrawable(int index) {\n        if (index >= mLayerState.mNum) {\n            throw new IndexOutOfBoundsException();\n        }\n        return mLayerState.mChildren[index].mDrawable;\n    }"}
{"Number":"145","API Relative Path":"src.android.graphics.drawable.LayerDrawable.java-getId(int)","Corresponding Source":"/**\n     * Returns the ID of the specified layer.\n     *\n     * @param index The index of the layer, must be in the range\n     *              {@code 0...getNumberOfLayers()-1}.\n     * @return The id of the layer or {@link android.view.View#NO_ID} if the\n     *         layer has no id.\n     *\n     * @see #setId(int, int)\n     * @attr ref android.R.styleable#LayerDrawableItem_id\n     */\n    public int getId(int index) {\n        if (index >= mLayerState.mNum) {\n            throw new IndexOutOfBoundsException();\n        }\n        return mLayerState.mChildren[index].mId;\n    }"}
{"Number":"146","API Relative Path":"src.android.graphics.drawable.LayerDrawable.java-LayerDrawable(Drawable[]-LayerState)","Corresponding Source":"/**\n     * Creates a new layer drawable with the specified list of layers and the\n     * specified constant state.\n     *\n     * @param layers The list of layers to add to this drawable.\n     * @param state The constant drawable state.\n     */\n    LayerDrawable(@NonNull Drawable[] layers, @Nullable LayerState state) {\n        this(state, null);\n\n        if (layers == null) {\n            throw new IllegalArgumentException(\"layers must be non-null\");\n        }\n\n        final int length = layers.length;\n        final ChildDrawable[] r = new ChildDrawable[length];\n        for (int i = 0; i < length; i++) {\n            r[i] = new ChildDrawable(mLayerState.mDensity);\n            r[i].mDrawable = layers[i];\n            layers[i].setCallback(this);\n            mLayerState.mChildrenChangingConfigurations |= layers[i].getChangingConfigurations();\n        }\n        mLayerState.mNum = length;\n        mLayerState.mChildren = r;\n\n        ensurePadding();\n        refreshPadding();\n    }"}
{"Number":"147","API Relative Path":"src.android.graphics.drawable.LayerDrawable.java-setDrawable(int-Drawable)","Corresponding Source":"/**\n     * Sets the drawable for the layer at the specified index.\n     *\n     * @param index The index of the layer to modify, must be in the range\n     *              {@code 0...getNumberOfLayers()-1}.\n     * @param drawable The drawable to set for the layer.\n     *\n     * @see #getDrawable(int)\n     * @attr ref android.R.styleable#LayerDrawableItem_drawable\n     */\n    public void setDrawable(int index, Drawable drawable) {\n        if (index >= mLayerState.mNum) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        final ChildDrawable[] layers = mLayerState.mChildren;\n        final ChildDrawable childDrawable = layers[index];\n        if (childDrawable.mDrawable != null) {\n            if (drawable != null) {\n                final Rect bounds = childDrawable.mDrawable.getBounds();\n                drawable.setBounds(bounds);\n            }\n\n            childDrawable.mDrawable.setCallback(null);\n        }\n\n        if (drawable != null) {\n            drawable.setCallback(this);\n        }\n\n        childDrawable.mDrawable = drawable;\n        mLayerState.invalidateCache();\n\n        refreshChildPadding(index, childDrawable);\n    }"}
{"Number":"148","API Relative Path":"src.android.graphics.drawable.RippleDrawable.java-RippleDrawable(ColorStateList-Drawable-Drawable)","Corresponding Source":"/**\n     * Creates a new ripple drawable with the specified ripple color and\n     * optional content and mask drawables.\n     *\n     * @param color The ripple color\n     * @param content The content drawable, may be {@code null}\n     * @param mask The mask drawable, may be {@code null}\n     */\n    public RippleDrawable(@NonNull ColorStateList color, @Nullable Drawable content,\n            @Nullable Drawable mask) {\n        this(new RippleState(null, null, null), null);\n\n        if (color == null) {\n            throw new IllegalArgumentException(\"RippleDrawable requires a non-null color\");\n        }\n\n        if (content != null) {\n            addLayer(content, null, 0, 0, 0, 0, 0);\n        }\n\n        if (mask != null) {\n            addLayer(mask, null, android.R.id.mask, 0, 0, 0, 0);\n        }\n\n        setColor(color);\n        ensurePadding();\n        refreshPadding();\n        updateLocalState();\n    }"}
{"Number":"149","API Relative Path":"src.android.graphics.drawable.shapes.RoundRectShape.java-RoundRectShape(float[]-RectF-float[])","Corresponding Source":"/**\n     * RoundRectShape constructor.\n     * Specifies an outer (round)rect and an optional inner (round)rect.\n     *\n     * @param outerRadii An array of 8 radius values, for the outer roundrect. \n     *                   The first two floats are for the \n     *                   top-left corner (remaining pairs correspond clockwise). \n     *                   For no rounded corners on the outer rectangle, \n     *                   pass null.\n     * @param inset      A RectF that specifies the distance from the inner \n     *                   rect to each side of the outer rect. \n     *                   For no inner, pass null.\n     * @param innerRadii An array of 8 radius values, for the inner roundrect.\n     *                   The first two floats are for the \n     *                   top-left corner (remaining pairs correspond clockwise). \n     *                   For no rounded corners on the inner rectangle, \n     *                   pass null.\n     *                   If inset parameter is null, this parameter is ignored. \n     */\n    public RoundRectShape(float[] outerRadii, RectF inset,\n                          float[] innerRadii) {\n        if (outerRadii != null && outerRadii.length < 8) {\n            throw new ArrayIndexOutOfBoundsException(\"outer radii must have >= 8 values\");\n        }\n        if (innerRadii != null && innerRadii.length < 8) {\n            throw new ArrayIndexOutOfBoundsException(\"inner radii must have >= 8 values\");\n        }\n        mOuterRadii = outerRadii;\n        mInset = inset;\n        mInnerRadii = innerRadii;\n        \n        if (inset != null) {\n            mInnerRect = new RectF();\n        }\n        mPath = new Path();\n    }"}
{"Number":"150","API Relative Path":"src.android.graphics.drawable.shapes.RoundRectShape.java-RoundRectShape(float[]-RectF-float[])","Corresponding Source":"/**\n     * RoundRectShape constructor.\n     * Specifies an outer (round)rect and an optional inner (round)rect.\n     *\n     * @param outerRadii An array of 8 radius values, for the outer roundrect. \n     *                   The first two floats are for the \n     *                   top-left corner (remaining pairs correspond clockwise). \n     *                   For no rounded corners on the outer rectangle, \n     *                   pass null.\n     * @param inset      A RectF that specifies the distance from the inner \n     *                   rect to each side of the outer rect. \n     *                   For no inner, pass null.\n     * @param innerRadii An array of 8 radius values, for the inner roundrect.\n     *                   The first two floats are for the \n     *                   top-left corner (remaining pairs correspond clockwise). \n     *                   For no rounded corners on the inner rectangle, \n     *                   pass null.\n     *                   If inset parameter is null, this parameter is ignored. \n     */\n    public RoundRectShape(float[] outerRadii, RectF inset,\n                          float[] innerRadii) {\n        if (outerRadii != null && outerRadii.length < 8) {\n            throw new ArrayIndexOutOfBoundsException(\"outer radii must have >= 8 values\");\n        }\n        if (innerRadii != null && innerRadii.length < 8) {\n            throw new ArrayIndexOutOfBoundsException(\"inner radii must have >= 8 values\");\n        }\n        mOuterRadii = outerRadii;\n        mInset = inset;\n        mInnerRadii = innerRadii;\n        \n        if (inset != null) {\n            mInnerRect = new RectF();\n        }\n        mPath = new Path();\n    }"}
{"Number":"151","API Relative Path":"src.android.graphics.drawable.StateListDrawable.java-addState(int[]-Drawable)","Corresponding Source":"/**\n     * Add a new image/string ID to the set of images.\n     *\n     * @param stateSet - An array of resource Ids to associate with the image.\n     *                 Switch to this image by calling setState().\n     * @param drawable -The image to show.\n     */\n    public void addState(int[] stateSet, Drawable drawable) {\n        if (drawable != null) {\n            mStateListState.addStateSet(stateSet, drawable);\n            // in case the new state matches our current state...\n            onStateChange(getState());\n        }\n    }"}
{"Number":"152","API Relative Path":"src.android.graphics.drawable.StateListDrawable.java-StateListDrawable(StateListState)","Corresponding Source":"/**\n     * This constructor exists so subclasses can avoid calling the default\n     * constructor and setting up a StateListDrawable-specific constant state.\n     */\n    StateListDrawable(@Nullable StateListState state) {\n        if (state != null) {\n            setConstantState(state);\n        }\n    }"}
{"Number":"153","API Relative Path":"src.android.graphics.EmbossMaskFilter.java-EmbossMaskFilter(float[]-float-float-float)","Corresponding Source":"/**\n     * Create an emboss maskfilter\n     *\n     * @param direction  array of 3 scalars [x, y, z] specifying the direction of the light source\n     * @param ambient    0...1 amount of ambient light\n     * @param specular   coefficient for specular highlights (e.g. 8)\n     * @param blurRadius amount to blur before applying lighting (e.g. 3)\n     * @return           the emboss maskfilter\n     */\n    public EmbossMaskFilter(float[] direction, float ambient, float specular, float blurRadius) {\n        if (direction.length < 3) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        native_instance = nativeConstructor(direction, ambient, specular, blurRadius);\n    }"}
{"Number":"154","API Relative Path":"src.android.graphics.Interpolator.java-setKeyFrame(int-int-float[]-float[])","Corresponding Source":"/**\n     * Assign the keyFrame (specified by index) a time value and an array of key\n     * values and blend array.\n     * \n     * @param index The index of the key frame to assign\n     * @param msec The time (in mililiseconds) for this key frame. Based on the\n     *        SystemClock.uptimeMillis() clock\n     * @param values Array of values associated with theis key frame\n     * @param blend (may be null) Optional array of 4 blend values\n     */\n    public void setKeyFrame(int index, int msec, float[] values, float[] blend) {\n        if (index < 0 || index >= mFrameCount) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (values.length < mValueCount) {\n            throw new ArrayStoreException();\n        }\n        if (blend != null && blend.length < 4) {\n            throw new ArrayStoreException();\n        }\n        nativeSetKeyFrame(native_instance, index, msec, values, blend);\n    }"}
{"Number":"155","API Relative Path":"src.android.graphics.Interpolator.java-setKeyFrame(int-int-float[]-float[])","Corresponding Source":"/**\n     * Assign the keyFrame (specified by index) a time value and an array of key\n     * values and blend array.\n     * \n     * @param index The index of the key frame to assign\n     * @param msec The time (in mililiseconds) for this key frame. Based on the\n     *        SystemClock.uptimeMillis() clock\n     * @param values Array of values associated with theis key frame\n     * @param blend (may be null) Optional array of 4 blend values\n     */\n    public void setKeyFrame(int index, int msec, float[] values, float[] blend) {\n        if (index < 0 || index >= mFrameCount) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (values.length < mValueCount) {\n            throw new ArrayStoreException();\n        }\n        if (blend != null && blend.length < 4) {\n            throw new ArrayStoreException();\n        }\n        nativeSetKeyFrame(native_instance, index, msec, values, blend);\n    }"}
{"Number":"156","API Relative Path":"src.android.graphics.Interpolator.java-timeToValues(int-float[])","Corresponding Source":"/**\n     * Given a millisecond time value (msec), return the interpolated values and\n     * return whether the specified time was within the range of key times\n     * (NORMAL), was before the first key time (FREEZE_START) or after the last\n     * key time (FREEZE_END). In any event, computed values are always returned.\n     * \n     * @param msec The time (in milliseconds) used to sample into the\n     *        Interpolator. Based on the SystemClock.uptimeMillis() clock\n     * @param values Where to write the computed values (may be NULL).\n     * @return how the values were computed (even if values == null)\n     */\n    public Result timeToValues(int msec, float[] values) {\n        if (values != null && values.length < mValueCount) {\n            throw new ArrayStoreException();\n        }\n        switch (nativeTimeToValues(native_instance, msec, values)) {\n            case 0: return Result.NORMAL;\n            case 1: return Result.FREEZE_START;\n            default: return Result.FREEZE_END;\n        }\n    }"}
{"Number":"157","API Relative Path":"src.android.graphics.LinearGradient.java-LinearGradient(float-float-float-float-int-float-TileMode)","Corresponding Source":"/** Create a shader that draws a linear gradient along a line.\n        @param x0           The x-coordinate for the start of the gradient line\n        @param y0           The y-coordinate for the start of the gradient line\n        @param x1           The x-coordinate for the end of the gradient line\n        @param y1           The y-coordinate for the end of the gradient line\n        @param  colors      The colors to be distributed along the gradient line\n        @param  positions   May be null. The relative positions [0..1] of\n                            each corresponding color in the colors array. If this is null,\n                            the the colors are distributed evenly along the gradient line.\n        @param  tile        The Shader tiling mode\n    */\n    public LinearGradient(float x0, float y0, float x1, float y1, int colors[], float positions[],\n            TileMode tile) {\n        if (colors.length < 2) {\n            throw new IllegalArgumentException(\"needs >= 2 number of colors\");\n        }\n        if (positions != null && colors.length != positions.length) {\n            throw new IllegalArgumentException(\"color and position arrays must be of equal length\");\n        }\n        mType = TYPE_COLORS_AND_POSITIONS;\n        mX0 = x0;\n        mY0 = y0;\n        mX1 = x1;\n        mY1 = y1;\n        mColors = colors;\n        mPositions = positions;\n        mTileMode = tile;\n        init(nativeCreate1(x0, y0, x1, y1, colors, positions, tile.nativeInt));\n    }"}
{"Number":"158","API Relative Path":"src.android.graphics.Matrix.java-getValues(float[])","Corresponding Source":"/** Copy 9 values from the matrix into the array.\n    */\n    public void getValues(float[] values) {\n        if (values.length < 9) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        native_getValues(native_instance, values);\n    }"}
{"Number":"159","API Relative Path":"src.android.graphics.Matrix.java-mapPoints(float[]-float[])","Corresponding Source":"/**\n     * Apply this matrix to the array of 2D points specified by src, and write\n     * the transformed points into the array of points specified by dst. The\n     * two arrays represent their \"points\" as pairs of floats [x, y].\n     *\n     * @param dst   The array of dst points (x,y pairs)\n     * @param src   The array of src points (x,y pairs)\n     */\n    public void mapPoints(float[] dst, float[] src) {\n        if (dst.length != src.length) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        mapPoints(dst, 0, src, 0, dst.length >> 1);\n    }"}
{"Number":"160","API Relative Path":"src.android.graphics.Matrix.java-mapRect(RectF-RectF)","Corresponding Source":"/**\n     * Apply this matrix to the src rectangle, and write the transformed\n     * rectangle into dst. This is accomplished by transforming the 4 corners of\n     * src, and then setting dst to the bounds of those points.\n     *\n     * @param dst Where the transformed rectangle is written.\n     * @param src The original rectangle to be transformed.\n     * @return the result of calling rectStaysRect()\n     */\n    public boolean mapRect(RectF dst, RectF src) {\n        if (dst == null || src == null) {\n            throw new NullPointerException();\n        }\n        return native_mapRect(native_instance, dst, src);\n    }"}
{"Number":"161","API Relative Path":"src.android.graphics.Matrix.java-mapVectors(float[]-float[])","Corresponding Source":"/**\n     * Apply this matrix to the array of 2D vectors specified by src, and write\n     * the transformed vectors into the array of vectors specified by dst. The\n     * two arrays represent their \"vectors\" as pairs of floats [x, y].\n     *\n     * Note: this method does not apply the translation associated with the matrix. Use\n     * {@link Matrix#mapPoints(float[], float[])} if you want the translation to be applied.\n     *\n     * @param dst   The array of dst vectors (x,y pairs)\n     * @param src   The array of src vectors (x,y pairs)\n     */\n    public void mapVectors(float[] dst, float[] src) {\n        if (dst.length != src.length) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        mapVectors(dst, 0, src, 0, dst.length >> 1);\n    }"}
{"Number":"162","API Relative Path":"src.android.graphics.Matrix.java-setPolyToPoly(float[]-int-float[]-int-int)","Corresponding Source":"/**\n     * Set the matrix such that the specified src points would map to the\n     * specified dst points. The \"points\" are represented as an array of floats,\n     * order [x0, y0, x1, y1, ...], where each \"point\" is 2 float values.\n     *\n     * @param src   The array of src [x,y] pairs (points)\n     * @param srcIndex Index of the first pair of src values\n     * @param dst   The array of dst [x,y] pairs (points)\n     * @param dstIndex Index of the first pair of dst values\n     * @param pointCount The number of pairs/points to be used. Must be [0..4]\n     * @return true if the matrix was set to the specified transformation\n     */\n    public boolean setPolyToPoly(float[] src, int srcIndex,\n                                 float[] dst, int dstIndex,\n                                 int pointCount) {\n        if (pointCount > 4) {\n            throw new IllegalArgumentException();\n        }\n        checkPointArrays(src, srcIndex, dst, dstIndex, pointCount);\n        return native_setPolyToPoly(native_instance, src, srcIndex,\n                                    dst, dstIndex, pointCount);\n    }"}
{"Number":"163","API Relative Path":"src.android.graphics.Matrix.java-setRectToRect(RectF-RectF-ScaleToFit)","Corresponding Source":"/**\n     * Set the matrix to the scale and translate values that map the source\n     * rectangle to the destination rectangle, returning true if the the result\n     * can be represented.\n     *\n     * @param src the source rectangle to map from.\n     * @param dst the destination rectangle to map to.\n     * @param stf the ScaleToFit option\n     * @return true if the matrix can be represented by the rectangle mapping.\n     */\n    public boolean setRectToRect(RectF src, RectF dst, ScaleToFit stf) {\n        if (dst == null || src == null) {\n            throw new NullPointerException();\n        }\n        return native_setRectToRect(native_instance, src, dst, stf.nativeInt);\n    }"}
{"Number":"164","API Relative Path":"src.android.graphics.Matrix.java-setValues(float[])","Corresponding Source":"/** Copy 9 values from the array into the matrix.\n        Depending on the implementation of Matrix, these may be\n        transformed into 16.16 integers in the Matrix, such that\n        a subsequent call to getValues() will not yield exactly\n        the same values.\n    */\n    public void setValues(float[] values) {\n        if (values.length < 9) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        native_setValues(native_instance, values);\n    }"}
{"Number":"165","API Relative Path":"src.android.graphics.Paint.java-breakText(char[]-int-int-float-float[])","Corresponding Source":"/**\n     * Measure the text, stopping early if the measured width exceeds maxWidth.\n     * Return the number of chars that were measured, and if measuredWidth is\n     * not null, return in it the actual width measured.\n     *\n     * @param text  The text to measure. Cannot be null.\n     * @param index The offset into text to begin measuring at\n     * @param count The number of maximum number of entries to measure. If count\n     *              is negative, then the characters are measured in reverse order.\n     * @param maxWidth The maximum width to accumulate.\n     * @param measuredWidth Optional. If not null, returns the actual width\n     *                     measured.\n     * @return The number of chars that were measured. Will always be <=\n     *         abs(count).\n     */\n    public int breakText(char[] text, int index, int count,\n                                float maxWidth, float[] measuredWidth) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"text cannot be null\");\n        }\n        if (index < 0 || text.length - index < Math.abs(count)) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n\n        if (text.length == 0 || count == 0) {\n            return 0;\n        }\n        if (!mHasCompatScaling) {\n            return nBreakText(mNativePaint, mNativeTypeface, text, index, count, maxWidth,\n                    mBidiFlags, measuredWidth);\n        }\n\n        final float oldSize = getTextSize();\n        setTextSize(oldSize * mCompatScaling);\n        int res = nBreakText(mNativePaint, mNativeTypeface, text, index, count,\n                maxWidth * mCompatScaling, mBidiFlags, measuredWidth);\n        setTextSize(oldSize);\n        if (measuredWidth != null) measuredWidth[0] *= mInvCompatScaling;\n        return res;\n    }"}
{"Number":"166","API Relative Path":"src.android.graphics.Paint.java-getOffsetForAdvance(char[]-int-int-int-int-boolean-float)","Corresponding Source":"/**\n     * @see #getOffsetForAdvance(char[], int, int, int, int, boolean, float)\n     *\n     * @param text the text to measure. Cannot be null.\n     * @param start the index of the start of the range to measure\n     * @param end the index + 1 of the end of the range to measure\n     * @param contextStart the index of the start of the shaping context\n     * @param contextEnd the index + 1 of the end of the range to measure\n     * @param isRtl whether the run is in RTL direction\n     * @param advance width relative to start of run\n     * @return index of offset\n     */\n    public int getOffsetForAdvance(CharSequence text, int start, int end, int contextStart,\n            int contextEnd, boolean isRtl, float advance) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"text cannot be null\");\n        }\n        if ((contextStart | start | end | contextEnd\n                | start - contextStart | end - start | contextEnd - end\n                | text.length() - contextEnd) < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n        // TODO performance: specialized alternatives to avoid buffer copy, if win is significant\n        char[] buf = TemporaryBuffer.obtain(contextEnd - contextStart);\n        TextUtils.getChars(text, contextStart, contextEnd, buf, 0);\n        int result = getOffsetForAdvance(buf, start - contextStart, end - contextStart, 0,\n                contextEnd - contextStart, isRtl, advance) + contextStart;\n        TemporaryBuffer.recycle(buf);\n        return result;\n    }"}
{"Number":"167","API Relative Path":"src.android.graphics.Paint.java-getRunAdvance(char[]-int-int-int-int-boolean-int)","Corresponding Source":"/**\n     * @see #getRunAdvance(char[], int, int, int, int, boolean, int)\n     *\n     * @param text the text to measure. Cannot be null.\n     * @param start the index of the start of the range to measure\n     * @param end the index + 1 of the end of the range to measure\n     * @param contextStart the index of the start of the shaping context\n     * @param contextEnd the index + 1 of the end of the shaping context\n     * @param isRtl whether the run is in RTL direction\n     * @param offset index of caret position\n     * @return width measurement between start and offset\n     */\n    public float getRunAdvance(CharSequence text, int start, int end, int contextStart,\n            int contextEnd, boolean isRtl, int offset) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"text cannot be null\");\n        }\n        if ((contextStart | start | offset | end | contextEnd\n                | start - contextStart | offset - start | end - offset\n                | contextEnd - end | text.length() - contextEnd) < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (end == start) {\n            return 0.0f;\n        }\n        // TODO performance: specialized alternatives to avoid buffer copy, if win is significant\n        char[] buf = TemporaryBuffer.obtain(contextEnd - contextStart);\n        TextUtils.getChars(text, contextStart, contextEnd, buf, 0);\n        float result = getRunAdvance(buf, start - contextStart, end - contextStart, 0,\n                contextEnd - contextStart, isRtl, offset - contextStart);\n        TemporaryBuffer.recycle(buf);\n        return result;\n    }"}
{"Number":"168","API Relative Path":"src.android.graphics.Paint.java-getTextBounds(char[]-int-int-Rect)","Corresponding Source":"/**\n     * Return in bounds (allocated by the caller) the smallest rectangle that\n     * encloses all of the characters, with an implied origin at (0,0).\n     *\n     * @param text  Array of chars to measure and return their unioned bounds\n     * @param index Index of the first char in the array to measure\n     * @param count The number of chars, beginning at index, to measure\n     * @param bounds Returns the unioned bounds of all the text. Must be\n     *               allocated by the caller.\n     */\n    public void getTextBounds(char[] text, int index, int count, Rect bounds) {\n        if ((index | count) < 0 || index + count > text.length) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        if (bounds == null) {\n            throw new NullPointerException(\"need bounds Rect\");\n        }\n        nGetCharArrayBounds(mNativePaint, mNativeTypeface, text, index, count, mBidiFlags,\n            bounds);\n    }"}
{"Number":"169","API Relative Path":"src.android.graphics.Paint.java-getTextBounds(char[]-int-int-Rect)","Corresponding Source":"/**\n     * Return in bounds (allocated by the caller) the smallest rectangle that\n     * encloses all of the characters, with an implied origin at (0,0).\n     *\n     * @param text  Array of chars to measure and return their unioned bounds\n     * @param index Index of the first char in the array to measure\n     * @param count The number of chars, beginning at index, to measure\n     * @param bounds Returns the unioned bounds of all the text. Must be\n     *               allocated by the caller.\n     */\n    public void getTextBounds(char[] text, int index, int count, Rect bounds) {\n        if ((index | count) < 0 || index + count > text.length) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        if (bounds == null) {\n            throw new NullPointerException(\"need bounds Rect\");\n        }\n        nGetCharArrayBounds(mNativePaint, mNativeTypeface, text, index, count, mBidiFlags,\n            bounds);\n    }"}
{"Number":"170","API Relative Path":"src.android.graphics.Paint.java-getTextBounds(String-int-int-Rect)","Corresponding Source":"/**\n     * Return in bounds (allocated by the caller) the smallest rectangle that\n     * encloses all of the characters, with an implied origin at (0,0).\n     *\n     * @param text  String to measure and return its bounds\n     * @param start Index of the first char in the string to measure\n     * @param end   1 past the last char in the string measure\n     * @param bounds Returns the unioned bounds of all the text. Must be\n     *               allocated by the caller.\n     */\n    public void getTextBounds(String text, int start, int end, Rect bounds) {\n        if ((start | end | (end - start) | (text.length() - end)) < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (bounds == null) {\n            throw new NullPointerException(\"need bounds Rect\");\n        }\n        nGetStringBounds(mNativePaint, mNativeTypeface, text, start, end, mBidiFlags, bounds);\n    }"}
{"Number":"171","API Relative Path":"src.android.graphics.Paint.java-getTextPath(char[]-int-int-float-float-Path)","Corresponding Source":"/**\n     * Return the path (outline) for the specified text.\n     * Note: just like Canvas.drawText, this will respect the Align setting in\n     * the paint.\n     *\n     * @param text     The text to retrieve the path from\n     * @param index    The index of the first character in text\n     * @param count    The number of characterss starting with index\n     * @param x        The x coordinate of the text's origin\n     * @param y        The y coordinate of the text's origin\n     * @param path     The path to receive the data describing the text. Must\n     *                 be allocated by the caller.\n     */\n    public void getTextPath(char[] text, int index, int count,\n                            float x, float y, Path path) {\n        if ((index | count) < 0 || index + count > text.length) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        nGetTextPath(mNativePaint, mNativeTypeface, mBidiFlags, text, index, count, x, y,\n                path.ni());\n    }"}
{"Number":"172","API Relative Path":"src.android.graphics.Paint.java-getTextRunAdvances(CharSequence-int-int-int-int-boolean-float[]-int)","Corresponding Source":"/**\n     * Convenience overload that takes a CharSequence instead of a\n     * String.\n     *\n     * @see #getTextRunAdvances(String, int, int, int, int, boolean, float[], int)\n     * @hide\n     */\n    public float getTextRunAdvances(CharSequence text, int start, int end,\n            int contextStart, int contextEnd, boolean isRtl, float[] advances,\n            int advancesIndex) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"text cannot be null\");\n        }\n        if ((start | end | contextStart | contextEnd | advancesIndex | (end - start)\n                | (start - contextStart) | (contextEnd - end)\n                | (text.length() - contextEnd)\n                | (advances == null ? 0 :\n                    (advances.length - advancesIndex - (end - start)))) < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        if (text instanceof String) {\n            return getTextRunAdvances((String) text, start, end,\n                    contextStart, contextEnd, isRtl, advances, advancesIndex);\n        }\n        if (text instanceof SpannedString ||\n            text instanceof SpannableString) {\n            return getTextRunAdvances(text.toString(), start, end,\n                    contextStart, contextEnd, isRtl, advances, advancesIndex);\n        }\n        if (text instanceof GraphicsOperations) {\n            return ((GraphicsOperations) text).getTextRunAdvances(start, end,\n                    contextStart, contextEnd, isRtl, advances, advancesIndex, this);\n        }\n        if (text.length() == 0 || end == start) {\n            return 0f;\n        }\n\n        int contextLen = contextEnd - contextStart;\n        int len = end - start;\n        char[] buf = TemporaryBuffer.obtain(contextLen);\n        TextUtils.getChars(text, contextStart, contextEnd, buf, 0);\n        float result = getTextRunAdvances(buf, start - contextStart, len,\n                0, contextLen, isRtl, advances, advancesIndex);\n        TemporaryBuffer.recycle(buf);\n        return result;\n    }"}
{"Number":"173","API Relative Path":"src.android.graphics.Paint.java-getTextRunAdvances(char[]-int-int-int-int-boolean-float[]-int)","Corresponding Source":"/**\n     * Convenience overload that takes a CharSequence instead of a\n     * String.\n     *\n     * @see #getTextRunAdvances(String, int, int, int, int, boolean, float[], int)\n     * @hide\n     */\n    public float getTextRunAdvances(CharSequence text, int start, int end,\n            int contextStart, int contextEnd, boolean isRtl, float[] advances,\n            int advancesIndex) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"text cannot be null\");\n        }\n        if ((start | end | contextStart | contextEnd | advancesIndex | (end - start)\n                | (start - contextStart) | (contextEnd - end)\n                | (text.length() - contextEnd)\n                | (advances == null ? 0 :\n                    (advances.length - advancesIndex - (end - start)))) < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        if (text instanceof String) {\n            return getTextRunAdvances((String) text, start, end,\n                    contextStart, contextEnd, isRtl, advances, advancesIndex);\n        }\n        if (text instanceof SpannedString ||\n            text instanceof SpannableString) {\n            return getTextRunAdvances(text.toString(), start, end,\n                    contextStart, contextEnd, isRtl, advances, advancesIndex);\n        }\n        if (text instanceof GraphicsOperations) {\n            return ((GraphicsOperations) text).getTextRunAdvances(start, end,\n                    contextStart, contextEnd, isRtl, advances, advancesIndex, this);\n        }\n        if (text.length() == 0 || end == start) {\n            return 0f;\n        }\n\n        int contextLen = contextEnd - contextStart;\n        int len = end - start;\n        char[] buf = TemporaryBuffer.obtain(contextLen);\n        TextUtils.getChars(text, contextStart, contextEnd, buf, 0);\n        float result = getTextRunAdvances(buf, start - contextStart, len,\n                0, contextLen, isRtl, advances, advancesIndex);\n        TemporaryBuffer.recycle(buf);\n        return result;\n    }"}
{"Number":"174","API Relative Path":"src.android.graphics.Paint.java-getTextRunAdvances(char[]-int-int-int-int-boolean-float[]-int)","Corresponding Source":"/**\n     * Convenience overload that takes a CharSequence instead of a\n     * String.\n     *\n     * @see #getTextRunAdvances(String, int, int, int, int, boolean, float[], int)\n     * @hide\n     */\n    public float getTextRunAdvances(CharSequence text, int start, int end,\n            int contextStart, int contextEnd, boolean isRtl, float[] advances,\n            int advancesIndex) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"text cannot be null\");\n        }\n        if ((start | end | contextStart | contextEnd | advancesIndex | (end - start)\n                | (start - contextStart) | (contextEnd - end)\n                | (text.length() - contextEnd)\n                | (advances == null ? 0 :\n                    (advances.length - advancesIndex - (end - start)))) < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        if (text instanceof String) {\n            return getTextRunAdvances((String) text, start, end,\n                    contextStart, contextEnd, isRtl, advances, advancesIndex);\n        }\n        if (text instanceof SpannedString ||\n            text instanceof SpannableString) {\n            return getTextRunAdvances(text.toString(), start, end,\n                    contextStart, contextEnd, isRtl, advances, advancesIndex);\n        }\n        if (text instanceof GraphicsOperations) {\n            return ((GraphicsOperations) text).getTextRunAdvances(start, end,\n                    contextStart, contextEnd, isRtl, advances, advancesIndex, this);\n        }\n        if (text.length() == 0 || end == start) {\n            return 0f;\n        }\n\n        int contextLen = contextEnd - contextStart;\n        int len = end - start;\n        char[] buf = TemporaryBuffer.obtain(contextLen);\n        TextUtils.getChars(text, contextStart, contextEnd, buf, 0);\n        float result = getTextRunAdvances(buf, start - contextStart, len,\n                0, contextLen, isRtl, advances, advancesIndex);\n        TemporaryBuffer.recycle(buf);\n        return result;\n    }"}
{"Number":"175","API Relative Path":"src.android.graphics.Paint.java-getTextRunCursor(char[]-int-int-int-int-int)","Corresponding Source":"/**\n     * Returns the next cursor position in the run.  This avoids placing the\n     * cursor between surrogates, between characters that form conjuncts,\n     * between base characters and combining marks, or within a reordering\n     * cluster.\n     *\n     * <p>ContextStart, contextEnd, and offset are relative to the start of\n     * text.  The context is the shaping context for cursor movement, generally\n     * the bounds of the metric span enclosing the cursor in the direction of\n     * movement.\n     *\n     * <p>If cursorOpt is {@link #CURSOR_AT} and the offset is not a valid\n     * cursor position, this returns -1.  Otherwise this will never return a\n     * value before contextStart or after contextEnd.\n     *\n     * @param text the text\n     * @param contextStart the start of the context\n     * @param contextEnd the end of the context\n     * @param dir either {@link #DIRECTION_RTL} or {@link #DIRECTION_LTR}\n     * @param offset the cursor position to move from\n     * @param cursorOpt how to move the cursor, one of {@link #CURSOR_AFTER},\n     * {@link #CURSOR_AT_OR_AFTER}, {@link #CURSOR_BEFORE},\n     * {@link #CURSOR_AT_OR_BEFORE}, or {@link #CURSOR_AT}\n     * @return the offset of the next position, or -1\n     * @hide\n     */\n    public int getTextRunCursor(CharSequence text, int contextStart,\n           int contextEnd, int dir, int offset, int cursorOpt) {\n\n        if (text instanceof String || text instanceof SpannedString ||\n                text instanceof SpannableString) {\n            return getTextRunCursor(text.toString(), contextStart, contextEnd,\n                    dir, offset, cursorOpt);\n        }\n        if (text instanceof GraphicsOperations) {\n            return ((GraphicsOperations) text).getTextRunCursor(\n                    contextStart, contextEnd, dir, offset, cursorOpt, this);\n        }\n\n        int contextLen = contextEnd - contextStart;\n        char[] buf = TemporaryBuffer.obtain(contextLen);\n        TextUtils.getChars(text, contextStart, contextEnd, buf, 0);\n        int relPos = getTextRunCursor(buf, 0, contextLen, dir, offset - contextStart, cursorOpt);\n        TemporaryBuffer.recycle(buf);\n        return (relPos == -1) ? -1 : relPos + contextStart;\n    }"}
{"Number":"176","API Relative Path":"src.android.graphics.Paint.java-getTextRunCursor(String-int-int-int-int-int)","Corresponding Source":"/**\n     * Returns the next cursor position in the run.  This avoids placing the\n     * cursor between surrogates, between characters that form conjuncts,\n     * between base characters and combining marks, or within a reordering\n     * cluster.\n     *\n     * <p>ContextStart, contextEnd, and offset are relative to the start of\n     * text.  The context is the shaping context for cursor movement, generally\n     * the bounds of the metric span enclosing the cursor in the direction of\n     * movement.\n     *\n     * <p>If cursorOpt is {@link #CURSOR_AT} and the offset is not a valid\n     * cursor position, this returns -1.  Otherwise this will never return a\n     * value before contextStart or after contextEnd.\n     *\n     * @param text the text\n     * @param contextStart the start of the context\n     * @param contextEnd the end of the context\n     * @param dir either {@link #DIRECTION_RTL} or {@link #DIRECTION_LTR}\n     * @param offset the cursor position to move from\n     * @param cursorOpt how to move the cursor, one of {@link #CURSOR_AFTER},\n     * {@link #CURSOR_AT_OR_AFTER}, {@link #CURSOR_BEFORE},\n     * {@link #CURSOR_AT_OR_BEFORE}, or {@link #CURSOR_AT}\n     * @return the offset of the next position, or -1\n     * @hide\n     */\n    public int getTextRunCursor(String text, int contextStart, int contextEnd,\n            int dir, int offset, int cursorOpt) {\n        if (((contextStart | contextEnd | offset | (contextEnd - contextStart)\n                | (offset - contextStart) | (contextEnd - offset)\n                | (text.length() - contextEnd) | cursorOpt) < 0)\n                || cursorOpt > CURSOR_OPT_MAX_VALUE) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        return nGetTextRunCursor(mNativePaint, text,\n                contextStart, contextEnd, dir, offset, cursorOpt);\n    }"}
{"Number":"177","API Relative Path":"src.android.graphics.Paint.java-getTextWidths(CharSequence-int-int-float[])","Corresponding Source":"/**\n     * Return the advance widths for the characters in the string.\n     *\n     * @param text     The text to measure. Cannot be null.\n     * @param start    The index of the first char to to measure\n     * @param end      The end of the text slice to measure\n     * @param widths   array to receive the advance widths of the characters.\n     *                 Must be at least a large as (end - start).\n     * @return         the actual number of widths returned.\n     */\n    public int getTextWidths(CharSequence text, int start, int end,\n                             float[] widths) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"text cannot be null\");\n        }\n        if ((start | end | (end - start) | (text.length() - end)) < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (end - start > widths.length) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n\n        if (text.length() == 0 || start == end) {\n            return 0;\n        }\n        if (text instanceof String) {\n            return getTextWidths((String) text, start, end, widths);\n        }\n        if (text instanceof SpannedString ||\n            text instanceof SpannableString) {\n            return getTextWidths(text.toString(), start, end, widths);\n        }\n        if (text instanceof GraphicsOperations) {\n            return ((GraphicsOperations) text).getTextWidths(start, end,\n                                                                 widths, this);\n        }\n\n        char[] buf = TemporaryBuffer.obtain(end - start);\n        TextUtils.getChars(text, start, end, buf, 0);\n        int result = getTextWidths(buf, 0, end - start, widths);\n        TemporaryBuffer.recycle(buf);\n        return result;\n    }"}
{"Number":"178","API Relative Path":"src.android.graphics.Paint.java-getTextWidths(char[]-int-int-float[])","Corresponding Source":"/**\n     * Return the advance widths for the characters in the string.\n     *\n     * @param text     The text to measure. Cannot be null.\n     * @param start    The index of the first char to to measure\n     * @param end      The end of the text slice to measure\n     * @param widths   array to receive the advance widths of the characters.\n     *                 Must be at least a large as (end - start).\n     * @return         the actual number of widths returned.\n     */\n    public int getTextWidths(CharSequence text, int start, int end,\n                             float[] widths) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"text cannot be null\");\n        }\n        if ((start | end | (end - start) | (text.length() - end)) < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (end - start > widths.length) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n\n        if (text.length() == 0 || start == end) {\n            return 0;\n        }\n        if (text instanceof String) {\n            return getTextWidths((String) text, start, end, widths);\n        }\n        if (text instanceof SpannedString ||\n            text instanceof SpannableString) {\n            return getTextWidths(text.toString(), start, end, widths);\n        }\n        if (text instanceof GraphicsOperations) {\n            return ((GraphicsOperations) text).getTextWidths(start, end,\n                                                                 widths, this);\n        }\n\n        char[] buf = TemporaryBuffer.obtain(end - start);\n        TextUtils.getChars(text, start, end, buf, 0);\n        int result = getTextWidths(buf, 0, end - start, widths);\n        TemporaryBuffer.recycle(buf);\n        return result;\n    }"}
{"Number":"179","API Relative Path":"src.android.graphics.Paint.java-getTextWidths(String-int-int-float[])","Corresponding Source":"/**\n     * Return the advance widths for the characters in the string.\n     *\n     * @param text   The text to measure. Cannot be null.\n     * @param start  The index of the first char to to measure\n     * @param end    The end of the text slice to measure\n     * @param widths array to receive the advance widths of the characters.\n     *               Must be at least a large as the text.\n     * @return       the number of code units in the specified text.\n     */\n    public int getTextWidths(String text, int start, int end, float[] widths) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"text cannot be null\");\n        }\n        if ((start | end | (end - start) | (text.length() - end)) < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (end - start > widths.length) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n\n        if (text.length() == 0 || start == end) {\n            return 0;\n        }\n        if (!mHasCompatScaling) {\n            nGetTextAdvances(mNativePaint, mNativeTypeface, text, start, end, start, end,\n                    mBidiFlags, widths, 0);\n            return end - start;\n        }\n\n        final float oldSize = getTextSize();\n        setTextSize(oldSize * mCompatScaling);\n        nGetTextAdvances(mNativePaint, mNativeTypeface, text, start, end, start, end,\n                mBidiFlags, widths, 0);\n        setTextSize(oldSize);\n        for (int i = 0; i < end - start; i++) {\n            widths[i] *= mInvCompatScaling;\n        }\n        return end - start;\n    }"}
{"Number":"180","API Relative Path":"src.android.graphics.Paint.java-measureText(CharSequence-int-int)","Corresponding Source":"/**\n     * Return the width of the text.\n     *\n     * @param text  The text to measure\n     * @param start The index of the first character to start measuring\n     * @param end   1 beyond the index of the last character to measure\n     * @return      The width of the text\n     */\n    public float measureText(CharSequence text, int start, int end) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"text cannot be null\");\n        }\n        if ((start | end | (end - start) | (text.length() - end)) < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        if (text.length() == 0 || start == end) {\n            return 0f;\n        }\n        if (text instanceof String) {\n            return measureText((String)text, start, end);\n        }\n        if (text instanceof SpannedString ||\n            text instanceof SpannableString) {\n            return measureText(text.toString(), start, end);\n        }\n        if (text instanceof GraphicsOperations) {\n            return ((GraphicsOperations)text).measureText(start, end, this);\n        }\n\n        char[] buf = TemporaryBuffer.obtain(end - start);\n        TextUtils.getChars(text, start, end, buf, 0);\n        float result = measureText(buf, 0, end - start);\n        TemporaryBuffer.recycle(buf);\n        return result;\n    }"}
{"Number":"181","API Relative Path":"src.android.graphics.Paint.java-measureText(char[]-int-int)","Corresponding Source":"/**\n     * Return the width of the text.\n     *\n     * @param text  The text to measure\n     * @param start The index of the first character to start measuring\n     * @param end   1 beyond the index of the last character to measure\n     * @return      The width of the text\n     */\n    public float measureText(CharSequence text, int start, int end) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"text cannot be null\");\n        }\n        if ((start | end | (end - start) | (text.length() - end)) < 0) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        if (text.length() == 0 || start == end) {\n            return 0f;\n        }\n        if (text instanceof String) {\n            return measureText((String)text, start, end);\n        }\n        if (text instanceof SpannedString ||\n            text instanceof SpannableString) {\n            return measureText(text.toString(), start, end);\n        }\n        if (text instanceof GraphicsOperations) {\n            return ((GraphicsOperations)text).measureText(start, end, this);\n        }\n\n        char[] buf = TemporaryBuffer.obtain(end - start);\n        TextUtils.getChars(text, start, end, buf, 0);\n        float result = measureText(buf, 0, end - start);\n        TemporaryBuffer.recycle(buf);\n        return result;\n    }"}
{"Number":"182","API Relative Path":"src.android.graphics.Paint.java-setBidiFlags(int)","Corresponding Source":"/**\n     * Set the bidi flags on the paint.\n     * @hide\n     */\n    public void setBidiFlags(int flags) {\n        // only flag value is the 3-bit BIDI control setting\n        flags &= BIDI_FLAG_MASK;\n        if (flags > BIDI_MAX_FLAG_VALUE) {\n            throw new IllegalArgumentException(\"unknown bidi flag: \" + flags);\n        }\n        mBidiFlags = flags;\n    }"}
{"Number":"183","API Relative Path":"src.android.graphics.Paint.java-setFontFeatureSettings(String)","Corresponding Source":"/**\n     * Set font feature settings.\n     *\n     * The format is the same as the CSS font-feature-settings attribute:\n     * <a href=\"http://dev.w3.org/csswg/css-fonts/#propdef-font-feature-settings\">\n     *     http://dev.w3.org/csswg/css-fonts/#propdef-font-feature-settings<\/a>\n     *\n     * @see #getFontFeatureSettings()\n     *\n     * @param settings the font feature settings string to use, may be null.\n     */\n    public void setFontFeatureSettings(String settings) {\n        if (settings != null && settings.equals(\"\")) {\n            settings = null;\n        }\n        if ((settings == null && mFontFeatureSettings == null)\n                || (settings != null && settings.equals(mFontFeatureSettings))) {\n            return;\n        }\n        mFontFeatureSettings = settings;\n        nSetFontFeatureSettings(mNativePaint, settings);\n    }"}
{"Number":"184","API Relative Path":"src.android.graphics.Paint.java-setTextLocale(Locale)","Corresponding Source":"/**\n     * Set the text locale list to a one-member list consisting of just the locale.\n     *\n     * See {@link #setTextLocales(LocaleList)} for how the locale list affects\n     * the way the text is drawn for some languages.\n     *\n     * @param locale the paint's locale value for drawing text, must not be null.\n     */\n    public void setTextLocale(@NonNull Locale locale) {\n        if (locale == null) {\n            throw new IllegalArgumentException(\"locale cannot be null\");\n        }\n        if (mLocales != null && mLocales.size() == 1 && locale.equals(mLocales.get(0))) {\n            return;\n        }\n        mLocales = new LocaleList(locale);\n        syncTextLocalesWithMinikin();\n    }"}
{"Number":"185","API Relative Path":"src.android.graphics.Path.java-addRoundRect(float-float-float-float-float[]-Direction)","Corresponding Source":"/**\n     * Add a closed round-rectangle contour to the path. Each corner receives\n     * two radius values [X, Y]. The corners are ordered top-left, top-right,\n     * bottom-right, bottom-left\n     *\n     * @param radii Array of 8 values, 4 pairs of [X,Y] radii\n     * @param dir  The direction to wind the round-rectangle's contour\n     */\n    public void addRoundRect(float left, float top, float right, float bottom, float[] radii,\n            Direction dir) {\n        if (radii.length < 8) {\n            throw new ArrayIndexOutOfBoundsException(\"radii[] needs 8 values\");\n        }\n        isSimplePath = false;\n        native_addRoundRect(mNativePath, left, top, right, bottom, radii, dir.nativeInt);\n    }"}
{"Number":"186","API Relative Path":"src.android.graphics.Path.java-addRoundRect(RectF-float[]-Direction)","Corresponding Source":"/**\n     * Add a closed round-rectangle contour to the path. Each corner receives\n     * two radius values [X, Y]. The corners are ordered top-left, top-right,\n     * bottom-right, bottom-left\n     *\n     * @param rect The bounds of a round-rectangle to add to the path\n     * @param radii Array of 8 values, 4 pairs of [X,Y] radii\n     * @param dir  The direction to wind the round-rectangle's contour\n     */\n    public void addRoundRect(RectF rect, float[] radii, Direction dir) {\n        if (rect == null) {\n            throw new NullPointerException(\"need rect parameter\");\n        }\n        addRoundRect(rect.left, rect.top, rect.right, rect.bottom, radii, dir);\n    }"}
{"Number":"187","API Relative Path":"src.android.graphics.PathMeasure.java-getPosTan(float-float-float)","Corresponding Source":"/**\n     * Pins distance to 0 <= distance <= getLength(), and then computes the\n     * corresponding position and tangent. Returns false if there is no path,\n     * or a zero-length path was specified, in which case position and tangent\n     * are unchanged.\n     *\n     * @param distance The distance along the current contour to sample\n     * @param pos If not null, eturns the sampled position (x==[0], y==[1])\n     * @param tan If not null, returns the sampled tangent (x==[0], y==[1])\n     * @return false if there was no path associated with this measure object\n    */\n    public boolean getPosTan(float distance, float pos[], float tan[]) {\n        if (pos != null && pos.length < 2 ||\n            tan != null && tan.length < 2) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        return native_getPosTan(native_instance, distance, pos, tan);\n    }"}
{"Number":"188","API Relative Path":"src.android.graphics.pdf.PdfDocument.java-finishPage(Page)","Corresponding Source":"/**\n     * Finishes a started page. You should always finish the last started page.\n     * <p>\n     * <strong>Note:<\/strong> Do not call this method after {@link #close()}.\n     * You should not finish the same page more than once.\n     * <\/p>\n     *\n     * @param page The page. Cannot be null.\n     *\n     * @see #startPage(PageInfo)\n     */\n    public void finishPage(Page page) {\n        throwIfClosed();\n        if (page == null) {\n            throw new IllegalArgumentException(\"page cannot be null\");\n        }\n        if (page != mCurrentPage) {\n            throw new IllegalStateException(\"invalid page\");\n        }\n        if (page.isFinished()) {\n            throw new IllegalStateException(\"page already finished\");\n        }\n        mPages.add(page.getInfo());\n        mCurrentPage = null;\n        nativeFinishPage(mNativeDocument);\n        page.finish();\n    }"}
{"Number":"189","API Relative Path":"src.android.graphics.pdf.PdfEditor.java-PdfEditor(ParcelFileDescriptor)","Corresponding Source":"/**\n     * Creates a new instance.\n     * <p>\n     * <strong>Note:<\/strong> The provided file descriptor must be <strong>seekable<\/strong>,\n     * i.e. its data being randomly accessed, e.g. pointing to a file. After finishing\n     * with this class you must call {@link #close()}.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This class takes ownership of the passed in file descriptor\n     * and is responsible for closing it when the editor is closed.\n     * <\/p>\n     *\n     * @param input Seekable file descriptor to read from.\n     *\n     * @throws java.io.IOException If an error occurs while reading the file.\n     * @throws java.lang.SecurityException If the file requires a password or\n     *         the security scheme is not supported.\n     *\n     * @see #close()\n     */\n    public PdfEditor(@NonNull ParcelFileDescriptor input) throws IOException {\n        if (input == null) {\n            throw new NullPointerException(\"input cannot be null\");\n        }\n\n        final long size;\n        try {\n            Libcore.os.lseek(input.getFileDescriptor(), 0, OsConstants.SEEK_SET);\n            size = Libcore.os.fstat(input.getFileDescriptor()).st_size;\n        } catch (ErrnoException ee) {\n            throw new IllegalArgumentException(\"file descriptor not seekable\");\n        }\n\n        mInput = input;\n        mNativeDocument = nativeOpen(mInput.getFd(), size);\n        mPageCount = nativeGetPageCount(mNativeDocument);\n        mCloseGuard.open(\"close\");\n    }"}
{"Number":"190","API Relative Path":"src.android.graphics.pdf.PdfRenderer.java-PdfRenderer(ParcelFileDescriptor)","Corresponding Source":"/**\n     * Creates a new instance.\n     * <p>\n     * <strong>Note:<\/strong> The provided file descriptor must be <strong>seekable<\/strong>,\n     * i.e. its data being randomly accessed, e.g. pointing to a file.\n     * <\/p>\n     * <p>\n     * <strong>Note:<\/strong> This class takes ownership of the passed in file descriptor\n     * and is responsible for closing it when the renderer is closed.\n     * <\/p>\n     * <p>\n     * If the file is from an untrusted source it is recommended to run the renderer in a separate,\n     * isolated process with minimal permissions to limit the impact of security exploits.\n     * <\/p>\n     *\n     * @param input Seekable file descriptor to read from.\n     *\n     * @throws java.io.IOException If an error occurs while reading the file.\n     * @throws java.lang.SecurityException If the file requires a password or\n     *         the security scheme is not supported.\n     */\n    public PdfRenderer(@NonNull ParcelFileDescriptor input) throws IOException {\n        if (input == null) {\n            throw new NullPointerException(\"input cannot be null\");\n        }\n\n        final long size;\n        try {\n            Libcore.os.lseek(input.getFileDescriptor(), 0, OsConstants.SEEK_SET);\n            size = Libcore.os.fstat(input.getFileDescriptor()).st_size;\n        } catch (ErrnoException ee) {\n            throw new IllegalArgumentException(\"file descriptor not seekable\");\n        }\n\n        mInput = input;\n        mNativeDocument = nativeCreate(mInput.getFd(), size);\n        mPageCount = nativeGetPageCount(mNativeDocument);\n        mCloseGuard.open(\"close\");\n    }"}
{"Number":"191","API Relative Path":"src.android.graphics.Picture.java-writeToStream(OutputStream)","Corresponding Source":"/**\n     * Write the picture contents to a stream. The data can be used to recreate\n     * the picture in this or another process by calling createFromStream(...)\n     * The resulting stream is NOT to be persisted across device restarts as\n     * there is no guarantee that the Picture can be successfully reconstructed.\n     *\n     * <p>\n     * <strong>Note:<\/strong> Prior to API level 23 a picture created from an\n     * input stream cannot be replayed on a hardware accelerated canvas.\n     *\n     * @see #createFromStream(java.io.InputStream)\n     * @deprecated The recommended alternative is to draw the picture into a\n     * Bitmap from which you can persist it as raw or compressed pixels.\n     */\n    @Deprecated\n    public void writeToStream(OutputStream stream) {\n        // do explicit check before calling the native method\n        if (stream == null) {\n            throw new NullPointerException();\n        }\n        if (!nativeWriteToStream(mNativePicture, stream,\n                             new byte[WORKING_STREAM_STORAGE])) {\n            throw new RuntimeException();\n        }\n    }"}
{"Number":"192","API Relative Path":"src.android.graphics.RadialGradient.java-RadialGradient(float-float-float-int-float-TileMode)","Corresponding Source":"/** Create a shader that draws a radial gradient given the center and radius.\n        @param centerX  The x-coordinate of the center of the radius\n        @param centerY  The y-coordinate of the center of the radius\n        @param radius   Must be positive. The radius of the circle for this gradient.\n        @param colors   The colors to be distributed between the center and edge of the circle\n        @param stops    May be <code>null<\/code>. Valid values are between <code>0.0f<\/code> and\n                        <code>1.0f<\/code>. The relative position of each corresponding color in\n                        the colors array. If <code>null<\/code>, colors are distributed evenly\n                        between the center and edge of the circle.\n        @param tileMode The Shader tiling mode\n    */\n    public RadialGradient(float centerX, float centerY, float radius,\n               @NonNull int colors[], @Nullable float stops[], @NonNull TileMode tileMode) {\n        if (radius <= 0) {\n            throw new IllegalArgumentException(\"radius must be > 0\");\n        }\n        if (colors.length < 2) {\n            throw new IllegalArgumentException(\"needs >= 2 number of colors\");\n        }\n        if (stops != null && colors.length != stops.length) {\n            throw new IllegalArgumentException(\"color and position arrays must be of equal length\");\n        }\n        mType = TYPE_COLORS_AND_POSITIONS;\n        mX = centerX;\n        mY = centerY;\n        mRadius = radius;\n        mColors = colors;\n        mPositions = stops;\n        mTileMode = tileMode;\n        init(nativeCreate1(centerX, centerY, radius, colors, stops, tileMode.nativeInt));\n    }"}
{"Number":"193","API Relative Path":"src.android.graphics.Region.java-getBounds(Rect)","Corresponding Source":"/**\n     * Set the Rect to the bounds of the region. If the region is empty, the\n     * Rect will be set to [0, 0, 0, 0]\n     */\n    public boolean getBounds(Rect r) {\n        if (r == null) {\n            throw new NullPointerException();\n        }\n        return nativeGetBounds(mNativeRegion, r);\n    }"}
{"Number":"194","API Relative Path":"src.android.graphics.RegionIterator.java-next(Rect)","Corresponding Source":"/**\n     * Return the next rectangle in the region. If there are no more rectangles\n     * this returns false and r is unchanged. If there is at least one more,\n     * this returns true and r is set to that rectangle.\n     */\n    public final boolean next(Rect r) {\n        if (r == null) {\n            throw new NullPointerException(\"The Rect must be provided\");\n        }\n        return nativeNext(mNativeIter, r);\n    }"}
{"Number":"195","API Relative Path":"src.android.graphics.SurfaceTexture.java-getTransformMatrix(float[])","Corresponding Source":"private native void nativeGetTransformMatrix(float[] mtx);"}
{"Number":"196","API Relative Path":"src.android.graphics.SweepGradient.java-SweepGradient(float-float-int-float)","Corresponding Source":"/**\n     * A subclass of Shader that draws a sweep gradient around a center point.\n     *\n     * @param cx       The x-coordinate of the center\n     * @param cy       The y-coordinate of the center\n     * @param colors   The colors to be distributed between around the center.\n     *                 There must be at least 2 colors in the array.\n     * @param positions May be NULL. The relative position of\n     *                 each corresponding color in the colors array, beginning\n     *                 with 0 and ending with 1.0. If the values are not\n     *                 monotonic, the drawing may produce unexpected results.\n     *                 If positions is NULL, then the colors are automatically\n     *                 spaced evenly.\n     */\n    public SweepGradient(float cx, float cy,\n                         int colors[], float positions[]) {\n        if (colors.length < 2) {\n            throw new IllegalArgumentException(\"needs >= 2 number of colors\");\n        }\n        if (positions != null && colors.length != positions.length) {\n            throw new IllegalArgumentException(\n                        \"color and position arrays must be of equal length\");\n        }\n        mType = TYPE_COLORS_AND_POSITIONS;\n        mCx = cx;\n        mCy = cy;\n        mColors = colors;\n        mPositions = positions;\n        init(nativeCreate1(cx, cy, colors, positions));\n    }"}
{"Number":"197","API Relative Path":"src.android.graphics.SweepGradient.java-SweepGradient(float-float-int-float)","Corresponding Source":"/**\n     * A subclass of Shader that draws a sweep gradient around a center point.\n     *\n     * @param cx       The x-coordinate of the center\n     * @param cy       The y-coordinate of the center\n     * @param colors   The colors to be distributed between around the center.\n     *                 There must be at least 2 colors in the array.\n     * @param positions May be NULL. The relative position of\n     *                 each corresponding color in the colors array, beginning\n     *                 with 0 and ending with 1.0. If the values are not\n     *                 monotonic, the drawing may produce unexpected results.\n     *                 If positions is NULL, then the colors are automatically\n     *                 spaced evenly.\n     */\n    public SweepGradient(float cx, float cy,\n                         int colors[], float positions[]) {\n        if (colors.length < 2) {\n            throw new IllegalArgumentException(\"needs >= 2 number of colors\");\n        }\n        if (positions != null && colors.length != positions.length) {\n            throw new IllegalArgumentException(\n                        \"color and position arrays must be of equal length\");\n        }\n        mType = TYPE_COLORS_AND_POSITIONS;\n        mCx = cx;\n        mCy = cy;\n        mColors = colors;\n        mPositions = positions;\n        init(nativeCreate1(cx, cy, colors, positions));\n    }"}
{"Number":"198","API Relative Path":"src.android.graphics.YuvImage.java-compressToJpeg(Rect-int-OutputStream)","Corresponding Source":"/**\n     * Compress a rectangle region in the YuvImage to a jpeg.\n     * Only ImageFormat.NV21 and ImageFormat.YUY2\n     * are supported for now.\n     *\n     * @param rectangle The rectangle region to be compressed. The medthod checks if rectangle is\n     *                  inside the image. Also, the method modifies rectangle if the chroma pixels\n     *                  in it are not matched with the luma pixels in it.\n     * @param quality   Hint to the compressor, 0-100. 0 meaning compress for\n     *                  small size, 100 meaning compress for max quality.\n     * @param stream    OutputStream to write the compressed data.\n     * @return          True if the compression is successful.\n     * @throws IllegalArgumentException if rectangle is invalid; quality is not within [0,\n     *                  100]; or stream is null.\n     */\n    public boolean compressToJpeg(Rect rectangle, int quality, OutputStream stream) {\n        Rect wholeImage = new Rect(0, 0, mWidth, mHeight);\n        if (!wholeImage.contains(rectangle)) {\n            throw new IllegalArgumentException(\n                    \"rectangle is not inside the image\");\n        }\n\n        if (quality < 0 || quality > 100) {\n            throw new IllegalArgumentException(\"quality must be 0..100\");\n        }\n\n        if (stream == null) {\n            throw new IllegalArgumentException(\"stream cannot be null\");\n        }\n\n        adjustRectangle(rectangle);\n        int[] offsets = calculateOffsets(rectangle.left, rectangle.top);\n\n        return nativeCompressToJpeg(mData, mFormat, rectangle.width(),\n                rectangle.height(), offsets, mStrides, quality, stream,\n                new byte[WORKING_COMPRESS_STORAGE]);\n    }"}
{"Number":"199","API Relative Path":"src.android.graphics.YuvImage.java-YuvImage(byte[]-int-int-int-int[])","Corresponding Source":"/**\n     * Construct an YuvImage.\n     *\n     * @param yuv     The YUV data. In the case of more than one image plane, all the planes must be\n     *                concatenated into a single byte array.\n     * @param format  The YUV data format as defined in {@link ImageFormat}.\n     * @param width   The width of the YuvImage.\n     * @param height  The height of the YuvImage.\n     * @param strides (Optional) Row bytes of each image plane. If yuv contains padding, the stride\n     *                of each image must be provided. If strides is null, the method assumes no\n     *                padding and derives the row bytes by format and width itself.\n     * @throws IllegalArgumentException if format is not support; width or height <= 0; or yuv is\n     *                null.\n     */\n    public YuvImage(byte[] yuv, int format, int width, int height, int[] strides) {\n        if (format != ImageFormat.NV21 &&\n                format != ImageFormat.YUY2) {\n            throw new IllegalArgumentException(\n                    \"only support ImageFormat.NV21 \" +\n                    \"and ImageFormat.YUY2 for now\");\n        }\n\n        if (width <= 0  || height <= 0) {\n            throw new IllegalArgumentException(\n                    \"width and height must large than 0\");\n        }\n\n        if (yuv == null) {\n            throw new IllegalArgumentException(\"yuv cannot be null\");\n        }\n\n        if (strides == null) {\n            mStrides = calculateStrides(width, format);\n        } else {\n            mStrides = strides;\n        }\n\n        mData = yuv;\n        mFormat = format;\n        mWidth = width;\n        mHeight = height;\n    }"}
{"Number":"200","API Relative Path":"src.android.hardware.Camera.java-openLegacy(int-int)","Corresponding Source":"/**\n     * Creates a new Camera object to access a particular hardware camera with\n     * given hal API version. If the same camera is opened by other applications\n     * or the hal API version is not supported by this device, this will throw a\n     * RuntimeException.\n     * <p>\n     * You must call {@link #release()} when you are done using the camera,\n     * otherwise it will remain locked and be unavailable to other applications.\n     * <p>\n     * Your application should only have one Camera object active at a time for\n     * a particular hardware camera.\n     * <p>\n     * Callbacks from other methods are delivered to the event loop of the\n     * thread which called open(). If this thread has no event loop, then\n     * callbacks are delivered to the main application event loop. If there is\n     * no main application event loop, callbacks are not delivered.\n     * <p class=\"caution\">\n     * <b>Caution:<\/b> On some devices, this method may take a long time to\n     * complete. It is best to call this method from a worker thread (possibly\n     * using {@link android.os.AsyncTask}) to avoid blocking the main\n     * application UI thread.\n     *\n     * @param cameraId The hardware camera to access, between 0 and\n     * {@link #getNumberOfCameras()}-1.\n     * @param halVersion The HAL API version this camera device to be opened as.\n     * @return a new Camera object, connected, locked and ready for use.\n     *\n     * @throws IllegalArgumentException if the {@code halVersion} is invalid\n     *\n     * @throws RuntimeException if opening the camera fails (for example, if the\n     * camera is in use by another process or device policy manager has disabled\n     * the camera).\n     *\n     * @see android.app.admin.DevicePolicyManager#getCameraDisabled(android.content.ComponentName)\n     * @see #CAMERA_HAL_API_VERSION_1_0\n     *\n     * @hide\n     */\n    public static Camera openLegacy(int cameraId, int halVersion) {\n        if (halVersion < CAMERA_HAL_API_VERSION_1_0) {\n            throw new IllegalArgumentException(\"Invalid HAL version \" + halVersion);\n        }\n\n        return new Camera(cameraId, halVersion);\n    }"}
{"Number":"201","API Relative Path":"src.android.hardware.camera2.CameraManager.java-throwAsPublicException(Throwable)","Corresponding Source":"/**\n     * Convert ServiceSpecificExceptions and Binder RemoteExceptions from camera binder interfaces\n     * into the correct public exceptions.\n     *\n     * @hide\n     */\n    public static void throwAsPublicException(Throwable t) throws CameraAccessException {\n        if (t instanceof ServiceSpecificException) {\n            ServiceSpecificException e = (ServiceSpecificException) t;\n            int reason = CameraAccessException.CAMERA_ERROR;\n            switch(e.errorCode) {\n                case ICameraService.ERROR_DISCONNECTED:\n                    reason = CameraAccessException.CAMERA_DISCONNECTED;\n                    break;\n                case ICameraService.ERROR_DISABLED:\n                    reason = CameraAccessException.CAMERA_DISABLED;\n                    break;\n                case ICameraService.ERROR_CAMERA_IN_USE:\n                    reason = CameraAccessException.CAMERA_IN_USE;\n                    break;\n                case ICameraService.ERROR_MAX_CAMERAS_IN_USE:\n                    reason = CameraAccessException.MAX_CAMERAS_IN_USE;\n                    break;\n                case ICameraService.ERROR_DEPRECATED_HAL:\n                    reason = CameraAccessException.CAMERA_DEPRECATED_HAL;\n                    break;\n                case ICameraService.ERROR_ILLEGAL_ARGUMENT:\n                case ICameraService.ERROR_ALREADY_EXISTS:\n                    throw new IllegalArgumentException(e.getMessage(), e);\n                case ICameraService.ERROR_PERMISSION_DENIED:\n                    throw new SecurityException(e.getMessage(), e);\n                case ICameraService.ERROR_TIMED_OUT:\n                case ICameraService.ERROR_INVALID_OPERATION:\n                default:\n                    reason = CameraAccessException.CAMERA_ERROR;\n            }\n            throw new CameraAccessException(reason, e.getMessage(), e);\n        } else if (t instanceof DeadObjectException) {\n            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED,\n                    \"Camera service has died unexpectedly\",\n                    t);\n        } else if (t instanceof RemoteException) {\n            throw new UnsupportedOperationException(\"An unknown RemoteException was thrown\" +\n                    \" which should never happen.\", t);\n        } else if (t instanceof RuntimeException) {\n            RuntimeException e = (RuntimeException) t;\n            throw e;\n        }\n    }"}
{"Number":"202","API Relative Path":"src.android.hardware.camera2.CameraManager.java-throwAsPublicException(Throwable)","Corresponding Source":"/**\n     * Convert ServiceSpecificExceptions and Binder RemoteExceptions from camera binder interfaces\n     * into the correct public exceptions.\n     *\n     * @hide\n     */\n    public static void throwAsPublicException(Throwable t) throws CameraAccessException {\n        if (t instanceof ServiceSpecificException) {\n            ServiceSpecificException e = (ServiceSpecificException) t;\n            int reason = CameraAccessException.CAMERA_ERROR;\n            switch(e.errorCode) {\n                case ICameraService.ERROR_DISCONNECTED:\n                    reason = CameraAccessException.CAMERA_DISCONNECTED;\n                    break;\n                case ICameraService.ERROR_DISABLED:\n                    reason = CameraAccessException.CAMERA_DISABLED;\n                    break;\n                case ICameraService.ERROR_CAMERA_IN_USE:\n                    reason = CameraAccessException.CAMERA_IN_USE;\n                    break;\n                case ICameraService.ERROR_MAX_CAMERAS_IN_USE:\n                    reason = CameraAccessException.MAX_CAMERAS_IN_USE;\n                    break;\n                case ICameraService.ERROR_DEPRECATED_HAL:\n                    reason = CameraAccessException.CAMERA_DEPRECATED_HAL;\n                    break;\n                case ICameraService.ERROR_ILLEGAL_ARGUMENT:\n                case ICameraService.ERROR_ALREADY_EXISTS:\n                    throw new IllegalArgumentException(e.getMessage(), e);\n                case ICameraService.ERROR_PERMISSION_DENIED:\n                    throw new SecurityException(e.getMessage(), e);\n                case ICameraService.ERROR_TIMED_OUT:\n                case ICameraService.ERROR_INVALID_OPERATION:\n                default:\n                    reason = CameraAccessException.CAMERA_ERROR;\n            }\n            throw new CameraAccessException(reason, e.getMessage(), e);\n        } else if (t instanceof DeadObjectException) {\n            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED,\n                    \"Camera service has died unexpectedly\",\n                    t);\n        } else if (t instanceof RemoteException) {\n            throw new UnsupportedOperationException(\"An unknown RemoteException was thrown\" +\n                    \" which should never happen.\", t);\n        } else if (t instanceof RuntimeException) {\n            RuntimeException e = (RuntimeException) t;\n            throw e;\n        }\n    }"}
{"Number":"203","API Relative Path":"src.android.hardware.camera2.CameraManager.java-throwAsPublicException(Throwable)","Corresponding Source":"/**\n     * Convert ServiceSpecificExceptions and Binder RemoteExceptions from camera binder interfaces\n     * into the correct public exceptions.\n     *\n     * @hide\n     */\n    public static void throwAsPublicException(Throwable t) throws CameraAccessException {\n        if (t instanceof ServiceSpecificException) {\n            ServiceSpecificException e = (ServiceSpecificException) t;\n            int reason = CameraAccessException.CAMERA_ERROR;\n            switch(e.errorCode) {\n                case ICameraService.ERROR_DISCONNECTED:\n                    reason = CameraAccessException.CAMERA_DISCONNECTED;\n                    break;\n                case ICameraService.ERROR_DISABLED:\n                    reason = CameraAccessException.CAMERA_DISABLED;\n                    break;\n                case ICameraService.ERROR_CAMERA_IN_USE:\n                    reason = CameraAccessException.CAMERA_IN_USE;\n                    break;\n                case ICameraService.ERROR_MAX_CAMERAS_IN_USE:\n                    reason = CameraAccessException.MAX_CAMERAS_IN_USE;\n                    break;\n                case ICameraService.ERROR_DEPRECATED_HAL:\n                    reason = CameraAccessException.CAMERA_DEPRECATED_HAL;\n                    break;\n                case ICameraService.ERROR_ILLEGAL_ARGUMENT:\n                case ICameraService.ERROR_ALREADY_EXISTS:\n                    throw new IllegalArgumentException(e.getMessage(), e);\n                case ICameraService.ERROR_PERMISSION_DENIED:\n                    throw new SecurityException(e.getMessage(), e);\n                case ICameraService.ERROR_TIMED_OUT:\n                case ICameraService.ERROR_INVALID_OPERATION:\n                default:\n                    reason = CameraAccessException.CAMERA_ERROR;\n            }\n            throw new CameraAccessException(reason, e.getMessage(), e);\n        } else if (t instanceof DeadObjectException) {\n            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED,\n                    \"Camera service has died unexpectedly\",\n                    t);\n        } else if (t instanceof RemoteException) {\n            throw new UnsupportedOperationException(\"An unknown RemoteException was thrown\" +\n                    \" which should never happen.\", t);\n        } else if (t instanceof RuntimeException) {\n            RuntimeException e = (RuntimeException) t;\n            throw e;\n        }\n    }"}
{"Number":"204","API Relative Path":"src.android.hardware.camera2.CaptureResult.java-CaptureResult(CameraMetadataNative-CaptureRequest-CaptureResultExtras)","Corresponding Source":"/**\n     * Takes ownership of the passed-in properties object\n     *\n     * <p>For internal use only<\/p>\n     * @hide\n     */\n    public CaptureResult(CameraMetadataNative results, CaptureRequest parent,\n            CaptureResultExtras extras) {\n        if (results == null) {\n            throw new IllegalArgumentException(\"results was null\");\n        }\n\n        if (parent == null) {\n            throw new IllegalArgumentException(\"parent was null\");\n        }\n\n        if (extras == null) {\n            throw new IllegalArgumentException(\"extras was null\");\n        }\n\n        mResults = CameraMetadataNative.move(results);\n        if (mResults.isEmpty()) {\n            throw new AssertionError(\"Results must not be empty\");\n        }\n        mRequest = parent;\n        mSequenceId = extras.getRequestId();\n        mFrameNumber = extras.getFrameNumber();\n    }"}
{"Number":"205","API Relative Path":"src.android.hardware.camera2.CaptureResult.java-CaptureResult(CameraMetadataNative-CaptureRequest-CaptureResultExtras)","Corresponding Source":"/**\n     * Takes ownership of the passed-in properties object\n     *\n     * <p>For internal use only<\/p>\n     * @hide\n     */\n    public CaptureResult(CameraMetadataNative results, CaptureRequest parent,\n            CaptureResultExtras extras) {\n        if (results == null) {\n            throw new IllegalArgumentException(\"results was null\");\n        }\n\n        if (parent == null) {\n            throw new IllegalArgumentException(\"parent was null\");\n        }\n\n        if (extras == null) {\n            throw new IllegalArgumentException(\"extras was null\");\n        }\n\n        mResults = CameraMetadataNative.move(results);\n        if (mResults.isEmpty()) {\n            throw new AssertionError(\"Results must not be empty\");\n        }\n        mRequest = parent;\n        mSequenceId = extras.getRequestId();\n        mFrameNumber = extras.getFrameNumber();\n    }"}
{"Number":"206","API Relative Path":"src.android.hardware.camera2.CaptureResult.java-CaptureResult(CameraMetadataNative-CaptureRequest-CaptureResultExtras)","Corresponding Source":"/**\n     * Takes ownership of the passed-in properties object\n     *\n     * <p>For internal use only<\/p>\n     * @hide\n     */\n    public CaptureResult(CameraMetadataNative results, CaptureRequest parent,\n            CaptureResultExtras extras) {\n        if (results == null) {\n            throw new IllegalArgumentException(\"results was null\");\n        }\n\n        if (parent == null) {\n            throw new IllegalArgumentException(\"parent was null\");\n        }\n\n        if (extras == null) {\n            throw new IllegalArgumentException(\"extras was null\");\n        }\n\n        mResults = CameraMetadataNative.move(results);\n        if (mResults.isEmpty()) {\n            throw new AssertionError(\"Results must not be empty\");\n        }\n        mRequest = parent;\n        mSequenceId = extras.getRequestId();\n        mFrameNumber = extras.getFrameNumber();\n    }"}
{"Number":"207","API Relative Path":"src.android.hardware.camera2.CaptureResult.java-CaptureResult(CameraMetadataNative-int)","Corresponding Source":"/**\n     * Creates a request-less result.\n     *\n     * <p><strong>For testing only.<\/strong><\/p>\n     * @hide\n     */\n    public CaptureResult(CameraMetadataNative results, int sequenceId) {\n        if (results == null) {\n            throw new IllegalArgumentException(\"results was null\");\n        }\n\n        mResults = CameraMetadataNative.move(results);\n        if (mResults.isEmpty()) {\n            throw new AssertionError(\"Results must not be empty\");\n        }\n\n        mRequest = null;\n        mSequenceId = sequenceId;\n        mFrameNumber = -1;\n    }"}
{"Number":"208","API Relative Path":"src.android.hardware.camera2.DngCreator.java-DngCreator(CameraCharacteristics-CaptureResult)","Corresponding Source":"/**\n     * Create a new DNG object.\n     *\n     * <p>\n     * It is not necessary to call any set methods to write a well-formatted DNG file.\n     * <\/p>\n     * <p>\n     * DNG metadata tags will be generated from the corresponding parameters in the\n     * {@link android.hardware.camera2.CaptureResult} object.\n     * <\/p>\n     * <p>\n     * For best quality DNG files, it is strongly recommended that lens shading map output is\n     * enabled if supported. See {@link CaptureRequest#STATISTICS_LENS_SHADING_MAP_MODE}.\n     * <\/p>\n     * @param characteristics an object containing the static\n     *          {@link android.hardware.camera2.CameraCharacteristics}.\n     * @param metadata a metadata object to generate tags from.\n     */\n    public DngCreator(@NonNull CameraCharacteristics characteristics,\n            @NonNull CaptureResult metadata) {\n        if (characteristics == null || metadata == null) {\n            throw new IllegalArgumentException(\"Null argument to DngCreator constructor\");\n        }\n\n        // Find current time\n        long currentTime = System.currentTimeMillis();\n\n        // Find boot time\n        long bootTimeMillis = currentTime - SystemClock.elapsedRealtime();\n\n        // Find capture time (nanos since boot)\n        Long timestamp = metadata.get(CaptureResult.SENSOR_TIMESTAMP);\n        long captureTime = currentTime;\n        if (timestamp != null) {\n            captureTime = timestamp / 1000000 + bootTimeMillis;\n        }\n\n        // Format for metadata\n        String formattedCaptureTime = sDateTimeStampFormat.format(captureTime);\n\n        nativeInit(characteristics.getNativeCopy(), metadata.getNativeCopy(),\n                formattedCaptureTime);\n    }"}
{"Number":"209","API Relative Path":"src.android.hardware.camera2.DngCreator.java-setDescription(String)","Corresponding Source":"private synchronized native void nativeSetDescription(String description);"}
{"Number":"210","API Relative Path":"src.android.hardware.camera2.DngCreator.java-setLocation(Location)","Corresponding Source":"/**\n     * Set image location metadata.\n     *\n     * <p>\n     * The given location object must contain at least a valid time, latitude, and longitude\n     * (equivalent to the values returned by {@link android.location.Location#getTime()},\n     * {@link android.location.Location#getLatitude()}, and\n     * {@link android.location.Location#getLongitude()} methods).\n     * <\/p>\n     *\n     * @param location an {@link android.location.Location} object to set.\n     * @return this {@link #DngCreator} object.\n     *\n     * @throws java.lang.IllegalArgumentException if the given location object doesn't\n     *          contain enough information to set location metadata.\n     */\n    @NonNull\n    public DngCreator setLocation(@NonNull Location location) {\n        if (location == null) {\n            throw new IllegalArgumentException(\"Null location passed to setLocation\");\n        }\n        double latitude = location.getLatitude();\n        double longitude = location.getLongitude();\n        long time = location.getTime();\n\n        int[] latTag = toExifLatLong(latitude);\n        int[] longTag = toExifLatLong(longitude);\n        String latRef = latitude >= 0 ? GPS_LAT_REF_NORTH : GPS_LAT_REF_SOUTH;\n        String longRef = longitude >= 0 ? GPS_LONG_REF_EAST : GPS_LONG_REF_WEST;\n\n        String dateTag = sExifGPSDateStamp.format(time);\n        mGPSTimeStampCalendar.setTimeInMillis(time);\n        int[] timeTag = new int[] { mGPSTimeStampCalendar.get(Calendar.HOUR_OF_DAY), 1,\n                mGPSTimeStampCalendar.get(Calendar.MINUTE), 1,\n                mGPSTimeStampCalendar.get(Calendar.SECOND), 1 };\n        nativeSetGpsTags(latTag, latRef, longTag, longRef, dateTag, timeTag);\n        return this;\n    }"}
{"Number":"211","API Relative Path":"src.android.hardware.camera2.DngCreator.java-setOrientation(int)","Corresponding Source":"private synchronized native void nativeSetOrientation(int orientation);"}
{"Number":"212","API Relative Path":"src.android.hardware.camera2.DngCreator.java-setThumbnail(Bitmap)","Corresponding Source":"/**\n     * Set the thumbnail image.\n     *\n     * <p>\n     * Pixel data will be converted to a Baseline TIFF RGB image, with 8 bits per color channel.\n     * The alpha channel will be discarded.  Thumbnail images with a dimension larger than\n     * {@link #MAX_THUMBNAIL_DIMENSION} will be rejected.\n     * <\/p>\n     *\n     * @param pixels a {@link android.graphics.Bitmap} of pixel data.\n     * @return this {@link #DngCreator} object.\n     * @throws java.lang.IllegalArgumentException if the given thumbnail image has a dimension\n     *      larger than {@link #MAX_THUMBNAIL_DIMENSION}.\n     */\n    @NonNull\n    public DngCreator setThumbnail(@NonNull Bitmap pixels) {\n        if (pixels == null) {\n            throw new IllegalArgumentException(\"Null argument to setThumbnail\");\n        }\n\n        int width = pixels.getWidth();\n        int height = pixels.getHeight();\n\n        if (width > MAX_THUMBNAIL_DIMENSION || height > MAX_THUMBNAIL_DIMENSION) {\n            throw new IllegalArgumentException(\"Thumbnail dimensions width,height (\" + width +\n                    \",\" + height + \") too large, dimensions must be smaller than \" +\n                    MAX_THUMBNAIL_DIMENSION);\n        }\n\n        ByteBuffer rgbBuffer = convertToRGB(pixels);\n        nativeSetThumbnail(rgbBuffer, width, height);\n\n        return this;\n    }"}
{"Number":"213","API Relative Path":"src.android.hardware.camera2.DngCreator.java-setThumbnail(Image)","Corresponding Source":"/**\n     * Set the thumbnail image.\n     *\n     * <p>\n     * Pixel data is interpreted as a {@link android.graphics.ImageFormat#YUV_420_888} image.\n     * Thumbnail images with a dimension larger than {@link #MAX_THUMBNAIL_DIMENSION} will be\n     * rejected.\n     * <\/p>\n     *\n     * @param pixels an {@link android.media.Image} object with the format\n     *               {@link android.graphics.ImageFormat#YUV_420_888}.\n     * @return this {@link #DngCreator} object.\n     * @throws java.lang.IllegalArgumentException if the given thumbnail image has a dimension\n     *      larger than {@link #MAX_THUMBNAIL_DIMENSION}.\n     */\n    @NonNull\n    public DngCreator setThumbnail(@NonNull Image pixels) {\n        if (pixels == null) {\n            throw new IllegalArgumentException(\"Null argument to setThumbnail\");\n        }\n\n        int format = pixels.getFormat();\n        if (format != ImageFormat.YUV_420_888) {\n            throw new IllegalArgumentException(\"Unsupported Image format \" + format);\n        }\n\n        int width = pixels.getWidth();\n        int height = pixels.getHeight();\n\n        if (width > MAX_THUMBNAIL_DIMENSION || height > MAX_THUMBNAIL_DIMENSION) {\n            throw new IllegalArgumentException(\"Thumbnail dimensions width,height (\" + width +\n                    \",\" + height + \") too large, dimensions must be smaller than \" +\n                    MAX_THUMBNAIL_DIMENSION);\n        }\n\n        ByteBuffer rgbBuffer = convertToRGB(pixels);\n        nativeSetThumbnail(rgbBuffer, width, height);\n\n        return this;\n    }"}
{"Number":"214","API Relative Path":"src.android.hardware.camera2.DngCreator.java-writeByteBuffer(OutputStream-Size-ByteBuffer-long)","Corresponding Source":"/**\n     * Write the {@link android.graphics.ImageFormat#RAW_SENSOR} pixel data to a DNG file with\n     * the currently configured metadata.\n     *\n     * <p>\n     * Raw pixel data must have 16 bits per pixel, and the input must contain at least\n     * {@code offset + 2 * width * height)} bytes.  The width and height of\n     * the input are taken from the width and height set in the {@link DngCreator} metadata tags,\n     * and will typically be equal to the width and height of\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE}.  Prior to\n     * API level 23, this was always the same as\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE}.\n     * The pixel layout in the input is determined from the reported color filter arrangement (CFA)\n     * set in {@link CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT}.  If insufficient\n     * metadata is available to write a well-formatted DNG file, an\n     * {@link java.lang.IllegalStateException} will be thrown.\n     * <\/p>\n     *\n     * <p>\n     * Any mark or limit set on this {@link ByteBuffer} is ignored, and will be cleared by this\n     * method.\n     * <\/p>\n     *\n     * @param dngOutput an {@link java.io.OutputStream} to write the DNG file to.\n     * @param size the {@link Size} of the image to write, in pixels.\n     * @param pixels an {@link java.nio.ByteBuffer} of pixel data to write.\n     * @param offset the offset of the raw image in bytes.  This indicates how many bytes will\n     *               be skipped in the input before any pixel data is read.\n     *\n     * @throws IOException if an error was encountered in the input or output stream.\n     * @throws java.lang.IllegalStateException if not enough metadata information has been\n     *          set to write a well-formatted DNG file.\n     */\n    public void writeByteBuffer(@NonNull OutputStream dngOutput, @NonNull Size size,\n            @NonNull ByteBuffer pixels, @IntRange(from=0) long offset)\n            throws IOException {\n        if (dngOutput == null) {\n            throw new IllegalArgumentException(\"Null dngOutput passed to writeByteBuffer\");\n        } else if (size == null) {\n            throw new IllegalArgumentException(\"Null size passed to writeByteBuffer\");\n        } else if (pixels == null) {\n            throw new IllegalArgumentException(\"Null pixels passed to writeByteBuffer\");\n        } else if (offset < 0) {\n            throw new IllegalArgumentException(\"Negative offset passed to writeByteBuffer\");\n        }\n\n        int width = size.getWidth();\n        int height = size.getHeight();\n\n        writeByteBuffer(width, height, pixels, dngOutput, DEFAULT_PIXEL_STRIDE,\n                width * DEFAULT_PIXEL_STRIDE, offset);\n    }"}
{"Number":"215","API Relative Path":"src.android.hardware.camera2.DngCreator.java-writeByteBuffer(OutputStream-Size-ByteBuffer-long)","Corresponding Source":"/**\n     * Write the {@link android.graphics.ImageFormat#RAW_SENSOR} pixel data to a DNG file with\n     * the currently configured metadata.\n     *\n     * <p>\n     * Raw pixel data must have 16 bits per pixel, and the input must contain at least\n     * {@code offset + 2 * width * height)} bytes.  The width and height of\n     * the input are taken from the width and height set in the {@link DngCreator} metadata tags,\n     * and will typically be equal to the width and height of\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE}.  Prior to\n     * API level 23, this was always the same as\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE}.\n     * The pixel layout in the input is determined from the reported color filter arrangement (CFA)\n     * set in {@link CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT}.  If insufficient\n     * metadata is available to write a well-formatted DNG file, an\n     * {@link java.lang.IllegalStateException} will be thrown.\n     * <\/p>\n     *\n     * <p>\n     * Any mark or limit set on this {@link ByteBuffer} is ignored, and will be cleared by this\n     * method.\n     * <\/p>\n     *\n     * @param dngOutput an {@link java.io.OutputStream} to write the DNG file to.\n     * @param size the {@link Size} of the image to write, in pixels.\n     * @param pixels an {@link java.nio.ByteBuffer} of pixel data to write.\n     * @param offset the offset of the raw image in bytes.  This indicates how many bytes will\n     *               be skipped in the input before any pixel data is read.\n     *\n     * @throws IOException if an error was encountered in the input or output stream.\n     * @throws java.lang.IllegalStateException if not enough metadata information has been\n     *          set to write a well-formatted DNG file.\n     */\n    public void writeByteBuffer(@NonNull OutputStream dngOutput, @NonNull Size size,\n            @NonNull ByteBuffer pixels, @IntRange(from=0) long offset)\n            throws IOException {\n        if (dngOutput == null) {\n            throw new IllegalArgumentException(\"Null dngOutput passed to writeByteBuffer\");\n        } else if (size == null) {\n            throw new IllegalArgumentException(\"Null size passed to writeByteBuffer\");\n        } else if (pixels == null) {\n            throw new IllegalArgumentException(\"Null pixels passed to writeByteBuffer\");\n        } else if (offset < 0) {\n            throw new IllegalArgumentException(\"Negative offset passed to writeByteBuffer\");\n        }\n\n        int width = size.getWidth();\n        int height = size.getHeight();\n\n        writeByteBuffer(width, height, pixels, dngOutput, DEFAULT_PIXEL_STRIDE,\n                width * DEFAULT_PIXEL_STRIDE, offset);\n    }"}
{"Number":"216","API Relative Path":"src.android.hardware.camera2.DngCreator.java-writeByteBuffer(OutputStream-Size-ByteBuffer-long)","Corresponding Source":"/**\n     * Write the {@link android.graphics.ImageFormat#RAW_SENSOR} pixel data to a DNG file with\n     * the currently configured metadata.\n     *\n     * <p>\n     * Raw pixel data must have 16 bits per pixel, and the input must contain at least\n     * {@code offset + 2 * width * height)} bytes.  The width and height of\n     * the input are taken from the width and height set in the {@link DngCreator} metadata tags,\n     * and will typically be equal to the width and height of\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE}.  Prior to\n     * API level 23, this was always the same as\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE}.\n     * The pixel layout in the input is determined from the reported color filter arrangement (CFA)\n     * set in {@link CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT}.  If insufficient\n     * metadata is available to write a well-formatted DNG file, an\n     * {@link java.lang.IllegalStateException} will be thrown.\n     * <\/p>\n     *\n     * <p>\n     * Any mark or limit set on this {@link ByteBuffer} is ignored, and will be cleared by this\n     * method.\n     * <\/p>\n     *\n     * @param dngOutput an {@link java.io.OutputStream} to write the DNG file to.\n     * @param size the {@link Size} of the image to write, in pixels.\n     * @param pixels an {@link java.nio.ByteBuffer} of pixel data to write.\n     * @param offset the offset of the raw image in bytes.  This indicates how many bytes will\n     *               be skipped in the input before any pixel data is read.\n     *\n     * @throws IOException if an error was encountered in the input or output stream.\n     * @throws java.lang.IllegalStateException if not enough metadata information has been\n     *          set to write a well-formatted DNG file.\n     */\n    public void writeByteBuffer(@NonNull OutputStream dngOutput, @NonNull Size size,\n            @NonNull ByteBuffer pixels, @IntRange(from=0) long offset)\n            throws IOException {\n        if (dngOutput == null) {\n            throw new IllegalArgumentException(\"Null dngOutput passed to writeByteBuffer\");\n        } else if (size == null) {\n            throw new IllegalArgumentException(\"Null size passed to writeByteBuffer\");\n        } else if (pixels == null) {\n            throw new IllegalArgumentException(\"Null pixels passed to writeByteBuffer\");\n        } else if (offset < 0) {\n            throw new IllegalArgumentException(\"Negative offset passed to writeByteBuffer\");\n        }\n\n        int width = size.getWidth();\n        int height = size.getHeight();\n\n        writeByteBuffer(width, height, pixels, dngOutput, DEFAULT_PIXEL_STRIDE,\n                width * DEFAULT_PIXEL_STRIDE, offset);\n    }"}
{"Number":"217","API Relative Path":"src.android.hardware.camera2.DngCreator.java-writeByteBuffer(OutputStream-Size-ByteBuffer-long)","Corresponding Source":"/**\n     * Write the {@link android.graphics.ImageFormat#RAW_SENSOR} pixel data to a DNG file with\n     * the currently configured metadata.\n     *\n     * <p>\n     * Raw pixel data must have 16 bits per pixel, and the input must contain at least\n     * {@code offset + 2 * width * height)} bytes.  The width and height of\n     * the input are taken from the width and height set in the {@link DngCreator} metadata tags,\n     * and will typically be equal to the width and height of\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE}.  Prior to\n     * API level 23, this was always the same as\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE}.\n     * The pixel layout in the input is determined from the reported color filter arrangement (CFA)\n     * set in {@link CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT}.  If insufficient\n     * metadata is available to write a well-formatted DNG file, an\n     * {@link java.lang.IllegalStateException} will be thrown.\n     * <\/p>\n     *\n     * <p>\n     * Any mark or limit set on this {@link ByteBuffer} is ignored, and will be cleared by this\n     * method.\n     * <\/p>\n     *\n     * @param dngOutput an {@link java.io.OutputStream} to write the DNG file to.\n     * @param size the {@link Size} of the image to write, in pixels.\n     * @param pixels an {@link java.nio.ByteBuffer} of pixel data to write.\n     * @param offset the offset of the raw image in bytes.  This indicates how many bytes will\n     *               be skipped in the input before any pixel data is read.\n     *\n     * @throws IOException if an error was encountered in the input or output stream.\n     * @throws java.lang.IllegalStateException if not enough metadata information has been\n     *          set to write a well-formatted DNG file.\n     */\n    public void writeByteBuffer(@NonNull OutputStream dngOutput, @NonNull Size size,\n            @NonNull ByteBuffer pixels, @IntRange(from=0) long offset)\n            throws IOException {\n        if (dngOutput == null) {\n            throw new IllegalArgumentException(\"Null dngOutput passed to writeByteBuffer\");\n        } else if (size == null) {\n            throw new IllegalArgumentException(\"Null size passed to writeByteBuffer\");\n        } else if (pixels == null) {\n            throw new IllegalArgumentException(\"Null pixels passed to writeByteBuffer\");\n        } else if (offset < 0) {\n            throw new IllegalArgumentException(\"Negative offset passed to writeByteBuffer\");\n        }\n\n        int width = size.getWidth();\n        int height = size.getHeight();\n\n        writeByteBuffer(width, height, pixels, dngOutput, DEFAULT_PIXEL_STRIDE,\n                width * DEFAULT_PIXEL_STRIDE, offset);\n    }"}
{"Number":"218","API Relative Path":"src.android.hardware.camera2.DngCreator.java-writeImage(OutputStream-Image)","Corresponding Source":"/**\n     * Write the pixel data to a DNG file with the currently configured metadata.\n     *\n     * <p>\n     * For this method to succeed, the {@link android.media.Image} input must contain\n     * {@link android.graphics.ImageFormat#RAW_SENSOR} pixel data, otherwise an\n     * {@link java.lang.IllegalArgumentException} will be thrown.\n     * <\/p>\n     *\n     * @param dngOutput an {@link java.io.OutputStream} to write the DNG file to.\n     * @param pixels an {@link android.media.Image} to write.\n     *\n     * @throws java.io.IOException if an error was encountered in the output stream.\n     * @throws java.lang.IllegalArgumentException if an image with an unsupported format was used.\n     * @throws java.lang.IllegalStateException if not enough metadata information has been\n     *          set to write a well-formatted DNG file.\n     */\n    public void writeImage(@NonNull OutputStream dngOutput, @NonNull Image pixels)\n            throws IOException {\n        if (dngOutput == null) {\n            throw new IllegalArgumentException(\"Null dngOutput to writeImage\");\n        } else if (pixels == null) {\n            throw new IllegalArgumentException(\"Null pixels to writeImage\");\n        }\n\n        int format = pixels.getFormat();\n        if (format != ImageFormat.RAW_SENSOR) {\n            throw new IllegalArgumentException(\"Unsupported image format \" + format);\n        }\n\n        Image.Plane[] planes = pixels.getPlanes();\n        if (planes == null || planes.length <= 0) {\n            throw new IllegalArgumentException(\"Image with no planes passed to writeImage\");\n        }\n\n        ByteBuffer buf = planes[0].getBuffer();\n        writeByteBuffer(pixels.getWidth(), pixels.getHeight(), buf, dngOutput,\n                planes[0].getPixelStride(), planes[0].getRowStride(), 0);\n    }"}
{"Number":"219","API Relative Path":"src.android.hardware.camera2.DngCreator.java-writeImage(OutputStream-Image)","Corresponding Source":"/**\n     * Write the pixel data to a DNG file with the currently configured metadata.\n     *\n     * <p>\n     * For this method to succeed, the {@link android.media.Image} input must contain\n     * {@link android.graphics.ImageFormat#RAW_SENSOR} pixel data, otherwise an\n     * {@link java.lang.IllegalArgumentException} will be thrown.\n     * <\/p>\n     *\n     * @param dngOutput an {@link java.io.OutputStream} to write the DNG file to.\n     * @param pixels an {@link android.media.Image} to write.\n     *\n     * @throws java.io.IOException if an error was encountered in the output stream.\n     * @throws java.lang.IllegalArgumentException if an image with an unsupported format was used.\n     * @throws java.lang.IllegalStateException if not enough metadata information has been\n     *          set to write a well-formatted DNG file.\n     */\n    public void writeImage(@NonNull OutputStream dngOutput, @NonNull Image pixels)\n            throws IOException {\n        if (dngOutput == null) {\n            throw new IllegalArgumentException(\"Null dngOutput to writeImage\");\n        } else if (pixels == null) {\n            throw new IllegalArgumentException(\"Null pixels to writeImage\");\n        }\n\n        int format = pixels.getFormat();\n        if (format != ImageFormat.RAW_SENSOR) {\n            throw new IllegalArgumentException(\"Unsupported image format \" + format);\n        }\n\n        Image.Plane[] planes = pixels.getPlanes();\n        if (planes == null || planes.length <= 0) {\n            throw new IllegalArgumentException(\"Image with no planes passed to writeImage\");\n        }\n\n        ByteBuffer buf = planes[0].getBuffer();\n        writeByteBuffer(pixels.getWidth(), pixels.getHeight(), buf, dngOutput,\n                planes[0].getPixelStride(), planes[0].getRowStride(), 0);\n    }"}
{"Number":"220","API Relative Path":"src.android.hardware.camera2.DngCreator.java-writeInputStream(OutputStream-Size-InputStream-long)","Corresponding Source":"/**\n     * Write the {@link android.graphics.ImageFormat#RAW_SENSOR} pixel data to a DNG file with\n     * the currently configured metadata.\n     *\n     * <p>\n     * Raw pixel data must have 16 bits per pixel, and the input must contain at least\n     * {@code offset + 2 * width * height)} bytes.  The width and height of\n     * the input are taken from the width and height set in the {@link DngCreator} metadata tags,\n     * and will typically be equal to the width and height of\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE}.  Prior to\n     * API level 23, this was always the same as\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE}.\n     * The pixel layout in the input is determined from the reported color filter arrangement (CFA)\n     * set in {@link CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT}.  If insufficient\n     * metadata is available to write a well-formatted DNG file, an\n     * {@link java.lang.IllegalStateException} will be thrown.\n     * <\/p>\n     *\n     * @param dngOutput an {@link java.io.OutputStream} to write the DNG file to.\n     * @param size the {@link Size} of the image to write, in pixels.\n     * @param pixels an {@link java.io.InputStream} of pixel data to write.\n     * @param offset the offset of the raw image in bytes.  This indicates how many bytes will\n     *               be skipped in the input before any pixel data is read.\n     *\n     * @throws IOException if an error was encountered in the input or output stream.\n     * @throws java.lang.IllegalStateException if not enough metadata information has been\n     *          set to write a well-formatted DNG file.\n     * @throws java.lang.IllegalArgumentException if the size passed in does not match the\n     */\n    public void writeInputStream(@NonNull OutputStream dngOutput, @NonNull Size size,\n            @NonNull InputStream pixels, @IntRange(from=0) long offset) throws IOException {\n        if (dngOutput == null) {\n            throw new IllegalArgumentException(\"Null dngOutput passed to writeInputStream\");\n        } else if (size == null) {\n            throw new IllegalArgumentException(\"Null size passed to writeInputStream\");\n        } else if (pixels == null) {\n            throw new IllegalArgumentException(\"Null pixels passed to writeInputStream\");\n        } else if (offset < 0) {\n            throw new IllegalArgumentException(\"Negative offset passed to writeInputStream\");\n        }\n\n        int width = size.getWidth();\n        int height = size.getHeight();\n        if (width <= 0 || height <= 0) {\n            throw new IllegalArgumentException(\"Size with invalid width, height: (\" + width + \",\" +\n                    height + \") passed to writeInputStream\");\n        }\n        nativeWriteInputStream(dngOutput, pixels, width, height, offset);\n    }"}
{"Number":"221","API Relative Path":"src.android.hardware.camera2.DngCreator.java-writeInputStream(OutputStream-Size-InputStream-long)","Corresponding Source":"/**\n     * Write the {@link android.graphics.ImageFormat#RAW_SENSOR} pixel data to a DNG file with\n     * the currently configured metadata.\n     *\n     * <p>\n     * Raw pixel data must have 16 bits per pixel, and the input must contain at least\n     * {@code offset + 2 * width * height)} bytes.  The width and height of\n     * the input are taken from the width and height set in the {@link DngCreator} metadata tags,\n     * and will typically be equal to the width and height of\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE}.  Prior to\n     * API level 23, this was always the same as\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE}.\n     * The pixel layout in the input is determined from the reported color filter arrangement (CFA)\n     * set in {@link CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT}.  If insufficient\n     * metadata is available to write a well-formatted DNG file, an\n     * {@link java.lang.IllegalStateException} will be thrown.\n     * <\/p>\n     *\n     * @param dngOutput an {@link java.io.OutputStream} to write the DNG file to.\n     * @param size the {@link Size} of the image to write, in pixels.\n     * @param pixels an {@link java.io.InputStream} of pixel data to write.\n     * @param offset the offset of the raw image in bytes.  This indicates how many bytes will\n     *               be skipped in the input before any pixel data is read.\n     *\n     * @throws IOException if an error was encountered in the input or output stream.\n     * @throws java.lang.IllegalStateException if not enough metadata information has been\n     *          set to write a well-formatted DNG file.\n     * @throws java.lang.IllegalArgumentException if the size passed in does not match the\n     */\n    public void writeInputStream(@NonNull OutputStream dngOutput, @NonNull Size size,\n            @NonNull InputStream pixels, @IntRange(from=0) long offset) throws IOException {\n        if (dngOutput == null) {\n            throw new IllegalArgumentException(\"Null dngOutput passed to writeInputStream\");\n        } else if (size == null) {\n            throw new IllegalArgumentException(\"Null size passed to writeInputStream\");\n        } else if (pixels == null) {\n            throw new IllegalArgumentException(\"Null pixels passed to writeInputStream\");\n        } else if (offset < 0) {\n            throw new IllegalArgumentException(\"Negative offset passed to writeInputStream\");\n        }\n\n        int width = size.getWidth();\n        int height = size.getHeight();\n        if (width <= 0 || height <= 0) {\n            throw new IllegalArgumentException(\"Size with invalid width, height: (\" + width + \",\" +\n                    height + \") passed to writeInputStream\");\n        }\n        nativeWriteInputStream(dngOutput, pixels, width, height, offset);\n    }"}
{"Number":"222","API Relative Path":"src.android.hardware.camera2.DngCreator.java-writeInputStream(OutputStream-Size-InputStream-long)","Corresponding Source":"/**\n     * Write the {@link android.graphics.ImageFormat#RAW_SENSOR} pixel data to a DNG file with\n     * the currently configured metadata.\n     *\n     * <p>\n     * Raw pixel data must have 16 bits per pixel, and the input must contain at least\n     * {@code offset + 2 * width * height)} bytes.  The width and height of\n     * the input are taken from the width and height set in the {@link DngCreator} metadata tags,\n     * and will typically be equal to the width and height of\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE}.  Prior to\n     * API level 23, this was always the same as\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE}.\n     * The pixel layout in the input is determined from the reported color filter arrangement (CFA)\n     * set in {@link CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT}.  If insufficient\n     * metadata is available to write a well-formatted DNG file, an\n     * {@link java.lang.IllegalStateException} will be thrown.\n     * <\/p>\n     *\n     * @param dngOutput an {@link java.io.OutputStream} to write the DNG file to.\n     * @param size the {@link Size} of the image to write, in pixels.\n     * @param pixels an {@link java.io.InputStream} of pixel data to write.\n     * @param offset the offset of the raw image in bytes.  This indicates how many bytes will\n     *               be skipped in the input before any pixel data is read.\n     *\n     * @throws IOException if an error was encountered in the input or output stream.\n     * @throws java.lang.IllegalStateException if not enough metadata information has been\n     *          set to write a well-formatted DNG file.\n     * @throws java.lang.IllegalArgumentException if the size passed in does not match the\n     */\n    public void writeInputStream(@NonNull OutputStream dngOutput, @NonNull Size size,\n            @NonNull InputStream pixels, @IntRange(from=0) long offset) throws IOException {\n        if (dngOutput == null) {\n            throw new IllegalArgumentException(\"Null dngOutput passed to writeInputStream\");\n        } else if (size == null) {\n            throw new IllegalArgumentException(\"Null size passed to writeInputStream\");\n        } else if (pixels == null) {\n            throw new IllegalArgumentException(\"Null pixels passed to writeInputStream\");\n        } else if (offset < 0) {\n            throw new IllegalArgumentException(\"Negative offset passed to writeInputStream\");\n        }\n\n        int width = size.getWidth();\n        int height = size.getHeight();\n        if (width <= 0 || height <= 0) {\n            throw new IllegalArgumentException(\"Size with invalid width, height: (\" + width + \",\" +\n                    height + \") passed to writeInputStream\");\n        }\n        nativeWriteInputStream(dngOutput, pixels, width, height, offset);\n    }"}
{"Number":"223","API Relative Path":"src.android.hardware.camera2.DngCreator.java-writeInputStream(OutputStream-Size-InputStream-long)","Corresponding Source":"/**\n     * Write the {@link android.graphics.ImageFormat#RAW_SENSOR} pixel data to a DNG file with\n     * the currently configured metadata.\n     *\n     * <p>\n     * Raw pixel data must have 16 bits per pixel, and the input must contain at least\n     * {@code offset + 2 * width * height)} bytes.  The width and height of\n     * the input are taken from the width and height set in the {@link DngCreator} metadata tags,\n     * and will typically be equal to the width and height of\n     * {@link CameraCharacteristics#SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE}.  Prior to\n     * API level 23, this was always the same as\n     * {@link CameraCharacteristics#SENSOR_INFO_ACTIVE_ARRAY_SIZE}.\n     * The pixel layout in the input is determined from the reported color filter arrangement (CFA)\n     * set in {@link CameraCharacteristics#SENSOR_INFO_COLOR_FILTER_ARRANGEMENT}.  If insufficient\n     * metadata is available to write a well-formatted DNG file, an\n     * {@link java.lang.IllegalStateException} will be thrown.\n     * <\/p>\n     *\n     * @param dngOutput an {@link java.io.OutputStream} to write the DNG file to.\n     * @param size the {@link Size} of the image to write, in pixels.\n     * @param pixels an {@link java.io.InputStream} of pixel data to write.\n     * @param offset the offset of the raw image in bytes.  This indicates how many bytes will\n     *               be skipped in the input before any pixel data is read.\n     *\n     * @throws IOException if an error was encountered in the input or output stream.\n     * @throws java.lang.IllegalStateException if not enough metadata information has been\n     *          set to write a well-formatted DNG file.\n     * @throws java.lang.IllegalArgumentException if the size passed in does not match the\n     */\n    public void writeInputStream(@NonNull OutputStream dngOutput, @NonNull Size size,\n            @NonNull InputStream pixels, @IntRange(from=0) long offset) throws IOException {\n        if (dngOutput == null) {\n            throw new IllegalArgumentException(\"Null dngOutput passed to writeInputStream\");\n        } else if (size == null) {\n            throw new IllegalArgumentException(\"Null size passed to writeInputStream\");\n        } else if (pixels == null) {\n            throw new IllegalArgumentException(\"Null pixels passed to writeInputStream\");\n        } else if (offset < 0) {\n            throw new IllegalArgumentException(\"Negative offset passed to writeInputStream\");\n        }\n\n        int width = size.getWidth();\n        int height = size.getHeight();\n        if (width <= 0 || height <= 0) {\n            throw new IllegalArgumentException(\"Size with invalid width, height: (\" + width + \",\" +\n                    height + \") passed to writeInputStream\");\n        }\n        nativeWriteInputStream(dngOutput, pixels, width, height, offset);\n    }"}
{"Number":"224","API Relative Path":"src.android.hardware.camera2.impl.CameraDeviceImpl.java-checkHandler(Handler)","Corresponding Source":"/**\n     * Default handler management.\n     *\n     * <p>\n     * If handler is null, get the current thread's\n     * Looper to create a Handler with. If no looper exists, throw {@code IllegalArgumentException}.\n     * <\/p>\n     */\n    static Handler checkHandler(Handler handler) {\n        if (handler == null) {\n            Looper looper = Looper.myLooper();\n            if (looper == null) {\n                throw new IllegalArgumentException(\n                    \"No handler given, and current thread has no looper!\");\n            }\n            handler = new Handler(looper);\n        }\n        return handler;\n    }"}
{"Number":"225","API Relative Path":"src.android.hardware.camera2.impl.CameraDeviceImpl.java-configureStreamsChecked(InputConfiguration-List-boolean)","Corresponding Source":"/**\n     * Attempt to configure the input and outputs; the device goes to idle and then configures the\n     * new input and outputs if possible.\n     *\n     * <p>The configuration may gracefully fail, if input configuration is not supported,\n     * if there are too many outputs, if the formats are not supported, or if the sizes for that\n     * format is not supported. In this case this function will return {@code false} and the\n     * unconfigured callback will be fired.<\/p>\n     *\n     * <p>If the configuration succeeds (with 1 or more outputs with or without an input),\n     * then the idle callback is fired. Unconfiguring the device always fires the idle callback.<\/p>\n     *\n     * @param inputConfig input configuration or {@code null} for no input\n     * @param outputs a list of one or more surfaces, or {@code null} to unconfigure\n     * @param isConstrainedHighSpeed If the streams configuration is for constrained high speed output.\n     * @return whether or not the configuration was successful\n     *\n     * @throws CameraAccessException if there were any unexpected problems during configuration\n     */\n    public boolean configureStreamsChecked(InputConfiguration inputConfig,\n            List<OutputConfiguration> outputs, boolean isConstrainedHighSpeed)\n                    throws CameraAccessException {\n        // Treat a null input the same an empty list\n        if (outputs == null) {\n            outputs = new ArrayList<OutputConfiguration>();\n        }\n        if (outputs.size() == 0 && inputConfig != null) {\n            throw new IllegalArgumentException(\"cannot configure an input stream without \" +\n                    \"any output streams\");\n        }\n\n        checkInputConfiguration(inputConfig);\n\n        boolean success = false;\n\n        synchronized(mInterfaceLock) {\n            checkIfCameraClosedOrInError();\n            // Streams to create\n            HashSet<OutputConfiguration> addSet = new HashSet<OutputConfiguration>(outputs);\n            // Streams to delete\n            List<Integer> deleteList = new ArrayList<Integer>();\n\n            // Determine which streams need to be created, which to be deleted\n            for (int i = 0; i < mConfiguredOutputs.size(); ++i) {\n                int streamId = mConfiguredOutputs.keyAt(i);\n                OutputConfiguration outConfig = mConfiguredOutputs.valueAt(i);\n\n                if (!outputs.contains(outConfig)) {\n                    deleteList.add(streamId);\n                } else {\n                    addSet.remove(outConfig);  // Don't create a stream previously created\n                }\n            }\n\n            mDeviceHandler.post(mCallOnBusy);\n            stopRepeating();\n\n            try {\n                waitUntilIdle();\n\n                mRemoteDevice.beginConfigure();\n\n                // reconfigure the input stream if the input configuration is different.\n                InputConfiguration currentInputConfig = mConfiguredInput.getValue();\n                if (inputConfig != currentInputConfig &&\n                        (inputConfig == null || !inputConfig.equals(currentInputConfig))) {\n                    if (currentInputConfig != null) {\n                        mRemoteDevice.deleteStream(mConfiguredInput.getKey());\n                        mConfiguredInput = new SimpleEntry<Integer, InputConfiguration>(\n                                REQUEST_ID_NONE, null);\n                    }\n                    if (inputConfig != null) {\n                        int streamId = mRemoteDevice.createInputStream(inputConfig.getWidth(),\n                                inputConfig.getHeight(), inputConfig.getFormat());\n                        mConfiguredInput = new SimpleEntry<Integer, InputConfiguration>(\n                                streamId, inputConfig);\n                    }\n                }\n\n                // Delete all streams first (to free up HW resources)\n                for (Integer streamId : deleteList) {\n                    mRemoteDevice.deleteStream(streamId);\n                    mConfiguredOutputs.delete(streamId);\n                }\n\n                // Add all new streams\n                for (OutputConfiguration outConfig : outputs) {\n                    if (addSet.contains(outConfig)) {\n                        int streamId = mRemoteDevice.createStream(outConfig);\n                        mConfiguredOutputs.put(streamId, outConfig);\n                    }\n                }\n\n                mRemoteDevice.endConfigure(isConstrainedHighSpeed);\n\n                success = true;\n            } catch (IllegalArgumentException e) {\n                // OK. camera service can reject stream config if it's not supported by HAL\n                // This is only the result of a programmer misusing the camera2 api.\n                Log.w(TAG, \"Stream configuration failed due to: \" + e.getMessage());\n                return false;\n            } catch (CameraAccessException e) {\n                if (e.getReason() == CameraAccessException.CAMERA_IN_USE) {\n                    throw new IllegalStateException(\"The camera is currently busy.\" +\n                            \" You must wait until the previous operation completes.\", e);\n                }\n                throw e;\n            } finally {\n                if (success && outputs.size() > 0) {\n                    mDeviceHandler.post(mCallOnIdle);\n                } else {\n                    // Always return to the 'unconfigured' state if we didn't hit a fatal error\n                    mDeviceHandler.post(mCallOnUnconfigured);\n                }\n            }\n        }\n\n        return success;\n    }"}
{"Number":"226","API Relative Path":"src.android.hardware.camera2.impl.CameraMetadataNative.java-getAllVendorKeys(Class)","Corresponding Source":"/**\n     * Return a list containing keys of the given key class for all defined vendor tags.\n     *\n     * @hide\n     */\n    public static <K> ArrayList<K> getAllVendorKeys(Class<K> keyClass) {\n        if (keyClass == null) {\n            throw new NullPointerException();\n        }\n        return (ArrayList<K>) nativeGetAllVendorKeys(keyClass);\n    }"}
{"Number":"227","API Relative Path":"src.android.hardware.camera2.legacy.LegacyCameraDevice.java-submitRequestList(CaptureRequest[]-boolean)","Corresponding Source":"/**\n     * Submit a burst of capture requests.\n     *\n     * @param requestList a list of capture requests to execute.\n     * @param repeating {@code true} if this burst is repeating.\n     * @return the submission info, including the new request id, and the last frame number, which\n     *   contains either the frame number of the last frame that will be returned for this request,\n     *   or the frame number of the last frame that will be returned for the current repeating\n     *   request if this burst is set to be repeating.\n     */\n    public SubmitInfo submitRequestList(CaptureRequest[] requestList, boolean repeating) {\n        if (requestList == null || requestList.length == 0) {\n            Log.e(TAG, \"submitRequestList - Empty/null requests are not allowed\");\n            throw new ServiceSpecificException(BAD_VALUE,\n                    \"submitRequestList - Empty/null requests are not allowed\");\n        }\n\n        List<Long> surfaceIds;\n\n        try {\n            surfaceIds = (mConfiguredSurfaces == null) ? new ArrayList<Long>() :\n                    getSurfaceIds(mConfiguredSurfaces);\n        } catch (BufferQueueAbandonedException e) {\n            throw new ServiceSpecificException(BAD_VALUE,\n                    \"submitRequestList - configured surface is abandoned.\");\n        }\n\n        // Make sure that there all requests have at least 1 surface; all surfaces are non-null\n        for (CaptureRequest request : requestList) {\n            if (request.getTargets().isEmpty()) {\n                Log.e(TAG, \"submitRequestList - \"\n                        + \"Each request must have at least one Surface target\");\n                throw new ServiceSpecificException(BAD_VALUE,\n                        \"submitRequestList - \"\n                        + \"Each request must have at least one Surface target\");\n            }\n\n            for (Surface surface : request.getTargets()) {\n                if (surface == null) {\n                    Log.e(TAG, \"submitRequestList - Null Surface targets are not allowed\");\n                    throw new ServiceSpecificException(BAD_VALUE,\n                            \"submitRequestList - Null Surface targets are not allowed\");\n                } else if (mConfiguredSurfaces == null) {\n                    Log.e(TAG, \"submitRequestList - must configure \" +\n                            \" device with valid surfaces before submitting requests\");\n                    throw new ServiceSpecificException(INVALID_OPERATION,\n                            \"submitRequestList - must configure \" +\n                            \" device with valid surfaces before submitting requests\");\n                } else if (!containsSurfaceId(surface, surfaceIds)) {\n                    Log.e(TAG, \"submitRequestList - cannot use a surface that wasn't configured\");\n                    throw new ServiceSpecificException(BAD_VALUE,\n                            \"submitRequestList - cannot use a surface that wasn't configured\");\n                }\n            }\n        }\n\n        // TODO: further validation of request here\n        mIdle.close();\n        return mRequestThreadManager.submitCaptureRequests(requestList, repeating);\n    }"}
{"Number":"228","API Relative Path":"src.android.hardware.camera2.legacy.LegacyExceptionUtils.java-throwOnError(int)","Corresponding Source":"/**\n     * Throw error codes used by legacy device methods as exceptions.\n     *\n     * <p>Non-negative return values are passed through, negative return values are thrown as\n     * exceptions.<\/p>\n     *\n     * @param errorFlag error to throw as an exception.\n     * @throws {@link BufferQueueAbandonedException} for -ENODEV.\n     * @throws {@link UnsupportedOperationException} for an unknown negative error code.\n     * @return {@code errorFlag} if the value was non-negative, throws otherwise.\n     */\n    public static int throwOnError(int errorFlag) throws BufferQueueAbandonedException {\n        if (errorFlag == NO_ERROR) {\n            return NO_ERROR;\n        } else if (errorFlag == -ENODEV) {\n            throw new BufferQueueAbandonedException();\n        }\n\n        if (errorFlag < 0) {\n            throw new UnsupportedOperationException(\"Unknown error \" + errorFlag);\n        }\n        return errorFlag;\n    }"}
{"Number":"229","API Relative Path":"src.android.hardware.camera2.legacy.LegacyExceptionUtils.java-throwOnError(int)","Corresponding Source":"/**\n     * Throw error codes used by legacy device methods as exceptions.\n     *\n     * <p>Non-negative return values are passed through, negative return values are thrown as\n     * exceptions.<\/p>\n     *\n     * @param errorFlag error to throw as an exception.\n     * @throws {@link BufferQueueAbandonedException} for -ENODEV.\n     * @throws {@link UnsupportedOperationException} for an unknown negative error code.\n     * @return {@code errorFlag} if the value was non-negative, throws otherwise.\n     */\n    public static int throwOnError(int errorFlag) throws BufferQueueAbandonedException {\n        if (errorFlag == NO_ERROR) {\n            return NO_ERROR;\n        } else if (errorFlag == -ENODEV) {\n            throw new BufferQueueAbandonedException();\n        }\n\n        if (errorFlag < 0) {\n            throw new UnsupportedOperationException(\"Unknown error \" + errorFlag);\n        }\n        return errorFlag;\n    }"}
{"Number":"230","API Relative Path":"src.android.hardware.camera2.marshal.MarshalHelpers.java-checkNativeTypeEquals(int-int)","Corresponding Source":"/**\n     * Ensure that the expected and actual native types are equal.\n     *\n     * @param expectedNativeType the expected native type\n     * @param actualNativeType the actual native type\n     * @return the actual native type\n     *\n     * @throws UnsupportedOperationException if the types are not equal\n     */\n    public static int checkNativeTypeEquals(int expectedNativeType, int actualNativeType) {\n        if (expectedNativeType != actualNativeType) {\n            throw new UnsupportedOperationException(\n                    String.format(\"Expected native type %d, but got %d\",\n                            expectedNativeType, actualNativeType));\n        }\n\n        return actualNativeType;\n    }"}
{"Number":"231","API Relative Path":"src.android.hardware.camera2.params.BlackLevelPattern.java-BlackLevelPattern(int[])","Corresponding Source":"/**\n     * Create a new {@link BlackLevelPattern} from a given offset array.\n     *\n     * <p>The given offset array must contain offsets for each color channel in\n     * a 2x2 pattern corresponding to the color filter arrangement.  Offsets are\n     * given in row-column scan order.<\/p>\n     *\n     * @param offsets an array containing a 2x2 pattern of offsets.\n     *\n     * @throws IllegalArgumentException if the given array has an incorrect length.\n     * @throws NullPointerException if the given array is null.\n     * @hide\n     */\n    public BlackLevelPattern(int[] offsets) {\n        if (offsets == null) {\n            throw new NullPointerException(\"Null offsets array passed to constructor\");\n        }\n        if (offsets.length < COUNT) {\n            throw new IllegalArgumentException(\"Invalid offsets array length\");\n        }\n        mCfaOffsets = Arrays.copyOf(offsets, COUNT);\n    }"}
{"Number":"232","API Relative Path":"src.android.hardware.camera2.params.BlackLevelPattern.java-BlackLevelPattern(int[])","Corresponding Source":"/**\n     * Create a new {@link BlackLevelPattern} from a given offset array.\n     *\n     * <p>The given offset array must contain offsets for each color channel in\n     * a 2x2 pattern corresponding to the color filter arrangement.  Offsets are\n     * given in row-column scan order.<\/p>\n     *\n     * @param offsets an array containing a 2x2 pattern of offsets.\n     *\n     * @throws IllegalArgumentException if the given array has an incorrect length.\n     * @throws NullPointerException if the given array is null.\n     * @hide\n     */\n    public BlackLevelPattern(int[] offsets) {\n        if (offsets == null) {\n            throw new NullPointerException(\"Null offsets array passed to constructor\");\n        }\n        if (offsets.length < COUNT) {\n            throw new IllegalArgumentException(\"Invalid offsets array length\");\n        }\n        mCfaOffsets = Arrays.copyOf(offsets, COUNT);\n    }"}
{"Number":"233","API Relative Path":"src.android.hardware.camera2.params.BlackLevelPattern.java-copyTo(int[]-int)","Corresponding Source":"/**\n     * Copy the ColorChannel offsets into the destination vector.\n     *\n     * <p>Offsets are given in row-column scan order for a given 2x2 color pattern.<\/p>\n     *\n     * @param destination an array big enough to hold at least {@value #COUNT} elements after the\n     *          {@code offset}\n     * @param offset a non-negative offset into the array\n     *\n     * @throws IllegalArgumentException if the offset is invalid.\n     * @throws ArrayIndexOutOfBoundsException if the destination vector is too small.\n     * @throws NullPointerException if the destination is null.\n     */\n    public void copyTo(int[] destination, int offset) {\n        checkNotNull(destination, \"destination must not be null\");\n        if (offset < 0) {\n            throw new IllegalArgumentException(\"Null offset passed to copyTo\");\n        }\n        if (destination.length - offset < COUNT) {\n            throw new ArrayIndexOutOfBoundsException(\"destination too small to fit elements\");\n        }\n        for (int i = 0; i < COUNT; ++i) {\n            destination[offset + i] = mCfaOffsets[i];\n        }\n    }"}
{"Number":"234","API Relative Path":"src.android.hardware.camera2.params.ColorSpaceTransform.java-ColorSpaceTransform(int[])","Corresponding Source":"/**\n     * Create a new immutable {@link ColorSpaceTransform} instance from an {@code int} array.\n     *\n     * <p>The elements must be stored in a row-major order. Each rational is stored\n     * contiguously as a {@code (numerator, denominator)} pair.<\/p>\n     *\n     * <p>In particular:<pre>{@code\n     * int[] elements = new int[\n     *     N11, D11, N12, D12, N13, D13,\n     *     N21, D21, N22, D22, N23, D23,\n     *     N31, D31, N32, D32, N33, D33\n     * ];\n     *\n     * new ColorSpaceTransform(elements)}<\/pre>\n     *\n     * where {@code Nij} and {@code Dij} is the numerator and denominator for row {@code i} and\n     * column {@code j}.<\/p>\n     *\n     * @param elements An array of {@code 18} elements\n     *\n     * @throws IllegalArgumentException\n     *            if the count of {@code elements} is not {@code 18}\n     * @throws NullPointerException\n     *            if {@code elements} is {@code null}\n     */\n    public ColorSpaceTransform(int[] elements) {\n        checkNotNull(elements, \"elements must not be null\");\n        if (elements.length != COUNT_INT) {\n            throw new IllegalArgumentException(\"elements must be \" + COUNT_INT + \" length\");\n        }\n\n        for (int i = 0; i < elements.length; ++i) {\n            checkNotNull(elements, \"element \" + i + \" must not be null\");\n        }\n\n        mElements = Arrays.copyOf(elements, elements.length);\n    }"}
{"Number":"235","API Relative Path":"src.android.hardware.camera2.params.ColorSpaceTransform.java-ColorSpaceTransform(Rational[])","Corresponding Source":"/**\n     * Create a new immutable {@link ColorSpaceTransform} instance from a {@link Rational} array.\n     *\n     * <p>The elements must be stored in a row-major order.<\/p>\n     *\n     * @param elements An array of {@code 9} elements\n     *\n     * @throws IllegalArgumentException\n     *            if the count of {@code elements} is not {@code 9}\n     * @throws NullPointerException\n     *            if {@code elements} or any sub-element is {@code null}\n     */\n    public ColorSpaceTransform(Rational[] elements) {\n\n        checkNotNull(elements, \"elements must not be null\");\n        if (elements.length != COUNT) {\n            throw new IllegalArgumentException(\"elements must be \" + COUNT + \" length\");\n        }\n\n        mElements = new int[COUNT_INT];\n\n        for (int i = 0; i < elements.length; ++i) {\n            checkNotNull(elements, \"element[\" + i + \"] must not be null\");\n            mElements[i * RATIONAL_SIZE + OFFSET_NUMERATOR] = elements[i].getNumerator();\n            mElements[i * RATIONAL_SIZE + OFFSET_DENOMINATOR] = elements[i].getDenominator();\n        }\n    }"}
{"Number":"236","API Relative Path":"src.android.hardware.camera2.params.ColorSpaceTransform.java-copyElements(int[]-int)","Corresponding Source":"/**\n     * Copy the {@link Rational} elements in row-major order from this matrix into the destination.\n     *\n     * <p>Each element is stored as a contiguous rational packed as a\n     * {@code (numerator, denominator)} pair of ints, identical to the\n     * {@link ColorSpaceTransform#ColorSpaceTransform(int[]) constructor}.<\/p>\n     *\n     * @param destination\n     *          an array big enough to hold at least {@code 18} elements after the\n     *          {@code offset}\n     * @param offset\n     *          a non-negative offset into the array\n     * @throws NullPointerException\n     *          If {@code destination} was {@code null}\n     * @throws ArrayIndexOutOfBoundsException\n     *          If there's not enough room to write the elements at the specified destination and\n     *          offset.\n     *\n     * @see ColorSpaceTransform#ColorSpaceTransform(int[])\n     */\n    public void copyElements(int[] destination, int offset) {\n        checkArgumentNonnegative(offset, \"offset must not be negative\");\n        checkNotNull(destination, \"destination must not be null\");\n        if (destination.length - offset < COUNT_INT) {\n            throw new ArrayIndexOutOfBoundsException(\"destination too small to fit elements\");\n        }\n\n        // Manual copy faster than System#arraycopy for very small loops\n        for (int i = 0; i < COUNT_INT; ++i) {\n            destination[i + offset] = mElements[i];\n        }\n    }"}
{"Number":"237","API Relative Path":"src.android.hardware.camera2.params.ColorSpaceTransform.java-copyElements(Rational[]-int)","Corresponding Source":"/**\n     * Copy the {@link Rational} elements in row-major order from this matrix into the destination.\n     *\n     * @param destination\n     *          an array big enough to hold at least {@code 9} elements after the\n     *          {@code offset}\n     * @param offset\n     *          a non-negative offset into the array\n     * @throws NullPointerException\n     *          If {@code destination} was {@code null}\n     * @throws ArrayIndexOutOfBoundsException\n     *          If there's not enough room to write the elements at the specified destination and\n     *          offset.\n     */\n    public void copyElements(Rational[] destination, int offset) {\n        checkArgumentNonnegative(offset, \"offset must not be negative\");\n        checkNotNull(destination, \"destination must not be null\");\n        if (destination.length - offset < COUNT) {\n            throw new ArrayIndexOutOfBoundsException(\"destination too small to fit elements\");\n        }\n\n        for (int i = 0, j = 0; i < COUNT; ++i, j += RATIONAL_SIZE) {\n            int numerator = mElements[j + OFFSET_NUMERATOR];\n            int denominator = mElements[j + OFFSET_DENOMINATOR];\n\n            destination[i + offset] = new Rational(numerator, denominator);\n        }\n    }"}
{"Number":"238","API Relative Path":"src.android.hardware.camera2.params.ColorSpaceTransform.java-getElement(int-int)","Corresponding Source":"/**\n     * Get an element of this matrix by its row and column.\n     *\n     * <p>The rows must be within the range [0, 3),\n     * and the column must be within the range [0, 3).<\/p>\n     *\n     * @return element (non-{@code null})\n     *\n     * @throws IllegalArgumentException if column or row was out of range\n     */\n    public Rational getElement(int column, int row) {\n        if (column < 0 || column >= COLUMNS) {\n            throw new IllegalArgumentException(\"column out of range\");\n        } else if (row < 0 || row >= ROWS) {\n            throw new IllegalArgumentException(\"row out of range\");\n        }\n\n        int numerator = mElements[(row * COLUMNS + column) * RATIONAL_SIZE + OFFSET_NUMERATOR];\n        int denominator = mElements[(row * COLUMNS + column) * RATIONAL_SIZE + OFFSET_DENOMINATOR];\n\n        return new Rational(numerator, denominator);\n    }"}
{"Number":"239","API Relative Path":"src.android.hardware.camera2.params.ColorSpaceTransform.java-getElement(int-int)","Corresponding Source":"/**\n     * Get an element of this matrix by its row and column.\n     *\n     * <p>The rows must be within the range [0, 3),\n     * and the column must be within the range [0, 3).<\/p>\n     *\n     * @return element (non-{@code null})\n     *\n     * @throws IllegalArgumentException if column or row was out of range\n     */\n    public Rational getElement(int column, int row) {\n        if (column < 0 || column >= COLUMNS) {\n            throw new IllegalArgumentException(\"column out of range\");\n        } else if (row < 0 || row >= ROWS) {\n            throw new IllegalArgumentException(\"row out of range\");\n        }\n\n        int numerator = mElements[(row * COLUMNS + column) * RATIONAL_SIZE + OFFSET_NUMERATOR];\n        int denominator = mElements[(row * COLUMNS + column) * RATIONAL_SIZE + OFFSET_DENOMINATOR];\n\n        return new Rational(numerator, denominator);\n    }"}
{"Number":"240","API Relative Path":"src.android.hardware.camera2.params.Face.java-Face(Rect-int-int-Point-Point-Point)","Corresponding Source":"/**\n     * Create a new face with all fields set.\n     *\n     * <p>The id, leftEyePosition, rightEyePosition, and mouthPosition are considered optional.\n     * They are only required when the {@link CaptureResult} reports that the value of key\n     * {@link CaptureResult#STATISTICS_FACE_DETECT_MODE} is\n     * {@link CameraMetadata#STATISTICS_FACE_DETECT_MODE_FULL}.\n     * If the id is {@value #ID_UNSUPPORTED} then the leftEyePosition, rightEyePosition, and\n     * mouthPositions are guaranteed to be {@code null}. Otherwise, each of leftEyePosition,\n     * rightEyePosition, and mouthPosition may be independently null or not-null.<\/p>\n     *\n     * @param bounds Bounds of the face.\n     * @param score Confidence level between {@value #SCORE_MIN}-{@value #SCORE_MAX}.\n     * @param id A unique ID per face visible to the tracker.\n     * @param leftEyePosition The position of the left eye.\n     * @param rightEyePosition The position of the right eye.\n     * @param mouthPosition The position of the mouth.\n     *\n     * @throws IllegalArgumentException\n     *             if bounds is {@code null},\n     *             or if the confidence is not in the range of\n     *             {@value #SCORE_MIN}-{@value #SCORE_MAX},\n     *             or if id is {@value #ID_UNSUPPORTED} and\n     *               leftEyePosition/rightEyePosition/mouthPosition aren't all null,\n     *             or else if id is negative.\n     *\n     * @hide\n     */\n    public Face(Rect bounds, int score, int id,\n            Point leftEyePosition, Point rightEyePosition, Point mouthPosition) {\n        checkNotNull(\"bounds\", bounds);\n        if (score < SCORE_MIN || score > SCORE_MAX) {\n            throw new IllegalArgumentException(\"Confidence out of range\");\n        } else if (id < 0 && id != ID_UNSUPPORTED) {\n            throw new IllegalArgumentException(\"Id out of range\");\n        }\n        if (id == ID_UNSUPPORTED) {\n            checkNull(\"leftEyePosition\", leftEyePosition);\n            checkNull(\"rightEyePosition\", rightEyePosition);\n            checkNull(\"mouthPosition\", mouthPosition);\n        }\n\n        mBounds = bounds;\n        mScore = score;\n        mId = id;\n        mLeftEye = leftEyePosition;\n        mRightEye = rightEyePosition;\n        mMouth = mouthPosition;\n    }"}
{"Number":"241","API Relative Path":"src.android.hardware.camera2.params.Face.java-Face(Rect-int-int-Point-Point-Point)","Corresponding Source":"/**\n     * Create a new face with all fields set.\n     *\n     * <p>The id, leftEyePosition, rightEyePosition, and mouthPosition are considered optional.\n     * They are only required when the {@link CaptureResult} reports that the value of key\n     * {@link CaptureResult#STATISTICS_FACE_DETECT_MODE} is\n     * {@link CameraMetadata#STATISTICS_FACE_DETECT_MODE_FULL}.\n     * If the id is {@value #ID_UNSUPPORTED} then the leftEyePosition, rightEyePosition, and\n     * mouthPositions are guaranteed to be {@code null}. Otherwise, each of leftEyePosition,\n     * rightEyePosition, and mouthPosition may be independently null or not-null.<\/p>\n     *\n     * @param bounds Bounds of the face.\n     * @param score Confidence level between {@value #SCORE_MIN}-{@value #SCORE_MAX}.\n     * @param id A unique ID per face visible to the tracker.\n     * @param leftEyePosition The position of the left eye.\n     * @param rightEyePosition The position of the right eye.\n     * @param mouthPosition The position of the mouth.\n     *\n     * @throws IllegalArgumentException\n     *             if bounds is {@code null},\n     *             or if the confidence is not in the range of\n     *             {@value #SCORE_MIN}-{@value #SCORE_MAX},\n     *             or if id is {@value #ID_UNSUPPORTED} and\n     *               leftEyePosition/rightEyePosition/mouthPosition aren't all null,\n     *             or else if id is negative.\n     *\n     * @hide\n     */\n    public Face(Rect bounds, int score, int id,\n            Point leftEyePosition, Point rightEyePosition, Point mouthPosition) {\n        checkNotNull(\"bounds\", bounds);\n        if (score < SCORE_MIN || score > SCORE_MAX) {\n            throw new IllegalArgumentException(\"Confidence out of range\");\n        } else if (id < 0 && id != ID_UNSUPPORTED) {\n            throw new IllegalArgumentException(\"Id out of range\");\n        }\n        if (id == ID_UNSUPPORTED) {\n            checkNull(\"leftEyePosition\", leftEyePosition);\n            checkNull(\"rightEyePosition\", rightEyePosition);\n            checkNull(\"mouthPosition\", mouthPosition);\n        }\n\n        mBounds = bounds;\n        mScore = score;\n        mId = id;\n        mLeftEye = leftEyePosition;\n        mRightEye = rightEyePosition;\n        mMouth = mouthPosition;\n    }"}
{"Number":"242","API Relative Path":"src.android.hardware.camera2.params.HighSpeedVideoConfiguration.java-HighSpeedVideoConfiguration(int-int-int-int-int)","Corresponding Source":"/**\n     * Create a new {@link HighSpeedVideoConfiguration}.\n     *\n     * @param width image width, in pixels (positive)\n     * @param height image height, in pixels (positive)\n     * @param fpsMin minimum frames per second for the configuration (positive)\n     * @param fpsMax maximum frames per second for the configuration (larger or equal to 60)\n     *\n     * @throws IllegalArgumentException\n     *              if width/height/fpsMin were not positive or fpsMax less than 60\n     *\n     * @hide\n     */\n    public HighSpeedVideoConfiguration(\n            final int width, final int height, final int fpsMin, final int fpsMax,\n            final int batchSizeMax) {\n        if (fpsMax < HIGH_SPEED_MAX_MINIMAL_FPS) {\n            throw new IllegalArgumentException(\"fpsMax must be at least \" +\n                    HIGH_SPEED_MAX_MINIMAL_FPS);\n        }\n        mFpsMax = fpsMax;\n        mWidth = checkArgumentPositive(width, \"width must be positive\");\n        mHeight = checkArgumentPositive(height, \"height must be positive\");\n        mFpsMin = checkArgumentPositive(fpsMin, \"fpsMin must be positive\");\n        mSize = new Size(mWidth, mHeight);\n        mBatchSizeMax = checkArgumentPositive(batchSizeMax, \"batchSizeMax must be positive\");\n        mFpsRange = new Range<Integer>(mFpsMin, mFpsMax);\n    }"}
{"Number":"243","API Relative Path":"src.android.hardware.camera2.params.LensShadingMap.java-getGainFactor(int-int-int)","Corresponding Source":"/**\n     * Get a single color channel gain factor from this lens shading map by its row and column.\n     *\n     * <p>The rows must be within the range [0, {@link #getRowCount}),\n     * the column must be within the range [0, {@link #getColumnCount}),\n     * and the color channel must be within the range [0, {@value RggbChannelVector#COUNT}).<\/p>\n     *\n     * <p>The channel order is {@code [R, Geven, Godd, B]}, where\n     * {@code Geven} is the green channel for the even rows of a Bayer pattern, and\n     * {@code Godd} is the odd rows.\n     * <\/p>\n     *\n     * @param colorChannel color channel from {@code [R, Geven, Godd, B]}\n     * @param column within the range [0, {@link #getColumnCount})\n     * @param row within the range [0, {@link #getRowCount})\n     *\n     * @return a gain factor >= {@value #MINIMUM_GAIN_FACTOR}\n     *\n     * @throws IllegalArgumentException if any of the parameters was out of range\n     *\n     * @see #RED\n     * @see #GREEN_EVEN\n     * @see #GREEN_ODD\n     * @see #BLUE\n     * @see #getRowCount\n     * @see #getColumnCount\n     */\n    public float getGainFactor(final int colorChannel, final int column, final int row) {\n        if (colorChannel < 0 || colorChannel > COUNT) {\n            throw new IllegalArgumentException(\"colorChannel out of range\");\n        } else if (column < 0 || column >= mColumns) {\n            throw new IllegalArgumentException(\"column out of range\");\n        } else if (row < 0 || row >= mRows) {\n            throw new IllegalArgumentException(\"row out of range\");\n        }\n\n        return mElements[colorChannel + (row * mColumns +  column) * COUNT ];\n    }"}
{"Number":"244","API Relative Path":"src.android.hardware.camera2.params.LensShadingMap.java-getGainFactor(int-int-int)","Corresponding Source":"/**\n     * Get a single color channel gain factor from this lens shading map by its row and column.\n     *\n     * <p>The rows must be within the range [0, {@link #getRowCount}),\n     * the column must be within the range [0, {@link #getColumnCount}),\n     * and the color channel must be within the range [0, {@value RggbChannelVector#COUNT}).<\/p>\n     *\n     * <p>The channel order is {@code [R, Geven, Godd, B]}, where\n     * {@code Geven} is the green channel for the even rows of a Bayer pattern, and\n     * {@code Godd} is the odd rows.\n     * <\/p>\n     *\n     * @param colorChannel color channel from {@code [R, Geven, Godd, B]}\n     * @param column within the range [0, {@link #getColumnCount})\n     * @param row within the range [0, {@link #getRowCount})\n     *\n     * @return a gain factor >= {@value #MINIMUM_GAIN_FACTOR}\n     *\n     * @throws IllegalArgumentException if any of the parameters was out of range\n     *\n     * @see #RED\n     * @see #GREEN_EVEN\n     * @see #GREEN_ODD\n     * @see #BLUE\n     * @see #getRowCount\n     * @see #getColumnCount\n     */\n    public float getGainFactor(final int colorChannel, final int column, final int row) {\n        if (colorChannel < 0 || colorChannel > COUNT) {\n            throw new IllegalArgumentException(\"colorChannel out of range\");\n        } else if (column < 0 || column >= mColumns) {\n            throw new IllegalArgumentException(\"column out of range\");\n        } else if (row < 0 || row >= mRows) {\n            throw new IllegalArgumentException(\"row out of range\");\n        }\n\n        return mElements[colorChannel + (row * mColumns +  column) * COUNT ];\n    }"}
{"Number":"245","API Relative Path":"src.android.hardware.camera2.params.LensShadingMap.java-getGainFactor(int-int-int)","Corresponding Source":"/**\n     * Get a single color channel gain factor from this lens shading map by its row and column.\n     *\n     * <p>The rows must be within the range [0, {@link #getRowCount}),\n     * the column must be within the range [0, {@link #getColumnCount}),\n     * and the color channel must be within the range [0, {@value RggbChannelVector#COUNT}).<\/p>\n     *\n     * <p>The channel order is {@code [R, Geven, Godd, B]}, where\n     * {@code Geven} is the green channel for the even rows of a Bayer pattern, and\n     * {@code Godd} is the odd rows.\n     * <\/p>\n     *\n     * @param colorChannel color channel from {@code [R, Geven, Godd, B]}\n     * @param column within the range [0, {@link #getColumnCount})\n     * @param row within the range [0, {@link #getRowCount})\n     *\n     * @return a gain factor >= {@value #MINIMUM_GAIN_FACTOR}\n     *\n     * @throws IllegalArgumentException if any of the parameters was out of range\n     *\n     * @see #RED\n     * @see #GREEN_EVEN\n     * @see #GREEN_ODD\n     * @see #BLUE\n     * @see #getRowCount\n     * @see #getColumnCount\n     */\n    public float getGainFactor(final int colorChannel, final int column, final int row) {\n        if (colorChannel < 0 || colorChannel > COUNT) {\n            throw new IllegalArgumentException(\"colorChannel out of range\");\n        } else if (column < 0 || column >= mColumns) {\n            throw new IllegalArgumentException(\"column out of range\");\n        } else if (row < 0 || row >= mRows) {\n            throw new IllegalArgumentException(\"row out of range\");\n        }\n\n        return mElements[colorChannel + (row * mColumns +  column) * COUNT ];\n    }"}
{"Number":"246","API Relative Path":"src.android.hardware.camera2.params.LensShadingMap.java-getGainFactorVector(int-int)","Corresponding Source":"/**\n     * Get a gain factor vector from this lens shading map by its row and column.\n     *\n     * <p>The rows must be within the range [0, {@link #getRowCount}),\n     * the column must be within the range [0, {@link #getColumnCount}).<\/p>\n     *\n     * @param column within the range [0, {@link #getColumnCount})\n     * @param row within the range [0, {@link #getRowCount})\n     *\n     * @return an {@link RggbChannelVector} where each gain factor >= {@value #MINIMUM_GAIN_FACTOR}\n     *\n     * @throws IllegalArgumentException if any of the parameters was out of range\n     *\n     * @see #getRowCount\n     * @see #getColumnCount\n     */\n    public RggbChannelVector getGainFactorVector(final int column, final int row) {\n        if (column < 0 || column >= mColumns) {\n            throw new IllegalArgumentException(\"column out of range\");\n        } else if (row < 0 || row >= mRows) {\n            throw new IllegalArgumentException(\"row out of range\");\n        }\n\n        final int offset = (row * mColumns +  column) * COUNT;\n\n        final float red =\n                mElements[RED + offset];\n        final float greenEven =\n                mElements[GREEN_EVEN + offset];\n        final float greenOdd =\n                mElements[GREEN_ODD + offset];\n        final float blue =\n                mElements[BLUE + offset];\n\n        return new RggbChannelVector(red, greenEven, greenOdd, blue);\n    }"}
{"Number":"247","API Relative Path":"src.android.hardware.camera2.params.LensShadingMap.java-getGainFactorVector(int-int)","Corresponding Source":"/**\n     * Get a gain factor vector from this lens shading map by its row and column.\n     *\n     * <p>The rows must be within the range [0, {@link #getRowCount}),\n     * the column must be within the range [0, {@link #getColumnCount}).<\/p>\n     *\n     * @param column within the range [0, {@link #getColumnCount})\n     * @param row within the range [0, {@link #getRowCount})\n     *\n     * @return an {@link RggbChannelVector} where each gain factor >= {@value #MINIMUM_GAIN_FACTOR}\n     *\n     * @throws IllegalArgumentException if any of the parameters was out of range\n     *\n     * @see #getRowCount\n     * @see #getColumnCount\n     */\n    public RggbChannelVector getGainFactorVector(final int column, final int row) {\n        if (column < 0 || column >= mColumns) {\n            throw new IllegalArgumentException(\"column out of range\");\n        } else if (row < 0 || row >= mRows) {\n            throw new IllegalArgumentException(\"row out of range\");\n        }\n\n        final int offset = (row * mColumns +  column) * COUNT;\n\n        final float red =\n                mElements[RED + offset];\n        final float greenEven =\n                mElements[GREEN_EVEN + offset];\n        final float greenOdd =\n                mElements[GREEN_ODD + offset];\n        final float blue =\n                mElements[BLUE + offset];\n\n        return new RggbChannelVector(red, greenEven, greenOdd, blue);\n    }"}
{"Number":"248","API Relative Path":"src.android.hardware.camera2.params.OutputConfiguration.java-OutputConfiguration(OutputConfiguration)","Corresponding Source":"/**\n     * Create a new {@link OutputConfiguration} instance with another {@link OutputConfiguration}\n     * instance.\n     *\n     * @param other Another {@link OutputConfiguration} instance to be copied.\n     *\n     * @hide\n     */\n    public OutputConfiguration(@NonNull OutputConfiguration other) {\n        if (other == null) {\n            throw new IllegalArgumentException(\"OutputConfiguration shouldn't be null\");\n        }\n\n        this.mSurface = other.mSurface;\n        this.mRotation = other.mRotation;\n        this.mSurfaceGroupId = other.mSurfaceGroupId;\n        this.mConfiguredDataspace = other.mConfiguredDataspace;\n        this.mConfiguredFormat = other.mConfiguredFormat;\n        this.mConfiguredSize = other.mConfiguredSize;\n        this.mConfiguredGenerationId = other.mConfiguredGenerationId;\n    }"}
{"Number":"249","API Relative Path":"src.android.hardware.camera2.params.RggbChannelVector.java-copyTo(float[]-int)","Corresponding Source":"/**\n     * Copy the vector into the destination in the order {@code [R, Geven, Godd, B]}.\n     *\n     * @param destination\n     *          an array big enough to hold at least {@value #COUNT} elements after the\n     *          {@code offset}\n     * @param offset\n     *          a non-negative offset into the array\n     *\n     * @throws NullPointerException\n     *          If {@code destination} was {@code null}\n     * @throws ArrayIndexOutOfBoundsException\n     *          If there's not enough room to write the elements at the specified destination and\n     *          offset.\n     */\n    public void copyTo(final float[] destination, final int offset) {\n        checkNotNull(destination, \"destination must not be null\");\n        if (destination.length - offset < COUNT) {\n            throw new ArrayIndexOutOfBoundsException(\"destination too small to fit elements\");\n        }\n\n        destination[offset + RED] = mRed;\n        destination[offset + GREEN_EVEN] = mGreenEven;\n        destination[offset + GREEN_ODD] = mGreenOdd;\n        destination[offset + BLUE] = mBlue;\n    }"}
{"Number":"250","API Relative Path":"src.android.hardware.camera2.params.RggbChannelVector.java-getComponent(int)","Corresponding Source":"/**\n     * Get the component by the color channel index.\n     *\n     * <p>{@code colorChannel} must be one of {@link #RED}, {@link #GREEN_EVEN}, {@link #GREEN_ODD},\n     * {@link #BLUE}.<\/p>\n     *\n     * @param colorChannel greater or equal to {@code 0} and less than {@link #COUNT}\n     * @return a floating point value (guaranteed to be finite)\n     *\n     * @throws IllegalArgumentException if {@code colorChannel} was out of range\n     */\n    public float getComponent(final int colorChannel) {\n        if (colorChannel < 0 || colorChannel >= COUNT) {\n            throw new IllegalArgumentException(\"Color channel out of range\");\n        }\n\n        switch (colorChannel) {\n            case RED:\n                return mRed;\n            case GREEN_EVEN:\n                return mGreenEven;\n            case GREEN_ODD:\n                return mGreenOdd;\n            case BLUE:\n                return mBlue;\n            default:\n                throw new AssertionError(\"Unhandled case \" + colorChannel);\n        }\n    }"}
{"Number":"251","API Relative Path":"src.android.hardware.camera2.params.StreamConfigurationMap.java-imageFormatToInternal(int[])","Corresponding Source":"/**\n     * Convert image formats from public to internal formats (in-place).\n     *\n     * @param formats an array of image formats\n     * @return {@code formats}\n     *\n     * @see #imageFormatToInternal\n     *\n     * @hide\n     */\n    public static int[] imageFormatToInternal(int[] formats) {\n        if (formats == null) {\n            return null;\n        }\n\n        for (int i = 0; i < formats.length; ++i) {\n            formats[i] = imageFormatToInternal(formats[i]);\n        }\n\n        return formats;\n    }"}
{"Number":"252","API Relative Path":"src.android.hardware.camera2.params.StreamConfigurationMap.java-imageFormatToPublic(int[])","Corresponding Source":"/**\n     * Convert image formats from internal to public formats (in-place).\n     *\n     * @param formats an array of image formats\n     * @return {@code formats}\n     *\n     * @see #imageFormatToPublic\n     */\n    static int[] imageFormatToPublic(int[] formats) {\n        if (formats == null) {\n            return null;\n        }\n\n        for (int i = 0; i < formats.length; ++i) {\n            formats[i] = imageFormatToPublic(formats[i]);\n        }\n\n        return formats;\n    }"}
{"Number":"253","API Relative Path":"src.android.hardware.camera2.params.StreamConfigurationMap.java-StreamConfigurationMap(StreamConfiguration[]-StreamConfigurationDuration[]-StreamConfigurationDuration[]-StreamConfiguration[]-StreamConfigurationDuration[]-StreamConfigurationDuration[]-HighSpeedVideoConfiguration[]-ReprocessFormatsMap-boolean)","Corresponding Source":"/**\n     * Create a new {@link StreamConfigurationMap}.\n     *\n     * <p>The array parameters ownership is passed to this object after creation; do not\n     * write to them after this constructor is invoked.<\/p>\n     *\n     * @param configurations a non-{@code null} array of {@link StreamConfiguration}\n     * @param minFrameDurations a non-{@code null} array of {@link StreamConfigurationDuration}\n     * @param stallDurations a non-{@code null} array of {@link StreamConfigurationDuration}\n     * @param highSpeedVideoConfigurations an array of {@link HighSpeedVideoConfiguration}, null if\n     *        camera device does not support high speed video recording\n     * @param listHighResolution a flag indicating whether the device supports BURST_CAPTURE\n     *        and thus needs a separate list of slow high-resolution output sizes\n     * @throws NullPointerException if any of the arguments except highSpeedVideoConfigurations\n     *         were {@code null} or any subelements were {@code null}\n     *\n     * @hide\n     */\n    public StreamConfigurationMap(\n            StreamConfiguration[] configurations,\n            StreamConfigurationDuration[] minFrameDurations,\n            StreamConfigurationDuration[] stallDurations,\n            StreamConfiguration[] depthConfigurations,\n            StreamConfigurationDuration[] depthMinFrameDurations,\n            StreamConfigurationDuration[] depthStallDurations,\n            HighSpeedVideoConfiguration[] highSpeedVideoConfigurations,\n            ReprocessFormatsMap inputOutputFormatsMap,\n            boolean listHighResolution) {\n\n        if (configurations == null) {\n            // If no color configurations exist, ensure depth ones do\n            checkArrayElementsNotNull(depthConfigurations, \"depthConfigurations\");\n            mConfigurations = new StreamConfiguration[0];\n            mMinFrameDurations = new StreamConfigurationDuration[0];\n            mStallDurations = new StreamConfigurationDuration[0];\n        } else {\n            mConfigurations = checkArrayElementsNotNull(configurations, \"configurations\");\n            mMinFrameDurations = checkArrayElementsNotNull(minFrameDurations, \"minFrameDurations\");\n            mStallDurations = checkArrayElementsNotNull(stallDurations, \"stallDurations\");\n        }\n\n        mListHighResolution = listHighResolution;\n\n        if (depthConfigurations == null) {\n            mDepthConfigurations = new StreamConfiguration[0];\n            mDepthMinFrameDurations = new StreamConfigurationDuration[0];\n            mDepthStallDurations = new StreamConfigurationDuration[0];\n        } else {\n            mDepthConfigurations = checkArrayElementsNotNull(depthConfigurations,\n                    \"depthConfigurations\");\n            mDepthMinFrameDurations = checkArrayElementsNotNull(depthMinFrameDurations,\n                    \"depthMinFrameDurations\");\n            mDepthStallDurations = checkArrayElementsNotNull(depthStallDurations,\n                    \"depthStallDurations\");\n        }\n\n        if (highSpeedVideoConfigurations == null) {\n            mHighSpeedVideoConfigurations = new HighSpeedVideoConfiguration[0];\n        } else {\n            mHighSpeedVideoConfigurations = checkArrayElementsNotNull(\n                    highSpeedVideoConfigurations, \"highSpeedVideoConfigurations\");\n        }\n\n        // For each format, track how many sizes there are available to configure\n        for (StreamConfiguration config : mConfigurations) {\n            int fmt = config.getFormat();\n            SparseIntArray map = null;\n            if (config.isOutput()) {\n                mAllOutputFormats.put(fmt, mAllOutputFormats.get(fmt) + 1);\n                long duration = 0;\n                if (mListHighResolution) {\n                    for (StreamConfigurationDuration configurationDuration : mMinFrameDurations) {\n                        if (configurationDuration.getFormat() == fmt &&\n                                configurationDuration.getWidth() == config.getSize().getWidth() &&\n                                configurationDuration.getHeight() == config.getSize().getHeight()) {\n                            duration = configurationDuration.getDuration();\n                            break;\n                        }\n                    }\n                }\n                map = duration <= DURATION_20FPS_NS ?\n                        mOutputFormats : mHighResOutputFormats;\n            } else {\n                map = mInputFormats;\n            }\n            map.put(fmt, map.get(fmt) + 1);\n        }\n\n        // For each depth format, track how many sizes there are available to configure\n        for (StreamConfiguration config : mDepthConfigurations) {\n            if (!config.isOutput()) {\n                // Ignoring input depth configs\n                continue;\n            }\n\n            mDepthOutputFormats.put(config.getFormat(),\n                    mDepthOutputFormats.get(config.getFormat()) + 1);\n        }\n\n        if (configurations != null &&\n                mOutputFormats.indexOfKey(HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED) < 0) {\n            throw new AssertionError(\n                    \"At least one stream configuration for IMPLEMENTATION_DEFINED must exist\");\n        }\n\n        // For each Size/FPS range, track how many FPS range/Size there are available\n        for (HighSpeedVideoConfiguration config : mHighSpeedVideoConfigurations) {\n            Size size = config.getSize();\n            Range<Integer> fpsRange = config.getFpsRange();\n            Integer fpsRangeCount = mHighSpeedVideoSizeMap.get(size);\n            if (fpsRangeCount == null) {\n                fpsRangeCount = 0;\n            }\n            mHighSpeedVideoSizeMap.put(size, fpsRangeCount + 1);\n            Integer sizeCount = mHighSpeedVideoFpsRangeMap.get(fpsRange);\n            if (sizeCount == null) {\n                sizeCount = 0;\n            }\n            mHighSpeedVideoFpsRangeMap.put(fpsRange, sizeCount + 1);\n        }\n\n        mInputOutputFormatsMap = inputOutputFormatsMap;\n    }"}
{"Number":"254","API Relative Path":"src.android.hardware.camera2.params.TonemapCurve.java-getPoint(int-int)","Corresponding Source":"/**\n     * Get the point for a color channel at a specified index.\n     *\n     * <p>The index must be at least 0 but no greater than {@link #getPointCount(int)} for\n     * that {@code colorChannel}.<\/p>\n     *\n     * <p>All returned coordinates in the point are between the range of\n     * [{@value #LEVEL_BLACK}, {@value #LEVEL_WHITE}].<\/p>\n     *\n     * @param colorChannel {@link #CHANNEL_RED}, {@link #CHANNEL_GREEN}, or {@link #CHANNEL_BLUE}\n     * @param index at least 0 but no greater than {@code getPointCount(colorChannel)}\n     * @return the {@code (Pin, Pout)} pair mapping the tone for that index\n     *\n     * @throws IllegalArgumentException if {@code colorChannel} or {@code index} was out of range\n     *\n     * @see #LEVEL_BLACK\n     * @see #LEVEL_WHITE\n     */\n    public PointF getPoint(int colorChannel, int index) {\n        checkArgumentColorChannel(colorChannel);\n        if (index < 0 || index >= getPointCount(colorChannel)) {\n            throw new IllegalArgumentException(\"index out of range\");\n        }\n\n        final float[] curve = getCurve(colorChannel);\n\n        final float pIn = curve[index * POINT_SIZE + OFFSET_POINT_IN];\n        final float pOut = curve[index * POINT_SIZE + OFFSET_POINT_OUT];\n\n        return new PointF(pIn, pOut);\n    }"}
{"Number":"255","API Relative Path":"src.android.hardware.camera2.utils.ArrayUtils.java-convertStringListToIntArray(List-String[]-int[])","Corresponding Source":"/**\n     * Create an {@code int[]} from the {@code List<>} by using {@code convertFrom} and\n     * {@code convertTo} as a one-to-one map (via the index).\n     *\n     * <p>Strings not appearing in {@code convertFrom} are ignored (with a logged warning);\n     * strings appearing in {@code convertFrom} but not {@code convertTo} are silently\n     * dropped.<\/p>\n     *\n     * @param list Source list of strings\n     * @param convertFrom Conversion list of strings\n     * @param convertTo Conversion list of ints\n     * @return An array of ints where the values correspond to the ones in {@code convertTo}\n     *         or {@code null} if {@code list} was {@code null}\n     */\n    public static int[] convertStringListToIntArray(\n            List<String> list, String[] convertFrom, int[] convertTo) {\n        if (list == null) {\n            return null;\n        }\n\n        List<Integer> convertedList = convertStringListToIntList(list, convertFrom, convertTo);\n\n        int[] returnArray = new int[convertedList.size()];\n        for (int i = 0; i < returnArray.length; ++i) {\n            returnArray[i] = convertedList.get(i);\n        }\n\n        return returnArray;\n    }"}
{"Number":"256","API Relative Path":"src.android.hardware.camera2.utils.ArrayUtils.java-convertStringListToIntList(List-String[]-int[])","Corresponding Source":"/**\n     * Create an {@code List<Integer>} from the {@code List<>} by using {@code convertFrom} and\n     * {@code convertTo} as a one-to-one map (via the index).\n     *\n     * <p>Strings not appearing in {@code convertFrom} are ignored (with a logged warning);\n     * strings appearing in {@code convertFrom} but not {@code convertTo} are silently\n     * dropped.<\/p>\n     *\n     * @param list Source list of strings\n     * @param convertFrom Conversion list of strings\n     * @param convertTo Conversion list of ints\n     * @return A list of ints where the values correspond to the ones in {@code convertTo}\n     *         or {@code null} if {@code list} was {@code null}\n     */\n    public static List<Integer> convertStringListToIntList(\n            List<String> list, String[] convertFrom, int[] convertTo) {\n        if (list == null) {\n            return null;\n        }\n\n        List<Integer> convertedList = new ArrayList<>(list.size());\n\n        for (String str : list) {\n            int strIndex = getArrayIndex(convertFrom, str);\n\n            // Guard against unexpected values\n            if (strIndex < 0) {\n                if (DEBUG) Log.v(TAG, \"Ignoring invalid value \" + str);\n                continue;\n            }\n\n            // Ignore values we can't map into (intentional)\n            if (strIndex < convertTo.length) {\n                convertedList.add(convertTo[strIndex]);\n            }\n        }\n\n        return convertedList;\n    }"}
{"Number":"257","API Relative Path":"src.android.hardware.camera2.utils.ArrayUtils.java-toIntArray(List)","Corresponding Source":"/**\n     * Convert the list of integers in {@code list} to an {@code int} array.\n     *\n     * <p>Every element in {@code list} must be non-{@code null}.<\/p>\n     *\n     * @param list a list of non-{@code null} integers\n     *\n     * @return a new int array containing all the elements from {@code list}\n     *\n     * @throws NullPointerException if any of the elements in {@code list} were {@code null}\n     */\n    public static int[] toIntArray(List<Integer> list) {\n        if (list == null) {\n            return null;\n        }\n\n        int[] arr = new int[list.size()];\n        int i = 0;\n        for (int elem : list) {\n            arr[i] = elem;\n            i++;\n        }\n\n        return arr;\n    }"}
{"Number":"258","API Relative Path":"src.android.hardware.camera2.utils.ListUtils.java-listSelectFirstFrom(List-T[])","Corresponding Source":"/**\n     * Return the first item from {@code choices} that is contained in the {@code list}.\n     *\n     * <p>Choices with an index closer to 0 get higher priority. If none of the {@code choices}\n     * are in the {@code list}, then {@code null} is returned.\n     *\n     * @param list a list of objects which may or may not contain one or more of the choices\n     * @param choices an array of objects which should be used to select an item from\n     *\n     * @return the first item from {@code choices} contained in {@code list}, otherwise {@code null}\n     */\n    public static <T> T listSelectFirstFrom(List<T> list, T[] choices) {\n        if (list == null) {\n            return null;\n        }\n\n        for (T choice : choices) {\n            if (list.contains(choice)) {\n                return choice;\n            }\n        }\n\n        return null;\n    }"}
{"Number":"259","API Relative Path":"src.android.hardware.camera2.utils.ListUtils.java-listToString(List)","Corresponding Source":"/**\n     * Return a human-readable representation of a list (non-recursively).\n     */\n    public static <T> String listToString(List<T> list) {\n        if (list == null) {\n            return null;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        sb.append('[');\n\n        int size = list.size();\n        int i = 0;\n        for (T elem : list) {\n            sb.append(elem);\n\n            if (i != size - 1) {\n                sb.append(',');\n            }\n            i++;\n        }\n        sb.append(']');\n\n        return sb.toString();\n    }"}
{"Number":"260","API Relative Path":"src.android.hardware.camera2.utils.SurfaceUtils.java-checkConstrainedHighSpeedSurfaces(Collection-Range-StreamConfigurationMap)","Corresponding Source":"/**\n     * Verify that that the surfaces are valid for high-speed recording mode,\n     * and that the FPS range is supported\n     *\n     * @param surfaces the surfaces to verify as valid in terms of size and format\n     * @param fpsRange the target high-speed FPS range to validate\n     * @param config The stream configuration map for the device in question\n     */\n    public static void checkConstrainedHighSpeedSurfaces(Collection<Surface> surfaces,\n            Range<Integer> fpsRange, StreamConfigurationMap config) {\n        if (surfaces == null || surfaces.size() == 0 || surfaces.size() > 2) {\n            throw new IllegalArgumentException(\"Output target surface list must not be null and\"\n                    + \" the size must be 1 or 2\");\n        }\n\n        List<Size> highSpeedSizes = null;\n        if (fpsRange == null) {\n            highSpeedSizes = Arrays.asList(config.getHighSpeedVideoSizes());\n        } else {\n            // Check the FPS range first if provided\n            Range<Integer>[] highSpeedFpsRanges = config.getHighSpeedVideoFpsRanges();\n            if(!Arrays.asList(highSpeedFpsRanges).contains(fpsRange)) {\n                throw new IllegalArgumentException(\"Fps range \" + fpsRange.toString() + \" in the\"\n                        + \" request is not a supported high speed fps range \" +\n                        Arrays.toString(highSpeedFpsRanges));\n            }\n            highSpeedSizes = Arrays.asList(config.getHighSpeedVideoSizesFor(fpsRange));\n        }\n\n        for (Surface surface : surfaces) {\n            checkHighSpeedSurfaceFormat(surface);\n\n            // Surface size must be supported high speed sizes.\n            Size surfaceSize = SurfaceUtils.getSurfaceSize(surface);\n            if (!highSpeedSizes.contains(surfaceSize)) {\n                throw new IllegalArgumentException(\"Surface size \" + surfaceSize.toString() + \" is\"\n                        + \" not part of the high speed supported size list \" +\n                        Arrays.toString(highSpeedSizes.toArray()));\n            }\n            // Each output surface must be either preview surface or recording surface.\n            if (!SurfaceUtils.isSurfaceForPreview(surface) &&\n                    !SurfaceUtils.isSurfaceForHwVideoEncoder(surface)) {\n                throw new IllegalArgumentException(\"This output surface is neither preview nor \"\n                        + \"hardware video encoding surface\");\n            }\n            if (SurfaceUtils.isSurfaceForPreview(surface) &&\n                    SurfaceUtils.isSurfaceForHwVideoEncoder(surface)) {\n                throw new IllegalArgumentException(\"This output surface can not be both preview\"\n                        + \" and hardware video encoding surface\");\n            }\n        }\n\n        // For 2 output surface case, they shouldn't be same type.\n        if (surfaces.size() == 2) {\n            // Up to here, each surface can only be either preview or recording.\n            Iterator<Surface> iterator = surfaces.iterator();\n            boolean isFirstSurfacePreview =\n                    SurfaceUtils.isSurfaceForPreview(iterator.next());\n            boolean isSecondSurfacePreview =\n                    SurfaceUtils.isSurfaceForPreview(iterator.next());\n            if (isFirstSurfacePreview == isSecondSurfacePreview) {\n                throw new IllegalArgumentException(\"The 2 output surfaces must have different\"\n                        + \" type\");\n            }\n        }\n    }"}
{"Number":"261","API Relative Path":"src.android.hardware.fingerprint.FingerprintManager.java-authenticate(CryptoObject-CancellationSignal-int-AuthenticationCallback-Handler-int)","Corresponding Source":"/**\n     * Per-user version\n     * @hide\n     */\n    @RequiresPermission(USE_FINGERPRINT)\n    public void authenticate(@Nullable CryptoObject crypto, @Nullable CancellationSignal cancel,\n            int flags, @NonNull AuthenticationCallback callback, Handler handler, int userId) {\n        if (callback == null) {\n            throw new IllegalArgumentException(\"Must supply an authentication callback\");\n        }\n\n        if (cancel != null) {\n            if (cancel.isCanceled()) {\n                Log.w(TAG, \"authentication already canceled\");\n                return;\n            } else {\n                cancel.setOnCancelListener(new OnAuthenticationCancelListener(crypto));\n            }\n        }\n\n        if (mService != null) try {\n            useHandler(handler);\n            mAuthenticationCallback = callback;\n            mCryptoObject = crypto;\n            long sessionId = crypto != null ? crypto.getOpId() : 0;\n            mService.authenticate(mToken, sessionId, userId, mServiceReceiver, flags,\n                    mContext.getOpPackageName());\n        } catch (RemoteException e) {\n            Log.w(TAG, \"Remote exception while authenticating: \", e);\n            if (callback != null) {\n                // Though this may not be a hardware issue, it will cause apps to give up or try\n                // again later.\n                callback.onAuthenticationError(FINGERPRINT_ERROR_HW_UNAVAILABLE,\n                        getErrorString(FINGERPRINT_ERROR_HW_UNAVAILABLE));\n            }\n        }\n    }"}
{"Number":"262","API Relative Path":"src.android.hardware.fingerprint.FingerprintManager.java-enroll(byte[]-CancellationSignal-int-int-EnrollmentCallback)","Corresponding Source":"/**\n     * Request fingerprint enrollment. This call warms up the fingerprint hardware\n     * and starts scanning for fingerprints. Progress will be indicated by callbacks to the\n     * {@link EnrollmentCallback} object. It terminates when\n     * {@link EnrollmentCallback#onEnrollmentError(int, CharSequence)} or\n     * {@link EnrollmentCallback#onEnrollmentProgress(int) is called with remaining == 0, at\n     * which point the object is no longer valid. The operation can be canceled by using the\n     * provided cancel object.\n     * @param token a unique token provided by a recent creation or verification of device\n     * credentials (e.g. pin, pattern or password).\n     * @param cancel an object that can be used to cancel enrollment\n     * @param flags optional flags\n     * @param userId the user to whom this fingerprint will belong to\n     * @param callback an object to receive enrollment events\n     * @hide\n     */\n    @RequiresPermission(MANAGE_FINGERPRINT)\n    public void enroll(byte [] token, CancellationSignal cancel, int flags,\n            int userId, EnrollmentCallback callback) {\n        if (userId == UserHandle.USER_CURRENT) {\n            userId = getCurrentUserId();\n        }\n        if (callback == null) {\n            throw new IllegalArgumentException(\"Must supply an enrollment callback\");\n        }\n\n        if (cancel != null) {\n            if (cancel.isCanceled()) {\n                Log.w(TAG, \"enrollment already canceled\");\n                return;\n            } else {\n                cancel.setOnCancelListener(new OnEnrollCancelListener());\n            }\n        }\n\n        if (mService != null) try {\n            mEnrollmentCallback = callback;\n            mService.enroll(mToken, token, userId, mServiceReceiver, flags,\n                    mContext.getOpPackageName());\n        } catch (RemoteException e) {\n            Log.w(TAG, \"Remote exception in enroll: \", e);\n            if (callback != null) {\n                // Though this may not be a hardware issue, it will cause apps to give up or try\n                // again later.\n                callback.onEnrollmentError(FINGERPRINT_ERROR_HW_UNAVAILABLE,\n                        getErrorString(FINGERPRINT_ERROR_HW_UNAVAILABLE));\n            }\n        }\n    }"}
{"Number":"263","API Relative Path":"src.android.hardware.hdmi.HdmiClient.java-setVendorCommandListener(VendorCommandListener)","Corresponding Source":"/**\n     * Sets a listener used to receive incoming vendor-specific command.\n     *\n     * @param listener listener object\n     */\n    public void setVendorCommandListener(@NonNull VendorCommandListener listener) {\n        if (listener == null) {\n            throw new IllegalArgumentException(\"listener cannot be null\");\n        }\n        if (mIHdmiVendorCommandListener != null) {\n            throw new IllegalStateException(\"listener was already set\");\n        }\n        try {\n            IHdmiVendorCommandListener wrappedListener = getListenerWrapper(listener);\n            mService.addVendorCommandListener(wrappedListener, getDeviceType());\n            mIHdmiVendorCommandListener = wrappedListener;\n        } catch (RemoteException e) {\n            Log.e(TAG, \"failed to set vendor command listener: \", e);\n        }\n    }"}
{"Number":"264","API Relative Path":"src.android.hardware.hdmi.HdmiRecordSources.java-ofAnalogue(int-int-int)","Corresponding Source":"/**\n     * Creates {@link AnalogueServiceSource} of analogue service.\n     *\n     * @param broadcastType\n     * @param frequency\n     * @param broadcastSystem\n     * @hide\n     */\n    @Nullable\n    public static AnalogueServiceSource ofAnalogue(int broadcastType, int frequency,\n            int broadcastSystem){\n        if (broadcastType < ANALOGUE_BROADCAST_TYPE_CABLE\n                || broadcastType > ANALOGUE_BROADCAST_TYPE_TERRESTRIAL) {\n            Log.w(TAG, \"Invalid Broadcast type:\" + broadcastType);\n            throw new IllegalArgumentException(\"Invalid Broadcast type:\" + broadcastType);\n        }\n        if (frequency < 0 || frequency > 0xFFFF) {\n            Log.w(TAG, \"Invalid frequency value[0x0000-0xFFFF]:\" + frequency);\n            throw new IllegalArgumentException(\n                    \"Invalid frequency value[0x0000-0xFFFF]:\" + frequency);\n        }\n        if (broadcastSystem < BROADCAST_SYSTEM_PAL_BG\n                || broadcastSystem > BROADCAST_SYSTEM_PAL_OTHER_SYSTEM) {\n\n            Log.w(TAG, \"Invalid Broadcast system:\" + broadcastSystem);\n            throw new IllegalArgumentException(\n                    \"Invalid Broadcast system:\" + broadcastSystem);\n        }\n\n        return new AnalogueServiceSource(broadcastType, frequency, broadcastSystem);\n    }"}
{"Number":"265","API Relative Path":"src.android.hardware.hdmi.HdmiRecordSources.java-ofAnalogue(int-int-int)","Corresponding Source":"/**\n     * Creates {@link AnalogueServiceSource} of analogue service.\n     *\n     * @param broadcastType\n     * @param frequency\n     * @param broadcastSystem\n     * @hide\n     */\n    @Nullable\n    public static AnalogueServiceSource ofAnalogue(int broadcastType, int frequency,\n            int broadcastSystem){\n        if (broadcastType < ANALOGUE_BROADCAST_TYPE_CABLE\n                || broadcastType > ANALOGUE_BROADCAST_TYPE_TERRESTRIAL) {\n            Log.w(TAG, \"Invalid Broadcast type:\" + broadcastType);\n            throw new IllegalArgumentException(\"Invalid Broadcast type:\" + broadcastType);\n        }\n        if (frequency < 0 || frequency > 0xFFFF) {\n            Log.w(TAG, \"Invalid frequency value[0x0000-0xFFFF]:\" + frequency);\n            throw new IllegalArgumentException(\n                    \"Invalid frequency value[0x0000-0xFFFF]:\" + frequency);\n        }\n        if (broadcastSystem < BROADCAST_SYSTEM_PAL_BG\n                || broadcastSystem > BROADCAST_SYSTEM_PAL_OTHER_SYSTEM) {\n\n            Log.w(TAG, \"Invalid Broadcast system:\" + broadcastSystem);\n            throw new IllegalArgumentException(\n                    \"Invalid Broadcast system:\" + broadcastSystem);\n        }\n\n        return new AnalogueServiceSource(broadcastType, frequency, broadcastSystem);\n    }"}
{"Number":"266","API Relative Path":"src.android.hardware.hdmi.HdmiRecordSources.java-ofAnalogue(int-int-int)","Corresponding Source":"/**\n     * Creates {@link AnalogueServiceSource} of analogue service.\n     *\n     * @param broadcastType\n     * @param frequency\n     * @param broadcastSystem\n     * @hide\n     */\n    @Nullable\n    public static AnalogueServiceSource ofAnalogue(int broadcastType, int frequency,\n            int broadcastSystem){\n        if (broadcastType < ANALOGUE_BROADCAST_TYPE_CABLE\n                || broadcastType > ANALOGUE_BROADCAST_TYPE_TERRESTRIAL) {\n            Log.w(TAG, \"Invalid Broadcast type:\" + broadcastType);\n            throw new IllegalArgumentException(\"Invalid Broadcast type:\" + broadcastType);\n        }\n        if (frequency < 0 || frequency > 0xFFFF) {\n            Log.w(TAG, \"Invalid frequency value[0x0000-0xFFFF]:\" + frequency);\n            throw new IllegalArgumentException(\n                    \"Invalid frequency value[0x0000-0xFFFF]:\" + frequency);\n        }\n        if (broadcastSystem < BROADCAST_SYSTEM_PAL_BG\n                || broadcastSystem > BROADCAST_SYSTEM_PAL_OTHER_SYSTEM) {\n\n            Log.w(TAG, \"Invalid Broadcast system:\" + broadcastSystem);\n            throw new IllegalArgumentException(\n                    \"Invalid Broadcast system:\" + broadcastSystem);\n        }\n\n        return new AnalogueServiceSource(broadcastType, frequency, broadcastSystem);\n    }"}
{"Number":"267","API Relative Path":"src.android.hardware.hdmi.HdmiRecordSources.java-ofArib(int-AribData)","Corresponding Source":"/**\n     * Creates {@link DigitalServiceSource} of ARIB type.\n     *\n     * @param aribType ARIB type. It should be one of\n     *            <ul>\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_ARIB}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_ARIB_BS}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_ARIB_CS}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_ARIB_T}\n     *            <\/ul>\n     * @hide\n     */\n    @Nullable\n    public static DigitalServiceSource ofArib(int aribType, AribData data) {\n        if (data == null) {\n            throw new IllegalArgumentException(\"data should not be null.\");\n        }\n        switch (aribType) {\n            case DIGITAL_BROADCAST_TYPE_ARIB:\n            case DIGITAL_BROADCAST_TYPE_ARIB_BS:\n            case DIGITAL_BROADCAST_TYPE_ARIB_CS:\n            case DIGITAL_BROADCAST_TYPE_ARIB_T:\n                return new DigitalServiceSource(\n                        DigitalServiceSource.DIGITAL_SERVICE_IDENTIFIED_BY_DIGITAL_ID,\n                        aribType, data);\n            default:\n                Log.w(TAG, \"Invalid ARIB type:\" + aribType);\n                throw new IllegalArgumentException(\"type should not be null.\");\n        }\n    }"}
{"Number":"268","API Relative Path":"src.android.hardware.hdmi.HdmiRecordSources.java-ofAtsc(int-AtscData)","Corresponding Source":"/**\n     * Creates {@link DigitalServiceSource} of ATSC type.\n     *\n     * @param atscType ATSC type. It should be one of\n     *            <ul>\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_ATSC}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_ATSC_CABLE}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_ATSC_SATELLITE}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_ATSC_TERRESTRIAL}\n     *            <\/ul>\n     * @hide\n     */\n    @Nullable\n    public static DigitalServiceSource ofAtsc(int atscType, AtscData data) {\n        if (data == null) {\n            throw new IllegalArgumentException(\"data should not be null.\");\n        }\n        switch (atscType) {\n            case DIGITAL_BROADCAST_TYPE_ATSC:\n            case DIGITAL_BROADCAST_TYPE_ATSC_CABLE:\n            case DIGITAL_BROADCAST_TYPE_ATSC_SATELLITE:\n            case DIGITAL_BROADCAST_TYPE_ATSC_TERRESTRIAL:\n                return new DigitalServiceSource(\n                        DigitalServiceSource.DIGITAL_SERVICE_IDENTIFIED_BY_DIGITAL_ID,\n                        atscType, data);\n            default:\n                Log.w(TAG, \"Invalid ATSC type:\" + atscType);\n                throw new IllegalArgumentException(\"Invalid ATSC type:\" + atscType);\n        }\n    }"}
{"Number":"269","API Relative Path":"src.android.hardware.hdmi.HdmiRecordSources.java-ofDigitalChannelId(int-DigitalChannelData)","Corresponding Source":"/**\n     * Creates {@link DigitalServiceSource} with channel type.\n     *\n     * @param broadcastSystem digital broadcast system. It should be one of\n     *            <ul>\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_ARIB}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_ATSC}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_DVB}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_ARIB_BS}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_ARIB_CS}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_ARIB_T}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_ATSC_CABLE}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_ATSC_SATELLITE}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_ATSC_TERRESTRIAL}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_DVB_C}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_DVB_S}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_DVB_S2}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_DVB_T}\n     *            <\/ul>\n     * @hide\n     */\n    public static DigitalServiceSource ofDigitalChannelId(int broadcastSystem,\n            DigitalChannelData data) {\n        if (data == null) {\n            throw new IllegalArgumentException(\"data should not be null.\");\n        }\n        switch (broadcastSystem) {\n            case DIGITAL_BROADCAST_TYPE_ARIB:\n            case DIGITAL_BROADCAST_TYPE_ATSC:\n            case DIGITAL_BROADCAST_TYPE_DVB:\n            case DIGITAL_BROADCAST_TYPE_ARIB_BS:\n            case DIGITAL_BROADCAST_TYPE_ARIB_CS:\n            case DIGITAL_BROADCAST_TYPE_ARIB_T:\n            case DIGITAL_BROADCAST_TYPE_ATSC_CABLE:\n            case DIGITAL_BROADCAST_TYPE_ATSC_SATELLITE:\n            case DIGITAL_BROADCAST_TYPE_ATSC_TERRESTRIAL:\n            case DIGITAL_BROADCAST_TYPE_DVB_C:\n            case DIGITAL_BROADCAST_TYPE_DVB_S:\n            case DIGITAL_BROADCAST_TYPE_DVB_S2:\n            case DIGITAL_BROADCAST_TYPE_DVB_T:\n                return new DigitalServiceSource(\n                        DigitalServiceSource.DIGITAL_SERVICE_IDENTIFIED_BY_CHANNEL,\n                        broadcastSystem,\n                        data);\n            default:\n                Log.w(TAG, \"Invalid broadcast type:\" + broadcastSystem);\n                throw new IllegalArgumentException(\n                        \"Invalid broadcast system value:\" + broadcastSystem);\n        }\n    }"}
{"Number":"270","API Relative Path":"src.android.hardware.hdmi.HdmiRecordSources.java-ofDvb(int-DvbData)","Corresponding Source":"/**\n     * Creates {@link DigitalServiceSource} of ATSC type.\n     *\n     * @param dvbType DVB type. It should be one of\n     *            <ul>\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_DVB}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_DVB_C}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_DVB_S}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_DVB_S2}\n     *            <li>{@link #DIGITAL_BROADCAST_TYPE_DVB_T}\n     *            <\/ul>\n     * @hide\n     */\n    @Nullable\n    public static DigitalServiceSource ofDvb(int dvbType, DvbData data) {\n        if (data == null) {\n            throw new IllegalArgumentException(\"data should not be null.\");\n        }\n        switch (dvbType) {\n            case DIGITAL_BROADCAST_TYPE_DVB:\n            case DIGITAL_BROADCAST_TYPE_DVB_C:\n            case DIGITAL_BROADCAST_TYPE_DVB_S:\n            case DIGITAL_BROADCAST_TYPE_DVB_S2:\n            case DIGITAL_BROADCAST_TYPE_DVB_T:\n                return new DigitalServiceSource(\n                        DigitalServiceSource.DIGITAL_SERVICE_IDENTIFIED_BY_DIGITAL_ID,\n                        dvbType, data);\n            default:\n                Log.w(TAG, \"Invalid DVB type:\" + dvbType);\n                throw new IllegalArgumentException(\"Invalid DVB type:\" + dvbType);\n        }\n    }"}
{"Number":"271","API Relative Path":"src.android.hardware.hdmi.HdmiRecordSources.java-ofExternalPhysicalAddress(int)","Corresponding Source":"// ---------------------------------------------------------------------------------------------\n    // ---- External physical address --------------------------------------------------------------\n    // ---------------------------------------------------------------------------------------------\n    /**\n     * Creates {@link ExternalPhysicalAddress} of external physical address.\n     *\n     * @param physicalAddress\n     * @hide\n     */\n    public static ExternalPhysicalAddress ofExternalPhysicalAddress(int physicalAddress) {\n        if ((physicalAddress & ~0xFFFF) != 0) {\n            Log.w(TAG, \"Invalid physical address:\" + physicalAddress);\n            throw new IllegalArgumentException(\"Invalid physical address:\" + physicalAddress);\n        }\n\n        return new ExternalPhysicalAddress(physicalAddress);\n    }"}
{"Number":"272","API Relative Path":"src.android.hardware.hdmi.HdmiRecordSources.java-ofExternalPlug(int)","Corresponding Source":"// ---------------------------------------------------------------------------------------------\n    // ---- External plug data ---------------------------------------------------------------------\n    // ---------------------------------------------------------------------------------------------\n    /**\n     * Creates {@link ExternalPlugData} of external plug type.\n     *\n     * @param plugNumber plug number. It should be in range of [1, 255]\n     * @hide\n     */\n    public static ExternalPlugData ofExternalPlug(int plugNumber) {\n        if (plugNumber < 1 || plugNumber > 255) {\n            Log.w(TAG, \"Invalid plug number[1-255]\" + plugNumber);\n            throw new IllegalArgumentException(\"Invalid plug number[1-255]\" + plugNumber);\n        }\n        return new ExternalPlugData(plugNumber);\n    }"}
{"Number":"273","API Relative Path":"src.android.hardware.hdmi.HdmiTimerRecordSources.java-timerInfoOf(int-int-Time-Duration-int)","Corresponding Source":"/**\n     * Creates {@link TimerInfo} with the given information.\n     *\n     * @param dayOfMonth day of month\n     * @param monthOfYear month of year\n     * @param startTime start time in {@link Time}\n     * @param duration duration in {@link Duration}\n     * @param recordingSequence recording sequence. Use RECORDING_SEQUENCE_REPEAT_ONCE_ONLY for no\n     *            repeat. Otherwise use combination of {@link #RECORDING_SEQUENCE_REPEAT_SUNDAY},\n     *            {@link #RECORDING_SEQUENCE_REPEAT_MONDAY},\n     *            {@link #RECORDING_SEQUENCE_REPEAT_TUESDAY},\n     *            {@link #RECORDING_SEQUENCE_REPEAT_WEDNESDAY},\n     *            {@link #RECORDING_SEQUENCE_REPEAT_THURSDAY},\n     *            {@link #RECORDING_SEQUENCE_REPEAT_FRIDAY},\n     *            {@link #RECORDING_SEQUENCE_REPEAT_SATUREDAY}.\n     * @return {@link TimerInfo}.\n     * @throws IllegalArgumentException if input value is invalid\n     */\n    public static TimerInfo timerInfoOf(int dayOfMonth, int monthOfYear, Time startTime,\n            Duration duration, int recordingSequence) {\n        if (dayOfMonth < 0 || dayOfMonth > 31) {\n            throw new IllegalArgumentException(\n                    \"Day of month should be in range of [0, 31]:\" + dayOfMonth);\n        }\n        if (monthOfYear < 1 || monthOfYear > 12) {\n            throw new IllegalArgumentException(\n                    \"Month of year should be in range of [1, 12]:\" + monthOfYear);\n        }\n        checkTimeValue(startTime.mHour, startTime.mMinute);\n        checkDurationValue(duration.mHour, duration.mMinute);\n        // Recording sequence should use least 7 bits or no bits.\n        if ((recordingSequence != 0)\n                && ((recordingSequence & ~RECORDING_SEQUENCE_REPEAT_MASK) != 0)) {\n            throw new IllegalArgumentException(\n                    \"Invalid reecording sequence value:\" + recordingSequence);\n        }\n\n        return new TimerInfo(dayOfMonth, monthOfYear, startTime, duration, recordingSequence);\n    }"}
{"Number":"274","API Relative Path":"src.android.hardware.hdmi.HdmiTimerRecordSources.java-timerInfoOf(int-int-Time-Duration-int)","Corresponding Source":"/**\n     * Creates {@link TimerInfo} with the given information.\n     *\n     * @param dayOfMonth day of month\n     * @param monthOfYear month of year\n     * @param startTime start time in {@link Time}\n     * @param duration duration in {@link Duration}\n     * @param recordingSequence recording sequence. Use RECORDING_SEQUENCE_REPEAT_ONCE_ONLY for no\n     *            repeat. Otherwise use combination of {@link #RECORDING_SEQUENCE_REPEAT_SUNDAY},\n     *            {@link #RECORDING_SEQUENCE_REPEAT_MONDAY},\n     *            {@link #RECORDING_SEQUENCE_REPEAT_TUESDAY},\n     *            {@link #RECORDING_SEQUENCE_REPEAT_WEDNESDAY},\n     *            {@link #RECORDING_SEQUENCE_REPEAT_THURSDAY},\n     *            {@link #RECORDING_SEQUENCE_REPEAT_FRIDAY},\n     *            {@link #RECORDING_SEQUENCE_REPEAT_SATUREDAY}.\n     * @return {@link TimerInfo}.\n     * @throws IllegalArgumentException if input value is invalid\n     */\n    public static TimerInfo timerInfoOf(int dayOfMonth, int monthOfYear, Time startTime,\n            Duration duration, int recordingSequence) {\n        if (dayOfMonth < 0 || dayOfMonth > 31) {\n            throw new IllegalArgumentException(\n                    \"Day of month should be in range of [0, 31]:\" + dayOfMonth);\n        }\n        if (monthOfYear < 1 || monthOfYear > 12) {\n            throw new IllegalArgumentException(\n                    \"Month of year should be in range of [1, 12]:\" + monthOfYear);\n        }\n        checkTimeValue(startTime.mHour, startTime.mMinute);\n        checkDurationValue(duration.mHour, duration.mMinute);\n        // Recording sequence should use least 7 bits or no bits.\n        if ((recordingSequence != 0)\n                && ((recordingSequence & ~RECORDING_SEQUENCE_REPEAT_MASK) != 0)) {\n            throw new IllegalArgumentException(\n                    \"Invalid reecording sequence value:\" + recordingSequence);\n        }\n\n        return new TimerInfo(dayOfMonth, monthOfYear, startTime, duration, recordingSequence);\n    }"}
{"Number":"275","API Relative Path":"src.android.hardware.hdmi.HdmiTimerRecordSources.java-timerInfoOf(int-int-Time-Duration-int)","Corresponding Source":"/**\n     * Creates {@link TimerInfo} with the given information.\n     *\n     * @param dayOfMonth day of month\n     * @param monthOfYear month of year\n     * @param startTime start time in {@link Time}\n     * @param duration duration in {@link Duration}\n     * @param recordingSequence recording sequence. Use RECORDING_SEQUENCE_REPEAT_ONCE_ONLY for no\n     *            repeat. Otherwise use combination of {@link #RECORDING_SEQUENCE_REPEAT_SUNDAY},\n     *            {@link #RECORDING_SEQUENCE_REPEAT_MONDAY},\n     *            {@link #RECORDING_SEQUENCE_REPEAT_TUESDAY},\n     *            {@link #RECORDING_SEQUENCE_REPEAT_WEDNESDAY},\n     *            {@link #RECORDING_SEQUENCE_REPEAT_THURSDAY},\n     *            {@link #RECORDING_SEQUENCE_REPEAT_FRIDAY},\n     *            {@link #RECORDING_SEQUENCE_REPEAT_SATUREDAY}.\n     * @return {@link TimerInfo}.\n     * @throws IllegalArgumentException if input value is invalid\n     */\n    public static TimerInfo timerInfoOf(int dayOfMonth, int monthOfYear, Time startTime,\n            Duration duration, int recordingSequence) {\n        if (dayOfMonth < 0 || dayOfMonth > 31) {\n            throw new IllegalArgumentException(\n                    \"Day of month should be in range of [0, 31]:\" + dayOfMonth);\n        }\n        if (monthOfYear < 1 || monthOfYear > 12) {\n            throw new IllegalArgumentException(\n                    \"Month of year should be in range of [1, 12]:\" + monthOfYear);\n        }\n        checkTimeValue(startTime.mHour, startTime.mMinute);\n        checkDurationValue(duration.mHour, duration.mMinute);\n        // Recording sequence should use least 7 bits or no bits.\n        if ((recordingSequence != 0)\n                && ((recordingSequence & ~RECORDING_SEQUENCE_REPEAT_MASK) != 0)) {\n            throw new IllegalArgumentException(\n                    \"Invalid reecording sequence value:\" + recordingSequence);\n        }\n\n        return new TimerInfo(dayOfMonth, monthOfYear, startTime, duration, recordingSequence);\n    }"}
{"Number":"276","API Relative Path":"src.android.hardware.hdmi.HdmiTvClient.java-clearTimerRecording(int-int-TimerRecordSource)","Corresponding Source":"/**\n     * Clears timer recording with the given recorder address and recording source.\n     * For more details, please refer {@link #startTimerRecording(int, int, TimerRecordSource)}.\n     */\n    public void clearTimerRecording(int recorderAddress, int sourceType, TimerRecordSource source) {\n        if (source == null) {\n            throw new IllegalArgumentException(\"source must not be null.\");\n        }\n\n        checkTimerRecordingSourceType(sourceType);\n        try {\n            byte[] data = new byte[source.getDataSize()];\n            source.toByteArray(data, 0);\n            mService.clearTimerRecording(recorderAddress, sourceType, data);\n        } catch (RemoteException e) {\n            Log.e(TAG, \"failed to start record: \", e);\n        }\n    }"}
{"Number":"277","API Relative Path":"src.android.hardware.hdmi.HdmiTvClient.java-deviceSelect(int-SelectCallback)","Corresponding Source":"/**\n     * Selects a CEC logical device to be a new active source.\n     *\n     * @param logicalAddress logical address of the device to select\n     * @param callback callback to get the result with\n     * @throws {@link IllegalArgumentException} if the {@code callback} is null\n     */\n    public void deviceSelect(int logicalAddress, @NonNull SelectCallback callback) {\n        if (callback == null) {\n            throw new IllegalArgumentException(\"callback must not be null.\");\n        }\n        try {\n            mService.deviceSelect(logicalAddress, getCallbackWrapper(callback));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"failed to select device: \", e);\n        }\n    }"}
{"Number":"278","API Relative Path":"src.android.hardware.hdmi.HdmiTvClient.java-portSelect(int-SelectCallback)","Corresponding Source":"/**\n     * Selects a HDMI port to be a new route path.\n     *\n     * @param portId HDMI port to select\n     * @param callback callback to get the result with\n     * @throws {@link IllegalArgumentException} if the {@code callback} is null\n     */\n    public void portSelect(int portId, @NonNull SelectCallback callback) {\n        if (callback == null) {\n            throw new IllegalArgumentException(\"Callback must not be null\");\n        }\n        try {\n            mService.portSelect(portId, getCallbackWrapper(callback));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"failed to select port: \", e);\n        }\n    }"}
{"Number":"279","API Relative Path":"src.android.hardware.hdmi.HdmiTvClient.java-sendMhlVendorCommand(int-int-int-byte[])","Corresponding Source":"/**\n     * Sends MHL vendor command to the device connected to a port of the given portId.\n     *\n     * @param portId id of port to send MHL vendor command\n     * @param offset offset in the in given data\n     * @param length length of data. offset + length should be bound to length of data.\n     * @param data container for vendor command data. It should be 16 bytes.\n     * @throws IllegalArgumentException if the given parameters are invalid\n     */\n    public void sendMhlVendorCommand(int portId, int offset, int length, byte[] data) {\n        if (data == null || data.length != VENDOR_DATA_SIZE) {\n            throw new IllegalArgumentException(\"Invalid vendor command data.\");\n        }\n        if (offset < 0 || offset >= VENDOR_DATA_SIZE) {\n            throw new IllegalArgumentException(\"Invalid offset:\" + offset);\n        }\n        if (length < 0 || offset + length > VENDOR_DATA_SIZE) {\n            throw new IllegalArgumentException(\"Invalid length:\" + length);\n        }\n\n        try {\n            mService.sendMhlVendorCommand(portId, offset, length, data);\n        } catch (RemoteException e) {\n            Log.e(TAG, \"failed to send vendor command: \", e);\n        }\n    }"}
{"Number":"280","API Relative Path":"src.android.hardware.hdmi.HdmiTvClient.java-sendMhlVendorCommand(int-int-int-byte[])","Corresponding Source":"/**\n     * Sends MHL vendor command to the device connected to a port of the given portId.\n     *\n     * @param portId id of port to send MHL vendor command\n     * @param offset offset in the in given data\n     * @param length length of data. offset + length should be bound to length of data.\n     * @param data container for vendor command data. It should be 16 bytes.\n     * @throws IllegalArgumentException if the given parameters are invalid\n     */\n    public void sendMhlVendorCommand(int portId, int offset, int length, byte[] data) {\n        if (data == null || data.length != VENDOR_DATA_SIZE) {\n            throw new IllegalArgumentException(\"Invalid vendor command data.\");\n        }\n        if (offset < 0 || offset >= VENDOR_DATA_SIZE) {\n            throw new IllegalArgumentException(\"Invalid offset:\" + offset);\n        }\n        if (length < 0 || offset + length > VENDOR_DATA_SIZE) {\n            throw new IllegalArgumentException(\"Invalid length:\" + length);\n        }\n\n        try {\n            mService.sendMhlVendorCommand(portId, offset, length, data);\n        } catch (RemoteException e) {\n            Log.e(TAG, \"failed to send vendor command: \", e);\n        }\n    }"}
{"Number":"281","API Relative Path":"src.android.hardware.hdmi.HdmiTvClient.java-sendMhlVendorCommand(int-int-int-byte[])","Corresponding Source":"/**\n     * Sends MHL vendor command to the device connected to a port of the given portId.\n     *\n     * @param portId id of port to send MHL vendor command\n     * @param offset offset in the in given data\n     * @param length length of data. offset + length should be bound to length of data.\n     * @param data container for vendor command data. It should be 16 bytes.\n     * @throws IllegalArgumentException if the given parameters are invalid\n     */\n    public void sendMhlVendorCommand(int portId, int offset, int length, byte[] data) {\n        if (data == null || data.length != VENDOR_DATA_SIZE) {\n            throw new IllegalArgumentException(\"Invalid vendor command data.\");\n        }\n        if (offset < 0 || offset >= VENDOR_DATA_SIZE) {\n            throw new IllegalArgumentException(\"Invalid offset:\" + offset);\n        }\n        if (length < 0 || offset + length > VENDOR_DATA_SIZE) {\n            throw new IllegalArgumentException(\"Invalid length:\" + length);\n        }\n\n        try {\n            mService.sendMhlVendorCommand(portId, offset, length, data);\n        } catch (RemoteException e) {\n            Log.e(TAG, \"failed to send vendor command: \", e);\n        }\n    }"}
{"Number":"282","API Relative Path":"src.android.hardware.hdmi.HdmiTvClient.java-setHdmiMhlVendorCommandListener(HdmiMhlVendorCommandListener)","Corresponding Source":"/**\n     * Sets {@link HdmiMhlVendorCommandListener} to get incoming MHL vendor command.\n     *\n     * @param listener to receive incoming MHL vendor command\n     */\n    public void setHdmiMhlVendorCommandListener(HdmiMhlVendorCommandListener listener) {\n        if (listener == null) {\n            throw new IllegalArgumentException(\"listener must not be null.\");\n        }\n        try {\n            mService.addHdmiMhlVendorCommandListener(getListenerWrapper(listener));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"failed to set hdmi mhl vendor command listener: \", e);\n        }\n    }"}
{"Number":"283","API Relative Path":"src.android.hardware.hdmi.HdmiTvClient.java-setInputChangeListener(InputChangeListener)","Corresponding Source":"/**\n     * Sets the listener used to get informed of the input change event.\n     *\n     * @param listener listener object\n     */\n    public void setInputChangeListener(InputChangeListener listener) {\n        if (listener == null) {\n            throw new IllegalArgumentException(\"listener must not be null.\");\n        }\n        try {\n            mService.setInputChangeListener(getListenerWrapper(listener));\n        } catch (RemoteException e) {\n            Log.e(\"TAG\", \"Failed to set InputChangeListener:\", e);\n        }\n    }"}
{"Number":"284","API Relative Path":"src.android.hardware.hdmi.HdmiTvClient.java-setRecordListener(HdmiRecordListener)","Corresponding Source":"/**\n     * Sets record listener.\n     *\n     * @param listener\n     */\n    public void setRecordListener(@NonNull HdmiRecordListener listener) {\n        if (listener == null) {\n            throw new IllegalArgumentException(\"listener must not be null.\");\n        }\n        try {\n            mService.setHdmiRecordListener(getListenerWrapper(listener));\n        } catch (RemoteException e) {\n            Log.e(TAG, \"failed to set record listener.\", e);\n        }\n    }"}
{"Number":"285","API Relative Path":"src.android.hardware.hdmi.HdmiTvClient.java-startOneTouchRecord(int-RecordSource)","Corresponding Source":"/**\n     * Starts one touch recording with the given recorder address and recorder source.\n     * <p>\n     * Usage\n     * <pre>\n     * HdmiTvClient tvClient = ....;\n     * // for own source.\n     * OwnSource ownSource = HdmiRecordSources.ofOwnSource();\n     * tvClient.startOneTouchRecord(recorderAddress, ownSource);\n     * <\/pre>\n     */\n    public void startOneTouchRecord(int recorderAddress, @NonNull RecordSource source) {\n        if (source == null) {\n            throw new IllegalArgumentException(\"source must not be null.\");\n        }\n\n        try {\n            byte[] data = new byte[source.getDataSize(true)];\n            source.toByteArray(true, data, 0);\n            mService.startOneTouchRecord(recorderAddress, data);\n        } catch (RemoteException e) {\n            Log.e(TAG, \"failed to start record: \", e);\n        }\n    }"}
{"Number":"286","API Relative Path":"src.android.hardware.hdmi.HdmiTvClient.java-startTimerRecording(int-int-TimerRecordSource)","Corresponding Source":"/**\n     * Starts timer recording with the given recoder address and recorder source.\n     * <p>\n     * Usage\n     * <pre>\n     * HdmiTvClient tvClient = ....;\n     * // create timer info\n     * TimerInfo timerInfo = HdmiTimerRecourdSources.timerInfoOf(...);\n     * // for digital source.\n     * DigitalServiceSource recordSource = HdmiRecordSources.ofDigitalService(...);\n     * // create timer recording source.\n     * TimerRecordSource source = HdmiTimerRecourdSources.ofDigitalSource(timerInfo, recordSource);\n     * tvClient.startTimerRecording(recorderAddress, source);\n     * <\/pre>\n     *\n     * @param recorderAddress target recorder address\n     * @param sourceType type of record source. It should be one of\n     *          {@link HdmiControlManager#TIMER_RECORDING_TYPE_DIGITAL},\n     *          {@link HdmiControlManager#TIMER_RECORDING_TYPE_ANALOGUE},\n     *          {@link HdmiControlManager#TIMER_RECORDING_TYPE_EXTERNAL}.\n     * @param source record source to be used\n     */\n    public void startTimerRecording(int recorderAddress, int sourceType, TimerRecordSource source) {\n        if (source == null) {\n            throw new IllegalArgumentException(\"source must not be null.\");\n        }\n\n        checkTimerRecordingSourceType(sourceType);\n\n        try {\n            byte[] data = new byte[source.getDataSize()];\n            source.toByteArray(data, 0);\n            mService.startTimerRecording(recorderAddress, sourceType, data);\n        } catch (RemoteException e) {\n            Log.e(TAG, \"failed to start record: \", e);\n        }\n    }"}
{"Number":"287","API Relative Path":"src.android.hardware.input.InputManager.java-addKeyboardLayoutForInputDevice(InputDeviceIdentifier-String)","Corresponding Source":"/**\n     * Adds the keyboard layout descriptor for the specified input device.\n     * <p>\n     * This method may have the side-effect of causing the input device in\n     * question to be reconfigured.\n     * <\/p>\n     *\n     * @param identifier The identifier for the input device.\n     * @param keyboardLayoutDescriptor The descriptor of the keyboard layout to\n     *            add.\n     * @hide\n     */\n    public void addKeyboardLayoutForInputDevice(InputDeviceIdentifier identifier,\n            String keyboardLayoutDescriptor) {\n        if (identifier == null) {\n            throw new IllegalArgumentException(\"inputDeviceDescriptor must not be null\");\n        }\n        if (keyboardLayoutDescriptor == null) {\n            throw new IllegalArgumentException(\"keyboardLayoutDescriptor must not be null\");\n        }\n\n        try {\n            mIm.addKeyboardLayoutForInputDevice(identifier, keyboardLayoutDescriptor);\n        } catch (RemoteException ex) {\n            throw ex.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"288","API Relative Path":"src.android.hardware.input.InputManager.java-addKeyboardLayoutForInputDevice(InputDeviceIdentifier-String)","Corresponding Source":"/**\n     * Adds the keyboard layout descriptor for the specified input device.\n     * <p>\n     * This method may have the side-effect of causing the input device in\n     * question to be reconfigured.\n     * <\/p>\n     *\n     * @param identifier The identifier for the input device.\n     * @param keyboardLayoutDescriptor The descriptor of the keyboard layout to\n     *            add.\n     * @hide\n     */\n    public void addKeyboardLayoutForInputDevice(InputDeviceIdentifier identifier,\n            String keyboardLayoutDescriptor) {\n        if (identifier == null) {\n            throw new IllegalArgumentException(\"inputDeviceDescriptor must not be null\");\n        }\n        if (keyboardLayoutDescriptor == null) {\n            throw new IllegalArgumentException(\"keyboardLayoutDescriptor must not be null\");\n        }\n\n        try {\n            mIm.addKeyboardLayoutForInputDevice(identifier, keyboardLayoutDescriptor);\n        } catch (RemoteException ex) {\n            throw ex.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"289","API Relative Path":"src.android.hardware.input.InputManager.java-getEnabledKeyboardLayoutsForInputDevice(InputDeviceIdentifier)","Corresponding Source":"/**\n     * Gets all keyboard layout descriptors that are enabled for the specified\n     * input device.\n     *\n     * @param identifier The identifier for the input device.\n     * @return The keyboard layout descriptors.\n     * @hide\n     */\n    public String[] getEnabledKeyboardLayoutsForInputDevice(InputDeviceIdentifier identifier) {\n        if (identifier == null) {\n            throw new IllegalArgumentException(\"inputDeviceDescriptor must not be null\");\n        }\n\n        try {\n            return mIm.getEnabledKeyboardLayoutsForInputDevice(identifier);\n        } catch (RemoteException ex) {\n            throw ex.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"290","API Relative Path":"src.android.hardware.input.InputManager.java-getInputDeviceByDescriptor(String)","Corresponding Source":"/**\n     * Gets information about the input device with the specified descriptor.\n     * @param descriptor The input device descriptor.\n     * @return The input device or null if not found.\n     * @hide\n     */\n    public InputDevice getInputDeviceByDescriptor(String descriptor) {\n        if (descriptor == null) {\n            throw new IllegalArgumentException(\"descriptor must not be null.\");\n        }\n\n        synchronized (mInputDevicesLock) {\n            populateInputDevicesLocked();\n\n            int numDevices = mInputDevices.size();\n            for (int i = 0; i < numDevices; i++) {\n                InputDevice inputDevice = mInputDevices.valueAt(i);\n                if (inputDevice == null) {\n                    int id = mInputDevices.keyAt(i);\n                    try {\n                        inputDevice = mIm.getInputDevice(id);\n                    } catch (RemoteException ex) {\n                        throw ex.rethrowFromSystemServer();\n                    }\n                    if (inputDevice == null) {\n                        continue;\n                    }\n                    mInputDevices.setValueAt(i, inputDevice);\n                }\n                if (descriptor.equals(inputDevice.getDescriptor())) {\n                    return inputDevice;\n                }\n            }\n            return null;\n        }\n    }"}
{"Number":"291","API Relative Path":"src.android.hardware.input.InputManager.java-getKeyboardLayout(String)","Corresponding Source":"/**\n     * Gets the keyboard layout with the specified descriptor.\n     *\n     * @param keyboardLayoutDescriptor The keyboard layout descriptor, as returned by\n     * {@link KeyboardLayout#getDescriptor()}.\n     * @return The keyboard layout, or null if it could not be loaded.\n     *\n     * @hide\n     */\n    public KeyboardLayout getKeyboardLayout(String keyboardLayoutDescriptor) {\n        if (keyboardLayoutDescriptor == null) {\n            throw new IllegalArgumentException(\"keyboardLayoutDescriptor must not be null\");\n        }\n\n        try {\n            return mIm.getKeyboardLayout(keyboardLayoutDescriptor);\n        } catch (RemoteException ex) {\n            throw ex.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"292","API Relative Path":"src.android.hardware.input.InputManager.java-injectInputEvent(InputEvent-int)","Corresponding Source":"/**\n     * Injects an input event into the event system on behalf of an application.\n     * The synchronization mode determines whether the method blocks while waiting for\n     * input injection to proceed.\n     * <p>\n     * Requires {@link android.Manifest.permission.INJECT_EVENTS} to inject into\n     * windows that are owned by other applications.\n     * <\/p><p>\n     * Make sure you correctly set the event time and input source of the event\n     * before calling this method.\n     * <\/p>\n     *\n     * @param event The event to inject.\n     * @param mode The synchronization mode.  One of:\n     * {@link #INJECT_INPUT_EVENT_MODE_ASYNC},\n     * {@link #INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT}, or\n     * {@link #INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH}.\n     * @return True if input event injection succeeded.\n     *\n     * @hide\n     */\n    public boolean injectInputEvent(InputEvent event, int mode) {\n        if (event == null) {\n            throw new IllegalArgumentException(\"event must not be null\");\n        }\n        if (mode != INJECT_INPUT_EVENT_MODE_ASYNC\n                && mode != INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH\n                && mode != INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT) {\n            throw new IllegalArgumentException(\"mode is invalid\");\n        }\n\n        try {\n            return mIm.injectInputEvent(event, mode);\n        } catch (RemoteException ex) {\n            throw ex.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"293","API Relative Path":"src.android.hardware.input.InputManager.java-injectInputEvent(InputEvent-int)","Corresponding Source":"/**\n     * Injects an input event into the event system on behalf of an application.\n     * The synchronization mode determines whether the method blocks while waiting for\n     * input injection to proceed.\n     * <p>\n     * Requires {@link android.Manifest.permission.INJECT_EVENTS} to inject into\n     * windows that are owned by other applications.\n     * <\/p><p>\n     * Make sure you correctly set the event time and input source of the event\n     * before calling this method.\n     * <\/p>\n     *\n     * @param event The event to inject.\n     * @param mode The synchronization mode.  One of:\n     * {@link #INJECT_INPUT_EVENT_MODE_ASYNC},\n     * {@link #INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT}, or\n     * {@link #INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH}.\n     * @return True if input event injection succeeded.\n     *\n     * @hide\n     */\n    public boolean injectInputEvent(InputEvent event, int mode) {\n        if (event == null) {\n            throw new IllegalArgumentException(\"event must not be null\");\n        }\n        if (mode != INJECT_INPUT_EVENT_MODE_ASYNC\n                && mode != INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH\n                && mode != INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT) {\n            throw new IllegalArgumentException(\"mode is invalid\");\n        }\n\n        try {\n            return mIm.injectInputEvent(event, mode);\n        } catch (RemoteException ex) {\n            throw ex.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"294","API Relative Path":"src.android.hardware.input.InputManager.java-registerInputDeviceListener(InputDeviceListener-Handler)","Corresponding Source":"/**\n     * Registers an input device listener to receive notifications about when\n     * input devices are added, removed or changed.\n     *\n     * @param listener The listener to register.\n     * @param handler The handler on which the listener should be invoked, or null\n     * if the listener should be invoked on the calling thread's looper.\n     *\n     * @see #unregisterInputDeviceListener\n     */\n    public void registerInputDeviceListener(InputDeviceListener listener, Handler handler) {\n        if (listener == null) {\n            throw new IllegalArgumentException(\"listener must not be null\");\n        }\n\n        synchronized (mInputDevicesLock) {\n            populateInputDevicesLocked();\n            int index = findInputDeviceListenerLocked(listener);\n            if (index < 0) {\n                mInputDeviceListeners.add(new InputDeviceListenerDelegate(listener, handler));\n            }\n        }\n    }"}
{"Number":"295","API Relative Path":"src.android.hardware.input.InputManager.java-registerOnTabletModeChangedListener(OnTabletModeChangedListener-Handler)","Corresponding Source":"/**\n     * Register a tablet mode changed listener.\n     *\n     * @param listener The listener to register.\n     * @param handler The handler on which the listener should be invoked, or null\n     * if the listener should be invoked on the calling thread's looper.\n     * @hide\n     */\n    public void registerOnTabletModeChangedListener(\n            OnTabletModeChangedListener listener, Handler handler) {\n        if (listener == null) {\n            throw new IllegalArgumentException(\"listener must not be null\");\n        }\n        synchronized (mTabletModeLock) {\n            if (mOnTabletModeChangedListeners == null) {\n                initializeTabletModeListenerLocked();\n            }\n            int idx = findOnTabletModeChangedListenerLocked(listener);\n            if (idx < 0) {\n                OnTabletModeChangedListenerDelegate d =\n                    new OnTabletModeChangedListenerDelegate(listener, handler);\n                mOnTabletModeChangedListeners.add(d);\n            }\n        }\n    }"}
{"Number":"296","API Relative Path":"src.android.hardware.input.InputManager.java-removeKeyboardLayoutForInputDevice(InputDeviceIdentifier-String)","Corresponding Source":"/**\n     * Removes the keyboard layout descriptor for the specified input device.\n     * <p>\n     * This method may have the side-effect of causing the input device in\n     * question to be reconfigured.\n     * <\/p>\n     *\n     * @param identifier The identifier for the input device.\n     * @param keyboardLayoutDescriptor The descriptor of the keyboard layout to\n     *            remove.\n     * @hide\n     */\n    public void removeKeyboardLayoutForInputDevice(InputDeviceIdentifier identifier,\n            String keyboardLayoutDescriptor) {\n        if (identifier == null) {\n            throw new IllegalArgumentException(\"inputDeviceDescriptor must not be null\");\n        }\n        if (keyboardLayoutDescriptor == null) {\n            throw new IllegalArgumentException(\"keyboardLayoutDescriptor must not be null\");\n        }\n\n        try {\n            mIm.removeKeyboardLayoutForInputDevice(identifier, keyboardLayoutDescriptor);\n        } catch (RemoteException ex) {\n            throw ex.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"297","API Relative Path":"src.android.hardware.input.InputManager.java-removeKeyboardLayoutForInputDevice(InputDeviceIdentifier-String)","Corresponding Source":"/**\n     * Removes the keyboard layout descriptor for the specified input device.\n     * <p>\n     * This method may have the side-effect of causing the input device in\n     * question to be reconfigured.\n     * <\/p>\n     *\n     * @param identifier The identifier for the input device.\n     * @param keyboardLayoutDescriptor The descriptor of the keyboard layout to\n     *            remove.\n     * @hide\n     */\n    public void removeKeyboardLayoutForInputDevice(InputDeviceIdentifier identifier,\n            String keyboardLayoutDescriptor) {\n        if (identifier == null) {\n            throw new IllegalArgumentException(\"inputDeviceDescriptor must not be null\");\n        }\n        if (keyboardLayoutDescriptor == null) {\n            throw new IllegalArgumentException(\"keyboardLayoutDescriptor must not be null\");\n        }\n\n        try {\n            mIm.removeKeyboardLayoutForInputDevice(identifier, keyboardLayoutDescriptor);\n        } catch (RemoteException ex) {\n            throw ex.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"298","API Relative Path":"src.android.hardware.input.InputManager.java-setCurrentKeyboardLayoutForInputDevice(InputDeviceIdentifier-String)","Corresponding Source":"/**\n     * Sets the current keyboard layout descriptor for the specified input\n     * device.\n     * <p>\n     * This method may have the side-effect of causing the input device in\n     * question to be reconfigured.\n     * <\/p>\n     *\n     * @param identifier The identifier for the input device.\n     * @param keyboardLayoutDescriptor The keyboard layout descriptor to use,\n     *            must not be null.\n     * @hide\n     */\n    public void setCurrentKeyboardLayoutForInputDevice(InputDeviceIdentifier identifier,\n            String keyboardLayoutDescriptor) {\n        if (identifier == null) {\n            throw new IllegalArgumentException(\"identifier must not be null\");\n        }\n        if (keyboardLayoutDescriptor == null) {\n            throw new IllegalArgumentException(\"keyboardLayoutDescriptor must not be null\");\n        }\n\n        try {\n            mIm.setCurrentKeyboardLayoutForInputDevice(identifier,\n                    keyboardLayoutDescriptor);\n        } catch (RemoteException ex) {\n            throw ex.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"299","API Relative Path":"src.android.hardware.input.InputManager.java-setCurrentKeyboardLayoutForInputDevice(InputDeviceIdentifier-String)","Corresponding Source":"/**\n     * Sets the current keyboard layout descriptor for the specified input\n     * device.\n     * <p>\n     * This method may have the side-effect of causing the input device in\n     * question to be reconfigured.\n     * <\/p>\n     *\n     * @param identifier The identifier for the input device.\n     * @param keyboardLayoutDescriptor The keyboard layout descriptor to use,\n     *            must not be null.\n     * @hide\n     */\n    public void setCurrentKeyboardLayoutForInputDevice(InputDeviceIdentifier identifier,\n            String keyboardLayoutDescriptor) {\n        if (identifier == null) {\n            throw new IllegalArgumentException(\"identifier must not be null\");\n        }\n        if (keyboardLayoutDescriptor == null) {\n            throw new IllegalArgumentException(\"keyboardLayoutDescriptor must not be null\");\n        }\n\n        try {\n            mIm.setCurrentKeyboardLayoutForInputDevice(identifier,\n                    keyboardLayoutDescriptor);\n        } catch (RemoteException ex) {\n            throw ex.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"300","API Relative Path":"src.android.hardware.input.InputManager.java-setPointerSpeed(Context-int)","Corresponding Source":"/**\n     * Sets the mouse pointer speed.\n     * <p>\n     * Requires {@link android.Manifest.permissions.WRITE_SETTINGS}.\n     * <\/p>\n     *\n     * @param context The application context.\n     * @param speed The pointer speed as a value between {@link #MIN_POINTER_SPEED} and\n     * {@link #MAX_POINTER_SPEED}, or the default value {@link #DEFAULT_POINTER_SPEED}.\n     *\n     * @hide\n     */\n    public void setPointerSpeed(Context context, int speed) {\n        if (speed < MIN_POINTER_SPEED || speed > MAX_POINTER_SPEED) {\n            throw new IllegalArgumentException(\"speed out of range\");\n        }\n\n        Settings.System.putInt(context.getContentResolver(),\n                Settings.System.POINTER_SPEED, speed);\n    }"}
{"Number":"301","API Relative Path":"src.android.hardware.input.InputManager.java-tryPointerSpeed(int)","Corresponding Source":"/**\n     * Changes the mouse pointer speed temporarily, but does not save the setting.\n     * <p>\n     * Requires {@link android.Manifest.permission.SET_POINTER_SPEED}.\n     * <\/p>\n     *\n     * @param speed The pointer speed as a value between {@link #MIN_POINTER_SPEED} and\n     * {@link #MAX_POINTER_SPEED}, or the default value {@link #DEFAULT_POINTER_SPEED}.\n     *\n     * @hide\n     */\n    public void tryPointerSpeed(int speed) {\n        if (speed < MIN_POINTER_SPEED || speed > MAX_POINTER_SPEED) {\n            throw new IllegalArgumentException(\"speed out of range\");\n        }\n\n        try {\n            mIm.tryPointerSpeed(speed);\n        } catch (RemoteException ex) {\n            throw ex.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"302","API Relative Path":"src.android.hardware.input.InputManager.java-unregisterInputDeviceListener(InputDeviceListener)","Corresponding Source":"/**\n     * Unregisters an input device listener.\n     *\n     * @param listener The listener to unregister.\n     *\n     * @see #registerInputDeviceListener\n     */\n    public void unregisterInputDeviceListener(InputDeviceListener listener) {\n        if (listener == null) {\n            throw new IllegalArgumentException(\"listener must not be null\");\n        }\n\n        synchronized (mInputDevicesLock) {\n            int index = findInputDeviceListenerLocked(listener);\n            if (index >= 0) {\n                InputDeviceListenerDelegate d = mInputDeviceListeners.get(index);\n                d.removeCallbacksAndMessages(null);\n                mInputDeviceListeners.remove(index);\n            }\n        }\n    }"}
{"Number":"303","API Relative Path":"src.android.hardware.input.InputManager.java-unregisterOnTabletModeChangedListener(OnTabletModeChangedListener)","Corresponding Source":"/**\n     * Unregister a tablet mode changed listener.\n     *\n     * @param listener The listener to unregister.\n     * @hide\n     */\n    public void unregisterOnTabletModeChangedListener(OnTabletModeChangedListener listener) {\n        if (listener == null) {\n            throw new IllegalArgumentException(\"listener must not be null\");\n        }\n        synchronized (mTabletModeLock) {\n            int idx = findOnTabletModeChangedListenerLocked(listener);\n            if (idx >= 0) {\n                OnTabletModeChangedListenerDelegate d = mOnTabletModeChangedListeners.remove(idx);\n                d.removeCallbacksAndMessages(null);\n            }\n        }\n    }"}
{"Number":"304","API Relative Path":"src.android.hardware.SensorManager.java-injectSensorData(Sensor-float[]-int-long)","Corresponding Source":"/**\n     * For testing purposes only. Not for third party applications.\n     *\n     * This method is used to inject raw sensor data into the HAL.  Call {@link\n     * initDataInjection(boolean)} before this method to set the HAL in data injection mode. This\n     * method should be called only if a previous call to initDataInjection has been successful and\n     * the HAL and SensorService are already opreating in data injection mode.\n     *\n     * @param sensor The sensor to inject.\n     * @param values Sensor values to inject. The length of this\n     *               array must be exactly equal to the number of\n     *               values reported by the sensor type.\n     * @param accuracy Accuracy of the sensor.\n     * @param timestamp Sensor timestamp associated with the event.\n     *\n     * @return boolean True if the data injection succeeds, false\n     *         otherwise.\n     * @throws IllegalArgumentException when the sensor is null,\n     *         data injection is not supported by the sensor, values\n     *         are null, incorrect number of values for the sensor,\n     *         sensor accuracy is incorrect or timestamps are\n     *         invalid.\n     * @hide\n     */\n    @SystemApi\n    public boolean injectSensorData(Sensor sensor, float[] values, int accuracy,\n                long timestamp) {\n        if (sensor == null) {\n            throw new IllegalArgumentException(\"sensor cannot be null\");\n        }\n        if (!sensor.isDataInjectionSupported()) {\n            throw new IllegalArgumentException(\"sensor does not support data injection\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"sensor data cannot be null\");\n        }\n        int expectedNumValues = Sensor.getMaxLengthValuesArray(sensor, Build.VERSION_CODES.M);\n        if (values.length != expectedNumValues) {\n            throw new  IllegalArgumentException (\"Wrong number of values for sensor \" +\n                    sensor.getName() + \" actual=\" + values.length + \" expected=\" +\n                                                  expectedNumValues);\n        }\n        if (accuracy < SENSOR_STATUS_NO_CONTACT || accuracy > SENSOR_STATUS_ACCURACY_HIGH) {\n            throw new IllegalArgumentException(\"Invalid sensor accuracy\");\n        }\n        if (timestamp <= 0) {\n            throw new IllegalArgumentException(\"Negative or zero sensor timestamp\");\n        }\n        return injectSensorDataImpl(sensor, values, accuracy, timestamp);\n    }"}
{"Number":"305","API Relative Path":"src.android.hardware.SensorManager.java-injectSensorData(Sensor-float[]-int-long)","Corresponding Source":"/**\n     * For testing purposes only. Not for third party applications.\n     *\n     * This method is used to inject raw sensor data into the HAL.  Call {@link\n     * initDataInjection(boolean)} before this method to set the HAL in data injection mode. This\n     * method should be called only if a previous call to initDataInjection has been successful and\n     * the HAL and SensorService are already opreating in data injection mode.\n     *\n     * @param sensor The sensor to inject.\n     * @param values Sensor values to inject. The length of this\n     *               array must be exactly equal to the number of\n     *               values reported by the sensor type.\n     * @param accuracy Accuracy of the sensor.\n     * @param timestamp Sensor timestamp associated with the event.\n     *\n     * @return boolean True if the data injection succeeds, false\n     *         otherwise.\n     * @throws IllegalArgumentException when the sensor is null,\n     *         data injection is not supported by the sensor, values\n     *         are null, incorrect number of values for the sensor,\n     *         sensor accuracy is incorrect or timestamps are\n     *         invalid.\n     * @hide\n     */\n    @SystemApi\n    public boolean injectSensorData(Sensor sensor, float[] values, int accuracy,\n                long timestamp) {\n        if (sensor == null) {\n            throw new IllegalArgumentException(\"sensor cannot be null\");\n        }\n        if (!sensor.isDataInjectionSupported()) {\n            throw new IllegalArgumentException(\"sensor does not support data injection\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"sensor data cannot be null\");\n        }\n        int expectedNumValues = Sensor.getMaxLengthValuesArray(sensor, Build.VERSION_CODES.M);\n        if (values.length != expectedNumValues) {\n            throw new  IllegalArgumentException (\"Wrong number of values for sensor \" +\n                    sensor.getName() + \" actual=\" + values.length + \" expected=\" +\n                                                  expectedNumValues);\n        }\n        if (accuracy < SENSOR_STATUS_NO_CONTACT || accuracy > SENSOR_STATUS_ACCURACY_HIGH) {\n            throw new IllegalArgumentException(\"Invalid sensor accuracy\");\n        }\n        if (timestamp <= 0) {\n            throw new IllegalArgumentException(\"Negative or zero sensor timestamp\");\n        }\n        return injectSensorDataImpl(sensor, values, accuracy, timestamp);\n    }"}
{"Number":"306","API Relative Path":"src.android.hardware.SensorManager.java-injectSensorData(Sensor-float[]-int-long)","Corresponding Source":"/**\n     * For testing purposes only. Not for third party applications.\n     *\n     * This method is used to inject raw sensor data into the HAL.  Call {@link\n     * initDataInjection(boolean)} before this method to set the HAL in data injection mode. This\n     * method should be called only if a previous call to initDataInjection has been successful and\n     * the HAL and SensorService are already opreating in data injection mode.\n     *\n     * @param sensor The sensor to inject.\n     * @param values Sensor values to inject. The length of this\n     *               array must be exactly equal to the number of\n     *               values reported by the sensor type.\n     * @param accuracy Accuracy of the sensor.\n     * @param timestamp Sensor timestamp associated with the event.\n     *\n     * @return boolean True if the data injection succeeds, false\n     *         otherwise.\n     * @throws IllegalArgumentException when the sensor is null,\n     *         data injection is not supported by the sensor, values\n     *         are null, incorrect number of values for the sensor,\n     *         sensor accuracy is incorrect or timestamps are\n     *         invalid.\n     * @hide\n     */\n    @SystemApi\n    public boolean injectSensorData(Sensor sensor, float[] values, int accuracy,\n                long timestamp) {\n        if (sensor == null) {\n            throw new IllegalArgumentException(\"sensor cannot be null\");\n        }\n        if (!sensor.isDataInjectionSupported()) {\n            throw new IllegalArgumentException(\"sensor does not support data injection\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"sensor data cannot be null\");\n        }\n        int expectedNumValues = Sensor.getMaxLengthValuesArray(sensor, Build.VERSION_CODES.M);\n        if (values.length != expectedNumValues) {\n            throw new  IllegalArgumentException (\"Wrong number of values for sensor \" +\n                    sensor.getName() + \" actual=\" + values.length + \" expected=\" +\n                                                  expectedNumValues);\n        }\n        if (accuracy < SENSOR_STATUS_NO_CONTACT || accuracy > SENSOR_STATUS_ACCURACY_HIGH) {\n            throw new IllegalArgumentException(\"Invalid sensor accuracy\");\n        }\n        if (timestamp <= 0) {\n            throw new IllegalArgumentException(\"Negative or zero sensor timestamp\");\n        }\n        return injectSensorDataImpl(sensor, values, accuracy, timestamp);\n    }"}
{"Number":"307","API Relative Path":"src.android.hardware.SensorManager.java-injectSensorData(Sensor-float[]-int-long)","Corresponding Source":"/**\n     * For testing purposes only. Not for third party applications.\n     *\n     * This method is used to inject raw sensor data into the HAL.  Call {@link\n     * initDataInjection(boolean)} before this method to set the HAL in data injection mode. This\n     * method should be called only if a previous call to initDataInjection has been successful and\n     * the HAL and SensorService are already opreating in data injection mode.\n     *\n     * @param sensor The sensor to inject.\n     * @param values Sensor values to inject. The length of this\n     *               array must be exactly equal to the number of\n     *               values reported by the sensor type.\n     * @param accuracy Accuracy of the sensor.\n     * @param timestamp Sensor timestamp associated with the event.\n     *\n     * @return boolean True if the data injection succeeds, false\n     *         otherwise.\n     * @throws IllegalArgumentException when the sensor is null,\n     *         data injection is not supported by the sensor, values\n     *         are null, incorrect number of values for the sensor,\n     *         sensor accuracy is incorrect or timestamps are\n     *         invalid.\n     * @hide\n     */\n    @SystemApi\n    public boolean injectSensorData(Sensor sensor, float[] values, int accuracy,\n                long timestamp) {\n        if (sensor == null) {\n            throw new IllegalArgumentException(\"sensor cannot be null\");\n        }\n        if (!sensor.isDataInjectionSupported()) {\n            throw new IllegalArgumentException(\"sensor does not support data injection\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"sensor data cannot be null\");\n        }\n        int expectedNumValues = Sensor.getMaxLengthValuesArray(sensor, Build.VERSION_CODES.M);\n        if (values.length != expectedNumValues) {\n            throw new  IllegalArgumentException (\"Wrong number of values for sensor \" +\n                    sensor.getName() + \" actual=\" + values.length + \" expected=\" +\n                                                  expectedNumValues);\n        }\n        if (accuracy < SENSOR_STATUS_NO_CONTACT || accuracy > SENSOR_STATUS_ACCURACY_HIGH) {\n            throw new IllegalArgumentException(\"Invalid sensor accuracy\");\n        }\n        if (timestamp <= 0) {\n            throw new IllegalArgumentException(\"Negative or zero sensor timestamp\");\n        }\n        return injectSensorDataImpl(sensor, values, accuracy, timestamp);\n    }"}
{"Number":"308","API Relative Path":"src.android.hardware.SensorManager.java-unregisterListener(SensorEventListener)","Corresponding Source":"/**\n     * Unregisters a listener for all sensors.\n     *\n     * @param listener\n     *        a SensorListener object\n     *\n     * @see #unregisterListener(SensorEventListener, Sensor)\n     * @see #registerListener(SensorEventListener, Sensor, int)\n     *\n     */\n    public void unregisterListener(SensorEventListener listener) {\n        if (listener == null) {\n            return;\n        }\n\n        unregisterListenerImpl(listener, null);\n    }"}
{"Number":"309","API Relative Path":"src.android.hardware.SensorManager.java-unregisterListener(SensorEventListener-Sensor)","Corresponding Source":"/**\n     * Unregisters a listener for the sensors with which it is registered.\n     *\n     * <p class=\"note\"><\/p>\n     * Note: Don't use this method with a one shot trigger sensor such as\n     * {@link Sensor#TYPE_SIGNIFICANT_MOTION}.\n     * Use {@link #cancelTriggerSensor(TriggerEventListener, Sensor)} instead.\n     * <\/p>\n     *\n     * @param listener\n     *        a SensorEventListener object\n     *\n     * @param sensor\n     *        the sensor to unregister from\n     *\n     * @see #unregisterListener(SensorEventListener)\n     * @see #registerListener(SensorEventListener, Sensor, int)\n     */\n    public void unregisterListener(SensorEventListener listener, Sensor sensor) {\n        if (listener == null || sensor == null) {\n            return;\n        }\n\n        unregisterListenerImpl(listener, sensor);\n    }"}
{"Number":"310","API Relative Path":"src.android.hardware.soundtrigger.SoundTrigger.java-attachModule(int-StatusListener-Handler)","Corresponding Source":"/**\n     * Get an interface on a hardware module to control sound models and recognition on\n     * this module.\n     * @param moduleId Sound module system identifier {@link ModuleProperties#id}. mandatory.\n     * @param listener {@link StatusListener} interface. Mandatory.\n     * @param handler the Handler that will receive the callabcks. Can be null if default handler\n     *                is OK.\n     * @return a valid sound module in case of success or null in case of error.\n     */\n    public static SoundTriggerModule attachModule(int moduleId,\n                                                  StatusListener listener,\n                                                  Handler handler) {\n        if (listener == null) {\n            return null;\n        }\n        SoundTriggerModule module = new SoundTriggerModule(moduleId, listener, handler);\n        return module;\n    }"}
{"Number":"311","API Relative Path":"src.android.hardware.SystemSensorManager.java-registerDynamicSensorCallbackImpl(DynamicSensorCallback-Handler)","Corresponding Source":"/** @hide */\n    protected void registerDynamicSensorCallbackImpl(\n            DynamicSensorCallback callback, Handler handler) {\n        if (DEBUG_DYNAMIC_SENSOR) {\n            Log.i(TAG, \"DYNS Register dynamic sensor callback\");\n        }\n\n        if (callback == null) {\n            throw new IllegalArgumentException(\"callback cannot be null\");\n        }\n        if (mDynamicSensorCallbacks.containsKey(callback)) {\n            // has been already registered, ignore\n            return;\n        }\n\n        setupDynamicSensorBroadcastReceiver();\n        mDynamicSensorCallbacks.put(callback, handler);\n    }"}
{"Number":"312","API Relative Path":"src.android.hardware.SystemSensorManager.java-requestTriggerSensorImpl(TriggerEventListener-Sensor)","Corresponding Source":"/** @hide */\n    @Override\n    protected boolean requestTriggerSensorImpl(TriggerEventListener listener, Sensor sensor) {\n        if (sensor == null) throw new IllegalArgumentException(\"sensor cannot be null\");\n\n        if (listener == null) throw new IllegalArgumentException(\"listener cannot be null\");\n\n        if (sensor.getReportingMode() != Sensor.REPORTING_MODE_ONE_SHOT) return false;\n\n        synchronized (mTriggerListeners) {\n            TriggerEventQueue queue = mTriggerListeners.get(listener);\n            if (queue == null) {\n                final String fullClassName = listener.getClass().getEnclosingClass() != null ?\n                    listener.getClass().getEnclosingClass().getName() :\n                    listener.getClass().getName();\n                queue = new TriggerEventQueue(listener, mMainLooper, this, fullClassName);\n                if (!queue.addSensor(sensor, 0, 0)) {\n                    queue.dispose();\n                    return false;\n                }\n                mTriggerListeners.put(listener, queue);\n                return true;\n            } else {\n                return queue.addSensor(sensor, 0, 0);\n            }\n        }\n    }"}
{"Number":"313","API Relative Path":"src.android.hardware.SystemSensorManager.java-requestTriggerSensorImpl(TriggerEventListener-Sensor)","Corresponding Source":"/** @hide */\n    @Override\n    protected boolean requestTriggerSensorImpl(TriggerEventListener listener, Sensor sensor) {\n        if (sensor == null) throw new IllegalArgumentException(\"sensor cannot be null\");\n\n        if (listener == null) throw new IllegalArgumentException(\"listener cannot be null\");\n\n        if (sensor.getReportingMode() != Sensor.REPORTING_MODE_ONE_SHOT) return false;\n\n        synchronized (mTriggerListeners) {\n            TriggerEventQueue queue = mTriggerListeners.get(listener);\n            if (queue == null) {\n                final String fullClassName = listener.getClass().getEnclosingClass() != null ?\n                    listener.getClass().getEnclosingClass().getName() :\n                    listener.getClass().getName();\n                queue = new TriggerEventQueue(listener, mMainLooper, this, fullClassName);\n                if (!queue.addSensor(sensor, 0, 0)) {\n                    queue.dispose();\n                    return false;\n                }\n                mTriggerListeners.put(listener, queue);\n                return true;\n            } else {\n                return queue.addSensor(sensor, 0, 0);\n            }\n        }\n    }"}
{"Number":"314","API Relative Path":"src.android.hardware.SystemSensorManager.java-unregisterListenerImpl(SensorEventListener-Sensor)","Corresponding Source":"/** @hide */\n    @Override\n    protected void unregisterListenerImpl(SensorEventListener listener, Sensor sensor) {\n        // Trigger Sensors should use the cancelTriggerSensor call.\n        if (sensor != null && sensor.getReportingMode() == Sensor.REPORTING_MODE_ONE_SHOT) {\n            return;\n        }\n\n        synchronized (mSensorListeners) {\n            SensorEventQueue queue = mSensorListeners.get(listener);\n            if (queue != null) {\n                boolean result;\n                if (sensor == null) {\n                    result = queue.removeAllSensors();\n                } else {\n                    result = queue.removeSensor(sensor, true);\n                }\n                if (result && !queue.hasSensors()) {\n                    mSensorListeners.remove(listener);\n                    queue.dispose();\n                }\n            }\n        }\n    }"}
{"Number":"315","API Relative Path":"src.android.location.Country.java-Country(String-int)","Corresponding Source":"/**\n     * @param countryIso the ISO 3166-1 two letters country code.\n     * @param source where the countryIso came from, could be one of below\n     *        values\n     *        <p>\n     *        <ul>\n     *        <li>{@link #COUNTRY_SOURCE_NETWORK}<\/li>\n     *        <li>{@link #COUNTRY_SOURCE_LOCATION}<\/li>\n     *        <li>{@link #COUNTRY_SOURCE_SIM}<\/li>\n     *        <li>{@link #COUNTRY_SOURCE_LOCALE}<\/li>\n     *        <\/ul>\n     */\n    public Country(final String countryIso, final int source) {\n        if (countryIso == null || source < COUNTRY_SOURCE_NETWORK\n                || source > COUNTRY_SOURCE_LOCALE) {\n            throw new IllegalArgumentException();\n        }\n        mCountryIso = countryIso.toUpperCase(Locale.US);\n        mSource = source;\n        mTimestamp = SystemClock.elapsedRealtime();\n    }"}
{"Number":"316","API Relative Path":"src.android.location.Criteria.java-setAccuracy(int)","Corresponding Source":"/**\n     * Indicates the desired accuracy for latitude and longitude. Accuracy\n     * may be {@link #ACCURACY_FINE} if desired location\n     * is fine, else it can be {@link #ACCURACY_COARSE}.\n     * More accurate location may consume more power and may take longer.\n     *\n     * @throws IllegalArgumentException if accuracy is not one of the supported constants\n     */\n    public void setAccuracy(int accuracy) {\n        if (accuracy < NO_REQUIREMENT || accuracy > ACCURACY_COARSE) {\n            throw new IllegalArgumentException(\"accuracy=\" + accuracy);\n        }\n        if (accuracy == ACCURACY_FINE) {\n            mHorizontalAccuracy = ACCURACY_HIGH;\n        } else {\n            mHorizontalAccuracy = ACCURACY_LOW;\n        }\n    }"}
{"Number":"317","API Relative Path":"src.android.location.Criteria.java-setBearingAccuracy(int)","Corresponding Source":"/**\n     * Indicates the desired bearing accuracy.\n     * Accuracy may be {@link #ACCURACY_LOW}, {@link #ACCURACY_HIGH},\n     * or {@link #NO_REQUIREMENT}.\n     * More accurate location may consume more power and may take longer.\n     *\n     * @throws IllegalArgumentException if accuracy is not one of the supported constants\n     */\n    public void setBearingAccuracy(int accuracy) {\n        if (accuracy < NO_REQUIREMENT || accuracy > ACCURACY_HIGH) {\n            throw new IllegalArgumentException(\"accuracy=\" + accuracy);\n        }\n        mBearingAccuracy = accuracy;\n    }"}
{"Number":"318","API Relative Path":"src.android.location.Criteria.java-setHorizontalAccuracy(int)","Corresponding Source":"/**\n     * Indicates the desired horizontal accuracy (latitude and longitude).\n     * Accuracy may be {@link #ACCURACY_LOW}, {@link #ACCURACY_MEDIUM},\n     * {@link #ACCURACY_HIGH} or {@link #NO_REQUIREMENT}.\n     * More accurate location may consume more power and may take longer.\n     *\n     * @throws IllegalArgumentException if accuracy is not one of the supported constants\n     */\n    public void setHorizontalAccuracy(int accuracy) {\n        if (accuracy < NO_REQUIREMENT || accuracy > ACCURACY_HIGH) {\n            throw new IllegalArgumentException(\"accuracy=\" + accuracy);\n        }\n        mHorizontalAccuracy = accuracy;\n    }"}
{"Number":"319","API Relative Path":"src.android.location.Criteria.java-setPowerRequirement(int)","Corresponding Source":"/**\n     * Indicates the desired maximum power level.  The level parameter\n     * must be one of NO_REQUIREMENT, POWER_LOW, POWER_MEDIUM, or\n     * POWER_HIGH.\n     */\n    public void setPowerRequirement(int level) {\n        if (level < NO_REQUIREMENT || level > POWER_HIGH) {\n            throw new IllegalArgumentException(\"level=\" + level);\n        }\n        mPowerRequirement = level;\n    }"}
{"Number":"320","API Relative Path":"src.android.location.Criteria.java-setSpeedAccuracy(int)","Corresponding Source":"/**\n     * Indicates the desired speed accuracy.\n     * Accuracy may be {@link #ACCURACY_LOW}, {@link #ACCURACY_HIGH},\n     * or {@link #NO_REQUIREMENT}.\n     * More accurate location may consume more power and may take longer.\n     *\n     * @throws IllegalArgumentException if accuracy is not one of the supported constants\n     */\n    public void setSpeedAccuracy(int accuracy) {\n        if (accuracy < NO_REQUIREMENT || accuracy > ACCURACY_HIGH) {\n            throw new IllegalArgumentException(\"accuracy=\" + accuracy);\n        }\n        mSpeedAccuracy = accuracy;\n    }"}
{"Number":"321","API Relative Path":"src.android.location.Criteria.java-setVerticalAccuracy(int)","Corresponding Source":"/**\n     * Indicates the desired vertical accuracy (altitude).\n     * Accuracy may be {@link #ACCURACY_LOW}, {@link #ACCURACY_MEDIUM},\n     * {@link #ACCURACY_HIGH} or {@link #NO_REQUIREMENT}.\n     * More accurate location may consume more power and may take longer.\n     *\n     * @throws IllegalArgumentException if accuracy is not one of the supported constants\n     */\n    public void setVerticalAccuracy(int accuracy) {\n        if (accuracy < NO_REQUIREMENT || accuracy > ACCURACY_HIGH) {\n            throw new IllegalArgumentException(\"accuracy=\" + accuracy);\n        }\n        mVerticalAccuracy = accuracy;\n    }"}
{"Number":"322","API Relative Path":"src.android.location.Geocoder.java-getFromLocation(double-double-int)","Corresponding Source":"/**\n     * Returns an array of Addresses that are known to describe the\n     * area immediately surrounding the given latitude and longitude.\n     * The returned addresses will be localized for the locale\n     * provided to this class's constructor.\n     *\n     * <p> The returned values may be obtained by means of a network lookup.\n     * The results are a best guess and are not guaranteed to be meaningful or\n     * correct. It may be useful to call this method from a thread separate from your\n     * primary UI thread.\n     *\n     * @param latitude the latitude a point for the search\n     * @param longitude the longitude a point for the search\n     * @param maxResults max number of addresses to return. Smaller numbers (1 to 5) are recommended\n     *\n     * @return a list of Address objects. Returns null or empty list if no matches were\n     * found or there is no backend service available.\n     *\n     * @throws IllegalArgumentException if latitude is\n     * less than -90 or greater than 90\n     * @throws IllegalArgumentException if longitude is\n     * less than -180 or greater than 180\n     * @throws IOException if the network is unavailable or any other\n     * I/O problem occurs\n     */\n    public List<Address> getFromLocation(double latitude, double longitude, int maxResults)\n        throws IOException {\n        if (latitude < -90.0 || latitude > 90.0) {\n            throw new IllegalArgumentException(\"latitude == \" + latitude);\n        }\n        if (longitude < -180.0 || longitude > 180.0) {\n            throw new IllegalArgumentException(\"longitude == \" + longitude);\n        }\n        try {\n            List<Address> results = new ArrayList<Address>();\n            String ex =  mService.getFromLocation(latitude, longitude, maxResults,\n                mParams, results);\n            if (ex != null) {\n                throw new IOException(ex);\n            } else {\n                return results;\n            }\n        } catch (RemoteException e) {\n            Log.e(TAG, \"getFromLocation: got RemoteException\", e);\n            return null;\n        }\n    }"}
{"Number":"323","API Relative Path":"src.android.location.Geocoder.java-getFromLocation(double-double-int)","Corresponding Source":"/**\n     * Returns an array of Addresses that are known to describe the\n     * area immediately surrounding the given latitude and longitude.\n     * The returned addresses will be localized for the locale\n     * provided to this class's constructor.\n     *\n     * <p> The returned values may be obtained by means of a network lookup.\n     * The results are a best guess and are not guaranteed to be meaningful or\n     * correct. It may be useful to call this method from a thread separate from your\n     * primary UI thread.\n     *\n     * @param latitude the latitude a point for the search\n     * @param longitude the longitude a point for the search\n     * @param maxResults max number of addresses to return. Smaller numbers (1 to 5) are recommended\n     *\n     * @return a list of Address objects. Returns null or empty list if no matches were\n     * found or there is no backend service available.\n     *\n     * @throws IllegalArgumentException if latitude is\n     * less than -90 or greater than 90\n     * @throws IllegalArgumentException if longitude is\n     * less than -180 or greater than 180\n     * @throws IOException if the network is unavailable or any other\n     * I/O problem occurs\n     */\n    public List<Address> getFromLocation(double latitude, double longitude, int maxResults)\n        throws IOException {\n        if (latitude < -90.0 || latitude > 90.0) {\n            throw new IllegalArgumentException(\"latitude == \" + latitude);\n        }\n        if (longitude < -180.0 || longitude > 180.0) {\n            throw new IllegalArgumentException(\"longitude == \" + longitude);\n        }\n        try {\n            List<Address> results = new ArrayList<Address>();\n            String ex =  mService.getFromLocation(latitude, longitude, maxResults,\n                mParams, results);\n            if (ex != null) {\n                throw new IOException(ex);\n            } else {\n                return results;\n            }\n        } catch (RemoteException e) {\n            Log.e(TAG, \"getFromLocation: got RemoteException\", e);\n            return null;\n        }\n    }"}
{"Number":"324","API Relative Path":"src.android.location.Geocoder.java-getFromLocationName(String-int-double-double-double-double)","Corresponding Source":"/**\n     * Returns an array of Addresses that are known to describe the\n     * named location, which may be a place name such as \"Dalvik,\n     * Iceland\", an address such as \"1600 Amphitheatre Parkway,\n     * Mountain View, CA\", an airport code such as \"SFO\", etc..  The\n     * returned addresses will be localized for the locale provided to\n     * this class's constructor.\n     *\n     * <p> You may specify a bounding box for the search results by including\n     * the Latitude and Longitude of the Lower Left point and Upper Right\n     * point of the box.\n     *\n     * <p> The query will block and returned values will be obtained by means of a network lookup.\n     * The results are a best guess and are not guaranteed to be meaningful or\n     * correct. It may be useful to call this method from a thread separate from your\n     * primary UI thread.\n     *\n     * @param locationName a user-supplied description of a location\n     * @param maxResults max number of addresses to return. Smaller numbers (1 to 5) are recommended\n     * @param lowerLeftLatitude the latitude of the lower left corner of the bounding box\n     * @param lowerLeftLongitude the longitude of the lower left corner of the bounding box\n     * @param upperRightLatitude the latitude of the upper right corner of the bounding box\n     * @param upperRightLongitude the longitude of the upper right corner of the bounding box\n     *\n     * @return a list of Address objects. Returns null or empty list if no matches were\n     * found or there is no backend service available.\n     *\n     * @throws IllegalArgumentException if locationName is null\n     * @throws IllegalArgumentException if any latitude is\n     * less than -90 or greater than 90\n     * @throws IllegalArgumentException if any longitude is\n     * less than -180 or greater than 180\n     * @throws IOException if the network is unavailable or any other\n     * I/O problem occurs\n     */\n    public List<Address> getFromLocationName(String locationName, int maxResults,\n        double lowerLeftLatitude, double lowerLeftLongitude,\n        double upperRightLatitude, double upperRightLongitude) throws IOException {\n        if (locationName == null) {\n            throw new IllegalArgumentException(\"locationName == null\");\n        }\n        if (lowerLeftLatitude < -90.0 || lowerLeftLatitude > 90.0) {\n            throw new IllegalArgumentException(\"lowerLeftLatitude == \"\n                + lowerLeftLatitude);\n        }\n        if (lowerLeftLongitude < -180.0 || lowerLeftLongitude > 180.0) {\n            throw new IllegalArgumentException(\"lowerLeftLongitude == \"\n                + lowerLeftLongitude);\n        }\n        if (upperRightLatitude < -90.0 || upperRightLatitude > 90.0) {\n            throw new IllegalArgumentException(\"upperRightLatitude == \"\n                + upperRightLatitude);\n        }\n        if (upperRightLongitude < -180.0 || upperRightLongitude > 180.0) {\n            throw new IllegalArgumentException(\"upperRightLongitude == \"\n                + upperRightLongitude);\n        }\n        try {\n            ArrayList<Address> result = new ArrayList<Address>();\n            String ex =  mService.getFromLocationName(locationName,\n                lowerLeftLatitude, lowerLeftLongitude, upperRightLatitude, upperRightLongitude,\n                maxResults, mParams, result);\n            if (ex != null) {\n                throw new IOException(ex);\n            } else {\n                return result;\n            }\n        } catch (RemoteException e) {\n            Log.e(TAG, \"getFromLocationName: got RemoteException\", e);\n            return null;\n        }\n    }"}
{"Number":"325","API Relative Path":"src.android.location.Geocoder.java-getFromLocationName(String-int-double-double-double-double)","Corresponding Source":"/**\n     * Returns an array of Addresses that are known to describe the\n     * named location, which may be a place name such as \"Dalvik,\n     * Iceland\", an address such as \"1600 Amphitheatre Parkway,\n     * Mountain View, CA\", an airport code such as \"SFO\", etc..  The\n     * returned addresses will be localized for the locale provided to\n     * this class's constructor.\n     *\n     * <p> You may specify a bounding box for the search results by including\n     * the Latitude and Longitude of the Lower Left point and Upper Right\n     * point of the box.\n     *\n     * <p> The query will block and returned values will be obtained by means of a network lookup.\n     * The results are a best guess and are not guaranteed to be meaningful or\n     * correct. It may be useful to call this method from a thread separate from your\n     * primary UI thread.\n     *\n     * @param locationName a user-supplied description of a location\n     * @param maxResults max number of addresses to return. Smaller numbers (1 to 5) are recommended\n     * @param lowerLeftLatitude the latitude of the lower left corner of the bounding box\n     * @param lowerLeftLongitude the longitude of the lower left corner of the bounding box\n     * @param upperRightLatitude the latitude of the upper right corner of the bounding box\n     * @param upperRightLongitude the longitude of the upper right corner of the bounding box\n     *\n     * @return a list of Address objects. Returns null or empty list if no matches were\n     * found or there is no backend service available.\n     *\n     * @throws IllegalArgumentException if locationName is null\n     * @throws IllegalArgumentException if any latitude is\n     * less than -90 or greater than 90\n     * @throws IllegalArgumentException if any longitude is\n     * less than -180 or greater than 180\n     * @throws IOException if the network is unavailable or any other\n     * I/O problem occurs\n     */\n    public List<Address> getFromLocationName(String locationName, int maxResults,\n        double lowerLeftLatitude, double lowerLeftLongitude,\n        double upperRightLatitude, double upperRightLongitude) throws IOException {\n        if (locationName == null) {\n            throw new IllegalArgumentException(\"locationName == null\");\n        }\n        if (lowerLeftLatitude < -90.0 || lowerLeftLatitude > 90.0) {\n            throw new IllegalArgumentException(\"lowerLeftLatitude == \"\n                + lowerLeftLatitude);\n        }\n        if (lowerLeftLongitude < -180.0 || lowerLeftLongitude > 180.0) {\n            throw new IllegalArgumentException(\"lowerLeftLongitude == \"\n                + lowerLeftLongitude);\n        }\n        if (upperRightLatitude < -90.0 || upperRightLatitude > 90.0) {\n            throw new IllegalArgumentException(\"upperRightLatitude == \"\n                + upperRightLatitude);\n        }\n        if (upperRightLongitude < -180.0 || upperRightLongitude > 180.0) {\n            throw new IllegalArgumentException(\"upperRightLongitude == \"\n                + upperRightLongitude);\n        }\n        try {\n            ArrayList<Address> result = new ArrayList<Address>();\n            String ex =  mService.getFromLocationName(locationName,\n                lowerLeftLatitude, lowerLeftLongitude, upperRightLatitude, upperRightLongitude,\n                maxResults, mParams, result);\n            if (ex != null) {\n                throw new IOException(ex);\n            } else {\n                return result;\n            }\n        } catch (RemoteException e) {\n            Log.e(TAG, \"getFromLocationName: got RemoteException\", e);\n            return null;\n        }\n    }"}
{"Number":"326","API Relative Path":"src.android.location.Geocoder.java-getFromLocationName(String-int-double-double-double-double)","Corresponding Source":"/**\n     * Returns an array of Addresses that are known to describe the\n     * named location, which may be a place name such as \"Dalvik,\n     * Iceland\", an address such as \"1600 Amphitheatre Parkway,\n     * Mountain View, CA\", an airport code such as \"SFO\", etc..  The\n     * returned addresses will be localized for the locale provided to\n     * this class's constructor.\n     *\n     * <p> You may specify a bounding box for the search results by including\n     * the Latitude and Longitude of the Lower Left point and Upper Right\n     * point of the box.\n     *\n     * <p> The query will block and returned values will be obtained by means of a network lookup.\n     * The results are a best guess and are not guaranteed to be meaningful or\n     * correct. It may be useful to call this method from a thread separate from your\n     * primary UI thread.\n     *\n     * @param locationName a user-supplied description of a location\n     * @param maxResults max number of addresses to return. Smaller numbers (1 to 5) are recommended\n     * @param lowerLeftLatitude the latitude of the lower left corner of the bounding box\n     * @param lowerLeftLongitude the longitude of the lower left corner of the bounding box\n     * @param upperRightLatitude the latitude of the upper right corner of the bounding box\n     * @param upperRightLongitude the longitude of the upper right corner of the bounding box\n     *\n     * @return a list of Address objects. Returns null or empty list if no matches were\n     * found or there is no backend service available.\n     *\n     * @throws IllegalArgumentException if locationName is null\n     * @throws IllegalArgumentException if any latitude is\n     * less than -90 or greater than 90\n     * @throws IllegalArgumentException if any longitude is\n     * less than -180 or greater than 180\n     * @throws IOException if the network is unavailable or any other\n     * I/O problem occurs\n     */\n    public List<Address> getFromLocationName(String locationName, int maxResults,\n        double lowerLeftLatitude, double lowerLeftLongitude,\n        double upperRightLatitude, double upperRightLongitude) throws IOException {\n        if (locationName == null) {\n            throw new IllegalArgumentException(\"locationName == null\");\n        }\n        if (lowerLeftLatitude < -90.0 || lowerLeftLatitude > 90.0) {\n            throw new IllegalArgumentException(\"lowerLeftLatitude == \"\n                + lowerLeftLatitude);\n        }\n        if (lowerLeftLongitude < -180.0 || lowerLeftLongitude > 180.0) {\n            throw new IllegalArgumentException(\"lowerLeftLongitude == \"\n                + lowerLeftLongitude);\n        }\n        if (upperRightLatitude < -90.0 || upperRightLatitude > 90.0) {\n            throw new IllegalArgumentException(\"upperRightLatitude == \"\n                + upperRightLatitude);\n        }\n        if (upperRightLongitude < -180.0 || upperRightLongitude > 180.0) {\n            throw new IllegalArgumentException(\"upperRightLongitude == \"\n                + upperRightLongitude);\n        }\n        try {\n            ArrayList<Address> result = new ArrayList<Address>();\n            String ex =  mService.getFromLocationName(locationName,\n                lowerLeftLatitude, lowerLeftLongitude, upperRightLatitude, upperRightLongitude,\n                maxResults, mParams, result);\n            if (ex != null) {\n                throw new IOException(ex);\n            } else {\n                return result;\n            }\n        } catch (RemoteException e) {\n            Log.e(TAG, \"getFromLocationName: got RemoteException\", e);\n            return null;\n        }\n    }"}
{"Number":"327","API Relative Path":"src.android.location.Geocoder.java-getFromLocationName(String-int-double-double-double-double)","Corresponding Source":"/**\n     * Returns an array of Addresses that are known to describe the\n     * named location, which may be a place name such as \"Dalvik,\n     * Iceland\", an address such as \"1600 Amphitheatre Parkway,\n     * Mountain View, CA\", an airport code such as \"SFO\", etc..  The\n     * returned addresses will be localized for the locale provided to\n     * this class's constructor.\n     *\n     * <p> You may specify a bounding box for the search results by including\n     * the Latitude and Longitude of the Lower Left point and Upper Right\n     * point of the box.\n     *\n     * <p> The query will block and returned values will be obtained by means of a network lookup.\n     * The results are a best guess and are not guaranteed to be meaningful or\n     * correct. It may be useful to call this method from a thread separate from your\n     * primary UI thread.\n     *\n     * @param locationName a user-supplied description of a location\n     * @param maxResults max number of addresses to return. Smaller numbers (1 to 5) are recommended\n     * @param lowerLeftLatitude the latitude of the lower left corner of the bounding box\n     * @param lowerLeftLongitude the longitude of the lower left corner of the bounding box\n     * @param upperRightLatitude the latitude of the upper right corner of the bounding box\n     * @param upperRightLongitude the longitude of the upper right corner of the bounding box\n     *\n     * @return a list of Address objects. Returns null or empty list if no matches were\n     * found or there is no backend service available.\n     *\n     * @throws IllegalArgumentException if locationName is null\n     * @throws IllegalArgumentException if any latitude is\n     * less than -90 or greater than 90\n     * @throws IllegalArgumentException if any longitude is\n     * less than -180 or greater than 180\n     * @throws IOException if the network is unavailable or any other\n     * I/O problem occurs\n     */\n    public List<Address> getFromLocationName(String locationName, int maxResults,\n        double lowerLeftLatitude, double lowerLeftLongitude,\n        double upperRightLatitude, double upperRightLongitude) throws IOException {\n        if (locationName == null) {\n            throw new IllegalArgumentException(\"locationName == null\");\n        }\n        if (lowerLeftLatitude < -90.0 || lowerLeftLatitude > 90.0) {\n            throw new IllegalArgumentException(\"lowerLeftLatitude == \"\n                + lowerLeftLatitude);\n        }\n        if (lowerLeftLongitude < -180.0 || lowerLeftLongitude > 180.0) {\n            throw new IllegalArgumentException(\"lowerLeftLongitude == \"\n                + lowerLeftLongitude);\n        }\n        if (upperRightLatitude < -90.0 || upperRightLatitude > 90.0) {\n            throw new IllegalArgumentException(\"upperRightLatitude == \"\n                + upperRightLatitude);\n        }\n        if (upperRightLongitude < -180.0 || upperRightLongitude > 180.0) {\n            throw new IllegalArgumentException(\"upperRightLongitude == \"\n                + upperRightLongitude);\n        }\n        try {\n            ArrayList<Address> result = new ArrayList<Address>();\n            String ex =  mService.getFromLocationName(locationName,\n                lowerLeftLatitude, lowerLeftLongitude, upperRightLatitude, upperRightLongitude,\n                maxResults, mParams, result);\n            if (ex != null) {\n                throw new IOException(ex);\n            } else {\n                return result;\n            }\n        } catch (RemoteException e) {\n            Log.e(TAG, \"getFromLocationName: got RemoteException\", e);\n            return null;\n        }\n    }"}
{"Number":"328","API Relative Path":"src.android.location.GnssMeasurementsEvent.java-GnssMeasurementsEvent(GnssClock-GnssMeasurement[])","Corresponding Source":"/**\n     * @hide\n     */\n    @TestApi\n    public GnssMeasurementsEvent(GnssClock clock, GnssMeasurement[] measurements) {\n        if (clock == null) {\n            throw new InvalidParameterException(\"Parameter 'clock' must not be null.\");\n        }\n        if (measurements == null || measurements.length == 0) {\n            throw new InvalidParameterException(\n                    \"Parameter 'measurements' must not be null or empty.\");\n        }\n\n        mClock = clock;\n        Collection<GnssMeasurement> measurementCollection = Arrays.asList(measurements);\n        mReadOnlyMeasurements = Collections.unmodifiableCollection(measurementCollection);\n    }"}
{"Number":"329","API Relative Path":"src.android.location.GnssMeasurementsEvent.java-GnssMeasurementsEvent(GnssClock-GnssMeasurement[])","Corresponding Source":"/**\n     * @hide\n     */\n    @TestApi\n    public GnssMeasurementsEvent(GnssClock clock, GnssMeasurement[] measurements) {\n        if (clock == null) {\n            throw new InvalidParameterException(\"Parameter 'clock' must not be null.\");\n        }\n        if (measurements == null || measurements.length == 0) {\n            throw new InvalidParameterException(\n                    \"Parameter 'measurements' must not be null or empty.\");\n        }\n\n        mClock = clock;\n        Collection<GnssMeasurement> measurementCollection = Arrays.asList(measurements);\n        mReadOnlyMeasurements = Collections.unmodifiableCollection(measurementCollection);\n    }"}
{"Number":"330","API Relative Path":"src.android.location.GnssNavigationMessage.java-setData(byte[])","Corresponding Source":"/**\n     * Sets the data associated with the Navigation Message.\n     * @hide\n     */\n    @TestApi\n    public void setData(byte[] value) {\n        if (value == null) {\n            throw new InvalidParameterException(\"Data must be a non-null array\");\n        }\n\n        mData = value;\n    }"}
{"Number":"331","API Relative Path":"src.android.location.GpsNavigationMessage.java-setData(byte[])","Corresponding Source":"/**\n     * Sets the data associated with the Navigation Message.\n     */\n    public void setData(byte[] value) {\n        if (value == null) {\n            throw new InvalidParameterException(\"Data must be a non-null array\");\n        }\n\n        mData = value;\n    }"}
{"Number":"332","API Relative Path":"src.android.location.Location.java-convert(double-int)","Corresponding Source":"/**\n     * Converts a coordinate to a String representation. The outputType\n     * may be one of FORMAT_DEGREES, FORMAT_MINUTES, or FORMAT_SECONDS.\n     * The coordinate must be a valid double between -180.0 and 180.0.\n     * This conversion is performed in a method that is dependent on the\n     * default locale, and so is not guaranteed to round-trip with\n     * {@link #convert(String)}.\n     *\n     * @throws IllegalArgumentException if coordinate is less than\n     * -180.0, greater than 180.0, or is not a number.\n     * @throws IllegalArgumentException if outputType is not one of\n     * FORMAT_DEGREES, FORMAT_MINUTES, or FORMAT_SECONDS.\n     */\n    public static String convert(double coordinate, int outputType) {\n        if (coordinate < -180.0 || coordinate > 180.0 ||\n            Double.isNaN(coordinate)) {\n            throw new IllegalArgumentException(\"coordinate=\" + coordinate);\n        }\n        if ((outputType != FORMAT_DEGREES) &&\n            (outputType != FORMAT_MINUTES) &&\n            (outputType != FORMAT_SECONDS)) {\n            throw new IllegalArgumentException(\"outputType=\" + outputType);\n        }\n\n        StringBuilder sb = new StringBuilder();\n\n        // Handle negative values\n        if (coordinate < 0) {\n            sb.append('-');\n            coordinate = -coordinate;\n        }\n\n        DecimalFormat df = new DecimalFormat(\"###.#####\");\n        if (outputType == FORMAT_MINUTES || outputType == FORMAT_SECONDS) {\n            int degrees = (int) Math.floor(coordinate);\n            sb.append(degrees);\n            sb.append(':');\n            coordinate -= degrees;\n            coordinate *= 60.0;\n            if (outputType == FORMAT_SECONDS) {\n                int minutes = (int) Math.floor(coordinate);\n                sb.append(minutes);\n                sb.append(':');\n                coordinate -= minutes;\n                coordinate *= 60.0;\n            }\n        }\n        sb.append(df.format(coordinate));\n        return sb.toString();\n    }"}
{"Number":"333","API Relative Path":"src.android.location.LocationRequest.java-setNumUpdates(int)","Corresponding Source":"/**\n     * Set the number of location updates.\n     *\n     * <p>By default locations are continuously updated until the request is explicitly\n     * removed, however you can optionally request a set number of updates.\n     * For example, if your application only needs a single fresh location,\n     * then call this method with a value of 1 before passing the request\n     * to the location manager.\n     *\n     * @param numUpdates the number of location updates requested\n     * @throws InvalidArgumentException if numUpdates is 0 or less\n     * @return the same object, so that setters can be chained\n     */\n    public LocationRequest setNumUpdates(int numUpdates) {\n        if (numUpdates <= 0) throw new IllegalArgumentException(\"invalid numUpdates: \" + numUpdates);\n        mNumUpdates = numUpdates;\n        return this;\n    }"}
{"Number":"334","API Relative Path":"src.android.media.AsyncPlayer.java-play(Context-Uri-boolean-AudioAttributes)","Corresponding Source":"/**\n     * Start playing the sound.  It will actually start playing at some\n     * point in the future.  There are no guarantees about latency here.\n     * Calling this before another audio file is done playing will stop\n     * that one and start the new one.\n     *\n     * @param context the non-null application's context.\n     * @param uri the non-null URI to play.  (see {@link MediaPlayer#setDataSource(Context, Uri)})\n     * @param looping whether the audio should loop forever.\n     *          (see {@link MediaPlayer#setLooping(boolean)})\n     * @param attributes the non-null {@link AudioAttributes} to use.\n     *          (see {@link MediaPlayer#setAudioAttributes(AudioAttributes)})\n     * @throws IllegalArgumentException\n     */\n    public void play(@NonNull Context context, @NonNull Uri uri, boolean looping,\n            @NonNull AudioAttributes attributes) throws IllegalArgumentException {\n        if (context == null || uri == null || attributes == null) {\n            throw new IllegalArgumentException(\"Illegal null AsyncPlayer.play() argument\");\n        }\n        Command cmd = new Command();\n        cmd.requestTime = SystemClock.uptimeMillis();\n        cmd.code = PLAY;\n        cmd.context = context;\n        cmd.uri = uri;\n        cmd.looping = looping;\n        cmd.attributes = attributes;\n        synchronized (mCmdQueue) {\n            enqueueLocked(cmd);\n            mState = PLAY;\n        }\n    }"}
{"Number":"335","API Relative Path":"src.android.media.AsyncPlayer.java-play(Context-Uri-boolean-int)","Corresponding Source":"/**\n     * Start playing the sound.  It will actually start playing at some\n     * point in the future.  There are no guarantees about latency here.\n     * Calling this before another audio file is done playing will stop\n     * that one and start the new one.\n     *\n     * @param context Your application's context.\n     * @param uri The URI to play.  (see {@link MediaPlayer#setDataSource(Context, Uri)})\n     * @param looping Whether the audio should loop forever.  \n     *          (see {@link MediaPlayer#setLooping(boolean)})\n     * @param stream the AudioStream to use.\n     *          (see {@link MediaPlayer#setAudioStreamType(int)})\n     * @deprecated use {@link #play(Context, Uri, boolean, AudioAttributes)} instead\n     */\n    public void play(Context context, Uri uri, boolean looping, int stream) {\n        if (context == null || uri == null) {\n            return;\n        }\n        try {\n            play(context, uri, looping,\n                    new AudioAttributes.Builder().setInternalLegacyStreamType(stream).build());\n        } catch (IllegalArgumentException e) {\n            Log.e(mTag, \"Call to deprecated AsyncPlayer.play() method caused:\", e);\n        }\n    }"}
{"Number":"336","API Relative Path":"src.android.media.AudioFormat.java-filterPublicFormats(int[])","Corresponding Source":"/**\n     * Returns an array of public encoding values extracted from an array of\n     * encoding values.\n     * @hide\n     */\n    public static int[] filterPublicFormats(int[] formats) {\n        if (formats == null) {\n            return null;\n        }\n        int[] myCopy = Arrays.copyOf(formats, formats.length);\n        int size = 0;\n        for (int i = 0; i < myCopy.length; i++) {\n            if (isPublicEncoding(myCopy[i])) {\n                if (size != i) {\n                    myCopy[size] = myCopy[i];\n                }\n                size++;\n            }\n        }\n        return Arrays.copyOf(myCopy, size);\n    }"}
{"Number":"337","API Relative Path":"src.android.media.AudioFormat.java-inChannelMaskFromOutChannelMask(int)","Corresponding Source":"/**\n     * @hide\n     * Return the input channel mask corresponding to an output channel mask.\n     * This can be used for submix rerouting for the mask of the recorder to map to that of the mix.\n     * @param outMask a combination of the CHANNEL_OUT_* definitions, but not CHANNEL_OUT_DEFAULT\n     * @return a combination of CHANNEL_IN_* definitions matching an output channel mask\n     * @throws IllegalArgumentException\n     */\n    public static int inChannelMaskFromOutChannelMask(int outMask) throws IllegalArgumentException {\n        if (outMask == CHANNEL_OUT_DEFAULT) {\n            throw new IllegalArgumentException(\n                    \"Illegal CHANNEL_OUT_DEFAULT channel mask for input.\");\n        }\n        switch (channelCountFromOutChannelMask(outMask)) {\n            case 1:\n                return CHANNEL_IN_MONO;\n            case 2:\n                return CHANNEL_IN_STEREO;\n            default:\n                throw new IllegalArgumentException(\"Unsupported channel configuration for input.\");\n        }\n    }"}
{"Number":"338","API Relative Path":"src.android.media.AudioManager.java-registerMediaButtonEventReceiver(ComponentName)","Corresponding Source":"/**\n     * Unregister the receiver of MEDIA_BUTTON intents.\n     * @param eventReceiver identifier of a {@link android.content.BroadcastReceiver}\n     *      that was registered with {@link #registerMediaButtonEventReceiver(ComponentName)}.\n     * @deprecated Use {@link MediaSession} instead.\n     */\n    @Deprecated\n    public void unregisterMediaButtonEventReceiver(ComponentName eventReceiver) {\n        if (eventReceiver == null) {\n            return;\n        }\n        // construct a PendingIntent for the media button and unregister it\n        Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);\n        //     the associated intent will be handled by the component being registered\n        mediaButtonIntent.setComponent(eventReceiver);\n        PendingIntent pi = PendingIntent.getBroadcast(getContext(),\n                0/*requestCode, ignored*/, mediaButtonIntent, 0/*flags*/);\n        unregisterMediaButtonIntent(pi);\n    }"}
{"Number":"339","API Relative Path":"src.android.media.AudioManager.java-registerMediaButtonEventReceiver(PendingIntent)","Corresponding Source":"/**\n     * Unregister the receiver of MEDIA_BUTTON intents.\n     * @param eventReceiver same PendingIntent that was registed with\n     *      {@link #registerMediaButtonEventReceiver(PendingIntent)}.\n     * @deprecated Use {@link MediaSession} instead.\n     */\n    @Deprecated\n    public void unregisterMediaButtonEventReceiver(PendingIntent eventReceiver) {\n        if (eventReceiver == null) {\n            return;\n        }\n        unregisterMediaButtonIntent(eventReceiver);\n    }"}
{"Number":"340","API Relative Path":"src.android.media.AudioManager.java-registerRemoteControlClient(RemoteControlClient)","Corresponding Source":"/**\n     * Unregisters the remote control client that was providing information to display on the\n     * remote controls.\n     * @param rcClient The remote control client to unregister.\n     * @see #registerRemoteControlClient(RemoteControlClient)\n     * @deprecated Use {@link MediaSession} instead.\n     */\n    @Deprecated\n    public void unregisterRemoteControlClient(RemoteControlClient rcClient) {\n        if ((rcClient == null) || (rcClient.getRcMediaIntent() == null)) {\n            return;\n        }\n        rcClient.unregisterWithSession(MediaSessionLegacyHelper.getHelper(getContext()));\n    }"}
{"Number":"341","API Relative Path":"src.android.media.AudioManager.java-requestAudioFocus(OnAudioFocusChangeListener-AudioAttributes-int-int)","Corresponding Source":"/**\n     * @hide\n     * Request audio focus.\n     * Send a request to obtain the audio focus. This method differs from\n     * {@link #requestAudioFocus(OnAudioFocusChangeListener, int, int)} in that it can express\n     * that the requester accepts delayed grants of audio focus.\n     * @param l the listener to be notified of audio focus changes. It is not allowed to be null\n     *     when the request is flagged with {@link #AUDIOFOCUS_FLAG_DELAY_OK}.\n     * @param requestAttributes non null {@link AudioAttributes} describing the main reason for\n     *     requesting audio focus.\n     * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus request\n     *      is temporary, and focus will be abandonned shortly. Examples of transient requests are\n     *      for the playback of driving directions, or notifications sounds.\n     *      Use {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok for\n     *      the previous focus owner to keep playing if it ducks its audio output.\n     *      Alternatively use {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE} for a temporary request\n     *      that benefits from the system not playing disruptive sounds like notifications, for\n     *      usecases such as voice memo recording, or speech recognition.\n     *      Use {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration such\n     *      as the playback of a song or a video.\n     * @param flags 0 or a combination of {link #AUDIOFOCUS_FLAG_DELAY_OK}\n     *     and {@link #AUDIOFOCUS_FLAG_PAUSES_ON_DUCKABLE_LOSS}.\n     *     <br>Use 0 when not using any flags for the request, which behaves like\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, int, int)}, where either audio\n     *     focus is granted immediately, or the grant request fails because the system is in a\n     *     state where focus cannot change (e.g. a phone call).\n     * @return {@link #AUDIOFOCUS_REQUEST_FAILED}, {@link #AUDIOFOCUS_REQUEST_GRANTED}\n     *     or {@link #AUDIOFOCUS_REQUEST_DELAYED}.\n     *     The return value is never {@link #AUDIOFOCUS_REQUEST_DELAYED} when focus is requested\n     *     without the {@link #AUDIOFOCUS_FLAG_DELAY_OK} flag.\n     * @throws IllegalArgumentException\n     */\n    @SystemApi\n    public int requestAudioFocus(OnAudioFocusChangeListener l,\n            @NonNull AudioAttributes requestAttributes,\n            int durationHint,\n            int flags) throws IllegalArgumentException {\n        if (flags != (flags & AUDIOFOCUS_FLAGS_APPS)) {\n            throw new IllegalArgumentException(\"Invalid flags 0x\"\n                    + Integer.toHexString(flags).toUpperCase());\n        }\n        return requestAudioFocus(l, requestAttributes, durationHint,\n                flags & AUDIOFOCUS_FLAGS_APPS,\n                null /* no AudioPolicy*/);\n    }"}
{"Number":"342","API Relative Path":"src.android.media.AudioManager.java-requestAudioFocus(OnAudioFocusChangeListener-AudioAttributes-int-int-AudioPolicy)","Corresponding Source":"/**\n     * @hide\n     * Request or lock audio focus.\n     * This method is to be used by system components that have registered an\n     * {@link android.media.audiopolicy.AudioPolicy} to request audio focus, but also to \"lock\" it\n     * so focus granting is temporarily disabled.\n     * @param l see the description of the same parameter in\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int)}\n     * @param requestAttributes non null {@link AudioAttributes} describing the main reason for\n     *     requesting audio focus.\n     * @param durationHint see the description of the same parameter in\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int)}\n     * @param flags 0 or a combination of {link #AUDIOFOCUS_FLAG_DELAY_OK},\n     *     {@link #AUDIOFOCUS_FLAG_PAUSES_ON_DUCKABLE_LOSS}, and {@link #AUDIOFOCUS_FLAG_LOCK}.\n     *     <br>Use 0 when not using any flags for the request, which behaves like\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, int, int)}, where either audio\n     *     focus is granted immediately, or the grant request fails because the system is in a\n     *     state where focus cannot change (e.g. a phone call).\n     * @param ap a registered {@link android.media.audiopolicy.AudioPolicy} instance when locking\n     *     focus, or null.\n     * @return see the description of the same return value in\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int)}\n     * @throws IllegalArgumentException\n     */\n    @SystemApi\n    public int requestAudioFocus(OnAudioFocusChangeListener l,\n            @NonNull AudioAttributes requestAttributes,\n            int durationHint,\n            int flags,\n            AudioPolicy ap) throws IllegalArgumentException {\n        // parameter checking\n        if (requestAttributes == null) {\n            throw new IllegalArgumentException(\"Illegal null AudioAttributes argument\");\n        }\n        if ((durationHint < AUDIOFOCUS_GAIN) ||\n                (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE)) {\n            throw new IllegalArgumentException(\"Invalid duration hint\");\n        }\n        if (flags != (flags & AUDIOFOCUS_FLAGS_SYSTEM)) {\n            throw new IllegalArgumentException(\"Illegal flags 0x\"\n                + Integer.toHexString(flags).toUpperCase());\n        }\n        if (((flags & AUDIOFOCUS_FLAG_DELAY_OK) == AUDIOFOCUS_FLAG_DELAY_OK) && (l == null)) {\n            throw new IllegalArgumentException(\n                    \"Illegal null focus listener when flagged as accepting delayed focus grant\");\n        }\n        if (((flags & AUDIOFOCUS_FLAG_LOCK) == AUDIOFOCUS_FLAG_LOCK) && (ap == null)) {\n            throw new IllegalArgumentException(\n                    \"Illegal null audio policy when locking audio focus\");\n        }\n\n        int status = AUDIOFOCUS_REQUEST_FAILED;\n        registerAudioFocusListener(l);\n        IAudioService service = getService();\n        try {\n            status = service.requestAudioFocus(requestAttributes, durationHint, mICallBack,\n                    mAudioFocusDispatcher, getIdForAudioFocusListener(l),\n                    getContext().getOpPackageName() /* package name */, flags,\n                    ap != null ? ap.cb() : null);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n        return status;\n    }"}
{"Number":"343","API Relative Path":"src.android.media.AudioManager.java-requestAudioFocus(OnAudioFocusChangeListener-AudioAttributes-int-int-AudioPolicy)","Corresponding Source":"/**\n     * @hide\n     * Request or lock audio focus.\n     * This method is to be used by system components that have registered an\n     * {@link android.media.audiopolicy.AudioPolicy} to request audio focus, but also to \"lock\" it\n     * so focus granting is temporarily disabled.\n     * @param l see the description of the same parameter in\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int)}\n     * @param requestAttributes non null {@link AudioAttributes} describing the main reason for\n     *     requesting audio focus.\n     * @param durationHint see the description of the same parameter in\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int)}\n     * @param flags 0 or a combination of {link #AUDIOFOCUS_FLAG_DELAY_OK},\n     *     {@link #AUDIOFOCUS_FLAG_PAUSES_ON_DUCKABLE_LOSS}, and {@link #AUDIOFOCUS_FLAG_LOCK}.\n     *     <br>Use 0 when not using any flags for the request, which behaves like\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, int, int)}, where either audio\n     *     focus is granted immediately, or the grant request fails because the system is in a\n     *     state where focus cannot change (e.g. a phone call).\n     * @param ap a registered {@link android.media.audiopolicy.AudioPolicy} instance when locking\n     *     focus, or null.\n     * @return see the description of the same return value in\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int)}\n     * @throws IllegalArgumentException\n     */\n    @SystemApi\n    public int requestAudioFocus(OnAudioFocusChangeListener l,\n            @NonNull AudioAttributes requestAttributes,\n            int durationHint,\n            int flags,\n            AudioPolicy ap) throws IllegalArgumentException {\n        // parameter checking\n        if (requestAttributes == null) {\n            throw new IllegalArgumentException(\"Illegal null AudioAttributes argument\");\n        }\n        if ((durationHint < AUDIOFOCUS_GAIN) ||\n                (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE)) {\n            throw new IllegalArgumentException(\"Invalid duration hint\");\n        }\n        if (flags != (flags & AUDIOFOCUS_FLAGS_SYSTEM)) {\n            throw new IllegalArgumentException(\"Illegal flags 0x\"\n                + Integer.toHexString(flags).toUpperCase());\n        }\n        if (((flags & AUDIOFOCUS_FLAG_DELAY_OK) == AUDIOFOCUS_FLAG_DELAY_OK) && (l == null)) {\n            throw new IllegalArgumentException(\n                    \"Illegal null focus listener when flagged as accepting delayed focus grant\");\n        }\n        if (((flags & AUDIOFOCUS_FLAG_LOCK) == AUDIOFOCUS_FLAG_LOCK) && (ap == null)) {\n            throw new IllegalArgumentException(\n                    \"Illegal null audio policy when locking audio focus\");\n        }\n\n        int status = AUDIOFOCUS_REQUEST_FAILED;\n        registerAudioFocusListener(l);\n        IAudioService service = getService();\n        try {\n            status = service.requestAudioFocus(requestAttributes, durationHint, mICallBack,\n                    mAudioFocusDispatcher, getIdForAudioFocusListener(l),\n                    getContext().getOpPackageName() /* package name */, flags,\n                    ap != null ? ap.cb() : null);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n        return status;\n    }"}
{"Number":"344","API Relative Path":"src.android.media.AudioManager.java-requestAudioFocus(OnAudioFocusChangeListener-AudioAttributes-int-int-AudioPolicy)","Corresponding Source":"/**\n     * @hide\n     * Request or lock audio focus.\n     * This method is to be used by system components that have registered an\n     * {@link android.media.audiopolicy.AudioPolicy} to request audio focus, but also to \"lock\" it\n     * so focus granting is temporarily disabled.\n     * @param l see the description of the same parameter in\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int)}\n     * @param requestAttributes non null {@link AudioAttributes} describing the main reason for\n     *     requesting audio focus.\n     * @param durationHint see the description of the same parameter in\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int)}\n     * @param flags 0 or a combination of {link #AUDIOFOCUS_FLAG_DELAY_OK},\n     *     {@link #AUDIOFOCUS_FLAG_PAUSES_ON_DUCKABLE_LOSS}, and {@link #AUDIOFOCUS_FLAG_LOCK}.\n     *     <br>Use 0 when not using any flags for the request, which behaves like\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, int, int)}, where either audio\n     *     focus is granted immediately, or the grant request fails because the system is in a\n     *     state where focus cannot change (e.g. a phone call).\n     * @param ap a registered {@link android.media.audiopolicy.AudioPolicy} instance when locking\n     *     focus, or null.\n     * @return see the description of the same return value in\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int)}\n     * @throws IllegalArgumentException\n     */\n    @SystemApi\n    public int requestAudioFocus(OnAudioFocusChangeListener l,\n            @NonNull AudioAttributes requestAttributes,\n            int durationHint,\n            int flags,\n            AudioPolicy ap) throws IllegalArgumentException {\n        // parameter checking\n        if (requestAttributes == null) {\n            throw new IllegalArgumentException(\"Illegal null AudioAttributes argument\");\n        }\n        if ((durationHint < AUDIOFOCUS_GAIN) ||\n                (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE)) {\n            throw new IllegalArgumentException(\"Invalid duration hint\");\n        }\n        if (flags != (flags & AUDIOFOCUS_FLAGS_SYSTEM)) {\n            throw new IllegalArgumentException(\"Illegal flags 0x\"\n                + Integer.toHexString(flags).toUpperCase());\n        }\n        if (((flags & AUDIOFOCUS_FLAG_DELAY_OK) == AUDIOFOCUS_FLAG_DELAY_OK) && (l == null)) {\n            throw new IllegalArgumentException(\n                    \"Illegal null focus listener when flagged as accepting delayed focus grant\");\n        }\n        if (((flags & AUDIOFOCUS_FLAG_LOCK) == AUDIOFOCUS_FLAG_LOCK) && (ap == null)) {\n            throw new IllegalArgumentException(\n                    \"Illegal null audio policy when locking audio focus\");\n        }\n\n        int status = AUDIOFOCUS_REQUEST_FAILED;\n        registerAudioFocusListener(l);\n        IAudioService service = getService();\n        try {\n            status = service.requestAudioFocus(requestAttributes, durationHint, mICallBack,\n                    mAudioFocusDispatcher, getIdForAudioFocusListener(l),\n                    getContext().getOpPackageName() /* package name */, flags,\n                    ap != null ? ap.cb() : null);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n        return status;\n    }"}
{"Number":"345","API Relative Path":"src.android.media.AudioManager.java-requestAudioFocus(OnAudioFocusChangeListener-AudioAttributes-int-int-AudioPolicy)","Corresponding Source":"/**\n     * @hide\n     * Request or lock audio focus.\n     * This method is to be used by system components that have registered an\n     * {@link android.media.audiopolicy.AudioPolicy} to request audio focus, but also to \"lock\" it\n     * so focus granting is temporarily disabled.\n     * @param l see the description of the same parameter in\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int)}\n     * @param requestAttributes non null {@link AudioAttributes} describing the main reason for\n     *     requesting audio focus.\n     * @param durationHint see the description of the same parameter in\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int)}\n     * @param flags 0 or a combination of {link #AUDIOFOCUS_FLAG_DELAY_OK},\n     *     {@link #AUDIOFOCUS_FLAG_PAUSES_ON_DUCKABLE_LOSS}, and {@link #AUDIOFOCUS_FLAG_LOCK}.\n     *     <br>Use 0 when not using any flags for the request, which behaves like\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, int, int)}, where either audio\n     *     focus is granted immediately, or the grant request fails because the system is in a\n     *     state where focus cannot change (e.g. a phone call).\n     * @param ap a registered {@link android.media.audiopolicy.AudioPolicy} instance when locking\n     *     focus, or null.\n     * @return see the description of the same return value in\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int)}\n     * @throws IllegalArgumentException\n     */\n    @SystemApi\n    public int requestAudioFocus(OnAudioFocusChangeListener l,\n            @NonNull AudioAttributes requestAttributes,\n            int durationHint,\n            int flags,\n            AudioPolicy ap) throws IllegalArgumentException {\n        // parameter checking\n        if (requestAttributes == null) {\n            throw new IllegalArgumentException(\"Illegal null AudioAttributes argument\");\n        }\n        if ((durationHint < AUDIOFOCUS_GAIN) ||\n                (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE)) {\n            throw new IllegalArgumentException(\"Invalid duration hint\");\n        }\n        if (flags != (flags & AUDIOFOCUS_FLAGS_SYSTEM)) {\n            throw new IllegalArgumentException(\"Illegal flags 0x\"\n                + Integer.toHexString(flags).toUpperCase());\n        }\n        if (((flags & AUDIOFOCUS_FLAG_DELAY_OK) == AUDIOFOCUS_FLAG_DELAY_OK) && (l == null)) {\n            throw new IllegalArgumentException(\n                    \"Illegal null focus listener when flagged as accepting delayed focus grant\");\n        }\n        if (((flags & AUDIOFOCUS_FLAG_LOCK) == AUDIOFOCUS_FLAG_LOCK) && (ap == null)) {\n            throw new IllegalArgumentException(\n                    \"Illegal null audio policy when locking audio focus\");\n        }\n\n        int status = AUDIOFOCUS_REQUEST_FAILED;\n        registerAudioFocusListener(l);\n        IAudioService service = getService();\n        try {\n            status = service.requestAudioFocus(requestAttributes, durationHint, mICallBack,\n                    mAudioFocusDispatcher, getIdForAudioFocusListener(l),\n                    getContext().getOpPackageName() /* package name */, flags,\n                    ap != null ? ap.cb() : null);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n        return status;\n    }"}
{"Number":"346","API Relative Path":"src.android.media.AudioManager.java-requestAudioFocus(OnAudioFocusChangeListener-AudioAttributes-int-int-AudioPolicy)","Corresponding Source":"/**\n     * @hide\n     * Request or lock audio focus.\n     * This method is to be used by system components that have registered an\n     * {@link android.media.audiopolicy.AudioPolicy} to request audio focus, but also to \"lock\" it\n     * so focus granting is temporarily disabled.\n     * @param l see the description of the same parameter in\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int)}\n     * @param requestAttributes non null {@link AudioAttributes} describing the main reason for\n     *     requesting audio focus.\n     * @param durationHint see the description of the same parameter in\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int)}\n     * @param flags 0 or a combination of {link #AUDIOFOCUS_FLAG_DELAY_OK},\n     *     {@link #AUDIOFOCUS_FLAG_PAUSES_ON_DUCKABLE_LOSS}, and {@link #AUDIOFOCUS_FLAG_LOCK}.\n     *     <br>Use 0 when not using any flags for the request, which behaves like\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, int, int)}, where either audio\n     *     focus is granted immediately, or the grant request fails because the system is in a\n     *     state where focus cannot change (e.g. a phone call).\n     * @param ap a registered {@link android.media.audiopolicy.AudioPolicy} instance when locking\n     *     focus, or null.\n     * @return see the description of the same return value in\n     *     {@link #requestAudioFocus(OnAudioFocusChangeListener, AudioAttributes, int, int)}\n     * @throws IllegalArgumentException\n     */\n    @SystemApi\n    public int requestAudioFocus(OnAudioFocusChangeListener l,\n            @NonNull AudioAttributes requestAttributes,\n            int durationHint,\n            int flags,\n            AudioPolicy ap) throws IllegalArgumentException {\n        // parameter checking\n        if (requestAttributes == null) {\n            throw new IllegalArgumentException(\"Illegal null AudioAttributes argument\");\n        }\n        if ((durationHint < AUDIOFOCUS_GAIN) ||\n                (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE)) {\n            throw new IllegalArgumentException(\"Invalid duration hint\");\n        }\n        if (flags != (flags & AUDIOFOCUS_FLAGS_SYSTEM)) {\n            throw new IllegalArgumentException(\"Illegal flags 0x\"\n                + Integer.toHexString(flags).toUpperCase());\n        }\n        if (((flags & AUDIOFOCUS_FLAG_DELAY_OK) == AUDIOFOCUS_FLAG_DELAY_OK) && (l == null)) {\n            throw new IllegalArgumentException(\n                    \"Illegal null focus listener when flagged as accepting delayed focus grant\");\n        }\n        if (((flags & AUDIOFOCUS_FLAG_LOCK) == AUDIOFOCUS_FLAG_LOCK) && (ap == null)) {\n            throw new IllegalArgumentException(\n                    \"Illegal null audio policy when locking audio focus\");\n        }\n\n        int status = AUDIOFOCUS_REQUEST_FAILED;\n        registerAudioFocusListener(l);\n        IAudioService service = getService();\n        try {\n            status = service.requestAudioFocus(requestAttributes, durationHint, mICallBack,\n                    mAudioFocusDispatcher, getIdForAudioFocusListener(l),\n                    getContext().getOpPackageName() /* package name */, flags,\n                    ap != null ? ap.cb() : null);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n        return status;\n    }"}
{"Number":"347","API Relative Path":"src.android.media.AudioManager.java-unregisterMediaButtonEventReceiver(ComponentName)","Corresponding Source":"/**\n     * Unregister the receiver of MEDIA_BUTTON intents.\n     * @param eventReceiver identifier of a {@link android.content.BroadcastReceiver}\n     *      that was registered with {@link #registerMediaButtonEventReceiver(ComponentName)}.\n     * @deprecated Use {@link MediaSession} instead.\n     */\n    @Deprecated\n    public void unregisterMediaButtonEventReceiver(ComponentName eventReceiver) {\n        if (eventReceiver == null) {\n            return;\n        }\n        // construct a PendingIntent for the media button and unregister it\n        Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);\n        //     the associated intent will be handled by the component being registered\n        mediaButtonIntent.setComponent(eventReceiver);\n        PendingIntent pi = PendingIntent.getBroadcast(getContext(),\n                0/*requestCode, ignored*/, mediaButtonIntent, 0/*flags*/);\n        unregisterMediaButtonIntent(pi);\n    }"}
{"Number":"348","API Relative Path":"src.android.media.AudioManager.java-unregisterMediaButtonEventReceiver(PendingIntent)","Corresponding Source":"/**\n     * Unregister the receiver of MEDIA_BUTTON intents.\n     * @param eventReceiver same PendingIntent that was registed with\n     *      {@link #registerMediaButtonEventReceiver(PendingIntent)}.\n     * @deprecated Use {@link MediaSession} instead.\n     */\n    @Deprecated\n    public void unregisterMediaButtonEventReceiver(PendingIntent eventReceiver) {\n        if (eventReceiver == null) {\n            return;\n        }\n        unregisterMediaButtonIntent(eventReceiver);\n    }"}
{"Number":"349","API Relative Path":"src.android.media.AudioManager.java-unregisterRemoteControlClient(RemoteControlClient)","Corresponding Source":"/**\n     * Unregisters the remote control client that was providing information to display on the\n     * remote controls.\n     * @param rcClient The remote control client to unregister.\n     * @see #registerRemoteControlClient(RemoteControlClient)\n     * @deprecated Use {@link MediaSession} instead.\n     */\n    @Deprecated\n    public void unregisterRemoteControlClient(RemoteControlClient rcClient) {\n        if ((rcClient == null) || (rcClient.getRcMediaIntent() == null)) {\n            return;\n        }\n        rcClient.unregisterWithSession(MediaSessionLegacyHelper.getHelper(getContext()));\n    }"}
{"Number":"350","API Relative Path":"src.android.media.AudioManager.java-unregisterRemoteController(RemoteController)","Corresponding Source":"/**\n     * Unregisters a {@link RemoteController}, causing it to no longer receive\n     * media metadata and playback state information, and no longer be capable\n     * of controlling playback.\n     *\n     * @param rctlr the object to unregister.\n     * @deprecated Use\n     *             {@link MediaSessionManager#removeOnActiveSessionsChangedListener(android.media.session.MediaSessionManager.OnActiveSessionsChangedListener)}\n     *             instead.\n     */\n    @Deprecated\n    public void unregisterRemoteController(RemoteController rctlr) {\n        if (rctlr == null) {\n            return;\n        }\n        rctlr.stopListeningToSessions();\n    }"}
{"Number":"351","API Relative Path":"src.android.media.audiopolicy.AudioPolicy.java-setFocusDuckingBehavior(int)","Corresponding Source":"// Note on implementation: not part of the Builder as there can be only one registered policy\n    // that handles ducking but there can be multiple policies\n    /**\n     * Sets the behavior for audio focus-related ducking.\n     * There must be a focus listener if this policy is to handle ducking.\n     * @param behavior {@link #FOCUS_POLICY_DUCKING_IN_APP} or\n     *     {@link #FOCUS_POLICY_DUCKING_IN_POLICY}\n     * @return {@link AudioManager#SUCCESS} or {@link AudioManager#ERROR} (for instance if there\n     *     is already an audio policy that handles ducking).\n     * @throws IllegalArgumentException\n     * @throws IllegalStateException\n     */\n    @SystemApi\n    public int setFocusDuckingBehavior(int behavior)\n            throws IllegalArgumentException, IllegalStateException {\n        if ((behavior != FOCUS_POLICY_DUCKING_IN_APP)\n                && (behavior != FOCUS_POLICY_DUCKING_IN_POLICY)) {\n            throw new IllegalArgumentException(\"Invalid ducking behavior \" + behavior);\n        }\n        synchronized (mLock) {\n            if (mStatus != POLICY_STATUS_REGISTERED) {\n                throw new IllegalStateException(\n                        \"Cannot change ducking behavior for unregistered policy\");\n            }\n            if ((behavior == FOCUS_POLICY_DUCKING_IN_POLICY)\n                    && (mFocusListener == null)) {\n                // there must be a focus listener if the policy handles ducking\n                throw new IllegalStateException(\n                        \"Cannot handle ducking without an audio focus listener\");\n            }\n            IAudioService service = getService();\n            try {\n                final int status = service.setFocusPropertiesForPolicy(behavior /*duckingBehavior*/,\n                        this.cb());\n                if (status == AudioManager.SUCCESS) {\n                    mConfig.mDuckingPolicy = behavior;\n                }\n                return status;\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Dead object in setFocusPropertiesForPolicy for behavior\", e);\n                return AudioManager.ERROR;\n            }\n        }\n    }"}
{"Number":"352","API Relative Path":"src.android.media.audiopolicy.AudioPolicy.java-setFocusDuckingBehavior(int)","Corresponding Source":"// Note on implementation: not part of the Builder as there can be only one registered policy\n    // that handles ducking but there can be multiple policies\n    /**\n     * Sets the behavior for audio focus-related ducking.\n     * There must be a focus listener if this policy is to handle ducking.\n     * @param behavior {@link #FOCUS_POLICY_DUCKING_IN_APP} or\n     *     {@link #FOCUS_POLICY_DUCKING_IN_POLICY}\n     * @return {@link AudioManager#SUCCESS} or {@link AudioManager#ERROR} (for instance if there\n     *     is already an audio policy that handles ducking).\n     * @throws IllegalArgumentException\n     * @throws IllegalStateException\n     */\n    @SystemApi\n    public int setFocusDuckingBehavior(int behavior)\n            throws IllegalArgumentException, IllegalStateException {\n        if ((behavior != FOCUS_POLICY_DUCKING_IN_APP)\n                && (behavior != FOCUS_POLICY_DUCKING_IN_POLICY)) {\n            throw new IllegalArgumentException(\"Invalid ducking behavior \" + behavior);\n        }\n        synchronized (mLock) {\n            if (mStatus != POLICY_STATUS_REGISTERED) {\n                throw new IllegalStateException(\n                        \"Cannot change ducking behavior for unregistered policy\");\n            }\n            if ((behavior == FOCUS_POLICY_DUCKING_IN_POLICY)\n                    && (mFocusListener == null)) {\n                // there must be a focus listener if the policy handles ducking\n                throw new IllegalStateException(\n                        \"Cannot handle ducking without an audio focus listener\");\n            }\n            IAudioService service = getService();\n            try {\n                final int status = service.setFocusPropertiesForPolicy(behavior /*duckingBehavior*/,\n                        this.cb());\n                if (status == AudioManager.SUCCESS) {\n                    mConfig.mDuckingPolicy = behavior;\n                }\n                return status;\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Dead object in setFocusPropertiesForPolicy for behavior\", e);\n                return AudioManager.ERROR;\n            }\n        }\n    }"}
{"Number":"353","API Relative Path":"src.android.media.AudioRecord.java-getTimestamp(AudioTimestamp-int)","Corresponding Source":"/**\n     * Poll for an {@link AudioTimestamp} on demand.\n     * <p>\n     * The AudioTimestamp reflects the frame delivery information at\n     * the earliest point available in the capture pipeline.\n     * <p>\n     * Calling {@link #startRecording()} following a {@link #stop()} will reset\n     * the frame count to 0.\n     *\n     * @param outTimestamp a caller provided non-null AudioTimestamp instance,\n     *        which is updated with the AudioRecord frame delivery information upon success.\n     * @param timebase one of\n     *        {@link AudioTimestamp#TIMEBASE_BOOTTIME AudioTimestamp.TIMEBASE_BOOTTIME} or\n     *        {@link AudioTimestamp#TIMEBASE_MONOTONIC AudioTimestamp.TIMEBASE_MONOTONIC},\n     *        used to select the clock for the AudioTimestamp time.\n     * @return {@link #SUCCESS} if a timestamp is available,\n     *         or {@link #ERROR_INVALID_OPERATION} if a timestamp not available.\n     */\n     public int getTimestamp(@NonNull AudioTimestamp outTimestamp,\n             @AudioTimestamp.Timebase int timebase)\n     {\n         if (outTimestamp == null ||\n                 (timebase != AudioTimestamp.TIMEBASE_BOOTTIME\n                 && timebase != AudioTimestamp.TIMEBASE_MONOTONIC)) {\n             throw new IllegalArgumentException();\n         }\n         return native_get_timestamp(outTimestamp, timebase);\n     }"}
{"Number":"354","API Relative Path":"src.android.media.AudioTrack.java-AudioTrack(AudioAttributes-AudioFormat-int-int-int)","Corresponding Source":"/**\n     * Class constructor with {@link AudioAttributes} and {@link AudioFormat}.\n     * @param attributes a non-null {@link AudioAttributes} instance.\n     * @param format a non-null {@link AudioFormat} instance describing the format of the data\n     *     that will be played through this AudioTrack. See {@link AudioFormat.Builder} for\n     *     configuring the audio format parameters such as encoding, channel mask and sample rate.\n     * @param bufferSizeInBytes the total size (in bytes) of the internal buffer where audio data is\n     *   read from for playback. This should be a nonzero multiple of the frame size in bytes.\n     *   <p> If the track's creation mode is {@link #MODE_STATIC},\n     *   this is the maximum length sample, or audio clip, that can be played by this instance.\n     *   <p> If the track's creation mode is {@link #MODE_STREAM},\n     *   this should be the desired buffer size\n     *   for the <code>AudioTrack<\/code> to satisfy the application's\n     *   latency requirements.\n     *   If <code>bufferSizeInBytes<\/code> is less than the\n     *   minimum buffer size for the output sink, it is increased to the minimum\n     *   buffer size.\n     *   The method {@link #getBufferSizeInFrames()} returns the\n     *   actual size in frames of the buffer created, which\n     *   determines the minimum frequency to write\n     *   to the streaming <code>AudioTrack<\/code> to avoid underrun.\n     *   See {@link #getMinBufferSize(int, int, int)} to determine the estimated minimum buffer size\n     *   for an AudioTrack instance in streaming mode.\n     * @param mode streaming or static buffer. See {@link #MODE_STATIC} and {@link #MODE_STREAM}.\n     * @param sessionId ID of audio session the AudioTrack must be attached to, or\n     *   {@link AudioManager#AUDIO_SESSION_ID_GENERATE} if the session isn't known at construction\n     *   time. See also {@link AudioManager#generateAudioSessionId()} to obtain a session ID before\n     *   construction.\n     * @throws IllegalArgumentException\n     */\n    public AudioTrack(AudioAttributes attributes, AudioFormat format, int bufferSizeInBytes,\n            int mode, int sessionId)\n                    throws IllegalArgumentException {\n        super(attributes);\n        // mState already == STATE_UNINITIALIZED\n\n        if (format == null) {\n            throw new IllegalArgumentException(\"Illegal null AudioFormat\");\n        }\n\n        // remember which looper is associated with the AudioTrack instantiation\n        Looper looper;\n        if ((looper = Looper.myLooper()) == null) {\n            looper = Looper.getMainLooper();\n        }\n\n        int rate = format.getSampleRate();\n        if (rate == AudioFormat.SAMPLE_RATE_UNSPECIFIED) {\n            rate = 0;\n        }\n\n        int channelIndexMask = 0;\n        if ((format.getPropertySetMask()\n                & AudioFormat.AUDIO_FORMAT_HAS_PROPERTY_CHANNEL_INDEX_MASK) != 0) {\n            channelIndexMask = format.getChannelIndexMask();\n        }\n        int channelMask = 0;\n        if ((format.getPropertySetMask()\n                & AudioFormat.AUDIO_FORMAT_HAS_PROPERTY_CHANNEL_MASK) != 0) {\n            channelMask = format.getChannelMask();\n        } else if (channelIndexMask == 0) { // if no masks at all, use stereo\n            channelMask = AudioFormat.CHANNEL_OUT_FRONT_LEFT\n                    | AudioFormat.CHANNEL_OUT_FRONT_RIGHT;\n        }\n        int encoding = AudioFormat.ENCODING_DEFAULT;\n        if ((format.getPropertySetMask() & AudioFormat.AUDIO_FORMAT_HAS_PROPERTY_ENCODING) != 0) {\n            encoding = format.getEncoding();\n        }\n        audioParamCheck(rate, channelMask, channelIndexMask, encoding, mode);\n        mStreamType = AudioSystem.STREAM_DEFAULT;\n\n        audioBuffSizeCheck(bufferSizeInBytes);\n\n        mInitializationLooper = looper;\n\n        if (sessionId < 0) {\n            throw new IllegalArgumentException(\"Invalid audio session ID: \"+sessionId);\n        }\n\n        int[] sampleRate = new int[] {mSampleRate};\n        int[] session = new int[1];\n        session[0] = sessionId;\n        // native initialization\n        int initResult = native_setup(new WeakReference<AudioTrack>(this), mAttributes,\n                sampleRate, mChannelMask, mChannelIndexMask, mAudioFormat,\n                mNativeBufferSizeInBytes, mDataLoadMode, session, 0 /*nativeTrackInJavaObj*/);\n        if (initResult != SUCCESS) {\n            loge(\"Error code \"+initResult+\" when initializing AudioTrack.\");\n            return; // with mState == STATE_UNINITIALIZED\n        }\n\n        mSampleRate = sampleRate[0];\n        mSessionId = session[0];\n\n        if (mDataLoadMode == MODE_STATIC) {\n            mState = STATE_NO_STATIC_DATA;\n        } else {\n            mState = STATE_INITIALIZED;\n        }\n    }"}
{"Number":"355","API Relative Path":"src.android.media.AudioTrack.java-setPlaybackParams(PlaybackParams)","Corresponding Source":"/**\n     * Sets the playback parameters.\n     * This method returns failure if it cannot apply the playback parameters.\n     * One possible cause is that the parameters for speed or pitch are out of range.\n     * Another possible cause is that the <code>AudioTrack<\/code> is streaming\n     * (see {@link #MODE_STREAM}) and the\n     * buffer size is too small. For speeds greater than 1.0f, the <code>AudioTrack<\/code> buffer\n     * on configuration must be larger than the speed multiplied by the minimum size\n     * {@link #getMinBufferSize(int, int, int)}) to allow proper playback.\n     * @param params see {@link PlaybackParams}. In particular,\n     * speed, pitch, and audio mode should be set.\n     * @throws IllegalArgumentException if the parameters are invalid or not accepted.\n     * @throws IllegalStateException if track is not initialized.\n     */\n    public void setPlaybackParams(@NonNull PlaybackParams params) {\n        if (params == null) {\n            throw new IllegalArgumentException(\"params is null\");\n        }\n        native_set_playback_params(params);\n    }"}
{"Number":"356","API Relative Path":"src.android.media.browse.MediaBrowser.java-getItem(String-ItemCallback)","Corresponding Source":"/**\n     * Retrieves a specific {@link MediaItem} from the connected service. Not\n     * all services may support this, so falling back to subscribing to the\n     * parent's id should be used when unavailable.\n     *\n     * @param mediaId The id of the item to retrieve.\n     * @param cb The callback to receive the result on.\n     */\n    public void getItem(final @NonNull String mediaId, @NonNull final ItemCallback cb) {\n        if (TextUtils.isEmpty(mediaId)) {\n            throw new IllegalArgumentException(\"mediaId is empty.\");\n        }\n        if (cb == null) {\n            throw new IllegalArgumentException(\"cb is null.\");\n        }\n        if (mState != CONNECT_STATE_CONNECTED) {\n            Log.i(TAG, \"Not connected, unable to retrieve the MediaItem.\");\n            mHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    cb.onError(mediaId);\n                }\n            });\n            return;\n        }\n        ResultReceiver receiver = new ResultReceiver(mHandler) {\n            @Override\n            protected void onReceiveResult(int resultCode, Bundle resultData) {\n                if (resultCode != 0 || resultData == null\n                        || !resultData.containsKey(MediaBrowserService.KEY_MEDIA_ITEM)) {\n                    cb.onError(mediaId);\n                    return;\n                }\n                Parcelable item = resultData.getParcelable(MediaBrowserService.KEY_MEDIA_ITEM);\n                if (!(item instanceof MediaItem)) {\n                    cb.onError(mediaId);\n                    return;\n                }\n                cb.onItemLoaded((MediaItem)item);\n            }\n        };\n        try {\n            mServiceBinder.getMediaItem(mediaId, receiver, mServiceCallbacks);\n        } catch (RemoteException e) {\n            Log.i(TAG, \"Remote error getting media item.\");\n            mHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    cb.onError(mediaId);\n                }\n            });\n        }\n    }"}
{"Number":"357","API Relative Path":"src.android.media.browse.MediaBrowser.java-MediaBrowser(Context-ComponentName-ConnectionCallback-Bundle)","Corresponding Source":"/**\n     * Creates a media browser for the specified media browse service.\n     *\n     * @param context The context.\n     * @param serviceComponent The component name of the media browse service.\n     * @param callback The connection callback.\n     * @param rootHints An optional bundle of service-specific arguments to send\n     * to the media browse service when connecting and retrieving the root id\n     * for browsing, or null if none. The contents of this bundle may affect\n     * the information returned when browsing.\n     * @see android.service.media.MediaBrowserService.BrowserRoot#EXTRA_RECENT\n     * @see android.service.media.MediaBrowserService.BrowserRoot#EXTRA_OFFLINE\n     * @see android.service.media.MediaBrowserService.BrowserRoot#EXTRA_SUGGESTED\n     */\n    public MediaBrowser(Context context, ComponentName serviceComponent,\n            ConnectionCallback callback, Bundle rootHints) {\n        if (context == null) {\n            throw new IllegalArgumentException(\"context must not be null\");\n        }\n        if (serviceComponent == null) {\n            throw new IllegalArgumentException(\"service component must not be null\");\n        }\n        if (callback == null) {\n            throw new IllegalArgumentException(\"connection callback must not be null\");\n        }\n        mContext = context;\n        mServiceComponent = serviceComponent;\n        mCallback = callback;\n        mRootHints = rootHints == null ? null : new Bundle(rootHints);\n    }"}
{"Number":"358","API Relative Path":"src.android.media.browse.MediaBrowser.java-MediaBrowser(Context-ComponentName-ConnectionCallback-Bundle)","Corresponding Source":"/**\n     * Creates a media browser for the specified media browse service.\n     *\n     * @param context The context.\n     * @param serviceComponent The component name of the media browse service.\n     * @param callback The connection callback.\n     * @param rootHints An optional bundle of service-specific arguments to send\n     * to the media browse service when connecting and retrieving the root id\n     * for browsing, or null if none. The contents of this bundle may affect\n     * the information returned when browsing.\n     * @see android.service.media.MediaBrowserService.BrowserRoot#EXTRA_RECENT\n     * @see android.service.media.MediaBrowserService.BrowserRoot#EXTRA_OFFLINE\n     * @see android.service.media.MediaBrowserService.BrowserRoot#EXTRA_SUGGESTED\n     */\n    public MediaBrowser(Context context, ComponentName serviceComponent,\n            ConnectionCallback callback, Bundle rootHints) {\n        if (context == null) {\n            throw new IllegalArgumentException(\"context must not be null\");\n        }\n        if (serviceComponent == null) {\n            throw new IllegalArgumentException(\"service component must not be null\");\n        }\n        if (callback == null) {\n            throw new IllegalArgumentException(\"connection callback must not be null\");\n        }\n        mContext = context;\n        mServiceComponent = serviceComponent;\n        mCallback = callback;\n        mRootHints = rootHints == null ? null : new Bundle(rootHints);\n    }"}
{"Number":"359","API Relative Path":"src.android.media.browse.MediaBrowser.java-MediaBrowser(Context-ComponentName-ConnectionCallback-Bundle)","Corresponding Source":"/**\n     * Creates a media browser for the specified media browse service.\n     *\n     * @param context The context.\n     * @param serviceComponent The component name of the media browse service.\n     * @param callback The connection callback.\n     * @param rootHints An optional bundle of service-specific arguments to send\n     * to the media browse service when connecting and retrieving the root id\n     * for browsing, or null if none. The contents of this bundle may affect\n     * the information returned when browsing.\n     * @see android.service.media.MediaBrowserService.BrowserRoot#EXTRA_RECENT\n     * @see android.service.media.MediaBrowserService.BrowserRoot#EXTRA_OFFLINE\n     * @see android.service.media.MediaBrowserService.BrowserRoot#EXTRA_SUGGESTED\n     */\n    public MediaBrowser(Context context, ComponentName serviceComponent,\n            ConnectionCallback callback, Bundle rootHints) {\n        if (context == null) {\n            throw new IllegalArgumentException(\"context must not be null\");\n        }\n        if (serviceComponent == null) {\n            throw new IllegalArgumentException(\"service component must not be null\");\n        }\n        if (callback == null) {\n            throw new IllegalArgumentException(\"connection callback must not be null\");\n        }\n        mContext = context;\n        mServiceComponent = serviceComponent;\n        mCallback = callback;\n        mRootHints = rootHints == null ? null : new Bundle(rootHints);\n    }"}
{"Number":"360","API Relative Path":"src.android.media.browse.MediaBrowser.java-subscribe(String-Bundle-SubscriptionCallback)","Corresponding Source":"/**\n     * Queries with service-specific arguments for information about the media items\n     * that are contained within the specified id and subscribes to receive updates\n     * when they change.\n     * <p>\n     * The list of subscriptions is maintained even when not connected and is\n     * restored after the reconnection. It is ok to subscribe while not connected\n     * but the results will not be returned until the connection completes.\n     * <\/p>\n     * <p>\n     * If the id is already subscribed with a different callback then the new\n     * callback will replace the previous one and the child data will be\n     * reloaded.\n     * <\/p>\n     *\n     * @param parentId The id of the parent media item whose list of children\n     *            will be subscribed.\n     * @param options A bundle of service-specific arguments to send to the media\n     *            browse service. The contents of this bundle may affect the\n     *            information returned when browsing.\n     * @param callback The callback to receive the list of children.\n     */\n    public void subscribe(@NonNull String parentId, @NonNull Bundle options,\n            @NonNull SubscriptionCallback callback) {\n        if (options == null) {\n            throw new IllegalArgumentException(\"options are null\");\n        }\n        subscribeInternal(parentId, new Bundle(options), callback);\n    }"}
{"Number":"361","API Relative Path":"src.android.media.browse.MediaBrowser.java-unsubscribe(String-SubscriptionCallback)","Corresponding Source":"/**\n     * Unsubscribes for changes to the children of the specified media id through a callback.\n     * <p>\n     * The query callback will no longer be invoked for results associated with\n     * this id once this method returns.\n     * <\/p>\n     *\n     * @param parentId The id of the parent media item whose list of children\n     *            will be unsubscribed.\n     * @param callback A callback sent to the media browse service to subscribe.\n     */\n    public void unsubscribe(@NonNull String parentId, @NonNull SubscriptionCallback callback) {\n        if (callback == null) {\n            throw new IllegalArgumentException(\"callback is null\");\n        }\n        unsubscribeInternal(parentId, callback);\n    }"}
{"Number":"362","API Relative Path":"src.android.media.CamcorderProfile.java-get(int-int)","Corresponding Source":"/**\n     * Returns the camcorder profile for the given camera at the given\n     * quality level.\n     *\n     * Quality levels QUALITY_LOW, QUALITY_HIGH are guaranteed to be supported, while\n     * other levels may or may not be supported. The supported levels can be checked using\n     * {@link #hasProfile(int, int)}.\n     * QUALITY_LOW refers to the lowest quality available, while QUALITY_HIGH refers to\n     * the highest quality available.\n     * QUALITY_LOW/QUALITY_HIGH have to match one of qcif, cif, 480p, 720p, 1080p or 2160p.\n     * E.g. if the device supports 480p, 720p, 1080p and 2160p, then low is 480p and high is\n     * 2160p.\n     *\n     * The same is true for time lapse quality levels, i.e. QUALITY_TIME_LAPSE_LOW,\n     * QUALITY_TIME_LAPSE_HIGH are guaranteed to be supported and have to match one of\n     * qcif, cif, 480p, 720p, 1080p, or 2160p.\n     *\n     * For high speed quality levels, they may or may not be supported. If a subset of the levels\n     * are supported, QUALITY_HIGH_SPEED_LOW and QUALITY_HIGH_SPEED_HIGH are guaranteed to be\n     * supported and have to match one of 480p, 720p, or 1080p.\n     *\n     * A camcorder recording session with higher quality level usually has higher output\n     * bit rate, better video and/or audio recording quality, larger video frame\n     * resolution and higher audio sampling rate, etc, than those with lower quality\n     * level.\n     *\n     * @param cameraId the id for the camera\n     * @param quality the target quality level for the camcorder profile.\n     * @see #QUALITY_LOW\n     * @see #QUALITY_HIGH\n     * @see #QUALITY_QCIF\n     * @see #QUALITY_CIF\n     * @see #QUALITY_480P\n     * @see #QUALITY_720P\n     * @see #QUALITY_1080P\n     * @see #QUALITY_2160P\n     * @see #QUALITY_TIME_LAPSE_LOW\n     * @see #QUALITY_TIME_LAPSE_HIGH\n     * @see #QUALITY_TIME_LAPSE_QCIF\n     * @see #QUALITY_TIME_LAPSE_CIF\n     * @see #QUALITY_TIME_LAPSE_480P\n     * @see #QUALITY_TIME_LAPSE_720P\n     * @see #QUALITY_TIME_LAPSE_1080P\n     * @see #QUALITY_TIME_LAPSE_2160P\n     * @see #QUALITY_HIGH_SPEED_LOW\n     * @see #QUALITY_HIGH_SPEED_HIGH\n     * @see #QUALITY_HIGH_SPEED_480P\n     * @see #QUALITY_HIGH_SPEED_720P\n     * @see #QUALITY_HIGH_SPEED_1080P\n     * @see #QUALITY_HIGH_SPEED_2160P\n    */\n    public static CamcorderProfile get(int cameraId, int quality) {\n        if (!((quality >= QUALITY_LIST_START &&\n               quality <= QUALITY_LIST_END) ||\n              (quality >= QUALITY_TIME_LAPSE_LIST_START &&\n               quality <= QUALITY_TIME_LAPSE_LIST_END) ||\n               (quality >= QUALITY_HIGH_SPEED_LIST_START &&\n               quality <= QUALITY_HIGH_SPEED_LIST_END))) {\n            String errMessage = \"Unsupported quality level: \" + quality;\n            throw new IllegalArgumentException(errMessage);\n        }\n        return native_get_camcorder_profile(cameraId, quality);\n    }"}
{"Number":"363","API Relative Path":"src.android.media.CameraProfile.java-getJpegEncodingQualityParameter(int-int)","Corresponding Source":"/**\n     * Returns a pre-defined still image capture (jpeg) quality level\n     * used for the given quality level in the Camera application for\n     * the specified camera.\n     *\n     * @param cameraId The id of the camera\n     * @param quality The target quality level\n     */\n    public static int getJpegEncodingQualityParameter(int cameraId, int quality) {\n        if (quality < QUALITY_LOW || quality > QUALITY_HIGH) {\n            throw new IllegalArgumentException(\"Unsupported quality level: \" + quality);\n        }\n        synchronized (sCache) {\n            int[] levels = sCache.get(cameraId);\n            if (levels == null) {\n                levels = getImageEncodingQualityLevels(cameraId);\n                sCache.put(cameraId, levels);\n            }\n            return levels[quality];\n        }\n    }"}
{"Number":"364","API Relative Path":"src.android.media.ExifInterface.java-ExifInterface(FileDescriptor)","Corresponding Source":"/**\n     * Reads Exif tags from the specified image file descriptor. Attribute mutation is supported\n     * for writable and seekable file descriptors only. This constructor will not rewind the offset\n     * of the given file descriptor. Developers should close the file descriptor after use.\n     */\n    public ExifInterface(FileDescriptor fileDescriptor) throws IOException {\n        if (fileDescriptor == null) {\n            throw new IllegalArgumentException(\"fileDescriptor cannot be null\");\n        }\n        mAssetInputStream = null;\n        mFilename = null;\n        if (isSeekableFD(fileDescriptor)) {\n            mSeekableFileDescriptor = fileDescriptor;\n            // Keep the original file descriptor in order to save attributes when it's seekable.\n            // Otherwise, just close the given file descriptor after reading it because the save\n            // feature won't be working.\n            try {\n                fileDescriptor = Os.dup(fileDescriptor);\n            } catch (ErrnoException e) {\n                throw e.rethrowAsIOException();\n            }\n        } else {\n            mSeekableFileDescriptor = null;\n        }\n        mIsInputStream = false;\n        FileInputStream in = null;\n        try {\n            in = new FileInputStream(fileDescriptor);\n            loadAttributes(in);\n        } finally {\n            IoUtils.closeQuietly(in);\n        }\n    }"}
{"Number":"365","API Relative Path":"src.android.media.ExifInterface.java-ExifInterface(InputStream)","Corresponding Source":"/**\n     * Reads Exif tags from the specified image input stream. Attribute mutation is not supported\n     * for input streams. The given input stream will proceed its current position. Developers\n     * should close the input stream after use.\n     */\n    public ExifInterface(InputStream inputStream) throws IOException {\n        if (inputStream == null) {\n            throw new IllegalArgumentException(\"inputStream cannot be null\");\n        }\n        mFilename = null;\n        if (inputStream instanceof AssetManager.AssetInputStream) {\n            mAssetInputStream = (AssetManager.AssetInputStream) inputStream;\n            mSeekableFileDescriptor = null;\n        } else if (inputStream instanceof FileInputStream\n                && isSeekableFD(((FileInputStream) inputStream).getFD())) {\n            mAssetInputStream = null;\n            mSeekableFileDescriptor = ((FileInputStream) inputStream).getFD();\n        } else {\n            mAssetInputStream = null;\n            mSeekableFileDescriptor = null;\n        }\n        mIsInputStream = true;\n        loadAttributes(inputStream);\n    }"}
{"Number":"366","API Relative Path":"src.android.media.ExifInterface.java-ExifInterface(String)","Corresponding Source":"/**\n     * Reads Exif tags from the specified image file.\n     */\n    public ExifInterface(String filename) throws IOException {\n        if (filename == null) {\n            throw new IllegalArgumentException(\"filename cannot be null\");\n        }\n        FileInputStream in = null;\n        mAssetInputStream = null;\n        mFilename = filename;\n        mIsInputStream = false;\n        try {\n            in = new FileInputStream(filename);\n            if (isSeekableFD(in.getFD())) {\n                mSeekableFileDescriptor = in.getFD();\n            } else {\n                mSeekableFileDescriptor = null;\n            }\n            loadAttributes(in);\n        } finally {\n            IoUtils.closeQuietly(in);\n        }\n    }"}
{"Number":"367","API Relative Path":"src.android.media.FaceDetector.java-findFaces(Bitmap-Face[])","Corresponding Source":"/**\n     * Finds all the faces found in a given {@link android.graphics.Bitmap}. \n     * The supplied array is populated with {@link FaceDetector.Face}s for each\n     * face found. The bitmap must be in 565 format (for now).\n     * \n     * @param bitmap the {@link android.graphics.Bitmap} graphic to be analyzed\n     * @param faces  an array in which to place all found \n     *               {@link FaceDetector.Face}s. The array must be sized equal\n     *               to the <var>maxFaces<\/var> value set at initialization\n     * @return the number of faces found\n     * @throws IllegalArgumentException if the Bitmap dimensions don't match\n     *               the dimensions defined at initialization or the given array \n     *               is not sized equal to the <var>maxFaces<\/var> value defined\n     *               at initialization\n     */\n    public int findFaces(Bitmap bitmap, Face[] faces)\n    {\n        if (!sInitialized) {\n            return 0;\n        }\n        if (bitmap.getWidth() != mWidth || bitmap.getHeight() != mHeight) {\n            throw new IllegalArgumentException(\n                    \"bitmap size doesn't match initialization\");\n        }\n        if (faces.length < mMaxFaces) {\n            throw new IllegalArgumentException(\n                    \"faces[] smaller than maxFaces\");\n        }\n        \n        int numFaces = fft_detect(bitmap);\n        if (numFaces >= mMaxFaces)\n            numFaces = mMaxFaces;\n        for (int i=0 ; i<numFaces ; i++) {\n            if (faces[i] == null)\n                faces[i] = new Face();\n            fft_get_face(faces[i], i);\n        }\n        return numFaces;\n    }"}
{"Number":"368","API Relative Path":"src.android.media.ImageReader.java-detachImage(Image)","Corresponding Source":"private synchronized native int nativeDetachImage(Image i);"}
{"Number":"369","API Relative Path":"src.android.media.ImageReader.java-ImageReader(int-int-int-int)","Corresponding Source":"/**\n     * @hide\n     */\n    protected ImageReader(int width, int height, int format, int maxImages) {\n        mWidth = width;\n        mHeight = height;\n        mFormat = format;\n        mMaxImages = maxImages;\n\n        if (width < 1 || height < 1) {\n            throw new IllegalArgumentException(\n                \"The image dimensions must be positive\");\n        }\n        if (mMaxImages < 1) {\n            throw new IllegalArgumentException(\n                \"Maximum outstanding image count must be at least 1\");\n        }\n\n        if (format == ImageFormat.NV21) {\n            throw new IllegalArgumentException(\n                    \"NV21 format is not supported\");\n        }\n\n        mNumPlanes = ImageUtils.getNumPlanesForFormat(mFormat);\n\n        nativeInit(new WeakReference<ImageReader>(this), width, height, format, maxImages);\n\n        mSurface = nativeGetSurface();\n\n        mIsReaderValid = true;\n        // Estimate the native buffer allocation size and register it so it gets accounted for\n        // during GC. Note that this doesn't include the buffers required by the buffer queue\n        // itself and the buffers requested by the producer.\n        // Only include memory for 1 buffer, since actually accounting for the memory used is\n        // complex, and 1 buffer is enough for the VM to treat the ImageReader as being of some\n        // size.\n        mEstimatedNativeAllocBytes = ImageUtils.getEstimatedNativeAllocBytes(\n                width, height, format, /*buffer count*/ 1);\n        VMRuntime.getRuntime().registerNativeAllocation(mEstimatedNativeAllocBytes);\n    }"}
{"Number":"370","API Relative Path":"src.android.media.ImageReader.java-ImageReader(int-int-int-int)","Corresponding Source":"/**\n     * @hide\n     */\n    protected ImageReader(int width, int height, int format, int maxImages) {\n        mWidth = width;\n        mHeight = height;\n        mFormat = format;\n        mMaxImages = maxImages;\n\n        if (width < 1 || height < 1) {\n            throw new IllegalArgumentException(\n                \"The image dimensions must be positive\");\n        }\n        if (mMaxImages < 1) {\n            throw new IllegalArgumentException(\n                \"Maximum outstanding image count must be at least 1\");\n        }\n\n        if (format == ImageFormat.NV21) {\n            throw new IllegalArgumentException(\n                    \"NV21 format is not supported\");\n        }\n\n        mNumPlanes = ImageUtils.getNumPlanesForFormat(mFormat);\n\n        nativeInit(new WeakReference<ImageReader>(this), width, height, format, maxImages);\n\n        mSurface = nativeGetSurface();\n\n        mIsReaderValid = true;\n        // Estimate the native buffer allocation size and register it so it gets accounted for\n        // during GC. Note that this doesn't include the buffers required by the buffer queue\n        // itself and the buffers requested by the producer.\n        // Only include memory for 1 buffer, since actually accounting for the memory used is\n        // complex, and 1 buffer is enough for the VM to treat the ImageReader as being of some\n        // size.\n        mEstimatedNativeAllocBytes = ImageUtils.getEstimatedNativeAllocBytes(\n                width, height, format, /*buffer count*/ 1);\n        VMRuntime.getRuntime().registerNativeAllocation(mEstimatedNativeAllocBytes);\n    }"}
{"Number":"371","API Relative Path":"src.android.media.ImageReader.java-setOnImageAvailableListener(OnImageAvailableListener-Handler)","Corresponding Source":"/**\n     * Register a listener to be invoked when a new image becomes available\n     * from the ImageReader.\n     *\n     * @param listener\n     *            The listener that will be run.\n     * @param handler\n     *            The handler on which the listener should be invoked, or null\n     *            if the listener should be invoked on the calling thread's looper.\n     * @throws IllegalArgumentException\n     *            If no handler specified and the calling thread has no looper.\n     */\n    public void setOnImageAvailableListener(OnImageAvailableListener listener, Handler handler) {\n        synchronized (mListenerLock) {\n            if (listener != null) {\n                Looper looper = handler != null ? handler.getLooper() : Looper.myLooper();\n                if (looper == null) {\n                    throw new IllegalArgumentException(\n                            \"handler is null but the current thread is not a looper\");\n                }\n                if (mListenerHandler == null || mListenerHandler.getLooper() != looper) {\n                    mListenerHandler = new ListenerHandler(looper);\n                }\n                mListener = listener;\n            } else {\n                mListener = null;\n                mListenerHandler = null;\n            }\n        }\n    }"}
{"Number":"372","API Relative Path":"src.android.media.ImageUtils.java-imageCopy(Image-Image)","Corresponding Source":"/**\n     * <p>\n     * Copy source image data to destination Image.\n     * <\/p>\n     * <p>\n     * Only support the copy between two non-{@link ImageFormat#PRIVATE PRIVATE} format\n     * images with same properties (format, size, etc.). The data from the\n     * source image will be copied to the byteBuffers from the destination Image\n     * starting from position zero, and the destination image will be rewound to\n     * zero after copy is done.\n     * <\/p>\n     *\n     * @param src The source image to be copied from.\n     * @param dst The destination image to be copied to.\n     * @throws IllegalArgumentException If the source and destination images\n     *             have different format, or one of the images is not copyable.\n     */\n    public static void imageCopy(Image src, Image dst) {\n        if (src == null || dst == null) {\n            throw new IllegalArgumentException(\"Images should be non-null\");\n        }\n        if (src.getFormat() != dst.getFormat()) {\n            throw new IllegalArgumentException(\"Src and dst images should have the same format\");\n        }\n        if (src.getFormat() == ImageFormat.PRIVATE ||\n                dst.getFormat() == ImageFormat.PRIVATE) {\n            throw new IllegalArgumentException(\"PRIVATE format images are not copyable\");\n        }\n        if (src.getFormat() == ImageFormat.RAW_PRIVATE) {\n            throw new IllegalArgumentException(\n                    \"Copy of RAW_OPAQUE format has not been implemented\");\n        }\n        if (!(dst.getOwner() instanceof ImageWriter)) {\n            throw new IllegalArgumentException(\"Destination image is not from ImageWriter. Only\"\n                    + \" the images from ImageWriter are writable\");\n        }\n        Size srcSize = new Size(src.getWidth(), src.getHeight());\n        Size dstSize = new Size(dst.getWidth(), dst.getHeight());\n        if (!srcSize.equals(dstSize)) {\n            throw new IllegalArgumentException(\"source image size \" + srcSize + \" is different\"\n                    + \" with \" + \"destination image size \" + dstSize);\n        }\n\n        Plane[] srcPlanes = src.getPlanes();\n        Plane[] dstPlanes = dst.getPlanes();\n        ByteBuffer srcBuffer = null;\n        ByteBuffer dstBuffer = null;\n        for (int i = 0; i < srcPlanes.length; i++) {\n            int srcRowStride = srcPlanes[i].getRowStride();\n            int dstRowStride = dstPlanes[i].getRowStride();\n            srcBuffer = srcPlanes[i].getBuffer();\n            dstBuffer = dstPlanes[i].getBuffer();\n            if (!(srcBuffer.isDirect() && dstBuffer.isDirect())) {\n                throw new IllegalArgumentException(\"Source and destination ByteBuffers must be\"\n                        + \" direct byteBuffer!\");\n            }\n            if (srcPlanes[i].getPixelStride() != dstPlanes[i].getPixelStride()) {\n                throw new IllegalArgumentException(\"Source plane image pixel stride \" +\n                        srcPlanes[i].getPixelStride() +\n                        \" must be same as destination image pixel stride \" +\n                        dstPlanes[i].getPixelStride());\n            }\n\n            int srcPos = srcBuffer.position();\n            srcBuffer.rewind();\n            dstBuffer.rewind();\n            if (srcRowStride == dstRowStride) {\n                // Fast path, just copy the content if the byteBuffer all together.\n                dstBuffer.put(srcBuffer);\n            } else {\n                // Source and destination images may have different alignment requirements,\n                // therefore may have different strides. Copy row by row for such case.\n                int srcOffset = srcBuffer.position();\n                int dstOffset = dstBuffer.position();\n                Size effectivePlaneSize = getEffectivePlaneSizeForImage(src, i);\n                int srcByteCount = effectivePlaneSize.getWidth() * srcPlanes[i].getPixelStride();\n                for (int row = 0; row < effectivePlaneSize.getHeight(); row++) {\n                    if (row == effectivePlaneSize.getHeight() - 1) {\n                        // Special case for NV21 backed YUV420_888: need handle the last row\n                        // carefully to avoid memory corruption. Check if we have enough bytes to\n                        // copy.\n                        int remainingBytes = srcBuffer.remaining() - srcOffset;\n                        if (srcByteCount > remainingBytes) {\n                            srcByteCount = remainingBytes;\n                        }\n                    }\n                    directByteBufferCopy(srcBuffer, srcOffset, dstBuffer, dstOffset, srcByteCount);\n                    srcOffset += srcRowStride;\n                    dstOffset += dstRowStride;\n                }\n            }\n\n            srcBuffer.position(srcPos);\n            dstBuffer.rewind();\n        }\n    }"}
{"Number":"373","API Relative Path":"src.android.media.ImageWriter.java-ImageWriter(Surface-int)","Corresponding Source":"/**\n     * @hide\n     */\n    protected ImageWriter(Surface surface, int maxImages) {\n        if (surface == null || maxImages < 1) {\n            throw new IllegalArgumentException(\"Illegal input argument: surface \" + surface\n                    + \", maxImages: \" + maxImages);\n        }\n\n        mMaxImages = maxImages;\n        // Note that the underlying BufferQueue is working in synchronous mode\n        // to avoid dropping any buffers.\n        mNativeContext = nativeInit(new WeakReference<ImageWriter>(this), surface, maxImages);\n\n        // Estimate the native buffer allocation size and register it so it gets accounted for\n        // during GC. Note that this doesn't include the buffers required by the buffer queue\n        // itself and the buffers requested by the producer.\n        // Only include memory for 1 buffer, since actually accounting for the memory used is\n        // complex, and 1 buffer is enough for the VM to treat the ImageWriter as being of some\n        // size.\n        Size surfSize = SurfaceUtils.getSurfaceSize(surface);\n        int format = SurfaceUtils.getSurfaceFormat(surface);\n        mEstimatedNativeAllocBytes =\n                ImageUtils.getEstimatedNativeAllocBytes(surfSize.getWidth(),surfSize.getHeight(),\n                        format, /*buffer count*/ 1);\n        VMRuntime.getRuntime().registerNativeAllocation(mEstimatedNativeAllocBytes);\n    }"}
{"Number":"374","API Relative Path":"src.android.media.ImageWriter.java-queueInputImage(Image)","Corresponding Source":"/**\n     * <p>\n     * Attach and queue input Image to this ImageWriter.\n     * <\/p>\n     * <p>\n     * When the format of an Image is {@link ImageFormat#PRIVATE PRIVATE}, or\n     * the source Image is so large that copying its data is too expensive, this\n     * method can be used to migrate the source Image into ImageWriter without a\n     * data copy, and then queue it to this ImageWriter. The source Image must\n     * be detached from its previous owner already, or this call will throw an\n     * {@link IllegalStateException}.\n     * <\/p>\n     * <p>\n     * After this call, the ImageWriter takes ownership of this Image. This\n     * ownership will automatically be removed from this writer after the\n     * consumer releases this Image, that is, after\n     * {@link OnImageReleasedListener#onImageReleased}. The caller is responsible for\n     * closing this Image through {@link Image#close()} to free up the resources\n     * held by this Image.\n     * <\/p>\n     *\n     * @param image The source Image to be attached and queued into this\n     *            ImageWriter for downstream consumer to use.\n     * @throws IllegalStateException if the Image is not detached from its\n     *             previous owner, or the Image is already attached to this\n     *             ImageWriter, or the source Image is invalid.\n     */\n    private void attachAndQueueInputImage(Image image) {\n        if (image == null) {\n            throw new IllegalArgumentException(\"image shouldn't be null\");\n        }\n        if (isImageOwnedByMe(image)) {\n            throw new IllegalArgumentException(\n                    \"Can not attach an image that is owned ImageWriter already\");\n        }\n        /**\n         * Throw ISE if the image is not attachable, which means that it is\n         * either owned by other entity now, or completely non-attachable (some\n         * stand-alone images are not backed by native gralloc buffer, thus not\n         * attachable).\n         */\n        if (!image.isAttachable()) {\n            throw new IllegalStateException(\"Image was not detached from last owner, or image \"\n                    + \" is not detachable\");\n        }\n\n        // TODO: what if attach failed, throw RTE or detach a slot then attach?\n        // need do some cleanup to make sure no orphaned\n        // buffer caused leak.\n        Rect crop = image.getCropRect();\n        nativeAttachAndQueueImage(mNativeContext, image.getNativeContext(), image.getFormat(),\n                image.getTimestamp(), crop.left, crop.top, crop.right, crop.bottom);\n    }"}
{"Number":"375","API Relative Path":"src.android.media.ImageWriter.java-queueInputImage(Image)","Corresponding Source":"/**\n     * <p>\n     * Attach and queue input Image to this ImageWriter.\n     * <\/p>\n     * <p>\n     * When the format of an Image is {@link ImageFormat#PRIVATE PRIVATE}, or\n     * the source Image is so large that copying its data is too expensive, this\n     * method can be used to migrate the source Image into ImageWriter without a\n     * data copy, and then queue it to this ImageWriter. The source Image must\n     * be detached from its previous owner already, or this call will throw an\n     * {@link IllegalStateException}.\n     * <\/p>\n     * <p>\n     * After this call, the ImageWriter takes ownership of this Image. This\n     * ownership will automatically be removed from this writer after the\n     * consumer releases this Image, that is, after\n     * {@link OnImageReleasedListener#onImageReleased}. The caller is responsible for\n     * closing this Image through {@link Image#close()} to free up the resources\n     * held by this Image.\n     * <\/p>\n     *\n     * @param image The source Image to be attached and queued into this\n     *            ImageWriter for downstream consumer to use.\n     * @throws IllegalStateException if the Image is not detached from its\n     *             previous owner, or the Image is already attached to this\n     *             ImageWriter, or the source Image is invalid.\n     */\n    private void attachAndQueueInputImage(Image image) {\n        if (image == null) {\n            throw new IllegalArgumentException(\"image shouldn't be null\");\n        }\n        if (isImageOwnedByMe(image)) {\n            throw new IllegalArgumentException(\n                    \"Can not attach an image that is owned ImageWriter already\");\n        }\n        /**\n         * Throw ISE if the image is not attachable, which means that it is\n         * either owned by other entity now, or completely non-attachable (some\n         * stand-alone images are not backed by native gralloc buffer, thus not\n         * attachable).\n         */\n        if (!image.isAttachable()) {\n            throw new IllegalStateException(\"Image was not detached from last owner, or image \"\n                    + \" is not detachable\");\n        }\n\n        // TODO: what if attach failed, throw RTE or detach a slot then attach?\n        // need do some cleanup to make sure no orphaned\n        // buffer caused leak.\n        Rect crop = image.getCropRect();\n        nativeAttachAndQueueImage(mNativeContext, image.getNativeContext(), image.getFormat(),\n                image.getTimestamp(), crop.left, crop.top, crop.right, crop.bottom);\n    }"}
{"Number":"376","API Relative Path":"src.android.media.ImageWriter.java-setOnImageReleasedListener(OnImageReleasedListener-Handler)","Corresponding Source":"/**\n     * Register a listener to be invoked when an input Image is returned to the\n     * ImageWriter.\n     *\n     * @param listener The listener that will be run.\n     * @param handler The handler on which the listener should be invoked, or\n     *            null if the listener should be invoked on the calling thread's\n     *            looper.\n     * @throws IllegalArgumentException If no handler specified and the calling\n     *             thread has no looper.\n     */\n    public void setOnImageReleasedListener(OnImageReleasedListener listener, Handler handler) {\n        synchronized (mListenerLock) {\n            if (listener != null) {\n                Looper looper = handler != null ? handler.getLooper() : Looper.myLooper();\n                if (looper == null) {\n                    throw new IllegalArgumentException(\n                            \"handler is null but the current thread is not a looper\");\n                }\n                if (mListenerHandler == null || mListenerHandler.getLooper() != looper) {\n                    mListenerHandler = new ListenerHandler(looper);\n                }\n                mListener = listener;\n            } else {\n                mListener = null;\n                mListenerHandler = null;\n            }\n        }\n    }"}
{"Number":"377","API Relative Path":"src.android.media.MediaActionSound.java-load(int)","Corresponding Source":"/**\n     * Preload a predefined platform sound to minimize latency when the sound is\n     * played later by {@link #play}.\n     * @param soundName The type of sound to preload, selected from\n     *         SHUTTER_CLICK, FOCUS_COMPLETE, START_VIDEO_RECORDING, or\n     *         STOP_VIDEO_RECORDING.\n     * @see #play\n     * @see #SHUTTER_CLICK\n     * @see #FOCUS_COMPLETE\n     * @see #START_VIDEO_RECORDING\n     * @see #STOP_VIDEO_RECORDING\n     */\n    public void load(int soundName) {\n        if (soundName < 0 || soundName >= SOUND_FILES.length) {\n            throw new RuntimeException(\"Unknown sound requested: \" + soundName);\n        }\n        SoundState sound = mSounds[soundName];\n        synchronized (sound) {\n            switch (sound.state) {\n            case STATE_NOT_LOADED:\n                if (loadSound(sound) <= 0) {\n                    Log.e(TAG, \"load() error loading sound: \" + soundName);\n                }\n                break;\n            default:\n                Log.e(TAG, \"load() called in wrong state: \" + sound + \" for sound: \"+ soundName);\n                break;\n            }\n        }\n    }"}
{"Number":"378","API Relative Path":"src.android.media.MediaActionSound.java-play(int)","Corresponding Source":"/**\n     * <p>Play one of the predefined platform sounds for media actions.<\/p>\n     *\n     * <p>Use this method to play a platform-specific sound for various media\n     * actions. The sound playback is done asynchronously, with the same\n     * behavior and content as the sounds played by\n     * {@link android.hardware.Camera#takePicture Camera.takePicture},\n     * {@link android.media.MediaRecorder#start MediaRecorder.start}, and\n     * {@link android.media.MediaRecorder#stop MediaRecorder.stop}.<\/p>\n     *\n     * <p>With the {@link android.hardware.camera2 camera2} API, this method can be used to play\n     * standard camera operation sounds with the appropriate system behavior for such sounds.<\/p>\n\n     * <p>With the older {@link android.hardware.Camera} API, using this method makes it easy to\n     * match the default device sounds when recording or capturing data through the preview\n     * callbacks, or when implementing custom camera-like features in your application.<\/p>\n     *\n     * <p>If the sound has not been loaded by {@link #load} before calling play,\n     * play will load the sound at the cost of some additional latency before\n     * sound playback begins. <\/p>\n     *\n     * @param soundName The type of sound to play, selected from\n     *         SHUTTER_CLICK, FOCUS_COMPLETE, START_VIDEO_RECORDING, or\n     *         STOP_VIDEO_RECORDING.\n     * @see android.hardware.Camera#takePicture\n     * @see android.media.MediaRecorder\n     * @see #SHUTTER_CLICK\n     * @see #FOCUS_COMPLETE\n     * @see #START_VIDEO_RECORDING\n     * @see #STOP_VIDEO_RECORDING\n     */\n    public void play(int soundName) {\n        if (soundName < 0 || soundName >= SOUND_FILES.length) {\n            throw new RuntimeException(\"Unknown sound requested: \" + soundName);\n        }\n        SoundState sound = mSounds[soundName];\n        synchronized (sound) {\n            switch (sound.state) {\n            case STATE_NOT_LOADED:\n                loadSound(sound);\n                if (loadSound(sound) <= 0) {\n                    Log.e(TAG, \"play() error loading sound: \" + soundName);\n                    break;\n                }\n                // FALL THROUGH\n\n            case STATE_LOADING:\n                sound.state = STATE_LOADING_PLAY_REQUESTED;\n                break;\n            case STATE_LOADED:\n                mSoundPool.play(sound.id, 1.0f, 1.0f, 0, 0, 1.0f);\n                break;\n            default:\n                Log.e(TAG, \"play() called in wrong state: \" + sound.state + \" for sound: \"+ soundName);\n                break;\n            }\n        }\n    }"}
{"Number":"379","API Relative Path":"src.android.media.MediaCodec.java-setInputSurface(Surface)","Corresponding Source":"private native final void native_setInputSurface(@NonNull Surface surface);"}
{"Number":"380","API Relative Path":"src.android.media.MediaCodec.java-setParameters(Bundle)","Corresponding Source":"/**\n     * Communicate additional parameter changes to the component instance.\n     * <b>Note:<\/b> Some of these parameter changes may silently fail to apply.\n     *\n     * @param params The bundle of parameters to set.\n     * @throws IllegalStateException if in the Released state.\n     */\n    public final void setParameters(@Nullable Bundle params) {\n        if (params == null) {\n            return;\n        }\n\n        String[] keys = new String[params.size()];\n        Object[] values = new Object[params.size()];\n\n        int i = 0;\n        for (final String key: params.keySet()) {\n            keys[i] = key;\n            values[i] = params.get(key);\n            ++i;\n        }\n\n        setParameters(keys, values);\n    }"}
{"Number":"381","API Relative Path":"src.android.media.MediaCodecList.java-getCodecInfoAt(int)","Corresponding Source":"/**\n     * Return the {@link MediaCodecInfo} object for the codec at\n     * the given {@code index} in the regular list.\n     *\n     * @deprecated Use {@link #getCodecInfos} instead.\n     *\n     * @see #REGULAR_CODECS\n     */\n    public static final MediaCodecInfo getCodecInfoAt(int index) {\n        initCodecList();\n        if (index < 0 || index > sRegularCodecInfos.length) {\n            throw new IllegalArgumentException();\n        }\n        return sRegularCodecInfos[index];\n    }"}
{"Number":"382","API Relative Path":"src.android.media.MediaMetadataRetriever.java-getFrameAtTime(long-int)","Corresponding Source":"private native Bitmap _getFrameAtTime(long timeUs, int option);"}
{"Number":"383","API Relative Path":"src.android.media.MediaMetadataRetriever.java-setDataSource(Context-Uri)","Corresponding Source":"/**\n     * Sets the data source as a content Uri. Call this method before \n     * the rest of the methods in this class. This method may be time-consuming.\n     * \n     * @param context the Context to use when resolving the Uri\n     * @param uri the Content URI of the data you want to play\n     * @throws IllegalArgumentException if the Uri is invalid\n     * @throws SecurityException if the Uri cannot be used due to lack of\n     * permission.\n     */\n    public void setDataSource(Context context, Uri uri)\n        throws IllegalArgumentException, SecurityException {\n        if (uri == null) {\n            throw new IllegalArgumentException();\n        }\n        \n        String scheme = uri.getScheme();\n        if(scheme == null || scheme.equals(\"file\")) {\n            setDataSource(uri.getPath());\n            return;\n        }\n\n        AssetFileDescriptor fd = null;\n        try {\n            ContentResolver resolver = context.getContentResolver();\n            try {\n                fd = resolver.openAssetFileDescriptor(uri, \"r\");\n            } catch(FileNotFoundException e) {\n                throw new IllegalArgumentException();\n            }\n            if (fd == null) {\n                throw new IllegalArgumentException();\n            }\n            FileDescriptor descriptor = fd.getFileDescriptor();\n            if (!descriptor.valid()) {\n                throw new IllegalArgumentException();\n            }\n            // Note: using getDeclaredLength so that our behavior is the same\n            // as previous versions when the content provider is returning\n            // a full file.\n            if (fd.getDeclaredLength() < 0) {\n                setDataSource(descriptor);\n            } else {\n                setDataSource(descriptor, fd.getStartOffset(), fd.getDeclaredLength());\n            }\n            return;\n        } catch (SecurityException ex) {\n        } finally {\n            try {\n                if (fd != null) {\n                    fd.close();\n                }\n            } catch(IOException ioEx) {\n            }\n        }\n        setDataSource(uri.toString());\n    }"}
{"Number":"384","API Relative Path":"src.android.media.MediaMetadataRetriever.java-setDataSource(String)","Corresponding Source":"/**\n     * Sets the data source (file pathname) to use. Call this\n     * method before the rest of the methods in this class. This method may be\n     * time-consuming.\n     * \n     * @param path The path of the input media file.\n     * @throws IllegalArgumentException If the path is invalid.\n     */\n    public void setDataSource(String path) throws IllegalArgumentException {\n        if (path == null) {\n            throw new IllegalArgumentException();\n        }\n\n        try (FileInputStream is = new FileInputStream(path)) {\n            FileDescriptor fd = is.getFD();\n            setDataSource(fd, 0, 0x7ffffffffffffffL);\n        } catch (FileNotFoundException fileEx) {\n            throw new IllegalArgumentException();\n        } catch (IOException ioEx) {\n            throw new IllegalArgumentException();\n        }\n    }"}
{"Number":"385","API Relative Path":"src.android.media.MediaMuxer.java-addTrack(MediaFormat)","Corresponding Source":"/**\n     * Adds a track with the specified format.\n     * <p>\n     * The following table summarizes support for specific format keys across android releases.\n     * Keys marked with '+:' are required.\n     *\n     * <table style=\"width: 0%\">\n     *  <thead>\n     *   <tr>\n     *    <th rowspan=2>OS Version(s)<\/th>\n     *    <td colspan=3>{@code MediaFormat} keys used for<\/th>\n     *   <\/tr><tr>\n     *    <th>All Tracks<\/th>\n     *    <th>Audio Tracks<\/th>\n     *    <th>Video Tracks<\/th>\n     *   <\/tr>\n     *  <\/thead>\n     *  <tbody>\n     *   <tr>\n     *    <td>{@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}<\/td>\n     *    <td rowspan=7>+: {@link MediaFormat#KEY_MIME}<\/td>\n     *    <td rowspan=3>+: {@link MediaFormat#KEY_SAMPLE_RATE},<br>\n     *        +: {@link MediaFormat#KEY_CHANNEL_COUNT},<br>\n     *        +: <strong>codec-specific data<sup>AAC<\/sup><\/strong><\/td>\n     *    <td rowspan=5>+: {@link MediaFormat#KEY_WIDTH},<br>\n     *        +: {@link MediaFormat#KEY_HEIGHT},<br>\n     *        no {@code KEY_ROTATION},\n     *        use {@link #setOrientationHint setOrientationHint()}<sup>.mp4<\/sup>,<br>\n     *        +: <strong>codec-specific data<sup>AVC, MPEG4<\/sup><\/strong><\/td>\n     *   <\/tr><tr>\n     *    <td>{@link android.os.Build.VERSION_CODES#KITKAT}<\/td>\n     *   <\/tr><tr>\n     *    <td>{@link android.os.Build.VERSION_CODES#KITKAT_WATCH}<\/td>\n     *   <\/tr><tr>\n     *    <td>{@link android.os.Build.VERSION_CODES#LOLLIPOP}<\/td>\n     *    <td rowspan=4>as above, plus<br>\n     *        +: <strong>codec-specific data<sup>Vorbis & .webm<\/sup><\/strong><\/td>\n     *   <\/tr><tr>\n     *    <td>{@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1}<\/td>\n     *   <\/tr><tr>\n     *    <td>{@link android.os.Build.VERSION_CODES#M}<\/td>\n     *    <td>as above, plus<br>\n     *        {@link MediaFormat#KEY_BIT_RATE}<sup>AAC<\/sup><\/td>\n     *   <\/tr><tr>\n     *    <td>{@link android.os.Build.VERSION_CODES#N}<\/td>\n     *    <td>as above, plus<br>\n     *        <!-- {link MediaFormat#KEY_MAX_BIT_RATE}<sup>AAC, MPEG4<\/sup>,<br> -->\n     *        {@link MediaFormat#KEY_BIT_RATE}<sup>MPEG4<\/sup>,<br>\n     *        {@link MediaFormat#KEY_HDR_STATIC_INFO}<sup>#, .webm<\/sup>,<br>\n     *        {@link MediaFormat#KEY_COLOR_STANDARD}<sup>#<\/sup>,<br>\n     *        {@link MediaFormat#KEY_COLOR_TRANSFER}<sup>#<\/sup>,<br>\n     *        {@link MediaFormat#KEY_COLOR_RANGE}<sup>#<\/sup>,<br>\n     *        +: <strong>codec-specific data<sup>HEVC<\/sup><\/strong>,<br>\n     *        codec-specific data<sup>VP9<\/sup><\/td>\n     *   <\/tr>\n     *   <tr>\n     *    <td colspan=4>\n     *     <p class=note><strong>Notes:<\/strong><br>\n     *      #: storing into container metadata.<br>\n     *      .mp4, .webm&hellip;: for listed containers<br>\n     *      MPEG4, AAC&hellip;: for listed codecs\n     *    <\/td>\n     *   <\/tr><tr>\n     *    <td colspan=4>\n     *     <p class=note>Note that the codec-specific data for the track must be specified using\n     *     this method. Furthermore, codec-specific data must not be passed/specified via the\n     *     {@link #writeSampleData writeSampleData()} call.\n     *    <\/td>\n     *   <\/tr>\n     *  <\/tbody>\n     * <\/table>\n     *\n     * <p>\n     * The following table summarizes codec support for containers across android releases:\n     *\n     * <table style=\"width: 0%\">\n     *  <thead>\n     *   <tr>\n     *    <th rowspan=2>OS Version(s)<\/th>\n     *    <td colspan=3>Codec support<\/th>\n     *   <\/tr><tr>\n     *    <th>{@linkplain OutputFormat#MUXER_OUTPUT_MPEG_4 MP4}<\/th>\n     *    <th>{@linkplain OutputFormat#MUXER_OUTPUT_WEBM WEBM}<\/th>\n     *   <\/tr>\n     *  <\/thead>\n     *  <tbody>\n     *   <tr>\n     *    <td>{@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}<\/td>\n     *    <td rowspan=6>{@link MediaFormat#MIMETYPE_AUDIO_AAC AAC},<br>\n     *        {@link MediaFormat#MIMETYPE_AUDIO_AMR_NB NB-AMR},<br>\n     *        {@link MediaFormat#MIMETYPE_AUDIO_AMR_WB WB-AMR},<br>\n     *        {@link MediaFormat#MIMETYPE_VIDEO_H263 H.263},<br>\n     *        {@link MediaFormat#MIMETYPE_VIDEO_MPEG4 MPEG-4},<br>\n     *        {@link MediaFormat#MIMETYPE_VIDEO_AVC AVC} (H.264)<\/td>\n     *    <td rowspan=3>Not supported<\/td>\n     *   <\/tr><tr>\n     *    <td>{@link android.os.Build.VERSION_CODES#KITKAT}<\/td>\n     *   <\/tr><tr>\n     *    <td>{@link android.os.Build.VERSION_CODES#KITKAT_WATCH}<\/td>\n     *   <\/tr><tr>\n     *    <td>{@link android.os.Build.VERSION_CODES#LOLLIPOP}<\/td>\n     *    <td rowspan=3>{@link MediaFormat#MIMETYPE_AUDIO_VORBIS Vorbis},<br>\n     *        {@link MediaFormat#MIMETYPE_VIDEO_VP8 VP8}<\/td>\n     *   <\/tr><tr>\n     *    <td>{@link android.os.Build.VERSION_CODES#LOLLIPOP_MR1}<\/td>\n     *   <\/tr><tr>\n     *    <td>{@link android.os.Build.VERSION_CODES#M}<\/td>\n     *   <\/tr><tr>\n     *    <td>{@link android.os.Build.VERSION_CODES#N}<\/td>\n     *    <td>as above, plus<br>\n     *        {@link MediaFormat#MIMETYPE_VIDEO_HEVC HEVC} (H.265)<\/td>\n     *    <td>as above, plus<br>\n     *        {@link MediaFormat#MIMETYPE_VIDEO_VP9 VP9}<\/td>\n     *   <\/tr>\n     *  <\/tbody>\n     * <\/table>\n     *\n     * @param format The media format for the track.  This must not be an empty\n     *               MediaFormat.\n     * @return The track index for this newly added track, and it should be used\n     * in the {@link #writeSampleData}.\n     * @throws IllegalArgumentException if format is invalid.\n     * @throws IllegalStateException if muxer is in the wrong state.\n     */\n    public int addTrack(@NonNull MediaFormat format) {\n        if (format == null) {\n            throw new IllegalArgumentException(\"format must not be null.\");\n        }\n        if (mState != MUXER_STATE_INITIALIZED) {\n            throw new IllegalStateException(\"Muxer is not initialized.\");\n        }\n        if (mNativeObject == 0) {\n            throw new IllegalStateException(\"Muxer has been released!\");\n        }\n        int trackIndex = -1;\n        // Convert the MediaFormat into key-value pairs and send to the native.\n        Map<String, Object> formatMap = format.getMap();\n\n        String[] keys = null;\n        Object[] values = null;\n        int mapSize = formatMap.size();\n        if (mapSize > 0) {\n            keys = new String[mapSize];\n            values = new Object[mapSize];\n            int i = 0;\n            for (Map.Entry<String, Object> entry : formatMap.entrySet()) {\n                keys[i] = entry.getKey();\n                values[i] = entry.getValue();\n                ++i;\n            }\n            trackIndex = nativeAddTrack(mNativeObject, keys, values);\n        } else {\n            throw new IllegalArgumentException(\"format must not be empty.\");\n        }\n\n        // Track index number is expected to incremented as addTrack succeed.\n        // However, if format is invalid, it will get a negative trackIndex.\n        if (mLastTrackIndex >= trackIndex) {\n            throw new IllegalArgumentException(\"Invalid format.\");\n        }\n        mLastTrackIndex = trackIndex;\n        return trackIndex;\n    }"}
{"Number":"386","API Relative Path":"src.android.media.MediaMuxer.java-MediaMuxer(String-int)","Corresponding Source":"/**\n     * Constructor.\n     * Creates a media muxer that writes to the specified path.\n     * @param path The path of the output media file.\n     * @param format The format of the output media file.\n     * @see android.media.MediaMuxer.OutputFormat\n     * @throws IllegalArgumentException if path is invalid or format is not supported.\n     * @throws IOException if failed to open the file for write.\n     */\n    public MediaMuxer(@NonNull String path, @Format int format) throws IOException {\n        if (path == null) {\n            throw new IllegalArgumentException(\"path must not be null\");\n        }\n        if (format != OutputFormat.MUXER_OUTPUT_MPEG_4 &&\n                format != OutputFormat.MUXER_OUTPUT_WEBM) {\n            throw new IllegalArgumentException(\"format is invalid\");\n        }\n        // Use RandomAccessFile so we can open the file with RW access;\n        // RW access allows the native writer to memory map the output file.\n        RandomAccessFile file = null;\n        try {\n            file = new RandomAccessFile(path, \"rws\");\n            FileDescriptor fd = file.getFD();\n            mNativeObject = nativeSetup(fd, format);\n            mState = MUXER_STATE_INITIALIZED;\n            mCloseGuard.open(\"release\");\n        } finally {\n            if (file != null) {\n                file.close();\n            }\n        }\n    }"}
{"Number":"387","API Relative Path":"src.android.media.MediaMuxer.java-MediaMuxer(String-int)","Corresponding Source":"/**\n     * Constructor.\n     * Creates a media muxer that writes to the specified path.\n     * @param path The path of the output media file.\n     * @param format The format of the output media file.\n     * @see android.media.MediaMuxer.OutputFormat\n     * @throws IllegalArgumentException if path is invalid or format is not supported.\n     * @throws IOException if failed to open the file for write.\n     */\n    public MediaMuxer(@NonNull String path, @Format int format) throws IOException {\n        if (path == null) {\n            throw new IllegalArgumentException(\"path must not be null\");\n        }\n        if (format != OutputFormat.MUXER_OUTPUT_MPEG_4 &&\n                format != OutputFormat.MUXER_OUTPUT_WEBM) {\n            throw new IllegalArgumentException(\"format is invalid\");\n        }\n        // Use RandomAccessFile so we can open the file with RW access;\n        // RW access allows the native writer to memory map the output file.\n        RandomAccessFile file = null;\n        try {\n            file = new RandomAccessFile(path, \"rws\");\n            FileDescriptor fd = file.getFD();\n            mNativeObject = nativeSetup(fd, format);\n            mState = MUXER_STATE_INITIALIZED;\n            mCloseGuard.open(\"release\");\n        } finally {\n            if (file != null) {\n                file.close();\n            }\n        }\n    }"}
{"Number":"388","API Relative Path":"src.android.media.MediaMuxer.java-setOrientationHint(int)","Corresponding Source":"/**\n     * Sets the orientation hint for output video playback.\n     * <p>This method should be called before {@link #start}. Calling this\n     * method will not rotate the video frame when muxer is generating the file,\n     * but add a composition matrix containing the rotation angle in the output\n     * video if the output format is\n     * {@link OutputFormat#MUXER_OUTPUT_MPEG_4} so that a video player can\n     * choose the proper orientation for playback. Note that some video players\n     * may choose to ignore the composition matrix in a video during playback.\n     * By default, the rotation degree is 0.<\/p>\n     * @param degrees the angle to be rotated clockwise in degrees.\n     * The supported angles are 0, 90, 180, and 270 degrees.\n     * @throws IllegalArgumentException if degree is not supported.\n     * @throws IllegalStateException If this method is called after {@link #start}.\n     */\n    public void setOrientationHint(int degrees) {\n        if (degrees != 0 && degrees != 90  && degrees != 180 && degrees != 270) {\n            throw new IllegalArgumentException(\"Unsupported angle: \" + degrees);\n        }\n        if (mState == MUXER_STATE_INITIALIZED) {\n            nativeSetOrientationHint(mNativeObject, degrees);\n        } else {\n            throw new IllegalStateException(\"Can't set rotation degrees due\" +\n                    \" to wrong state.\");\n        }\n    }"}
{"Number":"389","API Relative Path":"src.android.media.MediaMuxer.java-writeSampleData(int-ByteBuffer-BufferInfo)","Corresponding Source":"/**\n     * Writes an encoded sample into the muxer.\n     * <p>The application needs to make sure that the samples are written into\n     * the right tracks. Also, it needs to make sure the samples for each track\n     * are written in chronological order (e.g. in the order they are provided\n     * by the encoder.)<\/p>\n     * @param byteBuf The encoded sample.\n     * @param trackIndex The track index for this sample.\n     * @param bufferInfo The buffer information related to this sample.\n     * @throws IllegalArgumentException if trackIndex, byteBuf or bufferInfo is  invalid.\n     * @throws IllegalStateException if muxer is in wrong state.\n     * MediaMuxer uses the flags provided in {@link MediaCodec.BufferInfo},\n     * to signal sync frames.\n     */\n    public void writeSampleData(int trackIndex, @NonNull ByteBuffer byteBuf,\n            @NonNull BufferInfo bufferInfo) {\n        if (trackIndex < 0 || trackIndex > mLastTrackIndex) {\n            throw new IllegalArgumentException(\"trackIndex is invalid\");\n        }\n\n        if (byteBuf == null) {\n            throw new IllegalArgumentException(\"byteBuffer must not be null\");\n        }\n\n        if (bufferInfo == null) {\n            throw new IllegalArgumentException(\"bufferInfo must not be null\");\n        }\n        if (bufferInfo.size < 0 || bufferInfo.offset < 0\n                || (bufferInfo.offset + bufferInfo.size) > byteBuf.capacity()\n                || bufferInfo.presentationTimeUs < 0) {\n            throw new IllegalArgumentException(\"bufferInfo must specify a\" +\n                    \" valid buffer offset, size and presentation time\");\n        }\n\n        if (mNativeObject == 0) {\n            throw new IllegalStateException(\"Muxer has been released!\");\n        }\n\n        if (mState != MUXER_STATE_STARTED) {\n            throw new IllegalStateException(\"Can't write, muxer is not started\");\n        }\n\n        nativeWriteSampleData(mNativeObject, trackIndex, byteBuf,\n                bufferInfo.offset, bufferInfo.size,\n                bufferInfo.presentationTimeUs, bufferInfo.flags);\n    }"}
{"Number":"390","API Relative Path":"src.android.media.MediaMuxer.java-writeSampleData(int-ByteBuffer-BufferInfo)","Corresponding Source":"/**\n     * Writes an encoded sample into the muxer.\n     * <p>The application needs to make sure that the samples are written into\n     * the right tracks. Also, it needs to make sure the samples for each track\n     * are written in chronological order (e.g. in the order they are provided\n     * by the encoder.)<\/p>\n     * @param byteBuf The encoded sample.\n     * @param trackIndex The track index for this sample.\n     * @param bufferInfo The buffer information related to this sample.\n     * @throws IllegalArgumentException if trackIndex, byteBuf or bufferInfo is  invalid.\n     * @throws IllegalStateException if muxer is in wrong state.\n     * MediaMuxer uses the flags provided in {@link MediaCodec.BufferInfo},\n     * to signal sync frames.\n     */\n    public void writeSampleData(int trackIndex, @NonNull ByteBuffer byteBuf,\n            @NonNull BufferInfo bufferInfo) {\n        if (trackIndex < 0 || trackIndex > mLastTrackIndex) {\n            throw new IllegalArgumentException(\"trackIndex is invalid\");\n        }\n\n        if (byteBuf == null) {\n            throw new IllegalArgumentException(\"byteBuffer must not be null\");\n        }\n\n        if (bufferInfo == null) {\n            throw new IllegalArgumentException(\"bufferInfo must not be null\");\n        }\n        if (bufferInfo.size < 0 || bufferInfo.offset < 0\n                || (bufferInfo.offset + bufferInfo.size) > byteBuf.capacity()\n                || bufferInfo.presentationTimeUs < 0) {\n            throw new IllegalArgumentException(\"bufferInfo must specify a\" +\n                    \" valid buffer offset, size and presentation time\");\n        }\n\n        if (mNativeObject == 0) {\n            throw new IllegalStateException(\"Muxer has been released!\");\n        }\n\n        if (mState != MUXER_STATE_STARTED) {\n            throw new IllegalStateException(\"Can't write, muxer is not started\");\n        }\n\n        nativeWriteSampleData(mNativeObject, trackIndex, byteBuf,\n                bufferInfo.offset, bufferInfo.size,\n                bufferInfo.presentationTimeUs, bufferInfo.flags);\n    }"}
{"Number":"391","API Relative Path":"src.android.media.MediaMuxer.java-writeSampleData(int-ByteBuffer-BufferInfo)","Corresponding Source":"/**\n     * Writes an encoded sample into the muxer.\n     * <p>The application needs to make sure that the samples are written into\n     * the right tracks. Also, it needs to make sure the samples for each track\n     * are written in chronological order (e.g. in the order they are provided\n     * by the encoder.)<\/p>\n     * @param byteBuf The encoded sample.\n     * @param trackIndex The track index for this sample.\n     * @param bufferInfo The buffer information related to this sample.\n     * @throws IllegalArgumentException if trackIndex, byteBuf or bufferInfo is  invalid.\n     * @throws IllegalStateException if muxer is in wrong state.\n     * MediaMuxer uses the flags provided in {@link MediaCodec.BufferInfo},\n     * to signal sync frames.\n     */\n    public void writeSampleData(int trackIndex, @NonNull ByteBuffer byteBuf,\n            @NonNull BufferInfo bufferInfo) {\n        if (trackIndex < 0 || trackIndex > mLastTrackIndex) {\n            throw new IllegalArgumentException(\"trackIndex is invalid\");\n        }\n\n        if (byteBuf == null) {\n            throw new IllegalArgumentException(\"byteBuffer must not be null\");\n        }\n\n        if (bufferInfo == null) {\n            throw new IllegalArgumentException(\"bufferInfo must not be null\");\n        }\n        if (bufferInfo.size < 0 || bufferInfo.offset < 0\n                || (bufferInfo.offset + bufferInfo.size) > byteBuf.capacity()\n                || bufferInfo.presentationTimeUs < 0) {\n            throw new IllegalArgumentException(\"bufferInfo must specify a\" +\n                    \" valid buffer offset, size and presentation time\");\n        }\n\n        if (mNativeObject == 0) {\n            throw new IllegalStateException(\"Muxer has been released!\");\n        }\n\n        if (mState != MUXER_STATE_STARTED) {\n            throw new IllegalStateException(\"Can't write, muxer is not started\");\n        }\n\n        nativeWriteSampleData(mNativeObject, trackIndex, byteBuf,\n                bufferInfo.offset, bufferInfo.size,\n                bufferInfo.presentationTimeUs, bufferInfo.flags);\n    }"}
{"Number":"392","API Relative Path":"src.android.media.MediaMuxer.java-writeSampleData(int-ByteBuffer-BufferInfo)","Corresponding Source":"/**\n     * Writes an encoded sample into the muxer.\n     * <p>The application needs to make sure that the samples are written into\n     * the right tracks. Also, it needs to make sure the samples for each track\n     * are written in chronological order (e.g. in the order they are provided\n     * by the encoder.)<\/p>\n     * @param byteBuf The encoded sample.\n     * @param trackIndex The track index for this sample.\n     * @param bufferInfo The buffer information related to this sample.\n     * @throws IllegalArgumentException if trackIndex, byteBuf or bufferInfo is  invalid.\n     * @throws IllegalStateException if muxer is in wrong state.\n     * MediaMuxer uses the flags provided in {@link MediaCodec.BufferInfo},\n     * to signal sync frames.\n     */\n    public void writeSampleData(int trackIndex, @NonNull ByteBuffer byteBuf,\n            @NonNull BufferInfo bufferInfo) {\n        if (trackIndex < 0 || trackIndex > mLastTrackIndex) {\n            throw new IllegalArgumentException(\"trackIndex is invalid\");\n        }\n\n        if (byteBuf == null) {\n            throw new IllegalArgumentException(\"byteBuffer must not be null\");\n        }\n\n        if (bufferInfo == null) {\n            throw new IllegalArgumentException(\"bufferInfo must not be null\");\n        }\n        if (bufferInfo.size < 0 || bufferInfo.offset < 0\n                || (bufferInfo.offset + bufferInfo.size) > byteBuf.capacity()\n                || bufferInfo.presentationTimeUs < 0) {\n            throw new IllegalArgumentException(\"bufferInfo must specify a\" +\n                    \" valid buffer offset, size and presentation time\");\n        }\n\n        if (mNativeObject == 0) {\n            throw new IllegalStateException(\"Muxer has been released!\");\n        }\n\n        if (mState != MUXER_STATE_STARTED) {\n            throw new IllegalStateException(\"Can't write, muxer is not started\");\n        }\n\n        nativeWriteSampleData(mNativeObject, trackIndex, byteBuf,\n                bufferInfo.offset, bufferInfo.size,\n                bufferInfo.presentationTimeUs, bufferInfo.flags);\n    }"}
{"Number":"393","API Relative Path":"src.android.media.MediaRecorder.java-setAudioChannels(int)","Corresponding Source":"/**\n     * Sets the number of audio channels for recording. Call this method before prepare().\n     * Prepare() may perform additional checks on the parameter to make sure whether the\n     * specified number of audio channels are applicable.\n     *\n     * @param numChannels the number of audio channels. Usually it is either 1 (mono) or 2\n     * (stereo).\n     */\n    public void setAudioChannels(int numChannels) {\n        if (numChannels <= 0) {\n            throw new IllegalArgumentException(\"Number of channels is not positive\");\n        }\n        setParameter(\"audio-param-number-of-channels=\" + numChannels);\n    }"}
{"Number":"394","API Relative Path":"src.android.media.MediaRecorder.java-setAudioEncodingBitRate(int)","Corresponding Source":"/**\n     * Sets the audio encoding bit rate for recording. Call this method before prepare().\n     * Prepare() may perform additional checks on the parameter to make sure whether the\n     * specified bit rate is applicable, and sometimes the passed bitRate will be clipped\n     * internally to ensure the audio recording can proceed smoothly based on the\n     * capabilities of the platform.\n     *\n     * @param bitRate the audio encoding bit rate in bits per second.\n     */\n    public void setAudioEncodingBitRate(int bitRate) {\n        if (bitRate <= 0) {\n            throw new IllegalArgumentException(\"Audio encoding bit rate is not positive\");\n        }\n        setParameter(\"audio-param-encoding-bitrate=\" + bitRate);\n    }"}
{"Number":"395","API Relative Path":"src.android.media.MediaRecorder.java-setAudioSamplingRate(int)","Corresponding Source":"/**\n     * Sets the audio sampling rate for recording. Call this method before prepare().\n     * Prepare() may perform additional checks on the parameter to make sure whether\n     * the specified audio sampling rate is applicable. The sampling rate really depends\n     * on the format for the audio recording, as well as the capabilities of the platform.\n     * For instance, the sampling rate supported by AAC audio coding standard ranges\n     * from 8 to 96 kHz, the sampling rate supported by AMRNB is 8kHz, and the sampling\n     * rate supported by AMRWB is 16kHz. Please consult with the related audio coding\n     * standard for the supported audio sampling rate.\n     *\n     * @param samplingRate the sampling rate for audio in samples per second.\n     */\n    public void setAudioSamplingRate(int samplingRate) {\n        if (samplingRate <= 0) {\n            throw new IllegalArgumentException(\"Audio sampling rate is not positive\");\n        }\n        setParameter(\"audio-param-sampling-rate=\" + samplingRate);\n    }"}
{"Number":"396","API Relative Path":"src.android.media.MediaRecorder.java-setInputSurface(Surface)","Corresponding Source":"private native final void native_setInputSurface(@NonNull Surface surface);"}
{"Number":"397","API Relative Path":"src.android.media.MediaRecorder.java-setOrientationHint(int)","Corresponding Source":"/**\n     * Sets the orientation hint for output video playback.\n     * This method should be called before prepare(). This method will not\n     * trigger the source video frame to rotate during video recording, but to\n     * add a composition matrix containing the rotation angle in the output\n     * video if the output format is OutputFormat.THREE_GPP or\n     * OutputFormat.MPEG_4 so that a video player can choose the proper\n     * orientation for playback. Note that some video players may choose\n     * to ignore the compostion matrix in a video during playback.\n     *\n     * @param degrees the angle to be rotated clockwise in degrees.\n     * The supported angles are 0, 90, 180, and 270 degrees.\n     * @throws IllegalArgumentException if the angle is not supported.\n     *\n     */\n    public void setOrientationHint(int degrees) {\n        if (degrees != 0   &&\n            degrees != 90  &&\n            degrees != 180 &&\n            degrees != 270) {\n            throw new IllegalArgumentException(\"Unsupported angle: \" + degrees);\n        }\n        setParameter(\"video-param-rotation-angle-degrees=\" + degrees);\n    }"}
{"Number":"398","API Relative Path":"src.android.media.MediaRecorder.java-setVideoEncodingBitRate(int)","Corresponding Source":"/**\n     * Sets the video encoding bit rate for recording. Call this method before prepare().\n     * Prepare() may perform additional checks on the parameter to make sure whether the\n     * specified bit rate is applicable, and sometimes the passed bitRate will be\n     * clipped internally to ensure the video recording can proceed smoothly based on\n     * the capabilities of the platform.\n     *\n     * @param bitRate the video encoding bit rate in bits per second.\n     */\n    public void setVideoEncodingBitRate(int bitRate) {\n        if (bitRate <= 0) {\n            throw new IllegalArgumentException(\"Video encoding bit rate is not positive\");\n        }\n        setParameter(\"video-param-encoding-bitrate=\" + bitRate);\n    }"}
{"Number":"399","API Relative Path":"src.android.media.MediaRouter.java-getSelectedRoute(int)","Corresponding Source":"/**\n     * Return the currently selected route for any of the given types\n     *\n     * @param type route types\n     * @return the selected route\n     */\n    public RouteInfo getSelectedRoute(int type) {\n        if (sStatic.mSelectedRoute != null &&\n                (sStatic.mSelectedRoute.mSupportedTypes & type) != 0) {\n            // If the selected route supports any of the types supplied, it's still considered\n            // 'selected' for that type.\n            return sStatic.mSelectedRoute;\n        } else if (type == ROUTE_TYPE_USER) {\n            // The caller specifically asked for a user route and the currently selected route\n            // doesn't qualify.\n            return null;\n        }\n        // If the above didn't match and we're not specifically asking for a user route,\n        // consider the default selected.\n        return sStatic.mDefaultAudioVideo;\n    }"}
{"Number":"400","API Relative Path":"src.android.media.MediaSync.java-setAudioTrack(AudioTrack)","Corresponding Source":"private native final void native_setAudioTrack(@Nullable AudioTrack audioTrack);"}
{"Number":"401","API Relative Path":"src.android.media.midi.MidiDevice.java-connectPorts(MidiInputPort-int)","Corresponding Source":"/**\n     * Connects the supplied {@link MidiInputPort} to the output port of this device\n     * with the specified port number. Once the connection is made, the MidiInput port instance\n     * can no longer receive data via its {@link MidiReceiver#onSend} method.\n     * This method returns a {@link MidiDevice.MidiConnection} object, which can be used\n     * to close the connection.\n     *\n     * @param inputPort the inputPort to connect\n     * @param outputPortNumber the port number of the output port to connect inputPort to.\n     * @return {@link MidiDevice.MidiConnection} object if the connection is successful,\n     *         or null in case of failure.\n     */\n    public MidiConnection connectPorts(MidiInputPort inputPort, int outputPortNumber) {\n        if (outputPortNumber < 0 || outputPortNumber >= mDeviceInfo.getOutputPortCount()) {\n            throw new IllegalArgumentException(\"outputPortNumber out of range\");\n        }\n        if (mIsDeviceClosed) {\n            return null;\n        }\n\n        ParcelFileDescriptor pfd = inputPort.claimFileDescriptor();\n        if (pfd == null) {\n            return null;\n        }\n        try {\n            IBinder token = new Binder();\n            int calleePid = mDeviceServer.connectPorts(token, pfd, outputPortNumber);\n            // If the service is a different Process then it will duplicate the pfd\n            // and we can safely close this one.\n            // But if the service is in the same Process then closing the pfd will\n            // kill the connection. So don't do that.\n            if (calleePid != Process.myPid()) {\n                // close our copy of the file descriptor\n                IoUtils.closeQuietly(pfd);\n            }\n\n            return new MidiConnection(token, inputPort);\n        } catch (RemoteException e) {\n            Log.e(TAG, \"RemoteException in connectPorts\");\n            return null;\n        }\n    }"}
{"Number":"402","API Relative Path":"src.android.media.midi.MidiSender.java-connect(MidiReceiver)","Corresponding Source":"/**\n     * Called to disconnect a {@link MidiReceiver} from the sender\n     *\n     * @param receiver the receiver to disconnect\n     */\n    abstract public void onDisconnect(MidiReceiver receiver);"}
{"Number":"403","API Relative Path":"src.android.media.midi.MidiSender.java-disconnect(MidiReceiver)","Corresponding Source":"/**\n     * Called to disconnect a {@link MidiReceiver} from the sender\n     *\n     * @param receiver the receiver to disconnect\n     */\n    abstract public void onDisconnect(MidiReceiver receiver);"}
{"Number":"404","API Relative Path":"src.android.media.PlaybackParams.java-setPitch(float)","Corresponding Source":"/**\n     * Sets the pitch factor.\n     * @param pitch\n     * @return this <code>PlaybackParams<\/code> instance.\n     * @throws InvalidArgumentException if the pitch is negative\n     */\n    public PlaybackParams setPitch(float pitch) {\n        if (pitch < 0.f) {\n            throw new IllegalArgumentException(\"pitch must not be negative\");\n        }\n        mPitch = pitch;\n        mSet |= SET_PITCH;\n        return this;\n    }"}
{"Number":"405","API Relative Path":"src.android.media.projection.MediaProjection.java-registerCallback(Callback-Handler)","Corresponding Source":"/** Register a listener to receive notifications about when the {@link\n     * MediaProjection} changes state.\n     *\n     * @param callback The callback to call.\n     * @param handler The handler on which the callback should be invoked, or\n     * null if the callback should be invoked on the calling thread's looper.\n     *\n     * @see #unregisterCallback\n     */\n    public void registerCallback(Callback callback, Handler handler) {\n        if (callback == null) {\n            throw new IllegalArgumentException(\"callback should not be null\");\n        }\n        if (handler == null) {\n            handler = new Handler();\n        }\n        mCallbacks.put(callback, new CallbackRecord(callback, handler));\n    }"}
{"Number":"406","API Relative Path":"src.android.media.projection.MediaProjection.java-unregisterCallback(Callback)","Corresponding Source":"/** Unregister a MediaProjection listener.\n     *\n     * @param callback The callback to unregister.\n     *\n     * @see #registerCallback\n     */\n    public void unregisterCallback(Callback callback) {\n        if (callback == null) {\n            throw new IllegalArgumentException(\"callback should not be null\");\n        }\n        mCallbacks.remove(callback);\n    }"}
{"Number":"407","API Relative Path":"src.android.media.projection.MediaProjectionManager.java-addCallback(Callback-Handler)","Corresponding Source":"/**\n     * Add a callback to monitor all of the {@link MediaProjection}s activity.\n     * Not for use by regular applications, must have the MANAGE_MEDIA_PROJECTION permission.\n     * @hide\n     */\n    public void addCallback(@NonNull Callback callback, @Nullable Handler handler) {\n        if (callback == null) {\n            throw new IllegalArgumentException(\"callback must not be null\");\n        }\n        CallbackDelegate delegate = new CallbackDelegate(callback, handler);\n        mCallbacks.put(callback, delegate);\n        try {\n            mService.addCallback(delegate);\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to add callbacks to MediaProjection service\", e);\n        }\n    }"}
{"Number":"408","API Relative Path":"src.android.media.projection.MediaProjectionManager.java-getMediaProjection(int-Intent)","Corresponding Source":"/**\n     * Retrieve the MediaProjection obtained from a succesful screen\n     * capture request. Will be null if the result from the\n     * startActivityForResult() is anything other than RESULT_OK.\n     *\n     * @param resultCode The result code from {@link android.app.Activity#onActivityResult(int,\n     * int, android.content.Intent)}\n     * @param resultData The resulting data from {@link android.app.Activity#onActivityResult(int,\n     * int, android.content.Intent)}\n     */\n    public MediaProjection getMediaProjection(int resultCode, @NonNull Intent resultData) {\n        if (resultCode != Activity.RESULT_OK || resultData == null) {\n            return null;\n        }\n        IBinder projection = resultData.getIBinderExtra(EXTRA_MEDIA_PROJECTION);\n        if (projection == null) {\n            return null;\n        }\n        return new MediaProjection(mContext, IMediaProjection.Stub.asInterface(projection));\n    }"}
{"Number":"409","API Relative Path":"src.android.media.projection.MediaProjectionManager.java-removeCallback(Callback)","Corresponding Source":"/**\n     * Remove a MediaProjection monitoring callback.\n     * @hide\n     */\n    public void removeCallback(@NonNull Callback callback) {\n        if (callback == null) {\n            throw new IllegalArgumentException(\"callback must not be null\");\n        }\n        CallbackDelegate delegate = mCallbacks.remove(callback);\n        try {\n            if (delegate != null) {\n                mService.removeCallback(delegate);\n            }\n        } catch (RemoteException e) {\n            Log.e(TAG, \"Unable to add callbacks to MediaProjection service\", e);\n        }\n    }"}
{"Number":"410","API Relative Path":"src.android.media.RemoteController.java-RemoteController(Context-OnClientUpdateListener-Looper)","Corresponding Source":"/**\n     * Class constructor.\n     * @param context the {@link Context}, must be non-null.\n     * @param updateListener the listener to be called whenever new client information is available,\n     *     must be non-null.\n     * @param looper the {@link Looper} on which to run the event loop,\n     *     or null to use the current thread's looper.\n     * @throws java.lang.IllegalArgumentException\n     */\n    public RemoteController(Context context, OnClientUpdateListener updateListener, Looper looper)\n            throws IllegalArgumentException {\n        if (context == null) {\n            throw new IllegalArgumentException(\"Invalid null Context\");\n        }\n        if (updateListener == null) {\n            throw new IllegalArgumentException(\"Invalid null OnClientUpdateListener\");\n        }\n        if (looper != null) {\n            mEventHandler = new EventHandler(this, looper);\n        } else {\n            Looper l = Looper.myLooper();\n            if (l != null) {\n                mEventHandler = new EventHandler(this, l);\n            } else {\n                throw new IllegalArgumentException(\"Calling thread not associated with a looper\");\n            }\n        }\n        mOnClientUpdateListener = updateListener;\n        mContext = context;\n        mSessionManager = (MediaSessionManager) context\n                .getSystemService(Context.MEDIA_SESSION_SERVICE);\n        mSessionListener = new TopTransportSessionListener();\n\n        if (ActivityManager.isLowRamDeviceStatic()) {\n            mMaxBitmapDimension = MAX_BITMAP_DIMENSION;\n        } else {\n            final DisplayMetrics dm = context.getResources().getDisplayMetrics();\n            mMaxBitmapDimension = Math.max(dm.widthPixels, dm.heightPixels);\n        }\n    }"}
{"Number":"411","API Relative Path":"src.android.media.RemoteController.java-seekTo(long)","Corresponding Source":"/**\n     * Sets the new playback position.\n     * This method can only be called on a registered RemoteController.\n     * @param timeMs a 0 or positive value for the new playback position, expressed in ms.\n     * @return true if the command to set the playback position was successfully sent.\n     * @throws IllegalArgumentException\n     */\n    public boolean seekTo(long timeMs) throws IllegalArgumentException {\n        if (!mEnabled) {\n            Log.e(TAG, \"Cannot use seekTo() from a disabled RemoteController\");\n            return false;\n        }\n        if (timeMs < 0) {\n            throw new IllegalArgumentException(\"illegal negative time value\");\n        }\n        synchronized (mInfoLock) {\n            if (mCurrentSession != null) {\n                mCurrentSession.getTransportControls().seekTo(timeMs);\n            }\n        }\n        return true;\n    }"}
{"Number":"412","API Relative Path":"src.android.media.RemoteController.java-setArtworkConfiguration(boolean-int-int)","Corresponding Source":"/**\n     * @hide\n     * @param wantBitmap\n     * @param width\n     * @param height\n     * @return true if successful\n     * @throws IllegalArgumentException\n     */\n    public boolean setArtworkConfiguration(boolean wantBitmap, int width, int height)\n            throws IllegalArgumentException {\n        synchronized (mInfoLock) {\n            if (wantBitmap) {\n                if ((width > 0) && (height > 0)) {\n                    if (width > mMaxBitmapDimension) { width = mMaxBitmapDimension; }\n                    if (height > mMaxBitmapDimension) { height = mMaxBitmapDimension; }\n                    mArtworkWidth = width;\n                    mArtworkHeight = height;\n                } else {\n                    throw new IllegalArgumentException(\"Invalid dimensions\");\n                }\n            } else {\n                mArtworkWidth = -1;\n                mArtworkHeight = -1;\n            }\n        }\n        return true;\n    }"}
{"Number":"413","API Relative Path":"src.android.media.RemoteController.java-setSynchronizationMode(int)","Corresponding Source":"/**\n     * Set the playback position synchronization mode.\n     * Must be called on a registered RemoteController.\n     * @param sync {@link #POSITION_SYNCHRONIZATION_NONE} or {@link #POSITION_SYNCHRONIZATION_CHECK}\n     * @return true if the synchronization mode was successfully set.\n     * @throws IllegalArgumentException\n     */\n    public boolean setSynchronizationMode(int sync) throws IllegalArgumentException {\n        if ((sync != POSITION_SYNCHRONIZATION_NONE) && (sync != POSITION_SYNCHRONIZATION_CHECK)) {\n            throw new IllegalArgumentException(\"Unknown synchronization mode \" + sync);\n        }\n        if (!mIsRegistered) {\n            Log.e(TAG, \"Cannot set synchronization mode on an unregistered RemoteController\");\n            return false;\n        }\n        // deprecated, no-op\n        return true;\n    }"}
{"Number":"414","API Relative Path":"src.android.media.RemoteDisplay.java-listen(String-Listener-Handler-String)","Corresponding Source":"/**\n     * Starts listening for displays to be connected on the specified interface.\n     *\n     * @param iface The interface address and port in the form \"x.x.x.x:y\".\n     * @param listener The listener to invoke when displays are connected or disconnected.\n     * @param handler The handler on which to invoke the listener.\n     */\n    public static RemoteDisplay listen(String iface, Listener listener, Handler handler,\n            String opPackageName) {\n        if (iface == null) {\n            throw new IllegalArgumentException(\"iface must not be null\");\n        }\n        if (listener == null) {\n            throw new IllegalArgumentException(\"listener must not be null\");\n        }\n        if (handler == null) {\n            throw new IllegalArgumentException(\"handler must not be null\");\n        }\n\n        RemoteDisplay display = new RemoteDisplay(listener, handler, opPackageName);\n        display.startListening(iface);\n        return display;\n    }"}
{"Number":"415","API Relative Path":"src.android.media.RemoteDisplay.java-listen(String-Listener-Handler-String)","Corresponding Source":"/**\n     * Starts listening for displays to be connected on the specified interface.\n     *\n     * @param iface The interface address and port in the form \"x.x.x.x:y\".\n     * @param listener The listener to invoke when displays are connected or disconnected.\n     * @param handler The handler on which to invoke the listener.\n     */\n    public static RemoteDisplay listen(String iface, Listener listener, Handler handler,\n            String opPackageName) {\n        if (iface == null) {\n            throw new IllegalArgumentException(\"iface must not be null\");\n        }\n        if (listener == null) {\n            throw new IllegalArgumentException(\"listener must not be null\");\n        }\n        if (handler == null) {\n            throw new IllegalArgumentException(\"handler must not be null\");\n        }\n\n        RemoteDisplay display = new RemoteDisplay(listener, handler, opPackageName);\n        display.startListening(iface);\n        return display;\n    }"}
{"Number":"416","API Relative Path":"src.android.media.RemoteDisplay.java-listen(String-Listener-Handler-String)","Corresponding Source":"/**\n     * Starts listening for displays to be connected on the specified interface.\n     *\n     * @param iface The interface address and port in the form \"x.x.x.x:y\".\n     * @param listener The listener to invoke when displays are connected or disconnected.\n     * @param handler The handler on which to invoke the listener.\n     */\n    public static RemoteDisplay listen(String iface, Listener listener, Handler handler,\n            String opPackageName) {\n        if (iface == null) {\n            throw new IllegalArgumentException(\"iface must not be null\");\n        }\n        if (listener == null) {\n            throw new IllegalArgumentException(\"listener must not be null\");\n        }\n        if (handler == null) {\n            throw new IllegalArgumentException(\"handler must not be null\");\n        }\n\n        RemoteDisplay display = new RemoteDisplay(listener, handler, opPackageName);\n        display.startListening(iface);\n        return display;\n    }"}
{"Number":"417","API Relative Path":"src.android.media.ResampleInputStream.java-ResampleInputStream(InputStream-int-int)","Corresponding Source":"/**\n     * Create a new ResampleInputStream, which converts the sample rate\n     * @param inputStream InputStream containing 16 bit PCM.\n     * @param rateIn the input sample rate.\n     * @param rateOut the output sample rate.\n     * This only handles rateIn == rateOut / 2 for the moment.\n     */\n    public ResampleInputStream(InputStream inputStream, int rateIn, int rateOut) {\n        // only support 2:1 at the moment\n        if (rateIn != 2 * rateOut) throw new IllegalArgumentException(\"only support 2:1 at the moment\");\n        rateIn = 2;\n        rateOut = 1;\n\n        mInputStream = inputStream;\n        mRateIn = rateIn;\n        mRateOut = rateOut;\n    }"}
{"Number":"418","API Relative Path":"src.android.media.RingtoneManager.java-getRingtoneUri(int)","Corresponding Source":"/**\n     * Gets a {@link Uri} for the ringtone at the given position in the {@link Cursor}.\n     * \n     * @param position The position (in the {@link Cursor}) of the ringtone.\n     * @return A {@link Uri} pointing to the ringtone.\n     */\n    public Uri getRingtoneUri(int position) {\n        // use cursor directly instead of requerying it, which could easily\n        // cause position to shuffle.\n        if (mCursor == null || !mCursor.moveToPosition(position)) {\n            return null;\n        }\n        \n        return getUriFromCursor(mCursor);\n    }"}
{"Number":"419","API Relative Path":"src.android.media.session.MediaController.java-dispatchMediaButtonEvent(KeyEvent)","Corresponding Source":"/**\n     * Send the specified media button event to the session. Only media keys can\n     * be sent by this method, other keys will be ignored.\n     *\n     * @param keyEvent The media button event to dispatch.\n     * @return true if the event was sent to the session, false otherwise.\n     */\n    public boolean dispatchMediaButtonEvent(@NonNull KeyEvent keyEvent) {\n        if (keyEvent == null) {\n            throw new IllegalArgumentException(\"KeyEvent may not be null\");\n        }\n        if (!KeyEvent.isMediaKey(keyEvent.getKeyCode())) {\n            return false;\n        }\n        try {\n            return mSessionBinder.sendMediaButton(keyEvent);\n        } catch (RemoteException e) {\n            // System is dead. =(\n        }\n        return false;\n    }"}
{"Number":"420","API Relative Path":"src.android.media.session.MediaController.java-MediaController(Context-ISessionController)","Corresponding Source":"/**\n     * Call for creating a MediaController directly from a binder. Should only\n     * be used by framework code.\n     *\n     * @hide\n     */\n    public MediaController(Context context, ISessionController sessionBinder) {\n        if (sessionBinder == null) {\n            throw new IllegalArgumentException(\"Session token cannot be null\");\n        }\n        if (context == null) {\n            throw new IllegalArgumentException(\"Context cannot be null\");\n        }\n        mSessionBinder = sessionBinder;\n        mTransportControls = new TransportControls();\n        mToken = new MediaSession.Token(sessionBinder);\n        mContext = context;\n    }"}
{"Number":"421","API Relative Path":"src.android.media.session.MediaController.java-MediaController(Context-ISessionController)","Corresponding Source":"/**\n     * Call for creating a MediaController directly from a binder. Should only\n     * be used by framework code.\n     *\n     * @hide\n     */\n    public MediaController(Context context, ISessionController sessionBinder) {\n        if (sessionBinder == null) {\n            throw new IllegalArgumentException(\"Session token cannot be null\");\n        }\n        if (context == null) {\n            throw new IllegalArgumentException(\"Context cannot be null\");\n        }\n        mSessionBinder = sessionBinder;\n        mTransportControls = new TransportControls();\n        mToken = new MediaSession.Token(sessionBinder);\n        mContext = context;\n    }"}
{"Number":"422","API Relative Path":"src.android.media.session.MediaController.java-unregisterCallback(Callback)","Corresponding Source":"/**\n     * Unregisters the specified callback. If an update has already been posted\n     * you may still receive it after calling this method.\n     *\n     * @param callback The callback to remove.\n     */\n    public void unregisterCallback(@NonNull Callback callback) {\n        if (callback == null) {\n            throw new IllegalArgumentException(\"callback must not be null\");\n        }\n        synchronized (mLock) {\n            removeCallbackLocked(callback);\n        }\n    }"}
{"Number":"423","API Relative Path":"src.android.media.session.MediaSession.java-MediaSession(Context-String-int)","Corresponding Source":"/**\n     * Creates a new session as the specified user. To create a session as a\n     * user other than your own you must hold the\n     * {@link android.Manifest.permission#INTERACT_ACROSS_USERS_FULL}\n     * permission.\n     *\n     * @param context The context to use to create the session.\n     * @param tag A short name for debugging purposes.\n     * @param userId The user id to create the session as.\n     * @hide\n     */\n    public MediaSession(@NonNull Context context, @NonNull String tag, int userId) {\n        if (context == null) {\n            throw new IllegalArgumentException(\"context cannot be null.\");\n        }\n        if (TextUtils.isEmpty(tag)) {\n            throw new IllegalArgumentException(\"tag cannot be null or empty\");\n        }\n        mMaxBitmapSize = context.getResources().getDimensionPixelSize(\n                com.android.internal.R.dimen.config_mediaMetadataBitmapMaxSize);\n        mCbStub = new CallbackStub(this);\n        MediaSessionManager manager = (MediaSessionManager) context\n                .getSystemService(Context.MEDIA_SESSION_SERVICE);\n        try {\n            mBinder = manager.createSession(mCbStub, tag, userId);\n            mSessionToken = new Token(mBinder.getController());\n            mController = new MediaController(context, mSessionToken);\n        } catch (RemoteException e) {\n            throw new RuntimeException(\"Remote error creating session.\", e);\n        }\n    }"}
{"Number":"424","API Relative Path":"src.android.media.session.MediaSession.java-setCallback(Callback-Handler)","Corresponding Source":"/**\n     * Set the callback to receive updates for the MediaSession. This includes\n     * media button events and transport controls.\n     * <p>\n     * Set the callback to null to stop receiving updates.\n     *\n     * @param callback The callback to receive updates on.\n     * @param handler The handler that events should be posted on.\n     */\n    public void setCallback(@Nullable Callback callback, @Nullable Handler handler) {\n        synchronized (mLock) {\n            if (callback == null) {\n                if (mCallback != null) {\n                    mCallback.mCallback.mSession = null;\n                }\n                mCallback = null;\n                return;\n            }\n            if (mCallback != null) {\n                // We're updating the callback, clear the session from the old\n                // one.\n                mCallback.mCallback.mSession = null;\n            }\n            if (handler == null) {\n                handler = new Handler();\n            }\n            callback.mSession = this;\n            CallbackMessageHandler msgHandler = new CallbackMessageHandler(handler.getLooper(),\n                    callback);\n            mCallback = msgHandler;\n        }\n    }"}
{"Number":"425","API Relative Path":"src.android.media.session.MediaSession.java-setPlaybackToLocal(AudioAttributes)","Corresponding Source":"/**\n     * Set the attributes for this session's audio. This will affect the\n     * system's volume handling for this session. If\n     * {@link #setPlaybackToRemote} was previously called it will stop receiving\n     * volume commands and the system will begin sending volume changes to the\n     * appropriate stream.\n     * <p>\n     * By default sessions use attributes for media.\n     *\n     * @param attributes The {@link AudioAttributes} for this session's audio.\n     */\n    public void setPlaybackToLocal(AudioAttributes attributes) {\n        if (attributes == null) {\n            throw new IllegalArgumentException(\"Attributes cannot be null for local playback.\");\n        }\n        try {\n            mBinder.setPlaybackToLocal(attributes);\n        } catch (RemoteException e) {\n            Log.wtf(TAG, \"Failure in setPlaybackToLocal.\", e);\n        }\n    }"}
{"Number":"426","API Relative Path":"src.android.media.session.MediaSessionManager.java-addOnActiveSessionsChangedListener(OnActiveSessionsChangedListener-ComponentName-int-Handler)","Corresponding Source":"/**\n     * Add a listener to be notified when the list of active sessions\n     * changes.This requires the\n     * android.Manifest.permission.MEDIA_CONTENT_CONTROL permission be held by\n     * the calling app. You may also retrieve this list if your app is an\n     * enabled notification listener using the\n     * {@link NotificationListenerService} APIs, in which case you must pass the\n     * {@link ComponentName} of your enabled listener.\n     *\n     * @param sessionListener The listener to add.\n     * @param notificationListener The enabled notification listener component.\n     *            May be null.\n     * @param userId The userId to listen for changes on.\n     * @param handler The handler to post updates on.\n     * @hide\n     */\n    public void addOnActiveSessionsChangedListener(\n            @NonNull OnActiveSessionsChangedListener sessionListener,\n            @Nullable ComponentName notificationListener, int userId, @Nullable Handler handler) {\n        if (sessionListener == null) {\n            throw new IllegalArgumentException(\"listener may not be null\");\n        }\n        if (handler == null) {\n            handler = new Handler();\n        }\n        synchronized (mLock) {\n            if (mListeners.get(sessionListener) != null) {\n                Log.w(TAG, \"Attempted to add session listener twice, ignoring.\");\n                return;\n            }\n            SessionsChangedWrapper wrapper = new SessionsChangedWrapper(mContext, sessionListener,\n                    handler);\n            try {\n                mService.addSessionsListener(wrapper.mStub, notificationListener, userId);\n                mListeners.put(sessionListener, wrapper);\n            } catch (RemoteException e) {\n                Log.e(TAG, \"Error in addOnActiveSessionsChangedListener.\", e);\n            }\n        }\n    }"}
{"Number":"427","API Relative Path":"src.android.media.session.MediaSessionManager.java-removeOnActiveSessionsChangedListener(OnActiveSessionsChangedListener)","Corresponding Source":"/**\n     * Stop receiving active sessions updates on the specified listener.\n     *\n     * @param listener The listener to remove.\n     */\n    public void removeOnActiveSessionsChangedListener(\n            @NonNull OnActiveSessionsChangedListener listener) {\n        if (listener == null) {\n            throw new IllegalArgumentException(\"listener may not be null\");\n        }\n        synchronized (mLock) {\n            SessionsChangedWrapper wrapper = mListeners.remove(listener);\n            if (wrapper != null) {\n                try {\n                    mService.removeSessionsListener(wrapper.mStub);\n                } catch (RemoteException e) {\n                    Log.e(TAG, \"Error in removeOnActiveSessionsChangedListener.\", e);\n                } finally {\n                    wrapper.release();\n                }\n            }\n        }\n    }"}
{"Number":"428","API Relative Path":"src.android.media.SoundPool.java-load(AssetFileDescriptor-int)","Corresponding Source":"/**\n     * Load the sound from an asset file descriptor.\n     *\n     * @param afd an asset file descriptor\n     * @param priority the priority of the sound. Currently has no effect. Use\n     *                 a value of 1 for future compatibility.\n     * @return a sound ID. This value can be used to play or unload the sound.\n     */\n    public int load(AssetFileDescriptor afd, int priority) {\n        if (afd != null) {\n            long len = afd.getLength();\n            if (len < 0) {\n                throw new AndroidRuntimeException(\"no length for fd\");\n            }\n            return _load(afd.getFileDescriptor(), afd.getStartOffset(), len, priority);\n        } else {\n            return 0;\n        }\n    }"}
{"Number":"429","API Relative Path":"src.android.media.SyncParams.java-setTolerance(float)","Corresponding Source":"/**\n     * Sets the tolerance. The default tolerance is platform specific, but is never more than 1/24.\n     * @param tolerance A non-negative number representing\n     *     the maximum deviation of the playback rate from the playback rate\n     *     set. ({@code abs(actual_rate - set_rate) / set_rate})\n     * @return this <code>SyncParams<\/code> instance.\n     * @throws InvalidArgumentException if the tolerance is negative, or not less than one\n     */\n    public SyncParams setTolerance(float tolerance) {\n        if (tolerance < 0.f || tolerance >= 1.f) {\n            throw new IllegalArgumentException(\"tolerance must be less than one and non-negative\");\n        }\n        mTolerance = tolerance;\n        mSet |= SET_TOLERANCE;\n        return this;\n    }"}
{"Number":"430","API Relative Path":"src.android.media.ThumbnailUtils.java-extractThumbnail(Bitmap-int-int-int)","Corresponding Source":"/**\n     * Creates a centered bitmap of the desired size.\n     *\n     * @param source original bitmap source\n     * @param width targeted width\n     * @param height targeted height\n     * @param options options used during thumbnail extraction\n     */\n    public static Bitmap extractThumbnail(\n            Bitmap source, int width, int height, int options) {\n        if (source == null) {\n            return null;\n        }\n\n        float scale;\n        if (source.getWidth() < source.getHeight()) {\n            scale = width / (float) source.getWidth();\n        } else {\n            scale = height / (float) source.getHeight();\n        }\n        Matrix matrix = new Matrix();\n        matrix.setScale(scale, scale);\n        Bitmap thumbnail = transform(matrix, source, width, height,\n                OPTIONS_SCALE_UP | options);\n        return thumbnail;\n    }"}
{"Number":"431","API Relative Path":"src.android.media.tv.TvInputInfo.java-loadIcon(Context-int)","Corresponding Source":"/**\n     * Loads the user-displayed icon for this TV input per input state.\n     *\n     * @param context Supplies a {@link Context} used to load the icon.\n     * @param state The input state. Should be one of the followings.\n     *              {@link TvInputManager#INPUT_STATE_CONNECTED},\n     *              {@link TvInputManager#INPUT_STATE_CONNECTED_STANDBY} and\n     *              {@link TvInputManager#INPUT_STATE_DISCONNECTED}.\n     * @return a Drawable containing the TV input's icon for the given state or {@code null} if such\n     *         an icon is not defined.\n     * @hide\n     */\n    @SystemApi\n    public Drawable loadIcon(@NonNull Context context, int state) {\n        if (state == TvInputManager.INPUT_STATE_CONNECTED) {\n            return loadIcon(context);\n        } else if (state == TvInputManager.INPUT_STATE_CONNECTED_STANDBY) {\n            if (mIconStandby != null) {\n                return mIconStandby.loadDrawable(context);\n            }\n        } else if (state == TvInputManager.INPUT_STATE_DISCONNECTED) {\n            if (mIconDisconnected != null) {\n                return mIconDisconnected.loadDrawable(context);\n            }\n        } else {\n            throw new IllegalArgumentException(\"Unknown state: \" + state);\n        }\n        return null;\n    }"}
{"Number":"432","API Relative Path":"src.android.net.apf.ApfGenerator.java-addJumpIfBytesNotEqual(Register-byte[]-String)","Corresponding Source":"/**\n     * Add an instruction to the end of the program to jump to {@code target} if the bytes of the\n     * packet at, an offset specified by {@code register}, match {@code bytes}.\n     */\n    public ApfGenerator addJumpIfBytesNotEqual(Register register, byte[] bytes, String target)\n            throws IllegalInstructionException {\n        if (register == Register.R1) {\n            throw new IllegalInstructionException(\"JNEBS fails with R1\");\n        }\n        Instruction instruction = new Instruction(Opcodes.JNEBS, register);\n        instruction.setUnsignedImm(bytes.length);\n        instruction.setTargetLabel(target);\n        instruction.setCompareBytes(bytes);\n        addInstruction(instruction);\n        return this;\n    }"}
{"Number":"433","API Relative Path":"src.android.net.apf.ApfGenerator.java-addLoadFromMemory(Register-int)","Corresponding Source":"/**\n     * Add an instruction to the end of the program to load memory slot {@code slot} into\n     * {@code register}.\n     */\n    public ApfGenerator addLoadFromMemory(Register register, int slot)\n            throws IllegalInstructionException {\n        if (slot < 0 || slot > (MEMORY_SLOTS - 1)) {\n            throw new IllegalInstructionException(\"illegal memory slot number: \" + slot);\n        }\n        Instruction instruction = new Instruction(Opcodes.EXT, register);\n        instruction.setUnsignedImm(ExtendedOpcodes.LDM.value + slot);\n        addInstruction(instruction);\n        return this;\n    }"}
{"Number":"434","API Relative Path":"src.android.net.apf.ApfGenerator.java-addStoreToMemory(Register-int)","Corresponding Source":"/**\n     * Add an instruction to the end of the program to store {@code register} into memory slot\n     * {@code slot}.\n     */\n    public ApfGenerator addStoreToMemory(Register register, int slot)\n            throws IllegalInstructionException {\n        if (slot < 0 || slot > (MEMORY_SLOTS - 1)) {\n            throw new IllegalInstructionException(\"illegal memory slot number: \" + slot);\n        }\n        Instruction instruction = new Instruction(Opcodes.EXT, register);\n        instruction.setUnsignedImm(ExtendedOpcodes.STM.value + slot);\n        addInstruction(instruction);\n        return this;\n    }"}
{"Number":"435","API Relative Path":"src.android.net.ConnectivityManager.java-unregisterNetworkCallback(NetworkCallback)","Corresponding Source":"/**\n     * Unregisters callbacks about and possibly releases networks originating from\n     * {@link #requestNetwork(NetworkRequest, NetworkCallback)} and\n     * {@link #registerNetworkCallback(NetworkRequest, NetworkCallback)} calls.\n     * If the given {@code NetworkCallback} had previously been used with\n     * {@code #requestNetwork}, any networks that had been connected to only to satisfy that request\n     * will be disconnected.\n     *\n     * @param networkCallback The {@link NetworkCallback} used when making the request.\n     */\n    public void unregisterNetworkCallback(NetworkCallback networkCallback) {\n        if (networkCallback == null || networkCallback.networkRequest == null ||\n                networkCallback.networkRequest.requestId == REQUEST_ID_UNSET) {\n            throw new IllegalArgumentException(\"Invalid NetworkCallback\");\n        }\n        try {\n            mService.releaseNetworkRequest(networkCallback.networkRequest);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n\n        synchronized (sNetworkCallback) {\n            sNetworkCallback.remove(networkCallback.networkRequest);\n        }\n    }"}
{"Number":"436","API Relative Path":"src.android.net.dhcp.DhcpPacket.java-addTlv(ByteBuffer-byte-byte[])","Corresponding Source":"/**\n     * Adds an optional parameter containing an array of bytes.\n     */\n    protected static void addTlv(ByteBuffer buf, byte type, byte[] payload) {\n        if (payload != null) {\n            if (payload.length > MAX_OPTION_LEN) {\n                throw new IllegalArgumentException(\"DHCP option too long: \"\n                        + payload.length + \" vs. \" + MAX_OPTION_LEN);\n            }\n            buf.put(type);\n            buf.put((byte) payload.length);\n            buf.put(payload);\n        }\n    }"}
{"Number":"437","API Relative Path":"src.android.net.dhcp.DhcpPacket.java-addTlv(ByteBuffer-byte-byte[])","Corresponding Source":"/**\n     * Adds an optional parameter containing an array of bytes.\n     */\n    protected static void addTlv(ByteBuffer buf, byte type, byte[] payload) {\n        if (payload != null) {\n            if (payload.length > MAX_OPTION_LEN) {\n                throw new IllegalArgumentException(\"DHCP option too long: \"\n                        + payload.length + \" vs. \" + MAX_OPTION_LEN);\n            }\n            buf.put(type);\n            buf.put((byte) payload.length);\n            buf.put(payload);\n        }\n    }"}
{"Number":"438","API Relative Path":"src.android.net.dhcp.DhcpPacket.java-addTlv(ByteBuffer-byte-Inet4Address)","Corresponding Source":"/**\n     * Adds an optional parameter containing an IP address.\n     */\n    protected static void addTlv(ByteBuffer buf, byte type, Inet4Address addr) {\n        if (addr != null) {\n            addTlv(buf, type, addr.getAddress());\n        }\n    }"}
{"Number":"439","API Relative Path":"src.android.net.dhcp.DhcpPacket.java-addTlv(ByteBuffer-byte-Integer)","Corresponding Source":"/**\n     * Adds an optional parameter containing a simple integer\n     */\n    protected static void addTlv(ByteBuffer buf, byte type, Integer value) {\n        if (value != null) {\n            buf.put(type);\n            buf.put((byte) 4);\n            buf.putInt(value.intValue());\n        }\n    }"}
{"Number":"440","API Relative Path":"src.android.net.dhcp.DhcpPacket.java-addTlv(ByteBuffer-byte-List)","Corresponding Source":"/**\n     * Adds an optional parameter containing a list of IP addresses.\n     */\n    protected static void addTlv(ByteBuffer buf, byte type, List<Inet4Address> addrs) {\n        if (addrs == null || addrs.size() == 0) return;\n\n        int optionLen = 4 * addrs.size();\n        if (optionLen > MAX_OPTION_LEN) {\n            throw new IllegalArgumentException(\"DHCP option too long: \"\n                    + optionLen + \" vs. \" + MAX_OPTION_LEN);\n        }\n\n        buf.put(type);\n        buf.put((byte)(optionLen));\n\n        for (Inet4Address addr : addrs) {\n            buf.put(addr.getAddress());\n        }\n    }"}
{"Number":"441","API Relative Path":"src.android.net.dhcp.DhcpPacket.java-addTlv(ByteBuffer-byte-Short)","Corresponding Source":"/**\n     * Adds an optional parameter containing a short integer\n     */\n    protected static void addTlv(ByteBuffer buf, byte type, Short value) {\n        if (value != null) {\n            buf.put(type);\n            buf.put((byte) 2);\n            buf.putShort(value.shortValue());\n        }\n    }"}
{"Number":"442","API Relative Path":"src.android.net.dhcp.DhcpPacket.java-decodeFullPacket(ByteBuffer-int)","Corresponding Source":"/**\n     * Creates a concrete DhcpPacket from the supplied ByteBuffer.  The\n     * buffer may have an L2 encapsulation (which is the full EthernetII\n     * format starting with the source-address MAC) or an L3 encapsulation\n     * (which starts with the IP header).\n     * <br>\n     * A subset of the optional parameters are parsed and are stored\n     * in object fields.\n     */\n    public static DhcpPacket decodeFullPacket(ByteBuffer packet, int pktType) throws ParseException\n    {\n        // bootp parameters\n        int transactionId;\n        short secs;\n        Inet4Address clientIp;\n        Inet4Address yourIp;\n        Inet4Address nextIp;\n        Inet4Address relayIp;\n        byte[] clientMac;\n        List<Inet4Address> dnsServers = new ArrayList<>();\n        List<Inet4Address> gateways = new ArrayList<>();  // aka router\n        Inet4Address serverIdentifier = null;\n        Inet4Address netMask = null;\n        String message = null;\n        String vendorId = null;\n        String vendorInfo = null;\n        byte[] expectedParams = null;\n        String hostName = null;\n        String domainName = null;\n        Inet4Address ipSrc = null;\n        Inet4Address ipDst = null;\n        Inet4Address bcAddr = null;\n        Inet4Address requestedIp = null;\n\n        // The following are all unsigned integers. Internally we store them as signed integers of\n        // the same length because that way we're guaranteed that they can't be out of the range of\n        // the unsigned field in the packet. Callers wanting to pass in an unsigned value will need\n        // to cast it.\n        Short mtu = null;\n        Short maxMessageSize = null;\n        Integer leaseTime = null;\n        Integer T1 = null;\n        Integer T2 = null;\n\n        // dhcp options\n        byte dhcpType = (byte) 0xFF;\n\n        packet.order(ByteOrder.BIG_ENDIAN);\n\n        // check to see if we need to parse L2, IP, and UDP encaps\n        if (pktType == ENCAP_L2) {\n            if (packet.remaining() < MIN_PACKET_LENGTH_L2) {\n                throw new ParseException(DhcpErrorEvent.L2_TOO_SHORT,\n                        \"L2 packet too short, %d < %d\", packet.remaining(), MIN_PACKET_LENGTH_L2);\n            }\n\n            byte[] l2dst = new byte[6];\n            byte[] l2src = new byte[6];\n\n            packet.get(l2dst);\n            packet.get(l2src);\n\n            short l2type = packet.getShort();\n\n            if (l2type != OsConstants.ETH_P_IP) {\n                throw new ParseException(DhcpErrorEvent.L2_WRONG_ETH_TYPE,\n                        \"Unexpected L2 type 0x%04x, expected 0x%04x\", l2type, OsConstants.ETH_P_IP);\n            }\n        }\n\n        if (pktType <= ENCAP_L3) {\n            if (packet.remaining() < MIN_PACKET_LENGTH_L3) {\n                throw new ParseException(DhcpErrorEvent.L3_TOO_SHORT,\n                        \"L3 packet too short, %d < %d\", packet.remaining(), MIN_PACKET_LENGTH_L3);\n            }\n\n            byte ipTypeAndLength = packet.get();\n            int ipVersion = (ipTypeAndLength & 0xf0) >> 4;\n            if (ipVersion != 4) {\n                throw new ParseException(\n                        DhcpErrorEvent.L3_NOT_IPV4, \"Invalid IP version %d\", ipVersion);\n            }\n\n            // System.out.println(\"ipType is \" + ipType);\n            byte ipDiffServicesField = packet.get();\n            short ipTotalLength = packet.getShort();\n            short ipIdentification = packet.getShort();\n            byte ipFlags = packet.get();\n            byte ipFragOffset = packet.get();\n            byte ipTTL = packet.get();\n            byte ipProto = packet.get();\n            short ipChksm = packet.getShort();\n\n            ipSrc = readIpAddress(packet);\n            ipDst = readIpAddress(packet);\n\n            if (ipProto != IP_TYPE_UDP) {\n                throw new ParseException(\n                        DhcpErrorEvent.L4_NOT_UDP, \"Protocol not UDP: %d\", ipProto);\n            }\n\n            // Skip options. This cannot cause us to read beyond the end of the buffer because the\n            // IPv4 header cannot be more than (0x0f * 4) = 60 bytes long, and that is less than\n            // MIN_PACKET_LENGTH_L3.\n            int optionWords = ((ipTypeAndLength & 0x0f) - 5);\n            for (int i = 0; i < optionWords; i++) {\n                packet.getInt();\n            }\n\n            // assume UDP\n            short udpSrcPort = packet.getShort();\n            short udpDstPort = packet.getShort();\n            short udpLen = packet.getShort();\n            short udpChkSum = packet.getShort();\n\n            // Only accept packets to or from the well-known client port (expressly permitting\n            // packets from ports other than the well-known server port; http://b/24687559), and\n            // server-to-server packets, e.g. for relays.\n            if (!isPacketToOrFromClient(udpSrcPort, udpDstPort) &&\n                !isPacketServerToServer(udpSrcPort, udpDstPort)) {\n                // This should almost never happen because we use SO_ATTACH_FILTER on the packet\n                // socket to drop packets that don't have the right source ports. However, it's\n                // possible that a packet arrives between when the socket is bound and when the\n                // filter is set. http://b/26696823 .\n                throw new ParseException(DhcpErrorEvent.L4_WRONG_PORT,\n                        \"Unexpected UDP ports %d->%d\", udpSrcPort, udpDstPort);\n            }\n        }\n\n        // We need to check the length even for ENCAP_L3 because the IPv4 header is variable-length.\n        if (pktType > ENCAP_BOOTP || packet.remaining() < MIN_PACKET_LENGTH_BOOTP) {\n            throw new ParseException(DhcpErrorEvent.BOOTP_TOO_SHORT,\n                        \"Invalid type or BOOTP packet too short, %d < %d\",\n                        packet.remaining(), MIN_PACKET_LENGTH_BOOTP);\n        }\n\n        byte type = packet.get();\n        byte hwType = packet.get();\n        int addrLen = packet.get() & 0xff;\n        byte hops = packet.get();\n        transactionId = packet.getInt();\n        secs = packet.getShort();\n        short bootpFlags = packet.getShort();\n        boolean broadcast = (bootpFlags & 0x8000) != 0;\n        byte[] ipv4addr = new byte[4];\n\n        try {\n            packet.get(ipv4addr);\n            clientIp = (Inet4Address) Inet4Address.getByAddress(ipv4addr);\n            packet.get(ipv4addr);\n            yourIp = (Inet4Address) Inet4Address.getByAddress(ipv4addr);\n            packet.get(ipv4addr);\n            nextIp = (Inet4Address) Inet4Address.getByAddress(ipv4addr);\n            packet.get(ipv4addr);\n            relayIp = (Inet4Address) Inet4Address.getByAddress(ipv4addr);\n        } catch (UnknownHostException ex) {\n            throw new ParseException(DhcpErrorEvent.L3_INVALID_IP,\n                    \"Invalid IPv4 address: %s\", Arrays.toString(ipv4addr));\n        }\n\n        // Some DHCP servers have been known to announce invalid client hardware address values such\n        // as 0xff. The legacy DHCP client accepted these becuause it does not check the length at\n        // all but only checks that the interface MAC address matches the first bytes of the address\n        // in the packets. We're a bit stricter: if the length is obviously invalid (i.e., bigger\n        // than the size of the field), we fudge it to 6 (Ethernet). http://b/23725795\n        // TODO: evaluate whether to make this test more liberal.\n        if (addrLen > HWADDR_LEN) {\n            addrLen = ETHER_BROADCAST.length;\n        }\n\n        clientMac = new byte[addrLen];\n        packet.get(clientMac);\n\n        // skip over address padding (16 octets allocated)\n        packet.position(packet.position() + (16 - addrLen)\n                        + 64    // skip server host name (64 chars)\n                        + 128); // skip boot file name (128 chars)\n\n        int dhcpMagicCookie = packet.getInt();\n\n        if (dhcpMagicCookie != DHCP_MAGIC_COOKIE) {\n            throw new ParseException(DhcpErrorEvent.DHCP_BAD_MAGIC_COOKIE,\n                    \"Bad magic cookie 0x%08x, should be 0x%08x\",\n                    dhcpMagicCookie, DHCP_MAGIC_COOKIE);\n        }\n\n        // parse options\n        boolean notFinishedOptions = true;\n\n        while ((packet.position() < packet.limit()) && notFinishedOptions) {\n            final byte optionType = packet.get(); // cannot underflow because position < limit\n            try {\n                if (optionType == DHCP_OPTION_END) {\n                    notFinishedOptions = false;\n                } else if (optionType == DHCP_OPTION_PAD) {\n                    // The pad option doesn't have a length field. Nothing to do.\n                } else {\n                    int optionLen = packet.get() & 0xFF;\n                    int expectedLen = 0;\n\n                    switch(optionType) {\n                        case DHCP_SUBNET_MASK:\n                            netMask = readIpAddress(packet);\n                            expectedLen = 4;\n                            break;\n                        case DHCP_ROUTER:\n                            for (expectedLen = 0; expectedLen < optionLen; expectedLen += 4) {\n                                gateways.add(readIpAddress(packet));\n                            }\n                            break;\n                        case DHCP_DNS_SERVER:\n                            for (expectedLen = 0; expectedLen < optionLen; expectedLen += 4) {\n                                dnsServers.add(readIpAddress(packet));\n                            }\n                            break;\n                        case DHCP_HOST_NAME:\n                            expectedLen = optionLen;\n                            hostName = readAsciiString(packet, optionLen, false);\n                            break;\n                        case DHCP_MTU:\n                            expectedLen = 2;\n                            mtu = packet.getShort();\n                            break;\n                        case DHCP_DOMAIN_NAME:\n                            expectedLen = optionLen;\n                            domainName = readAsciiString(packet, optionLen, false);\n                            break;\n                        case DHCP_BROADCAST_ADDRESS:\n                            bcAddr = readIpAddress(packet);\n                            expectedLen = 4;\n                            break;\n                        case DHCP_REQUESTED_IP:\n                            requestedIp = readIpAddress(packet);\n                            expectedLen = 4;\n                            break;\n                        case DHCP_LEASE_TIME:\n                            leaseTime = Integer.valueOf(packet.getInt());\n                            expectedLen = 4;\n                            break;\n                        case DHCP_MESSAGE_TYPE:\n                            dhcpType = packet.get();\n                            expectedLen = 1;\n                            break;\n                        case DHCP_SERVER_IDENTIFIER:\n                            serverIdentifier = readIpAddress(packet);\n                            expectedLen = 4;\n                            break;\n                        case DHCP_PARAMETER_LIST:\n                            expectedParams = new byte[optionLen];\n                            packet.get(expectedParams);\n                            expectedLen = optionLen;\n                            break;\n                        case DHCP_MESSAGE:\n                            expectedLen = optionLen;\n                            message = readAsciiString(packet, optionLen, false);\n                            break;\n                        case DHCP_MAX_MESSAGE_SIZE:\n                            expectedLen = 2;\n                            maxMessageSize = Short.valueOf(packet.getShort());\n                            break;\n                        case DHCP_RENEWAL_TIME:\n                            expectedLen = 4;\n                            T1 = Integer.valueOf(packet.getInt());\n                            break;\n                        case DHCP_REBINDING_TIME:\n                            expectedLen = 4;\n                            T2 = Integer.valueOf(packet.getInt());\n                            break;\n                        case DHCP_VENDOR_CLASS_ID:\n                            expectedLen = optionLen;\n                            // Embedded nulls are safe as this does not get passed to netd.\n                            vendorId = readAsciiString(packet, optionLen, true);\n                            break;\n                        case DHCP_CLIENT_IDENTIFIER: { // Client identifier\n                            byte[] id = new byte[optionLen];\n                            packet.get(id);\n                            expectedLen = optionLen;\n                        } break;\n                        case DHCP_VENDOR_INFO:\n                            expectedLen = optionLen;\n                            // Embedded nulls are safe as this does not get passed to netd.\n                            vendorInfo = readAsciiString(packet, optionLen, true);\n                            break;\n                        default:\n                            // ignore any other parameters\n                            for (int i = 0; i < optionLen; i++) {\n                                expectedLen++;\n                                byte throwaway = packet.get();\n                            }\n                    }\n\n                    if (expectedLen != optionLen) {\n                        final int errorCode = DhcpErrorEvent.errorCodeWithOption(\n                                DhcpErrorEvent.DHCP_INVALID_OPTION_LENGTH, optionType);\n                        throw new ParseException(errorCode,\n                                \"Invalid length %d for option %d, expected %d\",\n                                optionLen, optionType, expectedLen);\n                    }\n                }\n            } catch (BufferUnderflowException e) {\n                final int errorCode = DhcpErrorEvent.errorCodeWithOption(\n                        DhcpErrorEvent.BUFFER_UNDERFLOW, optionType);\n                throw new ParseException(errorCode, \"BufferUnderflowException\");\n            }\n        }\n\n        DhcpPacket newPacket;\n\n        switch(dhcpType) {\n            case (byte) 0xFF:\n                throw new ParseException(DhcpErrorEvent.DHCP_NO_MSG_TYPE,\n                        \"No DHCP message type option\");\n            case DHCP_MESSAGE_TYPE_DISCOVER:\n                newPacket = new DhcpDiscoverPacket(\n                    transactionId, secs, clientMac, broadcast);\n                break;\n            case DHCP_MESSAGE_TYPE_OFFER:\n                newPacket = new DhcpOfferPacket(\n                    transactionId, secs, broadcast, ipSrc, clientIp, yourIp, clientMac);\n                break;\n            case DHCP_MESSAGE_TYPE_REQUEST:\n                newPacket = new DhcpRequestPacket(\n                    transactionId, secs, clientIp, clientMac, broadcast);\n                break;\n            case DHCP_MESSAGE_TYPE_DECLINE:\n                newPacket = new DhcpDeclinePacket(\n                    transactionId, secs, clientIp, yourIp, nextIp, relayIp,\n                    clientMac);\n                break;\n            case DHCP_MESSAGE_TYPE_ACK:\n                newPacket = new DhcpAckPacket(\n                    transactionId, secs, broadcast, ipSrc, clientIp, yourIp, clientMac);\n                break;\n            case DHCP_MESSAGE_TYPE_NAK:\n                newPacket = new DhcpNakPacket(\n                    transactionId, secs, clientIp, yourIp, nextIp, relayIp,\n                    clientMac);\n                break;\n            case DHCP_MESSAGE_TYPE_INFORM:\n                newPacket = new DhcpInformPacket(\n                    transactionId, secs, clientIp, yourIp, nextIp, relayIp,\n                    clientMac);\n                break;\n            default:\n                throw new ParseException(DhcpErrorEvent.DHCP_UNKNOWN_MSG_TYPE,\n                        \"Unimplemented DHCP type %d\", dhcpType);\n        }\n\n        newPacket.mBroadcastAddress = bcAddr;\n        newPacket.mDnsServers = dnsServers;\n        newPacket.mDomainName = domainName;\n        newPacket.mGateways = gateways;\n        newPacket.mHostName = hostName;\n        newPacket.mLeaseTime = leaseTime;\n        newPacket.mMessage = message;\n        newPacket.mMtu = mtu;\n        newPacket.mRequestedIp = requestedIp;\n        newPacket.mRequestedParams = expectedParams;\n        newPacket.mServerIdentifier = serverIdentifier;\n        newPacket.mSubnetMask = netMask;\n        newPacket.mMaxMessageSize = maxMessageSize;\n        newPacket.mT1 = T1;\n        newPacket.mT2 = T2;\n        newPacket.mVendorId = vendorId;\n        newPacket.mVendorInfo = vendorInfo;\n        return newPacket;\n    }"}
{"Number":"443","API Relative Path":"src.android.net.dhcp.DhcpPacket.java-decodeFullPacket(ByteBuffer-int)","Corresponding Source":"/**\n     * Creates a concrete DhcpPacket from the supplied ByteBuffer.  The\n     * buffer may have an L2 encapsulation (which is the full EthernetII\n     * format starting with the source-address MAC) or an L3 encapsulation\n     * (which starts with the IP header).\n     * <br>\n     * A subset of the optional parameters are parsed and are stored\n     * in object fields.\n     */\n    public static DhcpPacket decodeFullPacket(ByteBuffer packet, int pktType) throws ParseException\n    {\n        // bootp parameters\n        int transactionId;\n        short secs;\n        Inet4Address clientIp;\n        Inet4Address yourIp;\n        Inet4Address nextIp;\n        Inet4Address relayIp;\n        byte[] clientMac;\n        List<Inet4Address> dnsServers = new ArrayList<>();\n        List<Inet4Address> gateways = new ArrayList<>();  // aka router\n        Inet4Address serverIdentifier = null;\n        Inet4Address netMask = null;\n        String message = null;\n        String vendorId = null;\n        String vendorInfo = null;\n        byte[] expectedParams = null;\n        String hostName = null;\n        String domainName = null;\n        Inet4Address ipSrc = null;\n        Inet4Address ipDst = null;\n        Inet4Address bcAddr = null;\n        Inet4Address requestedIp = null;\n\n        // The following are all unsigned integers. Internally we store them as signed integers of\n        // the same length because that way we're guaranteed that they can't be out of the range of\n        // the unsigned field in the packet. Callers wanting to pass in an unsigned value will need\n        // to cast it.\n        Short mtu = null;\n        Short maxMessageSize = null;\n        Integer leaseTime = null;\n        Integer T1 = null;\n        Integer T2 = null;\n\n        // dhcp options\n        byte dhcpType = (byte) 0xFF;\n\n        packet.order(ByteOrder.BIG_ENDIAN);\n\n        // check to see if we need to parse L2, IP, and UDP encaps\n        if (pktType == ENCAP_L2) {\n            if (packet.remaining() < MIN_PACKET_LENGTH_L2) {\n                throw new ParseException(DhcpErrorEvent.L2_TOO_SHORT,\n                        \"L2 packet too short, %d < %d\", packet.remaining(), MIN_PACKET_LENGTH_L2);\n            }\n\n            byte[] l2dst = new byte[6];\n            byte[] l2src = new byte[6];\n\n            packet.get(l2dst);\n            packet.get(l2src);\n\n            short l2type = packet.getShort();\n\n            if (l2type != OsConstants.ETH_P_IP) {\n                throw new ParseException(DhcpErrorEvent.L2_WRONG_ETH_TYPE,\n                        \"Unexpected L2 type 0x%04x, expected 0x%04x\", l2type, OsConstants.ETH_P_IP);\n            }\n        }\n\n        if (pktType <= ENCAP_L3) {\n            if (packet.remaining() < MIN_PACKET_LENGTH_L3) {\n                throw new ParseException(DhcpErrorEvent.L3_TOO_SHORT,\n                        \"L3 packet too short, %d < %d\", packet.remaining(), MIN_PACKET_LENGTH_L3);\n            }\n\n            byte ipTypeAndLength = packet.get();\n            int ipVersion = (ipTypeAndLength & 0xf0) >> 4;\n            if (ipVersion != 4) {\n                throw new ParseException(\n                        DhcpErrorEvent.L3_NOT_IPV4, \"Invalid IP version %d\", ipVersion);\n            }\n\n            // System.out.println(\"ipType is \" + ipType);\n            byte ipDiffServicesField = packet.get();\n            short ipTotalLength = packet.getShort();\n            short ipIdentification = packet.getShort();\n            byte ipFlags = packet.get();\n            byte ipFragOffset = packet.get();\n            byte ipTTL = packet.get();\n            byte ipProto = packet.get();\n            short ipChksm = packet.getShort();\n\n            ipSrc = readIpAddress(packet);\n            ipDst = readIpAddress(packet);\n\n            if (ipProto != IP_TYPE_UDP) {\n                throw new ParseException(\n                        DhcpErrorEvent.L4_NOT_UDP, \"Protocol not UDP: %d\", ipProto);\n            }\n\n            // Skip options. This cannot cause us to read beyond the end of the buffer because the\n            // IPv4 header cannot be more than (0x0f * 4) = 60 bytes long, and that is less than\n            // MIN_PACKET_LENGTH_L3.\n            int optionWords = ((ipTypeAndLength & 0x0f) - 5);\n            for (int i = 0; i < optionWords; i++) {\n                packet.getInt();\n            }\n\n            // assume UDP\n            short udpSrcPort = packet.getShort();\n            short udpDstPort = packet.getShort();\n            short udpLen = packet.getShort();\n            short udpChkSum = packet.getShort();\n\n            // Only accept packets to or from the well-known client port (expressly permitting\n            // packets from ports other than the well-known server port; http://b/24687559), and\n            // server-to-server packets, e.g. for relays.\n            if (!isPacketToOrFromClient(udpSrcPort, udpDstPort) &&\n                !isPacketServerToServer(udpSrcPort, udpDstPort)) {\n                // This should almost never happen because we use SO_ATTACH_FILTER on the packet\n                // socket to drop packets that don't have the right source ports. However, it's\n                // possible that a packet arrives between when the socket is bound and when the\n                // filter is set. http://b/26696823 .\n                throw new ParseException(DhcpErrorEvent.L4_WRONG_PORT,\n                        \"Unexpected UDP ports %d->%d\", udpSrcPort, udpDstPort);\n            }\n        }\n\n        // We need to check the length even for ENCAP_L3 because the IPv4 header is variable-length.\n        if (pktType > ENCAP_BOOTP || packet.remaining() < MIN_PACKET_LENGTH_BOOTP) {\n            throw new ParseException(DhcpErrorEvent.BOOTP_TOO_SHORT,\n                        \"Invalid type or BOOTP packet too short, %d < %d\",\n                        packet.remaining(), MIN_PACKET_LENGTH_BOOTP);\n        }\n\n        byte type = packet.get();\n        byte hwType = packet.get();\n        int addrLen = packet.get() & 0xff;\n        byte hops = packet.get();\n        transactionId = packet.getInt();\n        secs = packet.getShort();\n        short bootpFlags = packet.getShort();\n        boolean broadcast = (bootpFlags & 0x8000) != 0;\n        byte[] ipv4addr = new byte[4];\n\n        try {\n            packet.get(ipv4addr);\n            clientIp = (Inet4Address) Inet4Address.getByAddress(ipv4addr);\n            packet.get(ipv4addr);\n            yourIp = (Inet4Address) Inet4Address.getByAddress(ipv4addr);\n            packet.get(ipv4addr);\n            nextIp = (Inet4Address) Inet4Address.getByAddress(ipv4addr);\n            packet.get(ipv4addr);\n            relayIp = (Inet4Address) Inet4Address.getByAddress(ipv4addr);\n        } catch (UnknownHostException ex) {\n            throw new ParseException(DhcpErrorEvent.L3_INVALID_IP,\n                    \"Invalid IPv4 address: %s\", Arrays.toString(ipv4addr));\n        }\n\n        // Some DHCP servers have been known to announce invalid client hardware address values such\n        // as 0xff. The legacy DHCP client accepted these becuause it does not check the length at\n        // all but only checks that the interface MAC address matches the first bytes of the address\n        // in the packets. We're a bit stricter: if the length is obviously invalid (i.e., bigger\n        // than the size of the field), we fudge it to 6 (Ethernet). http://b/23725795\n        // TODO: evaluate whether to make this test more liberal.\n        if (addrLen > HWADDR_LEN) {\n            addrLen = ETHER_BROADCAST.length;\n        }\n\n        clientMac = new byte[addrLen];\n        packet.get(clientMac);\n\n        // skip over address padding (16 octets allocated)\n        packet.position(packet.position() + (16 - addrLen)\n                        + 64    // skip server host name (64 chars)\n                        + 128); // skip boot file name (128 chars)\n\n        int dhcpMagicCookie = packet.getInt();\n\n        if (dhcpMagicCookie != DHCP_MAGIC_COOKIE) {\n            throw new ParseException(DhcpErrorEvent.DHCP_BAD_MAGIC_COOKIE,\n                    \"Bad magic cookie 0x%08x, should be 0x%08x\",\n                    dhcpMagicCookie, DHCP_MAGIC_COOKIE);\n        }\n\n        // parse options\n        boolean notFinishedOptions = true;\n\n        while ((packet.position() < packet.limit()) && notFinishedOptions) {\n            final byte optionType = packet.get(); // cannot underflow because position < limit\n            try {\n                if (optionType == DHCP_OPTION_END) {\n                    notFinishedOptions = false;\n                } else if (optionType == DHCP_OPTION_PAD) {\n                    // The pad option doesn't have a length field. Nothing to do.\n                } else {\n                    int optionLen = packet.get() & 0xFF;\n                    int expectedLen = 0;\n\n                    switch(optionType) {\n                        case DHCP_SUBNET_MASK:\n                            netMask = readIpAddress(packet);\n                            expectedLen = 4;\n                            break;\n                        case DHCP_ROUTER:\n                            for (expectedLen = 0; expectedLen < optionLen; expectedLen += 4) {\n                                gateways.add(readIpAddress(packet));\n                            }\n                            break;\n                        case DHCP_DNS_SERVER:\n                            for (expectedLen = 0; expectedLen < optionLen; expectedLen += 4) {\n                                dnsServers.add(readIpAddress(packet));\n                            }\n                            break;\n                        case DHCP_HOST_NAME:\n                            expectedLen = optionLen;\n                            hostName = readAsciiString(packet, optionLen, false);\n                            break;\n                        case DHCP_MTU:\n                            expectedLen = 2;\n                            mtu = packet.getShort();\n                            break;\n                        case DHCP_DOMAIN_NAME:\n                            expectedLen = optionLen;\n                            domainName = readAsciiString(packet, optionLen, false);\n                            break;\n                        case DHCP_BROADCAST_ADDRESS:\n                            bcAddr = readIpAddress(packet);\n                            expectedLen = 4;\n                            break;\n                        case DHCP_REQUESTED_IP:\n                            requestedIp = readIpAddress(packet);\n                            expectedLen = 4;\n                            break;\n                        case DHCP_LEASE_TIME:\n                            leaseTime = Integer.valueOf(packet.getInt());\n                            expectedLen = 4;\n                            break;\n                        case DHCP_MESSAGE_TYPE:\n                            dhcpType = packet.get();\n                            expectedLen = 1;\n                            break;\n                        case DHCP_SERVER_IDENTIFIER:\n                            serverIdentifier = readIpAddress(packet);\n                            expectedLen = 4;\n                            break;\n                        case DHCP_PARAMETER_LIST:\n                            expectedParams = new byte[optionLen];\n                            packet.get(expectedParams);\n                            expectedLen = optionLen;\n                            break;\n                        case DHCP_MESSAGE:\n                            expectedLen = optionLen;\n                            message = readAsciiString(packet, optionLen, false);\n                            break;\n                        case DHCP_MAX_MESSAGE_SIZE:\n                            expectedLen = 2;\n                            maxMessageSize = Short.valueOf(packet.getShort());\n                            break;\n                        case DHCP_RENEWAL_TIME:\n                            expectedLen = 4;\n                            T1 = Integer.valueOf(packet.getInt());\n                            break;\n                        case DHCP_REBINDING_TIME:\n                            expectedLen = 4;\n                            T2 = Integer.valueOf(packet.getInt());\n                            break;\n                        case DHCP_VENDOR_CLASS_ID:\n                            expectedLen = optionLen;\n                            // Embedded nulls are safe as this does not get passed to netd.\n                            vendorId = readAsciiString(packet, optionLen, true);\n                            break;\n                        case DHCP_CLIENT_IDENTIFIER: { // Client identifier\n                            byte[] id = new byte[optionLen];\n                            packet.get(id);\n                            expectedLen = optionLen;\n                        } break;\n                        case DHCP_VENDOR_INFO:\n                            expectedLen = optionLen;\n                            // Embedded nulls are safe as this does not get passed to netd.\n                            vendorInfo = readAsciiString(packet, optionLen, true);\n                            break;\n                        default:\n                            // ignore any other parameters\n                            for (int i = 0; i < optionLen; i++) {\n                                expectedLen++;\n                                byte throwaway = packet.get();\n                            }\n                    }\n\n                    if (expectedLen != optionLen) {\n                        final int errorCode = DhcpErrorEvent.errorCodeWithOption(\n                                DhcpErrorEvent.DHCP_INVALID_OPTION_LENGTH, optionType);\n                        throw new ParseException(errorCode,\n                                \"Invalid length %d for option %d, expected %d\",\n                                optionLen, optionType, expectedLen);\n                    }\n                }\n            } catch (BufferUnderflowException e) {\n                final int errorCode = DhcpErrorEvent.errorCodeWithOption(\n                        DhcpErrorEvent.BUFFER_UNDERFLOW, optionType);\n                throw new ParseException(errorCode, \"BufferUnderflowException\");\n            }\n        }\n\n        DhcpPacket newPacket;\n\n        switch(dhcpType) {\n            case (byte) 0xFF:\n                throw new ParseException(DhcpErrorEvent.DHCP_NO_MSG_TYPE,\n                        \"No DHCP message type option\");\n            case DHCP_MESSAGE_TYPE_DISCOVER:\n                newPacket = new DhcpDiscoverPacket(\n                    transactionId, secs, clientMac, broadcast);\n                break;\n            case DHCP_MESSAGE_TYPE_OFFER:\n                newPacket = new DhcpOfferPacket(\n                    transactionId, secs, broadcast, ipSrc, clientIp, yourIp, clientMac);\n                break;\n            case DHCP_MESSAGE_TYPE_REQUEST:\n                newPacket = new DhcpRequestPacket(\n                    transactionId, secs, clientIp, clientMac, broadcast);\n                break;\n            case DHCP_MESSAGE_TYPE_DECLINE:\n                newPacket = new DhcpDeclinePacket(\n                    transactionId, secs, clientIp, yourIp, nextIp, relayIp,\n                    clientMac);\n                break;\n            case DHCP_MESSAGE_TYPE_ACK:\n                newPacket = new DhcpAckPacket(\n                    transactionId, secs, broadcast, ipSrc, clientIp, yourIp, clientMac);\n                break;\n            case DHCP_MESSAGE_TYPE_NAK:\n                newPacket = new DhcpNakPacket(\n                    transactionId, secs, clientIp, yourIp, nextIp, relayIp,\n                    clientMac);\n                break;\n            case DHCP_MESSAGE_TYPE_INFORM:\n                newPacket = new DhcpInformPacket(\n                    transactionId, secs, clientIp, yourIp, nextIp, relayIp,\n                    clientMac);\n                break;\n            default:\n                throw new ParseException(DhcpErrorEvent.DHCP_UNKNOWN_MSG_TYPE,\n                        \"Unimplemented DHCP type %d\", dhcpType);\n        }\n\n        newPacket.mBroadcastAddress = bcAddr;\n        newPacket.mDnsServers = dnsServers;\n        newPacket.mDomainName = domainName;\n        newPacket.mGateways = gateways;\n        newPacket.mHostName = hostName;\n        newPacket.mLeaseTime = leaseTime;\n        newPacket.mMessage = message;\n        newPacket.mMtu = mtu;\n        newPacket.mRequestedIp = requestedIp;\n        newPacket.mRequestedParams = expectedParams;\n        newPacket.mServerIdentifier = serverIdentifier;\n        newPacket.mSubnetMask = netMask;\n        newPacket.mMaxMessageSize = maxMessageSize;\n        newPacket.mT1 = T1;\n        newPacket.mT2 = T2;\n        newPacket.mVendorId = vendorId;\n        newPacket.mVendorInfo = vendorInfo;\n        return newPacket;\n    }"}
{"Number":"444","API Relative Path":"src.android.net.dhcp.DhcpPacket.java-decodeFullPacket(ByteBuffer-int)","Corresponding Source":"/**\n     * Creates a concrete DhcpPacket from the supplied ByteBuffer.  The\n     * buffer may have an L2 encapsulation (which is the full EthernetII\n     * format starting with the source-address MAC) or an L3 encapsulation\n     * (which starts with the IP header).\n     * <br>\n     * A subset of the optional parameters are parsed and are stored\n     * in object fields.\n     */\n    public static DhcpPacket decodeFullPacket(ByteBuffer packet, int pktType) throws ParseException\n    {\n        // bootp parameters\n        int transactionId;\n        short secs;\n        Inet4Address clientIp;\n        Inet4Address yourIp;\n        Inet4Address nextIp;\n        Inet4Address relayIp;\n        byte[] clientMac;\n        List<Inet4Address> dnsServers = new ArrayList<>();\n        List<Inet4Address> gateways = new ArrayList<>();  // aka router\n        Inet4Address serverIdentifier = null;\n        Inet4Address netMask = null;\n        String message = null;\n        String vendorId = null;\n        String vendorInfo = null;\n        byte[] expectedParams = null;\n        String hostName = null;\n        String domainName = null;\n        Inet4Address ipSrc = null;\n        Inet4Address ipDst = null;\n        Inet4Address bcAddr = null;\n        Inet4Address requestedIp = null;\n\n        // The following are all unsigned integers. Internally we store them as signed integers of\n        // the same length because that way we're guaranteed that they can't be out of the range of\n        // the unsigned field in the packet. Callers wanting to pass in an unsigned value will need\n        // to cast it.\n        Short mtu = null;\n        Short maxMessageSize = null;\n        Integer leaseTime = null;\n        Integer T1 = null;\n        Integer T2 = null;\n\n        // dhcp options\n        byte dhcpType = (byte) 0xFF;\n\n        packet.order(ByteOrder.BIG_ENDIAN);\n\n        // check to see if we need to parse L2, IP, and UDP encaps\n        if (pktType == ENCAP_L2) {\n            if (packet.remaining() < MIN_PACKET_LENGTH_L2) {\n                throw new ParseException(DhcpErrorEvent.L2_TOO_SHORT,\n                        \"L2 packet too short, %d < %d\", packet.remaining(), MIN_PACKET_LENGTH_L2);\n            }\n\n            byte[] l2dst = new byte[6];\n            byte[] l2src = new byte[6];\n\n            packet.get(l2dst);\n            packet.get(l2src);\n\n            short l2type = packet.getShort();\n\n            if (l2type != OsConstants.ETH_P_IP) {\n                throw new ParseException(DhcpErrorEvent.L2_WRONG_ETH_TYPE,\n                        \"Unexpected L2 type 0x%04x, expected 0x%04x\", l2type, OsConstants.ETH_P_IP);\n            }\n        }\n\n        if (pktType <= ENCAP_L3) {\n            if (packet.remaining() < MIN_PACKET_LENGTH_L3) {\n                throw new ParseException(DhcpErrorEvent.L3_TOO_SHORT,\n                        \"L3 packet too short, %d < %d\", packet.remaining(), MIN_PACKET_LENGTH_L3);\n            }\n\n            byte ipTypeAndLength = packet.get();\n            int ipVersion = (ipTypeAndLength & 0xf0) >> 4;\n            if (ipVersion != 4) {\n                throw new ParseException(\n                        DhcpErrorEvent.L3_NOT_IPV4, \"Invalid IP version %d\", ipVersion);\n            }\n\n            // System.out.println(\"ipType is \" + ipType);\n            byte ipDiffServicesField = packet.get();\n            short ipTotalLength = packet.getShort();\n            short ipIdentification = packet.getShort();\n            byte ipFlags = packet.get();\n            byte ipFragOffset = packet.get();\n            byte ipTTL = packet.get();\n            byte ipProto = packet.get();\n            short ipChksm = packet.getShort();\n\n            ipSrc = readIpAddress(packet);\n            ipDst = readIpAddress(packet);\n\n            if (ipProto != IP_TYPE_UDP) {\n                throw new ParseException(\n                        DhcpErrorEvent.L4_NOT_UDP, \"Protocol not UDP: %d\", ipProto);\n            }\n\n            // Skip options. This cannot cause us to read beyond the end of the buffer because the\n            // IPv4 header cannot be more than (0x0f * 4) = 60 bytes long, and that is less than\n            // MIN_PACKET_LENGTH_L3.\n            int optionWords = ((ipTypeAndLength & 0x0f) - 5);\n            for (int i = 0; i < optionWords; i++) {\n                packet.getInt();\n            }\n\n            // assume UDP\n            short udpSrcPort = packet.getShort();\n            short udpDstPort = packet.getShort();\n            short udpLen = packet.getShort();\n            short udpChkSum = packet.getShort();\n\n            // Only accept packets to or from the well-known client port (expressly permitting\n            // packets from ports other than the well-known server port; http://b/24687559), and\n            // server-to-server packets, e.g. for relays.\n            if (!isPacketToOrFromClient(udpSrcPort, udpDstPort) &&\n                !isPacketServerToServer(udpSrcPort, udpDstPort)) {\n                // This should almost never happen because we use SO_ATTACH_FILTER on the packet\n                // socket to drop packets that don't have the right source ports. However, it's\n                // possible that a packet arrives between when the socket is bound and when the\n                // filter is set. http://b/26696823 .\n                throw new ParseException(DhcpErrorEvent.L4_WRONG_PORT,\n                        \"Unexpected UDP ports %d->%d\", udpSrcPort, udpDstPort);\n            }\n        }\n\n        // We need to check the length even for ENCAP_L3 because the IPv4 header is variable-length.\n        if (pktType > ENCAP_BOOTP || packet.remaining() < MIN_PACKET_LENGTH_BOOTP) {\n            throw new ParseException(DhcpErrorEvent.BOOTP_TOO_SHORT,\n                        \"Invalid type or BOOTP packet too short, %d < %d\",\n                        packet.remaining(), MIN_PACKET_LENGTH_BOOTP);\n        }\n\n        byte type = packet.get();\n        byte hwType = packet.get();\n        int addrLen = packet.get() & 0xff;\n        byte hops = packet.get();\n        transactionId = packet.getInt();\n        secs = packet.getShort();\n        short bootpFlags = packet.getShort();\n        boolean broadcast = (bootpFlags & 0x8000) != 0;\n        byte[] ipv4addr = new byte[4];\n\n        try {\n            packet.get(ipv4addr);\n            clientIp = (Inet4Address) Inet4Address.getByAddress(ipv4addr);\n            packet.get(ipv4addr);\n            yourIp = (Inet4Address) Inet4Address.getByAddress(ipv4addr);\n            packet.get(ipv4addr);\n            nextIp = (Inet4Address) Inet4Address.getByAddress(ipv4addr);\n            packet.get(ipv4addr);\n            relayIp = (Inet4Address) Inet4Address.getByAddress(ipv4addr);\n        } catch (UnknownHostException ex) {\n            throw new ParseException(DhcpErrorEvent.L3_INVALID_IP,\n                    \"Invalid IPv4 address: %s\", Arrays.toString(ipv4addr));\n        }\n\n        // Some DHCP servers have been known to announce invalid client hardware address values such\n        // as 0xff. The legacy DHCP client accepted these becuause it does not check the length at\n        // all but only checks that the interface MAC address matches the first bytes of the address\n        // in the packets. We're a bit stricter: if the length is obviously invalid (i.e., bigger\n        // than the size of the field), we fudge it to 6 (Ethernet). http://b/23725795\n        // TODO: evaluate whether to make this test more liberal.\n        if (addrLen > HWADDR_LEN) {\n            addrLen = ETHER_BROADCAST.length;\n        }\n\n        clientMac = new byte[addrLen];\n        packet.get(clientMac);\n\n        // skip over address padding (16 octets allocated)\n        packet.position(packet.position() + (16 - addrLen)\n                        + 64    // skip server host name (64 chars)\n                        + 128); // skip boot file name (128 chars)\n\n        int dhcpMagicCookie = packet.getInt();\n\n        if (dhcpMagicCookie != DHCP_MAGIC_COOKIE) {\n            throw new ParseException(DhcpErrorEvent.DHCP_BAD_MAGIC_COOKIE,\n                    \"Bad magic cookie 0x%08x, should be 0x%08x\",\n                    dhcpMagicCookie, DHCP_MAGIC_COOKIE);\n        }\n\n        // parse options\n        boolean notFinishedOptions = true;\n\n        while ((packet.position() < packet.limit()) && notFinishedOptions) {\n            final byte optionType = packet.get(); // cannot underflow because position < limit\n            try {\n                if (optionType == DHCP_OPTION_END) {\n                    notFinishedOptions = false;\n                } else if (optionType == DHCP_OPTION_PAD) {\n                    // The pad option doesn't have a length field. Nothing to do.\n                } else {\n                    int optionLen = packet.get() & 0xFF;\n                    int expectedLen = 0;\n\n                    switch(optionType) {\n                        case DHCP_SUBNET_MASK:\n                            netMask = readIpAddress(packet);\n                            expectedLen = 4;\n                            break;\n                        case DHCP_ROUTER:\n                            for (expectedLen = 0; expectedLen < optionLen; expectedLen += 4) {\n                                gateways.add(readIpAddress(packet));\n                            }\n                            break;\n                        case DHCP_DNS_SERVER:\n                            for (expectedLen = 0; expectedLen < optionLen; expectedLen += 4) {\n                                dnsServers.add(readIpAddress(packet));\n                            }\n                            break;\n                        case DHCP_HOST_NAME:\n                            expectedLen = optionLen;\n                            hostName = readAsciiString(packet, optionLen, false);\n                            break;\n                        case DHCP_MTU:\n                            expectedLen = 2;\n                            mtu = packet.getShort();\n                            break;\n                        case DHCP_DOMAIN_NAME:\n                            expectedLen = optionLen;\n                            domainName = readAsciiString(packet, optionLen, false);\n                            break;\n                        case DHCP_BROADCAST_ADDRESS:\n                            bcAddr = readIpAddress(packet);\n                            expectedLen = 4;\n                            break;\n                        case DHCP_REQUESTED_IP:\n                            requestedIp = readIpAddress(packet);\n                            expectedLen = 4;\n                            break;\n                        case DHCP_LEASE_TIME:\n                            leaseTime = Integer.valueOf(packet.getInt());\n                            expectedLen = 4;\n                            break;\n                        case DHCP_MESSAGE_TYPE:\n                            dhcpType = packet.get();\n                            expectedLen = 1;\n                            break;\n                        case DHCP_SERVER_IDENTIFIER:\n                            serverIdentifier = readIpAddress(packet);\n                            expectedLen = 4;\n                            break;\n                        case DHCP_PARAMETER_LIST:\n                            expectedParams = new byte[optionLen];\n                            packet.get(expectedParams);\n                            expectedLen = optionLen;\n                            break;\n                        case DHCP_MESSAGE:\n                            expectedLen = optionLen;\n                            message = readAsciiString(packet, optionLen, false);\n                            break;\n                        case DHCP_MAX_MESSAGE_SIZE:\n                            expectedLen = 2;\n                            maxMessageSize = Short.valueOf(packet.getShort());\n                            break;\n                        case DHCP_RENEWAL_TIME:\n                            expectedLen = 4;\n                            T1 = Integer.valueOf(packet.getInt());\n                            break;\n                        case DHCP_REBINDING_TIME:\n                            expectedLen = 4;\n                            T2 = Integer.valueOf(packet.getInt());\n                            break;\n                        case DHCP_VENDOR_CLASS_ID:\n                            expectedLen = optionLen;\n                            // Embedded nulls are safe as this does not get passed to netd.\n                            vendorId = readAsciiString(packet, optionLen, true);\n                            break;\n                        case DHCP_CLIENT_IDENTIFIER: { // Client identifier\n                            byte[] id = new byte[optionLen];\n                            packet.get(id);\n                            expectedLen = optionLen;\n                        } break;\n                        case DHCP_VENDOR_INFO:\n                            expectedLen = optionLen;\n                            // Embedded nulls are safe as this does not get passed to netd.\n                            vendorInfo = readAsciiString(packet, optionLen, true);\n                            break;\n                        default:\n                            // ignore any other parameters\n                            for (int i = 0; i < optionLen; i++) {\n                                expectedLen++;\n                                byte throwaway = packet.get();\n                            }\n                    }\n\n                    if (expectedLen != optionLen) {\n                        final int errorCode = DhcpErrorEvent.errorCodeWithOption(\n                                DhcpErrorEvent.DHCP_INVALID_OPTION_LENGTH, optionType);\n                        throw new ParseException(errorCode,\n                                \"Invalid length %d for option %d, expected %d\",\n                                optionLen, optionType, expectedLen);\n                    }\n                }\n            } catch (BufferUnderflowException e) {\n                final int errorCode = DhcpErrorEvent.errorCodeWithOption(\n                        DhcpErrorEvent.BUFFER_UNDERFLOW, optionType);\n                throw new ParseException(errorCode, \"BufferUnderflowException\");\n            }\n        }\n\n        DhcpPacket newPacket;\n\n        switch(dhcpType) {\n            case (byte) 0xFF:\n                throw new ParseException(DhcpErrorEvent.DHCP_NO_MSG_TYPE,\n                        \"No DHCP message type option\");\n            case DHCP_MESSAGE_TYPE_DISCOVER:\n                newPacket = new DhcpDiscoverPacket(\n                    transactionId, secs, clientMac, broadcast);\n                break;\n            case DHCP_MESSAGE_TYPE_OFFER:\n                newPacket = new DhcpOfferPacket(\n                    transactionId, secs, broadcast, ipSrc, clientIp, yourIp, clientMac);\n                break;\n            case DHCP_MESSAGE_TYPE_REQUEST:\n                newPacket = new DhcpRequestPacket(\n                    transactionId, secs, clientIp, clientMac, broadcast);\n                break;\n            case DHCP_MESSAGE_TYPE_DECLINE:\n                newPacket = new DhcpDeclinePacket(\n                    transactionId, secs, clientIp, yourIp, nextIp, relayIp,\n                    clientMac);\n                break;\n            case DHCP_MESSAGE_TYPE_ACK:\n                newPacket = new DhcpAckPacket(\n                    transactionId, secs, broadcast, ipSrc, clientIp, yourIp, clientMac);\n                break;\n            case DHCP_MESSAGE_TYPE_NAK:\n                newPacket = new DhcpNakPacket(\n                    transactionId, secs, clientIp, yourIp, nextIp, relayIp,\n                    clientMac);\n                break;\n            case DHCP_MESSAGE_TYPE_INFORM:\n                newPacket = new DhcpInformPacket(\n                    transactionId, secs, clientIp, yourIp, nextIp, relayIp,\n                    clientMac);\n                break;\n            default:\n                throw new ParseException(DhcpErrorEvent.DHCP_UNKNOWN_MSG_TYPE,\n                        \"Unimplemented DHCP type %d\", dhcpType);\n        }\n\n        newPacket.mBroadcastAddress = bcAddr;\n        newPacket.mDnsServers = dnsServers;\n        newPacket.mDomainName = domainName;\n        newPacket.mGateways = gateways;\n        newPacket.mHostName = hostName;\n        newPacket.mLeaseTime = leaseTime;\n        newPacket.mMessage = message;\n        newPacket.mMtu = mtu;\n        newPacket.mRequestedIp = requestedIp;\n        newPacket.mRequestedParams = expectedParams;\n        newPacket.mServerIdentifier = serverIdentifier;\n        newPacket.mSubnetMask = netMask;\n        newPacket.mMaxMessageSize = maxMessageSize;\n        newPacket.mT1 = T1;\n        newPacket.mT2 = T2;\n        newPacket.mVendorId = vendorId;\n        newPacket.mVendorInfo = vendorInfo;\n        return newPacket;\n    }"}
{"Number":"445","API Relative Path":"src.android.net.dhcp.DhcpPacket.java-decodeFullPacket(ByteBuffer-int)","Corresponding Source":"/**\n     * Creates a concrete DhcpPacket from the supplied ByteBuffer.  The\n     * buffer may have an L2 encapsulation (which is the full EthernetII\n     * format starting with the source-address MAC) or an L3 encapsulation\n     * (which starts with the IP header).\n     * <br>\n     * A subset of the optional parameters are parsed and are stored\n     * in object fields.\n     */\n    public static DhcpPacket decodeFullPacket(ByteBuffer packet, int pktType) throws ParseException\n    {\n        // bootp parameters\n        int transactionId;\n        short secs;\n        Inet4Address clientIp;\n        Inet4Address yourIp;\n        Inet4Address nextIp;\n        Inet4Address relayIp;\n        byte[] clientMac;\n        List<Inet4Address> dnsServers = new ArrayList<>();\n        List<Inet4Address> gateways = new ArrayList<>();  // aka router\n        Inet4Address serverIdentifier = null;\n        Inet4Address netMask = null;\n        String message = null;\n        String vendorId = null;\n        String vendorInfo = null;\n        byte[] expectedParams = null;\n        String hostName = null;\n        String domainName = null;\n        Inet4Address ipSrc = null;\n        Inet4Address ipDst = null;\n        Inet4Address bcAddr = null;\n        Inet4Address requestedIp = null;\n\n        // The following are all unsigned integers. Internally we store them as signed integers of\n        // the same length because that way we're guaranteed that they can't be out of the range of\n        // the unsigned field in the packet. Callers wanting to pass in an unsigned value will need\n        // to cast it.\n        Short mtu = null;\n        Short maxMessageSize = null;\n        Integer leaseTime = null;\n        Integer T1 = null;\n        Integer T2 = null;\n\n        // dhcp options\n        byte dhcpType = (byte) 0xFF;\n\n        packet.order(ByteOrder.BIG_ENDIAN);\n\n        // check to see if we need to parse L2, IP, and UDP encaps\n        if (pktType == ENCAP_L2) {\n            if (packet.remaining() < MIN_PACKET_LENGTH_L2) {\n                throw new ParseException(DhcpErrorEvent.L2_TOO_SHORT,\n                        \"L2 packet too short, %d < %d\", packet.remaining(), MIN_PACKET_LENGTH_L2);\n            }\n\n            byte[] l2dst = new byte[6];\n            byte[] l2src = new byte[6];\n\n            packet.get(l2dst);\n            packet.get(l2src);\n\n            short l2type = packet.getShort();\n\n            if (l2type != OsConstants.ETH_P_IP) {\n                throw new ParseException(DhcpErrorEvent.L2_WRONG_ETH_TYPE,\n                        \"Unexpected L2 type 0x%04x, expected 0x%04x\", l2type, OsConstants.ETH_P_IP);\n            }\n        }\n\n        if (pktType <= ENCAP_L3) {\n            if (packet.remaining() < MIN_PACKET_LENGTH_L3) {\n                throw new ParseException(DhcpErrorEvent.L3_TOO_SHORT,\n                        \"L3 packet too short, %d < %d\", packet.remaining(), MIN_PACKET_LENGTH_L3);\n            }\n\n            byte ipTypeAndLength = packet.get();\n            int ipVersion = (ipTypeAndLength & 0xf0) >> 4;\n            if (ipVersion != 4) {\n                throw new ParseException(\n                        DhcpErrorEvent.L3_NOT_IPV4, \"Invalid IP version %d\", ipVersion);\n            }\n\n            // System.out.println(\"ipType is \" + ipType);\n            byte ipDiffServicesField = packet.get();\n            short ipTotalLength = packet.getShort();\n            short ipIdentification = packet.getShort();\n            byte ipFlags = packet.get();\n            byte ipFragOffset = packet.get();\n            byte ipTTL = packet.get();\n            byte ipProto = packet.get();\n            short ipChksm = packet.getShort();\n\n            ipSrc = readIpAddress(packet);\n            ipDst = readIpAddress(packet);\n\n            if (ipProto != IP_TYPE_UDP) {\n                throw new ParseException(\n                        DhcpErrorEvent.L4_NOT_UDP, \"Protocol not UDP: %d\", ipProto);\n            }\n\n            // Skip options. This cannot cause us to read beyond the end of the buffer because the\n            // IPv4 header cannot be more than (0x0f * 4) = 60 bytes long, and that is less than\n            // MIN_PACKET_LENGTH_L3.\n            int optionWords = ((ipTypeAndLength & 0x0f) - 5);\n            for (int i = 0; i < optionWords; i++) {\n                packet.getInt();\n            }\n\n            // assume UDP\n            short udpSrcPort = packet.getShort();\n            short udpDstPort = packet.getShort();\n            short udpLen = packet.getShort();\n            short udpChkSum = packet.getShort();\n\n            // Only accept packets to or from the well-known client port (expressly permitting\n            // packets from ports other than the well-known server port; http://b/24687559), and\n            // server-to-server packets, e.g. for relays.\n            if (!isPacketToOrFromClient(udpSrcPort, udpDstPort) &&\n                !isPacketServerToServer(udpSrcPort, udpDstPort)) {\n                // This should almost never happen because we use SO_ATTACH_FILTER on the packet\n                // socket to drop packets that don't have the right source ports. However, it's\n                // possible that a packet arrives between when the socket is bound and when the\n                // filter is set. http://b/26696823 .\n                throw new ParseException(DhcpErrorEvent.L4_WRONG_PORT,\n                        \"Unexpected UDP ports %d->%d\", udpSrcPort, udpDstPort);\n            }\n        }\n\n        // We need to check the length even for ENCAP_L3 because the IPv4 header is variable-length.\n        if (pktType > ENCAP_BOOTP || packet.remaining() < MIN_PACKET_LENGTH_BOOTP) {\n            throw new ParseException(DhcpErrorEvent.BOOTP_TOO_SHORT,\n                        \"Invalid type or BOOTP packet too short, %d < %d\",\n                        packet.remaining(), MIN_PACKET_LENGTH_BOOTP);\n        }\n\n        byte type = packet.get();\n        byte hwType = packet.get();\n        int addrLen = packet.get() & 0xff;\n        byte hops = packet.get();\n        transactionId = packet.getInt();\n        secs = packet.getShort();\n        short bootpFlags = packet.getShort();\n        boolean broadcast = (bootpFlags & 0x8000) != 0;\n        byte[] ipv4addr = new byte[4];\n\n        try {\n            packet.get(ipv4addr);\n            clientIp = (Inet4Address) Inet4Address.getByAddress(ipv4addr);\n            packet.get(ipv4addr);\n            yourIp = (Inet4Address) Inet4Address.getByAddress(ipv4addr);\n            packet.get(ipv4addr);\n            nextIp = (Inet4Address) Inet4Address.getByAddress(ipv4addr);\n            packet.get(ipv4addr);\n            relayIp = (Inet4Address) Inet4Address.getByAddress(ipv4addr);\n        } catch (UnknownHostException ex) {\n            throw new ParseException(DhcpErrorEvent.L3_INVALID_IP,\n                    \"Invalid IPv4 address: %s\", Arrays.toString(ipv4addr));\n        }\n\n        // Some DHCP servers have been known to announce invalid client hardware address values such\n        // as 0xff. The legacy DHCP client accepted these becuause it does not check the length at\n        // all but only checks that the interface MAC address matches the first bytes of the address\n        // in the packets. We're a bit stricter: if the length is obviously invalid (i.e., bigger\n        // than the size of the field), we fudge it to 6 (Ethernet). http://b/23725795\n        // TODO: evaluate whether to make this test more liberal.\n        if (addrLen > HWADDR_LEN) {\n            addrLen = ETHER_BROADCAST.length;\n        }\n\n        clientMac = new byte[addrLen];\n        packet.get(clientMac);\n\n        // skip over address padding (16 octets allocated)\n        packet.position(packet.position() + (16 - addrLen)\n                        + 64    // skip server host name (64 chars)\n                        + 128); // skip boot file name (128 chars)\n\n        int dhcpMagicCookie = packet.getInt();\n\n        if (dhcpMagicCookie != DHCP_MAGIC_COOKIE) {\n            throw new ParseException(DhcpErrorEvent.DHCP_BAD_MAGIC_COOKIE,\n                    \"Bad magic cookie 0x%08x, should be 0x%08x\",\n                    dhcpMagicCookie, DHCP_MAGIC_COOKIE);\n        }\n\n        // parse options\n        boolean notFinishedOptions = true;\n\n        while ((packet.position() < packet.limit()) && notFinishedOptions) {\n            final byte optionType = packet.get(); // cannot underflow because position < limit\n            try {\n                if (optionType == DHCP_OPTION_END) {\n                    notFinishedOptions = false;\n                } else if (optionType == DHCP_OPTION_PAD) {\n                    // The pad option doesn't have a length field. Nothing to do.\n                } else {\n                    int optionLen = packet.get() & 0xFF;\n                    int expectedLen = 0;\n\n                    switch(optionType) {\n                        case DHCP_SUBNET_MASK:\n                            netMask = readIpAddress(packet);\n                            expectedLen = 4;\n                            break;\n                        case DHCP_ROUTER:\n                            for (expectedLen = 0; expectedLen < optionLen; expectedLen += 4) {\n                                gateways.add(readIpAddress(packet));\n                            }\n                            break;\n                        case DHCP_DNS_SERVER:\n                            for (expectedLen = 0; expectedLen < optionLen; expectedLen += 4) {\n                                dnsServers.add(readIpAddress(packet));\n                            }\n                            break;\n                        case DHCP_HOST_NAME:\n                            expectedLen = optionLen;\n                            hostName = readAsciiString(packet, optionLen, false);\n                            break;\n                        case DHCP_MTU:\n                            expectedLen = 2;\n                            mtu = packet.getShort();\n                            break;\n                        case DHCP_DOMAIN_NAME:\n                            expectedLen = optionLen;\n                            domainName = readAsciiString(packet, optionLen, false);\n                            break;\n                        case DHCP_BROADCAST_ADDRESS:\n                            bcAddr = readIpAddress(packet);\n                            expectedLen = 4;\n                            break;\n                        case DHCP_REQUESTED_IP:\n                            requestedIp = readIpAddress(packet);\n                            expectedLen = 4;\n                            break;\n                        case DHCP_LEASE_TIME:\n                            leaseTime = Integer.valueOf(packet.getInt());\n                            expectedLen = 4;\n                            break;\n                        case DHCP_MESSAGE_TYPE:\n                            dhcpType = packet.get();\n                            expectedLen = 1;\n                            break;\n                        case DHCP_SERVER_IDENTIFIER:\n                            serverIdentifier = readIpAddress(packet);\n                            expectedLen = 4;\n                            break;\n                        case DHCP_PARAMETER_LIST:\n                            expectedParams = new byte[optionLen];\n                            packet.get(expectedParams);\n                            expectedLen = optionLen;\n                            break;\n                        case DHCP_MESSAGE:\n                            expectedLen = optionLen;\n                            message = readAsciiString(packet, optionLen, false);\n                            break;\n                        case DHCP_MAX_MESSAGE_SIZE:\n                            expectedLen = 2;\n                            maxMessageSize = Short.valueOf(packet.getShort());\n                            break;\n                        case DHCP_RENEWAL_TIME:\n                            expectedLen = 4;\n                            T1 = Integer.valueOf(packet.getInt());\n                            break;\n                        case DHCP_REBINDING_TIME:\n                            expectedLen = 4;\n                            T2 = Integer.valueOf(packet.getInt());\n                            break;\n                        case DHCP_VENDOR_CLASS_ID:\n                            expectedLen = optionLen;\n                            // Embedded nulls are safe as this does not get passed to netd.\n                            vendorId = readAsciiString(packet, optionLen, true);\n                            break;\n                        case DHCP_CLIENT_IDENTIFIER: { // Client identifier\n                            byte[] id = new byte[optionLen];\n                            packet.get(id);\n                            expectedLen = optionLen;\n                        } break;\n                        case DHCP_VENDOR_INFO:\n                            expectedLen = optionLen;\n                            // Embedded nulls are safe as this does not get passed to netd.\n                            vendorInfo = readAsciiString(packet, optionLen, true);\n                            break;\n                        default:\n                            // ignore any other parameters\n                            for (int i = 0; i < optionLen; i++) {\n                                expectedLen++;\n                                byte throwaway = packet.get();\n                            }\n                    }\n\n                    if (expectedLen != optionLen) {\n                        final int errorCode = DhcpErrorEvent.errorCodeWithOption(\n                                DhcpErrorEvent.DHCP_INVALID_OPTION_LENGTH, optionType);\n                        throw new ParseException(errorCode,\n                                \"Invalid length %d for option %d, expected %d\",\n                                optionLen, optionType, expectedLen);\n                    }\n                }\n            } catch (BufferUnderflowException e) {\n                final int errorCode = DhcpErrorEvent.errorCodeWithOption(\n                        DhcpErrorEvent.BUFFER_UNDERFLOW, optionType);\n                throw new ParseException(errorCode, \"BufferUnderflowException\");\n            }\n        }\n\n        DhcpPacket newPacket;\n\n        switch(dhcpType) {\n            case (byte) 0xFF:\n                throw new ParseException(DhcpErrorEvent.DHCP_NO_MSG_TYPE,\n                        \"No DHCP message type option\");\n            case DHCP_MESSAGE_TYPE_DISCOVER:\n                newPacket = new DhcpDiscoverPacket(\n                    transactionId, secs, clientMac, broadcast);\n                break;\n            case DHCP_MESSAGE_TYPE_OFFER:\n                newPacket = new DhcpOfferPacket(\n                    transactionId, secs, broadcast, ipSrc, clientIp, yourIp, clientMac);\n                break;\n            case DHCP_MESSAGE_TYPE_REQUEST:\n                newPacket = new DhcpRequestPacket(\n                    transactionId, secs, clientIp, clientMac, broadcast);\n                break;\n            case DHCP_MESSAGE_TYPE_DECLINE:\n                newPacket = new DhcpDeclinePacket(\n                    transactionId, secs, clientIp, yourIp, nextIp, relayIp,\n                    clientMac);\n                break;\n            case DHCP_MESSAGE_TYPE_ACK:\n                newPacket = new DhcpAckPacket(\n                    transactionId, secs, broadcast, ipSrc, clientIp, yourIp, clientMac);\n                break;\n            case DHCP_MESSAGE_TYPE_NAK:\n                newPacket = new DhcpNakPacket(\n                    transactionId, secs, clientIp, yourIp, nextIp, relayIp,\n                    clientMac);\n                break;\n            case DHCP_MESSAGE_TYPE_INFORM:\n                newPacket = new DhcpInformPacket(\n                    transactionId, secs, clientIp, yourIp, nextIp, relayIp,\n                    clientMac);\n                break;\n            default:\n                throw new ParseException(DhcpErrorEvent.DHCP_UNKNOWN_MSG_TYPE,\n                        \"Unimplemented DHCP type %d\", dhcpType);\n        }\n\n        newPacket.mBroadcastAddress = bcAddr;\n        newPacket.mDnsServers = dnsServers;\n        newPacket.mDomainName = domainName;\n        newPacket.mGateways = gateways;\n        newPacket.mHostName = hostName;\n        newPacket.mLeaseTime = leaseTime;\n        newPacket.mMessage = message;\n        newPacket.mMtu = mtu;\n        newPacket.mRequestedIp = requestedIp;\n        newPacket.mRequestedParams = expectedParams;\n        newPacket.mServerIdentifier = serverIdentifier;\n        newPacket.mSubnetMask = netMask;\n        newPacket.mMaxMessageSize = maxMessageSize;\n        newPacket.mT1 = T1;\n        newPacket.mT2 = T2;\n        newPacket.mVendorId = vendorId;\n        newPacket.mVendorInfo = vendorInfo;\n        return newPacket;\n    }"}
{"Number":"446","API Relative Path":"src.android.net.dhcp.DhcpPacket.java-decodeFullPacket(ByteBuffer-int)","Corresponding Source":"/**\n     * Creates a concrete DhcpPacket from the supplied ByteBuffer.  The\n     * buffer may have an L2 encapsulation (which is the full EthernetII\n     * format starting with the source-address MAC) or an L3 encapsulation\n     * (which starts with the IP header).\n     * <br>\n     * A subset of the optional parameters are parsed and are stored\n     * in object fields.\n     */\n    public static DhcpPacket decodeFullPacket(ByteBuffer packet, int pktType) throws ParseException\n    {\n        // bootp parameters\n        int transactionId;\n        short secs;\n        Inet4Address clientIp;\n        Inet4Address yourIp;\n        Inet4Address nextIp;\n        Inet4Address relayIp;\n        byte[] clientMac;\n        List<Inet4Address> dnsServers = new ArrayList<>();\n        List<Inet4Address> gateways = new ArrayList<>();  // aka router\n        Inet4Address serverIdentifier = null;\n        Inet4Address netMask = null;\n        String message = null;\n        String vendorId = null;\n        String vendorInfo = null;\n        byte[] expectedParams = null;\n        String hostName = null;\n        String domainName = null;\n        Inet4Address ipSrc = null;\n        Inet4Address ipDst = null;\n        Inet4Address bcAddr = null;\n        Inet4Address requestedIp = null;\n\n        // The following are all unsigned integers. Internally we store them as signed integers of\n        // the same length because that way we're guaranteed that they can't be out of the range of\n        // the unsigned field in the packet. Callers wanting to pass in an unsigned value will need\n        // to cast it.\n        Short mtu = null;\n        Short maxMessageSize = null;\n        Integer leaseTime = null;\n        Integer T1 = null;\n        Integer T2 = null;\n\n        // dhcp options\n        byte dhcpType = (byte) 0xFF;\n\n        packet.order(ByteOrder.BIG_ENDIAN);\n\n        // check to see if we need to parse L2, IP, and UDP encaps\n        if (pktType == ENCAP_L2) {\n            if (packet.remaining() < MIN_PACKET_LENGTH_L2) {\n                throw new ParseException(DhcpErrorEvent.L2_TOO_SHORT,\n                        \"L2 packet too short, %d < %d\", packet.remaining(), MIN_PACKET_LENGTH_L2);\n            }\n\n            byte[] l2dst = new byte[6];\n            byte[] l2src = new byte[6];\n\n            packet.get(l2dst);\n            packet.get(l2src);\n\n            short l2type = packet.getShort();\n\n            if (l2type != OsConstants.ETH_P_IP) {\n                throw new ParseException(DhcpErrorEvent.L2_WRONG_ETH_TYPE,\n                        \"Unexpected L2 type 0x%04x, expected 0x%04x\", l2type, OsConstants.ETH_P_IP);\n            }\n        }\n\n        if (pktType <= ENCAP_L3) {\n            if (packet.remaining() < MIN_PACKET_LENGTH_L3) {\n                throw new ParseException(DhcpErrorEvent.L3_TOO_SHORT,\n                        \"L3 packet too short, %d < %d\", packet.remaining(), MIN_PACKET_LENGTH_L3);\n            }\n\n            byte ipTypeAndLength = packet.get();\n            int ipVersion = (ipTypeAndLength & 0xf0) >> 4;\n            if (ipVersion != 4) {\n                throw new ParseException(\n                        DhcpErrorEvent.L3_NOT_IPV4, \"Invalid IP version %d\", ipVersion);\n            }\n\n            // System.out.println(\"ipType is \" + ipType);\n            byte ipDiffServicesField = packet.get();\n            short ipTotalLength = packet.getShort();\n            short ipIdentification = packet.getShort();\n            byte ipFlags = packet.get();\n            byte ipFragOffset = packet.get();\n            byte ipTTL = packet.get();\n            byte ipProto = packet.get();\n            short ipChksm = packet.getShort();\n\n            ipSrc = readIpAddress(packet);\n            ipDst = readIpAddress(packet);\n\n            if (ipProto != IP_TYPE_UDP) {\n                throw new ParseException(\n                        DhcpErrorEvent.L4_NOT_UDP, \"Protocol not UDP: %d\", ipProto);\n            }\n\n            // Skip options. This cannot cause us to read beyond the end of the buffer because the\n            // IPv4 header cannot be more than (0x0f * 4) = 60 bytes long, and that is less than\n            // MIN_PACKET_LENGTH_L3.\n            int optionWords = ((ipTypeAndLength & 0x0f) - 5);\n            for (int i = 0; i < optionWords; i++) {\n                packet.getInt();\n            }\n\n            // assume UDP\n            short udpSrcPort = packet.getShort();\n            short udpDstPort = packet.getShort();\n            short udpLen = packet.getShort();\n            short udpChkSum = packet.getShort();\n\n            // Only accept packets to or from the well-known client port (expressly permitting\n            // packets from ports other than the well-known server port; http://b/24687559), and\n            // server-to-server packets, e.g. for relays.\n            if (!isPacketToOrFromClient(udpSrcPort, udpDstPort) &&\n                !isPacketServerToServer(udpSrcPort, udpDstPort)) {\n                // This should almost never happen because we use SO_ATTACH_FILTER on the packet\n                // socket to drop packets that don't have the right source ports. However, it's\n                // possible that a packet arrives between when the socket is bound and when the\n                // filter is set. http://b/26696823 .\n                throw new ParseException(DhcpErrorEvent.L4_WRONG_PORT,\n                        \"Unexpected UDP ports %d->%d\", udpSrcPort, udpDstPort);\n            }\n        }\n\n        // We need to check the length even for ENCAP_L3 because the IPv4 header is variable-length.\n        if (pktType > ENCAP_BOOTP || packet.remaining() < MIN_PACKET_LENGTH_BOOTP) {\n            throw new ParseException(DhcpErrorEvent.BOOTP_TOO_SHORT,\n                        \"Invalid type or BOOTP packet too short, %d < %d\",\n                        packet.remaining(), MIN_PACKET_LENGTH_BOOTP);\n        }\n\n        byte type = packet.get();\n        byte hwType = packet.get();\n        int addrLen = packet.get() & 0xff;\n        byte hops = packet.get();\n        transactionId = packet.getInt();\n        secs = packet.getShort();\n        short bootpFlags = packet.getShort();\n        boolean broadcast = (bootpFlags & 0x8000) != 0;\n        byte[] ipv4addr = new byte[4];\n\n        try {\n            packet.get(ipv4addr);\n            clientIp = (Inet4Address) Inet4Address.getByAddress(ipv4addr);\n            packet.get(ipv4addr);\n            yourIp = (Inet4Address) Inet4Address.getByAddress(ipv4addr);\n            packet.get(ipv4addr);\n            nextIp = (Inet4Address) Inet4Address.getByAddress(ipv4addr);\n            packet.get(ipv4addr);\n            relayIp = (Inet4Address) Inet4Address.getByAddress(ipv4addr);\n        } catch (UnknownHostException ex) {\n            throw new ParseException(DhcpErrorEvent.L3_INVALID_IP,\n                    \"Invalid IPv4 address: %s\", Arrays.toString(ipv4addr));\n        }\n\n        // Some DHCP servers have been known to announce invalid client hardware address values such\n        // as 0xff. The legacy DHCP client accepted these becuause it does not check the length at\n        // all but only checks that the interface MAC address matches the first bytes of the address\n        // in the packets. We're a bit stricter: if the length is obviously invalid (i.e., bigger\n        // than the size of the field), we fudge it to 6 (Ethernet). http://b/23725795\n        // TODO: evaluate whether to make this test more liberal.\n        if (addrLen > HWADDR_LEN) {\n            addrLen = ETHER_BROADCAST.length;\n        }\n\n        clientMac = new byte[addrLen];\n        packet.get(clientMac);\n\n        // skip over address padding (16 octets allocated)\n        packet.position(packet.position() + (16 - addrLen)\n                        + 64    // skip server host name (64 chars)\n                        + 128); // skip boot file name (128 chars)\n\n        int dhcpMagicCookie = packet.getInt();\n\n        if (dhcpMagicCookie != DHCP_MAGIC_COOKIE) {\n            throw new ParseException(DhcpErrorEvent.DHCP_BAD_MAGIC_COOKIE,\n                    \"Bad magic cookie 0x%08x, should be 0x%08x\",\n                    dhcpMagicCookie, DHCP_MAGIC_COOKIE);\n        }\n\n        // parse options\n        boolean notFinishedOptions = true;\n\n        while ((packet.position() < packet.limit()) && notFinishedOptions) {\n            final byte optionType = packet.get(); // cannot underflow because position < limit\n            try {\n                if (optionType == DHCP_OPTION_END) {\n                    notFinishedOptions = false;\n                } else if (optionType == DHCP_OPTION_PAD) {\n                    // The pad option doesn't have a length field. Nothing to do.\n                } else {\n                    int optionLen = packet.get() & 0xFF;\n                    int expectedLen = 0;\n\n                    switch(optionType) {\n                        case DHCP_SUBNET_MASK:\n                            netMask = readIpAddress(packet);\n                            expectedLen = 4;\n                            break;\n                        case DHCP_ROUTER:\n                            for (expectedLen = 0; expectedLen < optionLen; expectedLen += 4) {\n                                gateways.add(readIpAddress(packet));\n                            }\n                            break;\n                        case DHCP_DNS_SERVER:\n                            for (expectedLen = 0; expectedLen < optionLen; expectedLen += 4) {\n                                dnsServers.add(readIpAddress(packet));\n                            }\n                            break;\n                        case DHCP_HOST_NAME:\n                            expectedLen = optionLen;\n                            hostName = readAsciiString(packet, optionLen, false);\n                            break;\n                        case DHCP_MTU:\n                            expectedLen = 2;\n                            mtu = packet.getShort();\n                            break;\n                        case DHCP_DOMAIN_NAME:\n                            expectedLen = optionLen;\n                            domainName = readAsciiString(packet, optionLen, false);\n                            break;\n                        case DHCP_BROADCAST_ADDRESS:\n                            bcAddr = readIpAddress(packet);\n                            expectedLen = 4;\n                            break;\n                        case DHCP_REQUESTED_IP:\n                            requestedIp = readIpAddress(packet);\n                            expectedLen = 4;\n                            break;\n                        case DHCP_LEASE_TIME:\n                            leaseTime = Integer.valueOf(packet.getInt());\n                            expectedLen = 4;\n                            break;\n                        case DHCP_MESSAGE_TYPE:\n                            dhcpType = packet.get();\n                            expectedLen = 1;\n                            break;\n                        case DHCP_SERVER_IDENTIFIER:\n                            serverIdentifier = readIpAddress(packet);\n                            expectedLen = 4;\n                            break;\n                        case DHCP_PARAMETER_LIST:\n                            expectedParams = new byte[optionLen];\n                            packet.get(expectedParams);\n                            expectedLen = optionLen;\n                            break;\n                        case DHCP_MESSAGE:\n                            expectedLen = optionLen;\n                            message = readAsciiString(packet, optionLen, false);\n                            break;\n                        case DHCP_MAX_MESSAGE_SIZE:\n                            expectedLen = 2;\n                            maxMessageSize = Short.valueOf(packet.getShort());\n                            break;\n                        case DHCP_RENEWAL_TIME:\n                            expectedLen = 4;\n                            T1 = Integer.valueOf(packet.getInt());\n                            break;\n                        case DHCP_REBINDING_TIME:\n                            expectedLen = 4;\n                            T2 = Integer.valueOf(packet.getInt());\n                            break;\n                        case DHCP_VENDOR_CLASS_ID:\n                            expectedLen = optionLen;\n                            // Embedded nulls are safe as this does not get passed to netd.\n                            vendorId = readAsciiString(packet, optionLen, true);\n                            break;\n                        case DHCP_CLIENT_IDENTIFIER: { // Client identifier\n                            byte[] id = new byte[optionLen];\n                            packet.get(id);\n                            expectedLen = optionLen;\n                        } break;\n                        case DHCP_VENDOR_INFO:\n                            expectedLen = optionLen;\n                            // Embedded nulls are safe as this does not get passed to netd.\n                            vendorInfo = readAsciiString(packet, optionLen, true);\n                            break;\n                        default:\n                            // ignore any other parameters\n                            for (int i = 0; i < optionLen; i++) {\n                                expectedLen++;\n                                byte throwaway = packet.get();\n                            }\n                    }\n\n                    if (expectedLen != optionLen) {\n                        final int errorCode = DhcpErrorEvent.errorCodeWithOption(\n                                DhcpErrorEvent.DHCP_INVALID_OPTION_LENGTH, optionType);\n                        throw new ParseException(errorCode,\n                                \"Invalid length %d for option %d, expected %d\",\n                                optionLen, optionType, expectedLen);\n                    }\n                }\n            } catch (BufferUnderflowException e) {\n                final int errorCode = DhcpErrorEvent.errorCodeWithOption(\n                        DhcpErrorEvent.BUFFER_UNDERFLOW, optionType);\n                throw new ParseException(errorCode, \"BufferUnderflowException\");\n            }\n        }\n\n        DhcpPacket newPacket;\n\n        switch(dhcpType) {\n            case (byte) 0xFF:\n                throw new ParseException(DhcpErrorEvent.DHCP_NO_MSG_TYPE,\n                        \"No DHCP message type option\");\n            case DHCP_MESSAGE_TYPE_DISCOVER:\n                newPacket = new DhcpDiscoverPacket(\n                    transactionId, secs, clientMac, broadcast);\n                break;\n            case DHCP_MESSAGE_TYPE_OFFER:\n                newPacket = new DhcpOfferPacket(\n                    transactionId, secs, broadcast, ipSrc, clientIp, yourIp, clientMac);\n                break;\n            case DHCP_MESSAGE_TYPE_REQUEST:\n                newPacket = new DhcpRequestPacket(\n                    transactionId, secs, clientIp, clientMac, broadcast);\n                break;\n            case DHCP_MESSAGE_TYPE_DECLINE:\n                newPacket = new DhcpDeclinePacket(\n                    transactionId, secs, clientIp, yourIp, nextIp, relayIp,\n                    clientMac);\n                break;\n            case DHCP_MESSAGE_TYPE_ACK:\n                newPacket = new DhcpAckPacket(\n                    transactionId, secs, broadcast, ipSrc, clientIp, yourIp, clientMac);\n                break;\n            case DHCP_MESSAGE_TYPE_NAK:\n                newPacket = new DhcpNakPacket(\n                    transactionId, secs, clientIp, yourIp, nextIp, relayIp,\n                    clientMac);\n                break;\n            case DHCP_MESSAGE_TYPE_INFORM:\n                newPacket = new DhcpInformPacket(\n                    transactionId, secs, clientIp, yourIp, nextIp, relayIp,\n                    clientMac);\n                break;\n            default:\n                throw new ParseException(DhcpErrorEvent.DHCP_UNKNOWN_MSG_TYPE,\n                        \"Unimplemented DHCP type %d\", dhcpType);\n        }\n\n        newPacket.mBroadcastAddress = bcAddr;\n        newPacket.mDnsServers = dnsServers;\n        newPacket.mDomainName = domainName;\n        newPacket.mGateways = gateways;\n        newPacket.mHostName = hostName;\n        newPacket.mLeaseTime = leaseTime;\n        newPacket.mMessage = message;\n        newPacket.mMtu = mtu;\n        newPacket.mRequestedIp = requestedIp;\n        newPacket.mRequestedParams = expectedParams;\n        newPacket.mServerIdentifier = serverIdentifier;\n        newPacket.mSubnetMask = netMask;\n        newPacket.mMaxMessageSize = maxMessageSize;\n        newPacket.mT1 = T1;\n        newPacket.mT2 = T2;\n        newPacket.mVendorId = vendorId;\n        newPacket.mVendorInfo = vendorInfo;\n        return newPacket;\n    }"}
{"Number":"447","API Relative Path":"src.android.net.DhcpInfo.java-DhcpInfo(DhcpInfo)","Corresponding Source":"/** copy constructor {@hide} */\n    public DhcpInfo(DhcpInfo source) {\n        if (source != null) {\n            ipAddress = source.ipAddress;\n            gateway = source.gateway;\n            netmask = source.netmask;\n            dns1 = source.dns1;\n            dns2 = source.dns2;\n            serverAddress = source.serverAddress;\n            leaseDuration = source.leaseDuration;\n        }\n    }"}
{"Number":"448","API Relative Path":"src.android.net.http.SslCertificate.java-restoreState(Bundle)","Corresponding Source":"/**\n     * Restores the certificate stored in the bundle\n     * @param bundle The bundle with the certificate state stored in it\n     * @return The SSL certificate stored in the bundle or null if fails\n     */\n    public static SslCertificate restoreState(Bundle bundle) {\n        if (bundle == null) {\n            return null;\n        }\n        X509Certificate x509Certificate;\n        byte[] bytes = bundle.getByteArray(X509_CERTIFICATE);\n        if (bytes == null) {\n            x509Certificate = null;\n        } else {\n            try {\n                CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\");\n                Certificate cert = certFactory.generateCertificate(new ByteArrayInputStream(bytes));\n                x509Certificate = (X509Certificate) cert;\n            } catch (CertificateException e) {\n                x509Certificate = null;\n            }\n        }\n        return new SslCertificate(bundle.getString(ISSUED_TO),\n                                  bundle.getString(ISSUED_BY),\n                                  parseDate(bundle.getString(VALID_NOT_BEFORE)),\n                                  parseDate(bundle.getString(VALID_NOT_AFTER)),\n                                  x509Certificate);\n    }"}
{"Number":"449","API Relative Path":"src.android.net.http.SslCertificate.java-saveState(SslCertificate)","Corresponding Source":"/**\n     * Saves the certificate state to a bundle\n     * @param certificate The SSL certificate to store\n     * @return A bundle with the certificate stored in it or null if fails\n     */\n    public static Bundle saveState(SslCertificate certificate) {\n        if (certificate == null) {\n            return null;\n        }\n        Bundle bundle = new Bundle();\n        bundle.putString(ISSUED_TO, certificate.getIssuedTo().getDName());\n        bundle.putString(ISSUED_BY, certificate.getIssuedBy().getDName());\n        bundle.putString(VALID_NOT_BEFORE, certificate.getValidNotBefore());\n        bundle.putString(VALID_NOT_AFTER, certificate.getValidNotAfter());\n        X509Certificate x509Certificate = certificate.mX509Certificate;\n        if (x509Certificate != null) {\n            try {\n                bundle.putByteArray(X509_CERTIFICATE, x509Certificate.getEncoded());\n            } catch (CertificateEncodingException ignored) {\n            }\n        }\n        return bundle;\n    }"}
{"Number":"450","API Relative Path":"src.android.net.LinkProperties.java-addRoute(RouteInfo)","Corresponding Source":"/**\n     * Adds a {@link RouteInfo} to this {@code LinkProperties}, if not present. If the\n     * {@link RouteInfo} had an interface name set and that differs from the interface set for this\n     * {@code LinkProperties} an {@link IllegalArgumentException} will be thrown.  The proper\n     * course is to add either un-named or properly named {@link RouteInfo}.\n     *\n     * @param route A {@link RouteInfo} to add to this object.\n     * @return {@code false} if the route was already present, {@code true} if it was added.\n     *\n     * @hide\n     */\n    public boolean addRoute(RouteInfo route) {\n        if (route != null) {\n            String routeIface = route.getInterface();\n            if (routeIface != null && !routeIface.equals(mIfaceName)) {\n                throw new IllegalArgumentException(\n                   \"Route added with non-matching interface: \" + routeIface +\n                   \" vs. \" + mIfaceName);\n            }\n            route = routeWithInterface(route);\n            if (!mRoutes.contains(route)) {\n                mRoutes.add(route);\n                return true;\n            }\n        }\n        return false;\n    }"}
{"Number":"451","API Relative Path":"src.android.net.LinkProperties.java-LinkProperties(LinkProperties)","Corresponding Source":"/**\n     * @hide\n     */\n    public LinkProperties(LinkProperties source) {\n        if (source != null) {\n            mIfaceName = source.getInterfaceName();\n            for (LinkAddress l : source.getLinkAddresses()) mLinkAddresses.add(l);\n            for (InetAddress i : source.getDnsServers()) mDnses.add(i);\n            mDomains = source.getDomains();\n            for (RouteInfo r : source.getRoutes()) mRoutes.add(r);\n            mHttpProxy = (source.getHttpProxy() == null)  ?\n                    null : new ProxyInfo(source.getHttpProxy());\n            for (LinkProperties l: source.mStackedLinks.values()) {\n                addStackedLink(l);\n            }\n            setMtu(source.getMtu());\n            mTcpBufferSizes = source.mTcpBufferSizes;\n        }\n    }"}
{"Number":"452","API Relative Path":"src.android.net.MailTo.java-parse(String)","Corresponding Source":"/**\n     * Parse and decode a mailto scheme string. This parser implements\n     * RFC 2368. The returned object can be queried for the parsed parameters.\n     * @param url String containing a mailto URL\n     * @return MailTo object\n     * @exception ParseException if the scheme is not a mailto URL\n     */\n    public static MailTo parse(String url) throws ParseException {\n        if (url == null) {\n            throw new NullPointerException();\n        }\n        if (!isMailTo(url)) {\n             throw new ParseException(\"Not a mailto scheme\");\n        }\n        // Strip the scheme as the Uri parser can't cope with it.\n        String noScheme = url.substring(MAILTO_SCHEME.length());\n        Uri email = Uri.parse(noScheme);\n        MailTo m = new MailTo();\n        \n        // Parse out the query parameters\n        String query = email.getQuery();\n        if (query != null ) {\n            String[] queries = query.split(\"&\");\n            for (String q : queries) {\n                String[] nameval = q.split(\"=\");\n                if (nameval.length == 0) {\n                    continue;\n                }\n                // insert the headers with the name in lowercase so that\n                // we can easily find common headers\n                m.mHeaders.put(Uri.decode(nameval[0]).toLowerCase(Locale.ROOT),\n                        nameval.length > 1 ? Uri.decode(nameval[1]) : null);\n            }\n        }\n        \n        // Address can be specified in both the headers and just after the\n        // mailto line. Join the two together.\n        String address = email.getPath();\n        if (address != null) {\n            String addr = m.getTo();\n            if (addr != null) {\n                address += \", \" + addr;\n            }\n            m.mHeaders.put(TO, address);\n        }\n        \n        return m;\n    }"}
{"Number":"453","API Relative Path":"src.android.net.NetworkAgent.java-sendNetworkScore(int)","Corresponding Source":"/**\n     * Called by the bearer code when it has a new score for this network.\n     */\n    public void sendNetworkScore(int score) {\n        if (score < 0) {\n            throw new IllegalArgumentException(\"Score must be >= 0\");\n        }\n        queueOrSendMessage(EVENT_NETWORK_SCORE_CHANGED, new Integer(score));\n    }"}
{"Number":"454","API Relative Path":"src.android.net.NetworkCapabilities.java-addCapability(int)","Corresponding Source":"/**\n     * Adds the given capability to this {@code NetworkCapability} instance.\n     * Multiple capabilities may be applied sequentially.  Note that when searching\n     * for a network to satisfy a request, all capabilities requested must be satisfied.\n     *\n     * @param capability the {@code NetworkCapabilities.NET_CAPABILITY_*} to be added.\n     * @return This NetworkCapabilities instance, to facilitate chaining.\n     * @hide\n     */\n    public NetworkCapabilities addCapability(int capability) {\n        if (capability < MIN_NET_CAPABILITY || capability > MAX_NET_CAPABILITY) {\n            throw new IllegalArgumentException(\"NetworkCapability out of range\");\n        }\n        mNetworkCapabilities |= 1 << capability;\n        return this;\n    }"}
{"Number":"455","API Relative Path":"src.android.net.NetworkCapabilities.java-addTransportType(int)","Corresponding Source":"/**\n     * Adds the given transport type to this {@code NetworkCapability} instance.\n     * Multiple transports may be applied sequentially.  Note that when searching\n     * for a network to satisfy a request, any listed in the request will satisfy the request.\n     * For example {@code TRANSPORT_WIFI} and {@code TRANSPORT_ETHERNET} added to a\n     * {@code NetworkCapabilities} would cause either a Wi-Fi network or an Ethernet network\n     * to be selected.  This is logically different than\n     * {@code NetworkCapabilities.NET_CAPABILITY_*} listed above.\n     *\n     * @param transportType the {@code NetworkCapabilities.TRANSPORT_*} to be added.\n     * @return This NetworkCapabilities instance, to facilitate chaining.\n     * @hide\n     */\n    public NetworkCapabilities addTransportType(int transportType) {\n        if (transportType < MIN_TRANSPORT || transportType > MAX_TRANSPORT) {\n            throw new IllegalArgumentException(\"TransportType out of range\");\n        }\n        mTransportTypes |= 1 << transportType;\n        setNetworkSpecifier(mNetworkSpecifier); // used for exception checking\n        return this;\n    }"}
{"Number":"456","API Relative Path":"src.android.net.NetworkCapabilities.java-removeCapability(int)","Corresponding Source":"/**\n     * Removes (if found) the given capability from this {@code NetworkCapability} instance.\n     *\n     * @param capability the {@code NetworkCapabilities.NET_CAPABILTIY_*} to be removed.\n     * @return This NetworkCapabilities instance, to facilitate chaining.\n     * @hide\n     */\n    public NetworkCapabilities removeCapability(int capability) {\n        if (capability < MIN_NET_CAPABILITY || capability > MAX_NET_CAPABILITY) {\n            throw new IllegalArgumentException(\"NetworkCapability out of range\");\n        }\n        mNetworkCapabilities &= ~(1 << capability);\n        return this;\n    }"}
{"Number":"457","API Relative Path":"src.android.net.NetworkCapabilities.java-removeTransportType(int)","Corresponding Source":"/**\n     * Removes (if found) the given transport from this {@code NetworkCapability} instance.\n     *\n     * @param transportType the {@code NetworkCapabilities.TRANSPORT_*} to be removed.\n     * @return This NetworkCapabilities instance, to facilitate chaining.\n     * @hide\n     */\n    public NetworkCapabilities removeTransportType(int transportType) {\n        if (transportType < MIN_TRANSPORT || transportType > MAX_TRANSPORT) {\n            throw new IllegalArgumentException(\"TransportType out of range\");\n        }\n        mTransportTypes &= ~(1 << transportType);\n        setNetworkSpecifier(mNetworkSpecifier); // used for exception checking\n        return this;\n    }"}
{"Number":"458","API Relative Path":"src.android.net.NetworkIdentity.java-scrubSubscriberId(String[])","Corresponding Source":"/**\n     * Scrub given IMSI on production builds.\n     */\n    public static String[] scrubSubscriberId(String[] subscriberId) {\n        if (subscriberId == null) return null;\n        final String[] res = new String[subscriberId.length];\n        for (int i = 0; i < res.length; i++) {\n            res[i] = NetworkIdentity.scrubSubscriberId(subscriberId[i]);\n        }\n        return res;\n    }"}
{"Number":"459","API Relative Path":"src.android.net.NetworkInfo.java-NetworkInfo(NetworkInfo)","Corresponding Source":"/** {@hide} */\n    public NetworkInfo(NetworkInfo source) {\n        if (source != null) {\n            synchronized (source) {\n                mNetworkType = source.mNetworkType;\n                mSubtype = source.mSubtype;\n                mTypeName = source.mTypeName;\n                mSubtypeName = source.mSubtypeName;\n                mState = source.mState;\n                mDetailedState = source.mDetailedState;\n                mReason = source.mReason;\n                mExtraInfo = source.mExtraInfo;\n                mIsFailover = source.mIsFailover;\n                mIsAvailable = source.mIsAvailable;\n                mIsRoaming = source.mIsRoaming;\n                mIsMetered = source.mIsMetered;\n            }\n        }\n    }"}
{"Number":"460","API Relative Path":"src.android.net.NetworkPolicyManager.java-computeLastCycleBoundary(long-NetworkPolicy)","Corresponding Source":"/**\n     * Compute the last cycle boundary for the given {@link NetworkPolicy}. For\n     * example, if cycle day is 20th, and today is June 15th, it will return May\n     * 20th. When cycle day doesn't exist in current month, it snaps to the 1st\n     * of following month.\n     *\n     * @hide\n     */\n    public static long computeLastCycleBoundary(long currentTime, NetworkPolicy policy) {\n        if (policy.cycleDay == CYCLE_NONE) {\n            throw new IllegalArgumentException(\"Unable to compute boundary without cycleDay\");\n        }\n\n        final Time now = new Time(policy.cycleTimezone);\n        now.set(currentTime);\n\n        // first, find cycle boundary for current month\n        final Time cycle = new Time(now);\n        cycle.hour = cycle.minute = cycle.second = 0;\n        snapToCycleDay(cycle, policy.cycleDay);\n\n        if (Time.compare(cycle, now) >= 0) {\n            // cycle boundary is beyond now, use last cycle boundary; start by\n            // pushing ourselves squarely into last month.\n            final Time lastMonth = new Time(now);\n            lastMonth.hour = lastMonth.minute = lastMonth.second = 0;\n            lastMonth.monthDay = 1;\n            lastMonth.month -= 1;\n            lastMonth.normalize(true);\n\n            cycle.set(lastMonth);\n            snapToCycleDay(cycle, policy.cycleDay);\n        }\n\n        return cycle.toMillis(true);\n    }"}
{"Number":"461","API Relative Path":"src.android.net.NetworkPolicyManager.java-computeNextCycleBoundary(long-NetworkPolicy)","Corresponding Source":"/** {@hide} */\n    public static long computeNextCycleBoundary(long currentTime, NetworkPolicy policy) {\n        if (policy.cycleDay == CYCLE_NONE) {\n            throw new IllegalArgumentException(\"Unable to compute boundary without cycleDay\");\n        }\n\n        final Time now = new Time(policy.cycleTimezone);\n        now.set(currentTime);\n\n        // first, find cycle boundary for current month\n        final Time cycle = new Time(now);\n        cycle.hour = cycle.minute = cycle.second = 0;\n        snapToCycleDay(cycle, policy.cycleDay);\n\n        if (Time.compare(cycle, now) <= 0) {\n            // cycle boundary is before now, use next cycle boundary; start by\n            // pushing ourselves squarely into next month.\n            final Time nextMonth = new Time(now);\n            nextMonth.hour = nextMonth.minute = nextMonth.second = 0;\n            nextMonth.monthDay = 1;\n            nextMonth.month += 1;\n            nextMonth.normalize(true);\n\n            cycle.set(nextMonth);\n            snapToCycleDay(cycle, policy.cycleDay);\n        }\n\n        return cycle.toMillis(true);\n    }"}
{"Number":"462","API Relative Path":"src.android.net.NetworkRequest.java-NetworkRequest(NetworkCapabilities-int-int)","Corresponding Source":"/**\n     * @hide\n     */\n    public NetworkRequest(NetworkCapabilities nc, int legacyType, int rId) {\n        if (nc == null) {\n            throw new NullPointerException();\n        }\n        requestId = rId;\n        networkCapabilities = nc;\n        this.legacyType = legacyType;\n    }"}
{"Number":"463","API Relative Path":"src.android.net.NetworkUtils.java-maskRawAddress(byte[]-int)","Corresponding Source":"/**\n     *  Masks a raw IP address byte array with the specified prefix length.\n     */\n    public static void maskRawAddress(byte[] array, int prefixLength) {\n        if (prefixLength < 0 || prefixLength > array.length * 8) {\n            throw new RuntimeException(\"IP address with \" + array.length +\n                    \" bytes has invalid prefix length \" + prefixLength);\n        }\n\n        int offset = prefixLength / 8;\n        int remainder = prefixLength % 8;\n        byte mask = (byte)(0xFF << (8 - remainder));\n\n        if (offset < array.length) array[offset] = (byte)(array[offset] & mask);\n\n        offset++;\n\n        for (; offset < array.length; offset++) {\n            array[offset] = 0;\n        }\n    }"}
{"Number":"464","API Relative Path":"src.android.net.NetworkUtils.java-prefixLengthToNetmaskInt(int)","Corresponding Source":"/**\n     * Convert a network prefix length to an IPv4 netmask integer\n     * @param prefixLength\n     * @return the IPv4 netmask as an integer in network byte order\n     */\n    public static int prefixLengthToNetmaskInt(int prefixLength)\n            throws IllegalArgumentException {\n        if (prefixLength < 0 || prefixLength > 32) {\n            throw new IllegalArgumentException(\"Invalid prefix length (0 <= prefix <= 32)\");\n        }\n        int value = 0xffffffff << (32 - prefixLength);\n        return Integer.reverseBytes(value);\n    }"}
{"Number":"465","API Relative Path":"src.android.net.NetworkUtils.java-trimV4AddrZeros(String)","Corresponding Source":"/**\n     * Trim leading zeros from IPv4 address strings\n     * Our base libraries will interpret that as octel..\n     * Must leave non v4 addresses and host names alone.\n     * For example, 192.168.000.010 -> 192.168.0.10\n     * TODO - fix base libraries and remove this function\n     * @param addr a string representing an ip addr\n     * @return a string propertly trimmed\n     */\n    public static String trimV4AddrZeros(String addr) {\n        if (addr == null) return null;\n        String[] octets = addr.split(\"\\\\.\");\n        if (octets.length != 4) return addr;\n        StringBuilder builder = new StringBuilder(16);\n        String result = null;\n        for (int i = 0; i < 4; i++) {\n            try {\n                if (octets[i].length() > 3) return addr;\n                builder.append(Integer.parseInt(octets[i]));\n            } catch (NumberFormatException e) {\n                return addr;\n            }\n            if (i < 3) builder.append('.');\n        }\n        result = builder.toString();\n        return result;\n    }"}
{"Number":"466","API Relative Path":"src.android.net.nsd.DnsSdTxtRecord.java-DnsSdTxtRecord(DnsSdTxtRecord)","Corresponding Source":"/** Copy constructor */\n    public DnsSdTxtRecord(DnsSdTxtRecord src) {\n        if (src != null && src.mData != null) {\n            mData = (byte[]) src.mData.clone();\n        }\n    }"}
{"Number":"467","API Relative Path":"src.android.net.nsd.NsdManager.java-discoverServices(String-int-DiscoveryListener)","Corresponding Source":"/**\n     * Initiate service discovery to browse for instances of a service type. Service discovery\n     * consumes network bandwidth and will continue until the application calls\n     * {@link #stopServiceDiscovery}.\n     *\n     * <p> The function call immediately returns after sending a request to start service\n     * discovery to the framework. The application is notified of a success to initiate\n     * discovery through the callback {@link DiscoveryListener#onDiscoveryStarted} or a failure\n     * through {@link DiscoveryListener#onStartDiscoveryFailed}.\n     *\n     * <p> Upon successful start, application is notified when a service is found with\n     * {@link DiscoveryListener#onServiceFound} or when a service is lost with\n     * {@link DiscoveryListener#onServiceLost}.\n     *\n     * <p> Upon failure to start, service discovery is not active and application does\n     * not need to invoke {@link #stopServiceDiscovery}\n     *\n     * <p> The application should call {@link #stopServiceDiscovery} when discovery of this\n     * service type is no longer required, and/or whenever the application is paused or\n     * stopped.\n     *\n     * @param serviceType The service type being discovered. Examples include \"_http._tcp\" for\n     * http services or \"_ipp._tcp\" for printers\n     * @param protocolType The service discovery protocol\n     * @param listener  The listener notifies of a successful discovery and is used\n     * to stop discovery on this serviceType through a call on {@link #stopServiceDiscovery}.\n     * Cannot be null. Cannot be in use for an active service discovery.\n     */\n    public void discoverServices(String serviceType, int protocolType, DiscoveryListener listener) {\n        if (listener == null) {\n            throw new IllegalArgumentException(\"listener cannot be null\");\n        }\n        if (TextUtils.isEmpty(serviceType)) {\n            throw new IllegalArgumentException(\"Service type cannot be empty\");\n        }\n\n        if (protocolType != PROTOCOL_DNS_SD) {\n            throw new IllegalArgumentException(\"Unsupported protocol\");\n        }\n\n        NsdServiceInfo s = new NsdServiceInfo();\n        s.setServiceType(serviceType);\n\n        int key = putListener(listener, s);\n        if (key == BUSY_LISTENER_KEY) {\n            throw new IllegalArgumentException(\"listener already in use\");\n        }\n\n        mAsyncChannel.sendMessage(DISCOVER_SERVICES, 0, key, s);\n    }"}
{"Number":"468","API Relative Path":"src.android.net.nsd.NsdManager.java-registerService(NsdServiceInfo-int-RegistrationListener)","Corresponding Source":"/**\n     * Register a service to be discovered by other services.\n     *\n     * <p> The function call immediately returns after sending a request to register service\n     * to the framework. The application is notified of a successful registration\n     * through the callback {@link RegistrationListener#onServiceRegistered} or a failure\n     * through {@link RegistrationListener#onRegistrationFailed}.\n     *\n     * <p> The application should call {@link #unregisterService} when the service\n     * registration is no longer required, and/or whenever the application is stopped.\n     *\n     * @param serviceInfo The service being registered\n     * @param protocolType The service discovery protocol\n     * @param listener The listener notifies of a successful registration and is used to\n     * unregister this service through a call on {@link #unregisterService}. Cannot be null.\n     * Cannot be in use for an active service registration.\n     */\n    public void registerService(NsdServiceInfo serviceInfo, int protocolType,\n            RegistrationListener listener) {\n        if (TextUtils.isEmpty(serviceInfo.getServiceName()) ||\n                TextUtils.isEmpty(serviceInfo.getServiceType())) {\n            throw new IllegalArgumentException(\"Service name or type cannot be empty\");\n        }\n        if (serviceInfo.getPort() <= 0) {\n            throw new IllegalArgumentException(\"Invalid port number\");\n        }\n        if (listener == null) {\n            throw new IllegalArgumentException(\"listener cannot be null\");\n        }\n        if (protocolType != PROTOCOL_DNS_SD) {\n            throw new IllegalArgumentException(\"Unsupported protocol\");\n        }\n        int key = putListener(listener, serviceInfo);\n        if (key == BUSY_LISTENER_KEY) {\n            throw new IllegalArgumentException(\"listener already in use\");\n        }\n        mAsyncChannel.sendMessage(REGISTER_SERVICE, 0, key, serviceInfo);\n    }"}
{"Number":"469","API Relative Path":"src.android.net.nsd.NsdManager.java-stopServiceDiscovery(DiscoveryListener)","Corresponding Source":"/**\n     * Stop service discovery initiated with {@link #discoverServices}.  An active service\n     * discovery is notified to the application with {@link DiscoveryListener#onDiscoveryStarted}\n     * and it stays active until the application invokes a stop service discovery. A successful\n     * stop is notified to with a call to {@link DiscoveryListener#onDiscoveryStopped}.\n     *\n     * <p> Upon failure to stop service discovery, application is notified through\n     * {@link DiscoveryListener#onStopDiscoveryFailed}.\n     *\n     * @param listener This should be the listener object that was passed to {@link #discoverServices}.\n     * It identifies the discovery that should be stopped and notifies of a successful or\n     * unsuccessful stop.  In API versions 20 and above, the listener object may be used for\n     * another service discovery once the callback has been called.  In API versions <= 19,\n     * there is no entirely reliable way to know when a listener may be re-used, and a new\n     * listener should be created for each service discovery request.\n     */\n    public void stopServiceDiscovery(DiscoveryListener listener) {\n        int id = getListenerKey(listener);\n        if (id == INVALID_LISTENER_KEY) {\n            throw new IllegalArgumentException(\"service discovery not active on listener\");\n        }\n        if (listener == null) {\n            throw new IllegalArgumentException(\"listener cannot be null\");\n        }\n        mAsyncChannel.sendMessage(STOP_DISCOVERY, 0, id);\n    }"}
{"Number":"470","API Relative Path":"src.android.net.nsd.NsdManager.java-unregisterService(RegistrationListener)","Corresponding Source":"/**\n     * Unregister a service registered through {@link #registerService}. A successful\n     * unregister is notified to the application with a call to\n     * {@link RegistrationListener#onServiceUnregistered}.\n     *\n     * @param listener This should be the listener object that was passed to\n     * {@link #registerService}. It identifies the service that should be unregistered\n     * and notifies of a successful or unsuccessful unregistration via the listener\n     * callbacks.  In API versions 20 and above, the listener object may be used for\n     * another service registration once the callback has been called.  In API versions <= 19,\n     * there is no entirely reliable way to know when a listener may be re-used, and a new\n     * listener should be created for each service registration request.\n     */\n    public void unregisterService(RegistrationListener listener) {\n        int id = getListenerKey(listener);\n        if (id == INVALID_LISTENER_KEY) {\n            throw new IllegalArgumentException(\"listener not registered\");\n        }\n        if (listener == null) {\n            throw new IllegalArgumentException(\"listener cannot be null\");\n        }\n        mAsyncChannel.sendMessage(UNREGISTER_SERVICE, 0, id);\n    }"}
{"Number":"471","API Relative Path":"src.android.net.ProxyInfo.java-ProxyInfo(Uri)","Corresponding Source":"/**\n     * Create a ProxyProperties that points at a PAC URL.\n     * @hide\n     */\n    public ProxyInfo(Uri pacFileUrl) {\n        mHost = LOCAL_HOST;\n        mPort = LOCAL_PORT;\n        setExclusionList(LOCAL_EXCL_LIST);\n        if (pacFileUrl == null) {\n            throw new NullPointerException();\n        }\n        mPacFileUrl = pacFileUrl;\n    }"}
{"Number":"472","API Relative Path":"src.android.net.ProxyInfo.java-ProxyInfo(Uri-int)","Corresponding Source":"/**\n     * Only used in PacManager after Local Proxy is bound.\n     * @hide\n     */\n    public ProxyInfo(Uri pacFileUrl, int localProxyPort) {\n        mHost = LOCAL_HOST;\n        mPort = localProxyPort;\n        setExclusionList(LOCAL_EXCL_LIST);\n        if (pacFileUrl == null) {\n            throw new NullPointerException();\n        }\n        mPacFileUrl = pacFileUrl;\n    }"}
{"Number":"473","API Relative Path":"src.android.net.RouteInfo.java-makeHostRoute(InetAddress-InetAddress-String)","Corresponding Source":"/**\n     * @hide\n     */\n    public static RouteInfo makeHostRoute(InetAddress host, InetAddress gateway, String iface) {\n        if (host == null) return null;\n\n        if (host instanceof Inet4Address) {\n            return new RouteInfo(new IpPrefix(host, 32), gateway, iface);\n        } else {\n            return new RouteInfo(new IpPrefix(host, 128), gateway, iface);\n        }\n    }"}
{"Number":"474","API Relative Path":"src.android.net.RouteInfo.java-RouteInfo(IpPrefix-InetAddress-String-int)","Corresponding Source":"/**\n     * Constructs a RouteInfo object.\n     *\n     * If destination is null, then gateway must be specified and the\n     * constructed route is either the IPv4 default route <code>0.0.0.0<\/code>\n     * if the gateway is an instance of {@link Inet4Address}, or the IPv6 default\n     * route <code>::/0<\/code> if gateway is an instance of\n     * {@link Inet6Address}.\n     * <p>\n     * destination and gateway may not both be null.\n     *\n     * @param destination the destination prefix\n     * @param gateway the IP address to route packets through\n     * @param iface the interface name to send packets on\n     *\n     * @hide\n     */\n    public RouteInfo(IpPrefix destination, InetAddress gateway, String iface, int type) {\n        switch (type) {\n            case RTN_UNICAST:\n            case RTN_UNREACHABLE:\n            case RTN_THROW:\n                // TODO: It would be nice to ensure that route types that don't have nexthops or\n                // interfaces, such as unreachable or throw, can't be created if an interface or\n                // a gateway is specified. This is a bit too complicated to do at the moment\n                // because:\n                //\n                // - LinkProperties sets the interface on routes added to it, and modifies the\n                //   interfaces of all the routes when its interface name changes.\n                // - Even when the gateway is null, we store a non-null gateway here.\n                //\n                // For now, we just rely on the code that sets routes to do things properly.\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unknown route type \" + type);\n        }\n\n        if (destination == null) {\n            if (gateway != null) {\n                if (gateway instanceof Inet4Address) {\n                    destination = new IpPrefix(Inet4Address.ANY, 0);\n                } else {\n                    destination = new IpPrefix(Inet6Address.ANY, 0);\n                }\n            } else {\n                // no destination, no gateway. invalid.\n                throw new IllegalArgumentException(\"Invalid arguments passed in: \" + gateway + \",\" +\n                                                   destination);\n            }\n        }\n        // TODO: set mGateway to null if there is no gateway. This is more correct, saves space, and\n        // matches the documented behaviour. Before we can do this we need to fix all callers (e.g.,\n        // ConnectivityService) to stop doing things like r.getGateway().equals(), ... .\n        if (gateway == null) {\n            if (destination.getAddress() instanceof Inet4Address) {\n                gateway = Inet4Address.ANY;\n            } else {\n                gateway = Inet6Address.ANY;\n            }\n        }\n        mHasGateway = (!gateway.isAnyLocalAddress());\n\n        if ((destination.getAddress() instanceof Inet4Address &&\n                 (gateway instanceof Inet4Address == false)) ||\n                (destination.getAddress() instanceof Inet6Address &&\n                 (gateway instanceof Inet6Address == false))) {\n            throw new IllegalArgumentException(\"address family mismatch in RouteInfo constructor\");\n        }\n        mDestination = destination;  // IpPrefix objects are immutable.\n        mGateway = gateway;          // InetAddress objects are immutable.\n        mInterface = iface;          // Strings are immutable.\n        mType = type;\n        mIsHost = isHost();\n    }"}
{"Number":"475","API Relative Path":"src.android.net.RouteInfo.java-RouteInfo(IpPrefix-InetAddress-String-int)","Corresponding Source":"/**\n     * Constructs a RouteInfo object.\n     *\n     * If destination is null, then gateway must be specified and the\n     * constructed route is either the IPv4 default route <code>0.0.0.0<\/code>\n     * if the gateway is an instance of {@link Inet4Address}, or the IPv6 default\n     * route <code>::/0<\/code> if gateway is an instance of\n     * {@link Inet6Address}.\n     * <p>\n     * destination and gateway may not both be null.\n     *\n     * @param destination the destination prefix\n     * @param gateway the IP address to route packets through\n     * @param iface the interface name to send packets on\n     *\n     * @hide\n     */\n    public RouteInfo(IpPrefix destination, InetAddress gateway, String iface, int type) {\n        switch (type) {\n            case RTN_UNICAST:\n            case RTN_UNREACHABLE:\n            case RTN_THROW:\n                // TODO: It would be nice to ensure that route types that don't have nexthops or\n                // interfaces, such as unreachable or throw, can't be created if an interface or\n                // a gateway is specified. This is a bit too complicated to do at the moment\n                // because:\n                //\n                // - LinkProperties sets the interface on routes added to it, and modifies the\n                //   interfaces of all the routes when its interface name changes.\n                // - Even when the gateway is null, we store a non-null gateway here.\n                //\n                // For now, we just rely on the code that sets routes to do things properly.\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unknown route type \" + type);\n        }\n\n        if (destination == null) {\n            if (gateway != null) {\n                if (gateway instanceof Inet4Address) {\n                    destination = new IpPrefix(Inet4Address.ANY, 0);\n                } else {\n                    destination = new IpPrefix(Inet6Address.ANY, 0);\n                }\n            } else {\n                // no destination, no gateway. invalid.\n                throw new IllegalArgumentException(\"Invalid arguments passed in: \" + gateway + \",\" +\n                                                   destination);\n            }\n        }\n        // TODO: set mGateway to null if there is no gateway. This is more correct, saves space, and\n        // matches the documented behaviour. Before we can do this we need to fix all callers (e.g.,\n        // ConnectivityService) to stop doing things like r.getGateway().equals(), ... .\n        if (gateway == null) {\n            if (destination.getAddress() instanceof Inet4Address) {\n                gateway = Inet4Address.ANY;\n            } else {\n                gateway = Inet6Address.ANY;\n            }\n        }\n        mHasGateway = (!gateway.isAnyLocalAddress());\n\n        if ((destination.getAddress() instanceof Inet4Address &&\n                 (gateway instanceof Inet4Address == false)) ||\n                (destination.getAddress() instanceof Inet6Address &&\n                 (gateway instanceof Inet6Address == false))) {\n            throw new IllegalArgumentException(\"address family mismatch in RouteInfo constructor\");\n        }\n        mDestination = destination;  // IpPrefix objects are immutable.\n        mGateway = gateway;          // InetAddress objects are immutable.\n        mInterface = iface;          // Strings are immutable.\n        mType = type;\n        mIsHost = isHost();\n    }"}
{"Number":"476","API Relative Path":"src.android.net.RouteInfo.java-selectBestRoute(Collection-InetAddress)","Corresponding Source":"/**\n     * Find the route from a Collection of routes that best matches a given address.\n     * May return null if no routes are applicable.\n     * @param routes a Collection of RouteInfos to chose from\n     * @param dest the InetAddress your trying to get to\n     * @return the RouteInfo from the Collection that best fits the given address\n     *\n     * @hide\n     */\n    public static RouteInfo selectBestRoute(Collection<RouteInfo> routes, InetAddress dest) {\n        if ((routes == null) || (dest == null)) return null;\n\n        RouteInfo bestRoute = null;\n        // pick a longest prefix match under same address type\n        for (RouteInfo route : routes) {\n            if (NetworkUtils.addressTypeMatches(route.mDestination.getAddress(), dest)) {\n                if ((bestRoute != null) &&\n                        (bestRoute.mDestination.getPrefixLength() >=\n                        route.mDestination.getPrefixLength())) {\n                    continue;\n                }\n                if (route.matches(dest)) bestRoute = route;\n            }\n        }\n        return bestRoute;\n    }"}
{"Number":"477","API Relative Path":"src.android.net.RssiCurve.java-RssiCurve(int-int-byte[]-int)","Corresponding Source":"/**\n     * Construct a new {@link RssiCurve}.\n     *\n     * @param start the starting dBm of the curve.\n     * @param bucketWidth the width of each RSSI bucket, in dBm.\n     * @param rssiBuckets the score for each RSSI bucket.\n     * @param activeNetworkRssiBoost the RSSI boost to apply when this network is active, in dBm.\n     */\n    public RssiCurve(int start, int bucketWidth, byte[] rssiBuckets, int activeNetworkRssiBoost) {\n        this.start = start;\n        this.bucketWidth = bucketWidth;\n        if (rssiBuckets == null || rssiBuckets.length == 0) {\n            throw new IllegalArgumentException(\"rssiBuckets must be at least one element large.\");\n        }\n        this.rssiBuckets = rssiBuckets;\n        this.activeNetworkRssiBoost = activeNetworkRssiBoost;\n    }"}
{"Number":"478","API Relative Path":"src.android.net.rtp.AudioGroup.java-sendDtmf(int)","Corresponding Source":"private native void nativeSendDtmf(int event);"}
{"Number":"479","API Relative Path":"src.android.net.rtp.AudioGroup.java-setMode(int)","Corresponding Source":"private native void nativeSetMode(int mode);"}
{"Number":"480","API Relative Path":"src.android.net.rtp.AudioStream.java-setCodec(AudioCodec)","Corresponding Source":"/**\n     * Sets the {@link AudioCodec}.\n     *\n     * @param codec The AudioCodec to be used.\n     * @throws IllegalArgumentException if its type is used by DTMF.\n     * @throws IllegalStateException if the stream is busy.\n     */\n    public void setCodec(AudioCodec codec) {\n        if (isBusy()) {\n            throw new IllegalStateException(\"Busy\");\n        }\n        if (codec.type == mDtmfType) {\n            throw new IllegalArgumentException(\"The type is used by DTMF\");\n        }\n        mCodec = codec;\n    }"}
{"Number":"481","API Relative Path":"src.android.net.rtp.AudioStream.java-setDtmfType(int)","Corresponding Source":"/**\n     * Sets the RTP payload type for dual-tone multi-frequency (DTMF) digits.\n     * The primary usage is to send digits to the remote gateway to perform\n     * certain tasks, such as second-stage dialing. According to RFC 2833, the\n     * RTP payload type for DTMF is assigned dynamically, so it must be in the\n     * range of 96 and 127. One can use {@code -1} to disable DTMF and free up\n     * the previous assigned type. This method cannot be called when the stream\n     * already joined an {@link AudioGroup}.\n     *\n     * @param type The RTP payload type to be used or {@code -1} to disable it.\n     * @throws IllegalArgumentException if the type is invalid or used by codec.\n     * @throws IllegalStateException if the stream is busy.\n     * @see AudioGroup#sendDtmf(int)\n     */\n    public void setDtmfType(int type) {\n        if (isBusy()) {\n            throw new IllegalStateException(\"Busy\");\n        }\n        if (type != -1) {\n            if (type < 96 || type > 127) {\n                throw new IllegalArgumentException(\"Invalid type\");\n            }\n            if (mCodec != null && type == mCodec.type) {\n                throw new IllegalArgumentException(\"The type is used by codec\");\n            }\n        }\n        mDtmfType = type;\n    }"}
{"Number":"482","API Relative Path":"src.android.net.rtp.AudioStream.java-setDtmfType(int)","Corresponding Source":"/**\n     * Sets the RTP payload type for dual-tone multi-frequency (DTMF) digits.\n     * The primary usage is to send digits to the remote gateway to perform\n     * certain tasks, such as second-stage dialing. According to RFC 2833, the\n     * RTP payload type for DTMF is assigned dynamically, so it must be in the\n     * range of 96 and 127. One can use {@code -1} to disable DTMF and free up\n     * the previous assigned type. This method cannot be called when the stream\n     * already joined an {@link AudioGroup}.\n     *\n     * @param type The RTP payload type to be used or {@code -1} to disable it.\n     * @throws IllegalArgumentException if the type is invalid or used by codec.\n     * @throws IllegalStateException if the stream is busy.\n     * @see AudioGroup#sendDtmf(int)\n     */\n    public void setDtmfType(int type) {\n        if (isBusy()) {\n            throw new IllegalStateException(\"Busy\");\n        }\n        if (type != -1) {\n            if (type < 96 || type > 127) {\n                throw new IllegalArgumentException(\"Invalid type\");\n            }\n            if (mCodec != null && type == mCodec.type) {\n                throw new IllegalArgumentException(\"The type is used by codec\");\n            }\n        }\n        mDtmfType = type;\n    }"}
{"Number":"483","API Relative Path":"src.android.net.rtp.RtpStream.java-associate(InetAddress-int)","Corresponding Source":"/**\n     * Associates with a remote host. This defines the destination of the\n     * outgoing packets.\n     *\n     * @param address The network address of the remote host.\n     * @param port The network port of the remote host.\n     * @throws IllegalArgumentException if the address is not supported or the\n     *     port is invalid.\n     * @throws IllegalStateException if the stream is busy.\n     * @see #isBusy()\n     */\n    public void associate(InetAddress address, int port) {\n        if (isBusy()) {\n            throw new IllegalStateException(\"Busy\");\n        }\n        if (!(address instanceof Inet4Address && mLocalAddress instanceof Inet4Address) &&\n                !(address instanceof Inet6Address && mLocalAddress instanceof Inet6Address)) {\n            throw new IllegalArgumentException(\"Unsupported address\");\n        }\n        if (port < 0 || port > 65535) {\n            throw new IllegalArgumentException(\"Invalid port\");\n        }\n        mRemoteAddress = address;\n        mRemotePort = port;\n    }"}
{"Number":"484","API Relative Path":"src.android.net.rtp.RtpStream.java-associate(InetAddress-int)","Corresponding Source":"/**\n     * Associates with a remote host. This defines the destination of the\n     * outgoing packets.\n     *\n     * @param address The network address of the remote host.\n     * @param port The network port of the remote host.\n     * @throws IllegalArgumentException if the address is not supported or the\n     *     port is invalid.\n     * @throws IllegalStateException if the stream is busy.\n     * @see #isBusy()\n     */\n    public void associate(InetAddress address, int port) {\n        if (isBusy()) {\n            throw new IllegalStateException(\"Busy\");\n        }\n        if (!(address instanceof Inet4Address && mLocalAddress instanceof Inet4Address) &&\n                !(address instanceof Inet6Address && mLocalAddress instanceof Inet6Address)) {\n            throw new IllegalArgumentException(\"Unsupported address\");\n        }\n        if (port < 0 || port > 65535) {\n            throw new IllegalArgumentException(\"Invalid port\");\n        }\n        mRemoteAddress = address;\n        mRemotePort = port;\n    }"}
{"Number":"485","API Relative Path":"src.android.net.rtp.RtpStream.java-setMode(int)","Corresponding Source":"/**\n     * Changes the current mode. It must be one of {@link #MODE_NORMAL},\n     * {@link #MODE_SEND_ONLY}, and {@link #MODE_RECEIVE_ONLY}.\n     *\n     * @param mode The mode to change to.\n     * @throws IllegalArgumentException if the mode is invalid.\n     * @throws IllegalStateException if the stream is busy.\n     * @see #isBusy()\n     */\n    public void setMode(int mode) {\n        if (isBusy()) {\n            throw new IllegalStateException(\"Busy\");\n        }\n        if (mode < 0 || mode > MODE_LAST) {\n            throw new IllegalArgumentException(\"Invalid mode\");\n        }\n        mMode = mode;\n    }"}
{"Number":"486","API Relative Path":"src.android.net.SSLCertificateSocketFactory.java-toLengthPrefixedList(byte[])","Corresponding Source":"/**\n     * Returns an array containing the concatenation of length-prefixed byte\n     * strings.\n     */\n    static byte[] toLengthPrefixedList(byte[]... items) {\n        if (items.length == 0) {\n            throw new IllegalArgumentException(\"items.length == 0\");\n        }\n        int totalLength = 0;\n        for (byte[] s : items) {\n            if (s.length == 0 || s.length > 255) {\n                throw new IllegalArgumentException(\"s.length == 0 || s.length > 255: \" + s.length);\n            }\n            totalLength += 1 + s.length;\n        }\n        byte[] result = new byte[totalLength];\n        int pos = 0;\n        for (byte[] s : items) {\n            result[pos++] = (byte) s.length;\n            for (byte b : s) {\n                result[pos++] = b;\n            }\n        }\n        return result;\n    }"}
{"Number":"487","API Relative Path":"src.android.net.SSLCertificateSocketFactory.java-verifyHostname(Socket-String)","Corresponding Source":"/**\n     * Verify the hostname of the certificate used by the other end of a\n     * connected socket.  You MUST call this if you did not supply a hostname\n     * to {@link #createSocket()}.  It is harmless to call this method\n     * redundantly if the hostname has already been verified.\n     *\n     * <p>Wildcard certificates are allowed to verify any matching hostname,\n     * so \"foo.bar.example.com\" is verified if the peer has a certificate\n     * for \"*.example.com\".\n     *\n     * @param socket An SSL socket which has been connected to a server\n     * @param hostname The expected hostname of the remote server\n     * @throws IOException if something goes wrong handshaking with the server\n     * @throws SSLPeerUnverifiedException if the server cannot prove its identity\n     *\n     * @hide\n     */\n    public static void verifyHostname(Socket socket, String hostname) throws IOException {\n        if (!(socket instanceof SSLSocket)) {\n            throw new IllegalArgumentException(\"Attempt to verify non-SSL socket\");\n        }\n\n        if (!isSslCheckRelaxed()) {\n            // The code at the start of OpenSSLSocketImpl.startHandshake()\n            // ensures that the call is idempotent, so we can safely call it.\n            SSLSocket ssl = (SSLSocket) socket;\n            ssl.startHandshake();\n\n            SSLSession session = ssl.getSession();\n            if (session == null) {\n                throw new SSLException(\"Cannot verify SSL socket without session\");\n            }\n            if (!HttpsURLConnection.getDefaultHostnameVerifier().verify(hostname, session)) {\n                throw new SSLPeerUnverifiedException(\"Cannot verify hostname: \" + hostname);\n            }\n        }\n    }"}
{"Number":"488","API Relative Path":"src.android.net.TrafficStats.java-closeQuietly(INetworkStatsSession)","Corresponding Source":"/** {@hide} */\n    public static void closeQuietly(INetworkStatsSession session) {\n        // TODO: move to NetworkStatsService once it exists\n        if (session != null) {\n            try {\n                session.close();\n            } catch (RuntimeException rethrown) {\n                throw rethrown;\n            } catch (Exception ignored) {\n            }\n        }\n    }"}
{"Number":"489","API Relative Path":"src.android.net.Uri.java-decode(String)","Corresponding Source":"/**\n     * Decodes '%'-escaped octets in the given string using the UTF-8 scheme.\n     * Replaces invalid octets with the unicode replacement character\n     * (\"\\\\uFFFD\").\n     *\n     * @param s encoded string to decode\n     * @return the given string with escaped octets decoded, or null if\n     *  s is null\n     */\n    public static String decode(String s) {\n        if (s == null) {\n            return null;\n        }\n        return UriCodec.decode(s, false, StandardCharsets.UTF_8, false);\n    }"}
{"Number":"490","API Relative Path":"src.android.net.Uri.java-encode(String-String)","Corresponding Source":"/**\n     * Encodes characters in the given string as '%'-escaped octets\n     * using the UTF-8 scheme. Leaves letters (\"A-Z\", \"a-z\"), numbers\n     * (\"0-9\"), and unreserved characters (\"_-!.~'()*\") intact. Encodes\n     * all other characters with the exception of those specified in the\n     * allow argument.\n     *\n     * @param s string to encode\n     * @param allow set of additional characters to allow in the encoded form,\n     *  null if no characters should be skipped\n     * @return an encoded version of s suitable for use as a URI component,\n     *  or null if s is null\n     */\n    public static String encode(String s, String allow) {\n        if (s == null) {\n            return null;\n        }\n\n        // Lazily-initialized buffers.\n        StringBuilder encoded = null;\n\n        int oldLength = s.length();\n\n        // This loop alternates between copying over allowed characters and\n        // encoding in chunks. This results in fewer method calls and\n        // allocations than encoding one character at a time.\n        int current = 0;\n        while (current < oldLength) {\n            // Start in \"copying\" mode where we copy over allowed chars.\n\n            // Find the next character which needs to be encoded.\n            int nextToEncode = current;\n            while (nextToEncode < oldLength\n                    && isAllowed(s.charAt(nextToEncode), allow)) {\n                nextToEncode++;\n            }\n\n            // If there's nothing more to encode...\n            if (nextToEncode == oldLength) {\n                if (current == 0) {\n                    // We didn't need to encode anything!\n                    return s;\n                } else {\n                    // Presumably, we've already done some encoding.\n                    encoded.append(s, current, oldLength);\n                    return encoded.toString();\n                }\n            }\n\n            if (encoded == null) {\n                encoded = new StringBuilder();\n            }\n\n            if (nextToEncode > current) {\n                // Append allowed characters leading up to this point.\n                encoded.append(s, current, nextToEncode);\n            } else {\n                // assert nextToEncode == current\n            }\n\n            // Switch to \"encoding\" mode.\n\n            // Find the next allowed character.\n            current = nextToEncode;\n            int nextAllowed = current + 1;\n            while (nextAllowed < oldLength\n                    && !isAllowed(s.charAt(nextAllowed), allow)) {\n                nextAllowed++;\n            }\n\n            // Convert the substring to bytes and encode the bytes as\n            // '%'-escaped octets.\n            String toEncode = s.substring(current, nextAllowed);\n            try {\n                byte[] bytes = toEncode.getBytes(DEFAULT_ENCODING);\n                int bytesLength = bytes.length;\n                for (int i = 0; i < bytesLength; i++) {\n                    encoded.append('%');\n                    encoded.append(HEX_DIGITS[(bytes[i] & 0xf0) >> 4]);\n                    encoded.append(HEX_DIGITS[bytes[i] & 0xf]);\n                }\n            } catch (UnsupportedEncodingException e) {\n                throw new AssertionError(e);\n            }\n\n            current = nextAllowed;\n        }\n\n        // Encoded could still be null at this point if s is empty.\n        return encoded == null ? s : encoded.toString();\n    }"}
{"Number":"491","API Relative Path":"src.android.net.WebAddress.java-WebAddress(String)","Corresponding Source":"/** parses given uriString. */\n    public WebAddress(String address) throws ParseException {\n        if (address == null) {\n            throw new NullPointerException();\n        }\n\n        // android.util.Log.d(LOGTAG, \"WebAddress: \" + address);\n\n        mScheme = \"\";\n        mHost = \"\";\n        mPort = -1;\n        mPath = \"/\";\n        mAuthInfo = \"\";\n\n        Matcher m = sAddressPattern.matcher(address);\n        String t;\n        if (m.matches()) {\n            t = m.group(MATCH_GROUP_SCHEME);\n            if (t != null) mScheme = t.toLowerCase(Locale.ROOT);\n            t = m.group(MATCH_GROUP_AUTHORITY);\n            if (t != null) mAuthInfo = t;\n            t = m.group(MATCH_GROUP_HOST);\n            if (t != null) mHost = t;\n            t = m.group(MATCH_GROUP_PORT);\n            if (t != null && t.length() > 0) {\n                // The ':' character is not returned by the regex.\n                try {\n                    mPort = Integer.parseInt(t);\n                } catch (NumberFormatException ex) {\n                    throw new ParseException(\"Bad port\");\n                }\n            }\n            t = m.group(MATCH_GROUP_PATH);\n            if (t != null && t.length() > 0) {\n                /* handle busted myspace frontpage redirect with\n                   missing initial \"/\" */\n                if (t.charAt(0) == '/') {\n                    mPath = t;\n                } else {\n                    mPath = \"/\" + t;\n                }\n            }\n\n        } else {\n            // nothing found... outa here\n            throw new ParseException(\"Bad address\");\n        }\n\n        /* Get port from scheme or scheme from port, if necessary and\n           possible */\n        if (mPort == 443 && mScheme.equals(\"\")) {\n            mScheme = \"https\";\n        } else if (mPort == -1) {\n            if (mScheme.equals(\"https\"))\n                mPort = 443;\n            else\n                mPort = 80; // default\n        }\n        if (mScheme.equals(\"\")) mScheme = \"http\";\n    }"}
{"Number":"492","API Relative Path":"src.android.net.wifi.nan.WifiNanManager.java-publish(int-PublishData-PublishSettings)","Corresponding Source":"/**\n     * {@hide}\n     */\n    public void publish(int sessionId, PublishData publishData, PublishSettings publishSettings) {\n        if (VDBG) Log.v(TAG, \"publish(): data='\" + publishData + \"', settings=\" + publishSettings);\n\n        if (publishSettings.mPublishType == PublishSettings.PUBLISH_TYPE_UNSOLICITED\n                && publishData.mRxFilterLength != 0) {\n            throw new IllegalArgumentException(\"Invalid publish data & settings: UNSOLICITED \"\n                    + \"publishes (active) can't have an Rx filter\");\n        }\n        if (publishSettings.mPublishType == PublishSettings.PUBLISH_TYPE_SOLICITED\n                && publishData.mTxFilterLength != 0) {\n            throw new IllegalArgumentException(\"Invalid publish data & settings: SOLICITED \"\n                    + \"publishes (passive) can't have a Tx filter\");\n        }\n\n        try {\n            mService.publish(sessionId, publishData, publishSettings);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"493","API Relative Path":"src.android.net.wifi.nan.WifiNanManager.java-publish(int-PublishData-PublishSettings)","Corresponding Source":"/**\n     * {@hide}\n     */\n    public void publish(int sessionId, PublishData publishData, PublishSettings publishSettings) {\n        if (VDBG) Log.v(TAG, \"publish(): data='\" + publishData + \"', settings=\" + publishSettings);\n\n        if (publishSettings.mPublishType == PublishSettings.PUBLISH_TYPE_UNSOLICITED\n                && publishData.mRxFilterLength != 0) {\n            throw new IllegalArgumentException(\"Invalid publish data & settings: UNSOLICITED \"\n                    + \"publishes (active) can't have an Rx filter\");\n        }\n        if (publishSettings.mPublishType == PublishSettings.PUBLISH_TYPE_SOLICITED\n                && publishData.mTxFilterLength != 0) {\n            throw new IllegalArgumentException(\"Invalid publish data & settings: SOLICITED \"\n                    + \"publishes (passive) can't have a Tx filter\");\n        }\n\n        try {\n            mService.publish(sessionId, publishData, publishSettings);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"494","API Relative Path":"src.android.net.wifi.nan.WifiNanManager.java-publishRaw(PublishData-PublishSettings-WifiNanSessionListener-int)","Corresponding Source":"/**\n     * Same as publish(*) but does not modify the event flag\n     *\n     * @hide\n     */\n    public WifiNanPublishSession publishRaw(PublishData publishData,\n            PublishSettings publishSettings, WifiNanSessionListener listener, int events) {\n        if (VDBG) Log.v(TAG, \"publish(): data='\" + publishData + \"', settings=\" + publishSettings);\n\n        if (publishSettings.mPublishType == PublishSettings.PUBLISH_TYPE_UNSOLICITED\n                && publishData.mRxFilterLength != 0) {\n            throw new IllegalArgumentException(\"Invalid publish data & settings: UNSOLICITED \"\n                    + \"publishes (active) can't have an Rx filter\");\n        }\n        if (publishSettings.mPublishType == PublishSettings.PUBLISH_TYPE_SOLICITED\n                && publishData.mTxFilterLength != 0) {\n            throw new IllegalArgumentException(\"Invalid publish data & settings: SOLICITED \"\n                    + \"publishes (passive) can't have a Tx filter\");\n        }\n        if (listener == null) {\n            throw new IllegalArgumentException(\"Invalid listener - must not be null\");\n        }\n\n        int sessionId;\n\n        try {\n            sessionId = mService.createSession(listener.callback, events);\n            if (DBG) Log.d(TAG, \"publish: session created - sessionId=\" + sessionId);\n            mService.publish(sessionId, publishData, publishSettings);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n\n        return new WifiNanPublishSession(this, sessionId);\n    }"}
{"Number":"495","API Relative Path":"src.android.net.wifi.nan.WifiNanManager.java-publishRaw(PublishData-PublishSettings-WifiNanSessionListener-int)","Corresponding Source":"/**\n     * Same as publish(*) but does not modify the event flag\n     *\n     * @hide\n     */\n    public WifiNanPublishSession publishRaw(PublishData publishData,\n            PublishSettings publishSettings, WifiNanSessionListener listener, int events) {\n        if (VDBG) Log.v(TAG, \"publish(): data='\" + publishData + \"', settings=\" + publishSettings);\n\n        if (publishSettings.mPublishType == PublishSettings.PUBLISH_TYPE_UNSOLICITED\n                && publishData.mRxFilterLength != 0) {\n            throw new IllegalArgumentException(\"Invalid publish data & settings: UNSOLICITED \"\n                    + \"publishes (active) can't have an Rx filter\");\n        }\n        if (publishSettings.mPublishType == PublishSettings.PUBLISH_TYPE_SOLICITED\n                && publishData.mTxFilterLength != 0) {\n            throw new IllegalArgumentException(\"Invalid publish data & settings: SOLICITED \"\n                    + \"publishes (passive) can't have a Tx filter\");\n        }\n        if (listener == null) {\n            throw new IllegalArgumentException(\"Invalid listener - must not be null\");\n        }\n\n        int sessionId;\n\n        try {\n            sessionId = mService.createSession(listener.callback, events);\n            if (DBG) Log.d(TAG, \"publish: session created - sessionId=\" + sessionId);\n            mService.publish(sessionId, publishData, publishSettings);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n\n        return new WifiNanPublishSession(this, sessionId);\n    }"}
{"Number":"496","API Relative Path":"src.android.net.wifi.nan.WifiNanManager.java-publishRaw(PublishData-PublishSettings-WifiNanSessionListener-int)","Corresponding Source":"/**\n     * Same as publish(*) but does not modify the event flag\n     *\n     * @hide\n     */\n    public WifiNanPublishSession publishRaw(PublishData publishData,\n            PublishSettings publishSettings, WifiNanSessionListener listener, int events) {\n        if (VDBG) Log.v(TAG, \"publish(): data='\" + publishData + \"', settings=\" + publishSettings);\n\n        if (publishSettings.mPublishType == PublishSettings.PUBLISH_TYPE_UNSOLICITED\n                && publishData.mRxFilterLength != 0) {\n            throw new IllegalArgumentException(\"Invalid publish data & settings: UNSOLICITED \"\n                    + \"publishes (active) can't have an Rx filter\");\n        }\n        if (publishSettings.mPublishType == PublishSettings.PUBLISH_TYPE_SOLICITED\n                && publishData.mTxFilterLength != 0) {\n            throw new IllegalArgumentException(\"Invalid publish data & settings: SOLICITED \"\n                    + \"publishes (passive) can't have a Tx filter\");\n        }\n        if (listener == null) {\n            throw new IllegalArgumentException(\"Invalid listener - must not be null\");\n        }\n\n        int sessionId;\n\n        try {\n            sessionId = mService.createSession(listener.callback, events);\n            if (DBG) Log.d(TAG, \"publish: session created - sessionId=\" + sessionId);\n            mService.publish(sessionId, publishData, publishSettings);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n\n        return new WifiNanPublishSession(this, sessionId);\n    }"}
{"Number":"497","API Relative Path":"src.android.net.wifi.nan.WifiNanManager.java-subscribe(int-SubscribeData-SubscribeSettings)","Corresponding Source":"/**\n     * {@hide}\n     */\n    public void subscribe(int sessionId, SubscribeData subscribeData,\n            SubscribeSettings subscribeSettings) {\n        if (VDBG) {\n            Log.v(TAG, \"subscribe(): data='\" + subscribeData + \"', settings=\" + subscribeSettings);\n        }\n\n        if (subscribeSettings.mSubscribeType == SubscribeSettings.SUBSCRIBE_TYPE_ACTIVE\n                && subscribeData.mRxFilterLength != 0) {\n            throw new IllegalArgumentException(\n                    \"Invalid subscribe data & settings: ACTIVE subscribes can't have an Rx filter\");\n        }\n        if (subscribeSettings.mSubscribeType == SubscribeSettings.SUBSCRIBE_TYPE_PASSIVE\n                && subscribeData.mTxFilterLength != 0) {\n            throw new IllegalArgumentException(\n                    \"Invalid subscribe data & settings: PASSIVE subscribes can't have a Tx filter\");\n        }\n\n        try {\n            mService.subscribe(sessionId, subscribeData, subscribeSettings);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"498","API Relative Path":"src.android.net.wifi.nan.WifiNanManager.java-subscribe(int-SubscribeData-SubscribeSettings)","Corresponding Source":"/**\n     * {@hide}\n     */\n    public void subscribe(int sessionId, SubscribeData subscribeData,\n            SubscribeSettings subscribeSettings) {\n        if (VDBG) {\n            Log.v(TAG, \"subscribe(): data='\" + subscribeData + \"', settings=\" + subscribeSettings);\n        }\n\n        if (subscribeSettings.mSubscribeType == SubscribeSettings.SUBSCRIBE_TYPE_ACTIVE\n                && subscribeData.mRxFilterLength != 0) {\n            throw new IllegalArgumentException(\n                    \"Invalid subscribe data & settings: ACTIVE subscribes can't have an Rx filter\");\n        }\n        if (subscribeSettings.mSubscribeType == SubscribeSettings.SUBSCRIBE_TYPE_PASSIVE\n                && subscribeData.mTxFilterLength != 0) {\n            throw new IllegalArgumentException(\n                    \"Invalid subscribe data & settings: PASSIVE subscribes can't have a Tx filter\");\n        }\n\n        try {\n            mService.subscribe(sessionId, subscribeData, subscribeSettings);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"499","API Relative Path":"src.android.net.wifi.nan.WifiNanManager.java-subscribeRaw(SubscribeData-SubscribeSettings-WifiNanSessionListener-int)","Corresponding Source":"/**\n     * Same as subscribe(*) but does not modify the event flag\n     *\n     * @hide\n     */\n    public WifiNanSubscribeSession subscribeRaw(SubscribeData subscribeData,\n            SubscribeSettings subscribeSettings, WifiNanSessionListener listener, int events) {\n        if (VDBG) {\n            Log.v(TAG, \"subscribe(): data='\" + subscribeData + \"', settings=\" + subscribeSettings);\n        }\n\n        if (subscribeSettings.mSubscribeType == SubscribeSettings.SUBSCRIBE_TYPE_ACTIVE\n                && subscribeData.mRxFilterLength != 0) {\n            throw new IllegalArgumentException(\n                    \"Invalid subscribe data & settings: ACTIVE subscribes can't have an Rx filter\");\n        }\n        if (subscribeSettings.mSubscribeType == SubscribeSettings.SUBSCRIBE_TYPE_PASSIVE\n                && subscribeData.mTxFilterLength != 0) {\n            throw new IllegalArgumentException(\n                    \"Invalid subscribe data & settings: PASSIVE subscribes can't have a Tx filter\");\n        }\n\n        int sessionId;\n\n        try {\n            sessionId = mService.createSession(listener.callback, events);\n            if (DBG) Log.d(TAG, \"subscribe: session created - sessionId=\" + sessionId);\n            mService.subscribe(sessionId, subscribeData, subscribeSettings);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n\n        return new WifiNanSubscribeSession(this, sessionId);\n    }"}
{"Number":"500","API Relative Path":"src.android.net.wifi.nan.WifiNanManager.java-subscribeRaw(SubscribeData-SubscribeSettings-WifiNanSessionListener-int)","Corresponding Source":"/**\n     * Same as subscribe(*) but does not modify the event flag\n     *\n     * @hide\n     */\n    public WifiNanSubscribeSession subscribeRaw(SubscribeData subscribeData,\n            SubscribeSettings subscribeSettings, WifiNanSessionListener listener, int events) {\n        if (VDBG) {\n            Log.v(TAG, \"subscribe(): data='\" + subscribeData + \"', settings=\" + subscribeSettings);\n        }\n\n        if (subscribeSettings.mSubscribeType == SubscribeSettings.SUBSCRIBE_TYPE_ACTIVE\n                && subscribeData.mRxFilterLength != 0) {\n            throw new IllegalArgumentException(\n                    \"Invalid subscribe data & settings: ACTIVE subscribes can't have an Rx filter\");\n        }\n        if (subscribeSettings.mSubscribeType == SubscribeSettings.SUBSCRIBE_TYPE_PASSIVE\n                && subscribeData.mTxFilterLength != 0) {\n            throw new IllegalArgumentException(\n                    \"Invalid subscribe data & settings: PASSIVE subscribes can't have a Tx filter\");\n        }\n\n        int sessionId;\n\n        try {\n            sessionId = mService.createSession(listener.callback, events);\n            if (DBG) Log.d(TAG, \"subscribe: session created - sessionId=\" + sessionId);\n            mService.subscribe(sessionId, subscribeData, subscribeSettings);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n\n        return new WifiNanSubscribeSession(this, sessionId);\n    }"}
{"Number":"501","API Relative Path":"src.android.net.wifi.p2p.nsd.WifiP2pDnsSdServiceRequest.java-newInstance(String)","Corresponding Source":"/**\n     * Create a service discovery to search for Bonjour services with the specified\n     * service type.\n     *\n     * @param serviceType service type. Cannot be null <br>\n     *  \"_afpovertcp._tcp.\"(Apple File Sharing over TCP)<br>\n     *  \"_ipp._tcp\" (IP Printing over TCP)<br>\n     *  \"_http._tcp\" (http service)\n     * @return service request for DnsSd.\n     */\n    public static WifiP2pDnsSdServiceRequest newInstance(String serviceType) {\n        if (serviceType == null) {\n            throw new IllegalArgumentException(\"service type cannot be null\");\n        }\n        return new WifiP2pDnsSdServiceRequest(serviceType + \".local.\",\n                WifiP2pDnsSdServiceInfo.DNS_TYPE_PTR,\n                WifiP2pDnsSdServiceInfo.VERSION_1);\n    }"}
{"Number":"502","API Relative Path":"src.android.net.wifi.p2p.nsd.WifiP2pDnsSdServiceRequest.java-newInstance(String-String)","Corresponding Source":"/**\n     * Create a service discovery request to get the TXT data from the specified\n     * Bonjour service.\n     *\n     * @param instanceName instance name. Cannot be null. <br>\n     *  \"MyPrinter\"\n     * @param serviceType service type. Cannot be null. <br>\n     * e.g) <br>\n     *  \"_afpovertcp._tcp\"(Apple File Sharing over TCP)<br>\n     *  \"_ipp._tcp\" (IP Printing over TCP)<br>\n     * @return service request for Bonjour.\n     */\n    public static WifiP2pDnsSdServiceRequest newInstance(String instanceName,\n            String serviceType) {\n        if (instanceName == null || serviceType == null) {\n            throw new IllegalArgumentException(\n                    \"instance name or service type cannot be null\");\n        }\n        String fullDomainName = instanceName + \".\" + serviceType + \".local.\";\n        return new WifiP2pDnsSdServiceRequest(fullDomainName,\n                WifiP2pDnsSdServiceInfo.DNS_TYPE_TXT,\n                WifiP2pDnsSdServiceInfo.VERSION_1);\n    }"}
{"Number":"503","API Relative Path":"src.android.net.wifi.p2p.nsd.WifiP2pServiceInfo.java-WifiP2pServiceInfo(List)","Corresponding Source":"/**\n     * This is only used in subclass.\n     *\n     * @param queryList query string for wpa_supplicant\n     * @hide\n     */\n    protected WifiP2pServiceInfo(List<String> queryList) {\n        if (queryList == null) {\n            throw new IllegalArgumentException(\"query list cannot be null\");\n        }\n        mQueryList = queryList;\n    }"}
{"Number":"504","API Relative Path":"src.android.net.wifi.p2p.nsd.WifiP2pServiceResponse.java-setSrcDevice(WifiP2pDevice)","Corresponding Source":"/** @hide */\n    public void setSrcDevice(WifiP2pDevice dev) {\n        if (dev == null) return;\n        this.mDevice = dev;\n    }"}
{"Number":"505","API Relative Path":"src.android.net.wifi.p2p.nsd.WifiP2pUpnpServiceInfo.java-newInstance(String-String-List)","Corresponding Source":"/**\n     * Create UPnP service information object.\n     *\n     * @param uuid a string representation of this UUID in the following format,\n     *  as per <a href=\"http://www.ietf.org/rfc/rfc4122.txt\">RFC 4122<\/a>.<br>\n     *  e.g) 6859dede-8574-59ab-9332-123456789012\n     * @param device a string representation of this device in the following format,\n     * as per\n     * <a href=\"http://www.upnp.org/specs/arch/UPnP-arch-DeviceArchitecture-v1.1.pdf\">\n     *  UPnP Device Architecture1.1<\/a><br>\n     *  e.g) urn:schemas-upnp-org:device:MediaServer:1\n     * @param services a string representation of this service in the following format,\n     * as per\n     * <a href=\"http://www.upnp.org/specs/arch/UPnP-arch-DeviceArchitecture-v1.1.pdf\">\n     *  UPnP Device Architecture1.1<\/a><br>\n     *  e.g) urn:schemas-upnp-org:service:ContentDirectory:1\n     * @return UPnP service information object.\n     */\n    public static WifiP2pUpnpServiceInfo newInstance(String uuid,\n            String device, List<String> services) {\n        if (uuid == null || device == null) {\n            throw new IllegalArgumentException(\"uuid or device cannnot be null\");\n        }\n        UUID.fromString(uuid);\n\n        ArrayList<String> info = new ArrayList<String>();\n\n        info.add(createSupplicantQuery(uuid, null));\n        info.add(createSupplicantQuery(uuid, \"upnp:rootdevice\"));\n        info.add(createSupplicantQuery(uuid, device));\n        if (services != null) {\n            for (String service:services) {\n                info.add(createSupplicantQuery(uuid, service));\n            }\n        }\n\n        return new WifiP2pUpnpServiceInfo(info);\n    }"}
{"Number":"506","API Relative Path":"src.android.net.wifi.p2p.WifiP2pConfig.java-WifiP2pConfig(WifiP2pConfig)","Corresponding Source":"/** copy constructor */\n    public WifiP2pConfig(WifiP2pConfig source) {\n        if (source != null) {\n            deviceAddress = source.deviceAddress;\n            wps = new WpsInfo(source.wps);\n            groupOwnerIntent = source.groupOwnerIntent;\n            netId = source.netId;\n        }\n    }"}
{"Number":"507","API Relative Path":"src.android.net.wifi.p2p.WifiP2pDevice.java-updateSupplicantDetails(WifiP2pDevice)","Corresponding Source":"/** Updates details obtained from supplicant @hide */\n    public void updateSupplicantDetails(WifiP2pDevice device) {\n        if (device == null) {\n            throw new IllegalArgumentException(\"device is null\");\n        }\n        if (device.deviceAddress == null) {\n            throw new IllegalArgumentException(\"deviceAddress is null\");\n        }\n        if (!deviceAddress.equals(device.deviceAddress)) {\n            throw new IllegalArgumentException(\"deviceAddress does not match\");\n        }\n        deviceName = device.deviceName;\n        primaryDeviceType = device.primaryDeviceType;\n        secondaryDeviceType = device.secondaryDeviceType;\n        wpsConfigMethodsSupported = device.wpsConfigMethodsSupported;\n        deviceCapability = device.deviceCapability;\n        groupCapability = device.groupCapability;\n        wfdInfo = device.wfdInfo;\n    }"}
{"Number":"508","API Relative Path":"src.android.net.wifi.p2p.WifiP2pDevice.java-updateSupplicantDetails(WifiP2pDevice)","Corresponding Source":"/** Updates details obtained from supplicant @hide */\n    public void updateSupplicantDetails(WifiP2pDevice device) {\n        if (device == null) {\n            throw new IllegalArgumentException(\"device is null\");\n        }\n        if (device.deviceAddress == null) {\n            throw new IllegalArgumentException(\"deviceAddress is null\");\n        }\n        if (!deviceAddress.equals(device.deviceAddress)) {\n            throw new IllegalArgumentException(\"deviceAddress does not match\");\n        }\n        deviceName = device.deviceName;\n        primaryDeviceType = device.primaryDeviceType;\n        secondaryDeviceType = device.secondaryDeviceType;\n        wpsConfigMethodsSupported = device.wpsConfigMethodsSupported;\n        deviceCapability = device.deviceCapability;\n        groupCapability = device.groupCapability;\n        wfdInfo = device.wfdInfo;\n    }"}
{"Number":"509","API Relative Path":"src.android.net.wifi.p2p.WifiP2pDevice.java-WifiP2pDevice(WifiP2pDevice)","Corresponding Source":"/** copy constructor */\n    public WifiP2pDevice(WifiP2pDevice source) {\n        if (source != null) {\n            deviceName = source.deviceName;\n            deviceAddress = source.deviceAddress;\n            primaryDeviceType = source.primaryDeviceType;\n            secondaryDeviceType = source.secondaryDeviceType;\n            wpsConfigMethodsSupported = source.wpsConfigMethodsSupported;\n            deviceCapability = source.deviceCapability;\n            groupCapability = source.groupCapability;\n            status = source.status;\n            wfdInfo = new WifiP2pWfdInfo(source.wfdInfo);\n        }\n    }"}
{"Number":"510","API Relative Path":"src.android.net.wifi.p2p.WifiP2pDeviceList.java-WifiP2pDeviceList(WifiP2pDeviceList)","Corresponding Source":"/** copy constructor */\n    public WifiP2pDeviceList(WifiP2pDeviceList source) {\n        if (source != null) {\n            for (WifiP2pDevice d : source.getDeviceList()) {\n                mDevices.put(d.deviceAddress, new WifiP2pDevice(d));\n            }\n        }\n    }"}
{"Number":"511","API Relative Path":"src.android.net.wifi.p2p.WifiP2pGroup.java-WifiP2pGroup(WifiP2pGroup)","Corresponding Source":"/** copy constructor */\n    public WifiP2pGroup(WifiP2pGroup source) {\n        if (source != null) {\n            mNetworkName = source.getNetworkName();\n            mOwner = new WifiP2pDevice(source.getOwner());\n            mIsGroupOwner = source.mIsGroupOwner;\n            for (WifiP2pDevice d : source.getClientList()) mClients.add(d);\n            mPassphrase = source.getPassphrase();\n            mInterface = source.getInterface();\n            mNetId = source.getNetworkId();\n        }\n    }"}
{"Number":"512","API Relative Path":"src.android.net.wifi.p2p.WifiP2pGroupList.java-WifiP2pGroupList(WifiP2pGroupList-GroupDeleteListener)","Corresponding Source":"/** @hide */\n    public WifiP2pGroupList(WifiP2pGroupList source, GroupDeleteListener listener) {\n        mListener = listener;\n        mGroups = new LruCache<Integer, WifiP2pGroup>(CREDENTIAL_MAX_NUM) {\n            @Override\n            protected void entryRemoved(boolean evicted, Integer netId,\n                    WifiP2pGroup oldValue, WifiP2pGroup newValue) {\n                if (mListener != null && !isClearCalled) {\n                    mListener.onDeleteGroup(oldValue.getNetworkId());\n                }\n            }\n        };\n\n        if (source != null) {\n            for (Map.Entry<Integer, WifiP2pGroup> item : source.mGroups.snapshot().entrySet()) {\n                mGroups.put(item.getKey(), item.getValue());\n            }\n        }\n    }"}
{"Number":"513","API Relative Path":"src.android.net.wifi.p2p.WifiP2pInfo.java-WifiP2pInfo(WifiP2pInfo)","Corresponding Source":"/** copy constructor */\n    public WifiP2pInfo(WifiP2pInfo source) {\n        if (source != null) {\n            groupFormed = source.groupFormed;\n            isGroupOwner = source.isGroupOwner;\n            groupOwnerAddress = source.groupOwnerAddress;\n       }\n    }"}
{"Number":"514","API Relative Path":"src.android.net.wifi.p2p.WifiP2pWfdInfo.java-WifiP2pWfdInfo(WifiP2pWfdInfo)","Corresponding Source":"/** copy constructor */\n    public WifiP2pWfdInfo(WifiP2pWfdInfo source) {\n        if (source != null) {\n            mWfdEnabled = source.mWfdEnabled;\n            mDeviceInfo = source.mDeviceInfo;\n            mCtrlPort = source.mCtrlPort;\n            mMaxThroughput = source.mMaxThroughput;\n        }\n    }"}
{"Number":"515","API Relative Path":"src.android.net.wifi.ScanResult.java-ScanResult(ScanResult)","Corresponding Source":"/** copy constructor {@hide} */\n    public ScanResult(ScanResult source) {\n        if (source != null) {\n            wifiSsid = source.wifiSsid;\n            SSID = source.SSID;\n            BSSID = source.BSSID;\n            hessid = source.hessid;\n            anqpDomainId = source.anqpDomainId;\n            informationElements = source.informationElements;\n            anqpElements = source.anqpElements;\n            capabilities = source.capabilities;\n            level = source.level;\n            frequency = source.frequency;\n            channelWidth = source.channelWidth;\n            centerFreq0 = source.centerFreq0;\n            centerFreq1 = source.centerFreq1;\n            timestamp = source.timestamp;\n            distanceCm = source.distanceCm;\n            distanceSdCm = source.distanceSdCm;\n            seen = source.seen;\n            untrusted = source.untrusted;\n            numConnection = source.numConnection;\n            numUsage = source.numUsage;\n            numIpConfigFailures = source.numIpConfigFailures;\n            isAutoJoinCandidate = source.isAutoJoinCandidate;\n            venueName = source.venueName;\n            operatorFriendlyName = source.operatorFriendlyName;\n            flags = source.flags;\n        }\n    }"}
{"Number":"516","API Relative Path":"src.android.net.wifi.ScanSettings.java-ScanSettings(ScanSettings)","Corresponding Source":"/** copy constructor */\n    public ScanSettings(ScanSettings source) {\n        if (source.channelSet != null)\n            channelSet = new ArrayList<WifiChannel>(source.channelSet);\n    }"}
{"Number":"517","API Relative Path":"src.android.net.wifi.WifiConfiguration.java-WifiConfiguration(WifiConfiguration)","Corresponding Source":"/** copy constructor {@hide} */\n    public WifiConfiguration(WifiConfiguration source) {\n        if (source != null) {\n            networkId = source.networkId;\n            status = source.status;\n            SSID = source.SSID;\n            BSSID = source.BSSID;\n            FQDN = source.FQDN;\n            roamingConsortiumIds = source.roamingConsortiumIds.clone();\n            providerFriendlyName = source.providerFriendlyName;\n            preSharedKey = source.preSharedKey;\n\n            mNetworkSelectionStatus.copy(source.getNetworkSelectionStatus());\n            apBand = source.apBand;\n            apChannel = source.apChannel;\n\n            wepKeys = new String[4];\n            for (int i = 0; i < wepKeys.length; i++) {\n                wepKeys[i] = source.wepKeys[i];\n            }\n\n            wepTxKeyIndex = source.wepTxKeyIndex;\n            priority = source.priority;\n            hiddenSSID = source.hiddenSSID;\n            allowedKeyManagement   = (BitSet) source.allowedKeyManagement.clone();\n            allowedProtocols       = (BitSet) source.allowedProtocols.clone();\n            allowedAuthAlgorithms  = (BitSet) source.allowedAuthAlgorithms.clone();\n            allowedPairwiseCiphers = (BitSet) source.allowedPairwiseCiphers.clone();\n            allowedGroupCiphers    = (BitSet) source.allowedGroupCiphers.clone();\n            enterpriseConfig = new WifiEnterpriseConfig(source.enterpriseConfig);\n\n            defaultGwMacAddress = source.defaultGwMacAddress;\n\n            mIpConfiguration = new IpConfiguration(source.mIpConfiguration);\n\n            if ((source.linkedConfigurations != null)\n                    && (source.linkedConfigurations.size() > 0)) {\n                linkedConfigurations = new HashMap<String, Integer>();\n                linkedConfigurations.putAll(source.linkedConfigurations);\n            }\n            mCachedConfigKey = null; //force null configKey\n            selfAdded = source.selfAdded;\n            validatedInternetAccess = source.validatedInternetAccess;\n            ephemeral = source.ephemeral;\n            meteredHint = source.meteredHint;\n            useExternalScores = source.useExternalScores;\n            if (source.visibility != null) {\n                visibility = new Visibility(source.visibility);\n            }\n\n            lastFailure = source.lastFailure;\n            didSelfAdd = source.didSelfAdd;\n            lastConnectUid = source.lastConnectUid;\n            lastUpdateUid = source.lastUpdateUid;\n            creatorUid = source.creatorUid;\n            creatorName = source.creatorName;\n            lastUpdateName = source.lastUpdateName;\n            peerWifiConfiguration = source.peerWifiConfiguration;\n\n            lastConnected = source.lastConnected;\n            lastDisconnected = source.lastDisconnected;\n            lastConnectionFailure = source.lastConnectionFailure;\n            lastRoamingFailure = source.lastRoamingFailure;\n            lastRoamingFailureReason = source.lastRoamingFailureReason;\n            roamingFailureBlackListTimeMilli = source.roamingFailureBlackListTimeMilli;\n            numScorerOverride = source.numScorerOverride;\n            numScorerOverrideAndSwitchedNetwork = source.numScorerOverrideAndSwitchedNetwork;\n            numAssociation = source.numAssociation;\n            numUserTriggeredWifiDisableLowRSSI = source.numUserTriggeredWifiDisableLowRSSI;\n            numUserTriggeredWifiDisableBadRSSI = source.numUserTriggeredWifiDisableBadRSSI;\n            numUserTriggeredWifiDisableNotHighRSSI = source.numUserTriggeredWifiDisableNotHighRSSI;\n            numTicksAtLowRSSI = source.numTicksAtLowRSSI;\n            numTicksAtBadRSSI = source.numTicksAtBadRSSI;\n            numTicksAtNotHighRSSI = source.numTicksAtNotHighRSSI;\n            numUserTriggeredJoinAttempts = source.numUserTriggeredJoinAttempts;\n            userApproved = source.userApproved;\n            numNoInternetAccessReports = source.numNoInternetAccessReports;\n            noInternetAccessExpected = source.noInternetAccessExpected;\n            creationTime = source.creationTime;\n            updateTime = source.updateTime;\n            shared = source.shared;\n        }\n    }"}
{"Number":"518","API Relative Path":"src.android.net.wifi.WifiConnectionStatistics.java-WifiConnectionStatistics(WifiConnectionStatistics)","Corresponding Source":"/** copy constructor*/\n    public WifiConnectionStatistics(WifiConnectionStatistics source) {\n        untrustedNetworkHistory = new HashMap<String, WifiNetworkConnectionStatistics>();\n        if (source != null) {\n            untrustedNetworkHistory.putAll(source.untrustedNetworkHistory);\n        }\n    }"}
{"Number":"519","API Relative Path":"src.android.net.wifi.WifiEnterpriseConfig.java-setClientKeyEntry(PrivateKey-X509Certificate)","Corresponding Source":"/**\n     * Specify a private key and client certificate for client authorization.\n     *\n     * <p>A default name is automatically assigned to the key entry and used\n     * with this configuration.  The framework takes care of installing the\n     * key entry when the config is saved and removing the key entry when\n     * the config is removed.\n\n     * @param privateKey\n     * @param clientCertificate\n     * @throws IllegalArgumentException for an invalid key or certificate.\n     */\n    public void setClientKeyEntry(PrivateKey privateKey, X509Certificate clientCertificate) {\n        if (clientCertificate != null) {\n            if (clientCertificate.getBasicConstraints() != -1) {\n                throw new IllegalArgumentException(\"Cannot be a CA certificate\");\n            }\n            if (privateKey == null) {\n                throw new IllegalArgumentException(\"Client cert without a private key\");\n            }\n            if (privateKey.getEncoded() == null) {\n                throw new IllegalArgumentException(\"Private key cannot be encoded\");\n            }\n        }\n\n        mClientPrivateKey = privateKey;\n        mClientCertificate = clientCertificate;\n    }"}
{"Number":"520","API Relative Path":"src.android.net.wifi.WifiInfo.java-removeDoubleQuotes(String)","Corresponding Source":"/** {@hide} */\n    public static String removeDoubleQuotes(String string) {\n        if (string == null) return null;\n        final int length = string.length();\n        if ((length > 1) && (string.charAt(0) == '\"') && (string.charAt(length - 1) == '\"')) {\n            return string.substring(1, length - 1);\n        }\n        return string;\n    }"}
{"Number":"521","API Relative Path":"src.android.net.wifi.WifiInfo.java-WifiInfo(WifiInfo)","Corresponding Source":"/**\n     * Copy constructor\n     * @hide\n     */\n    public WifiInfo(WifiInfo source) {\n        if (source != null) {\n            mSupplicantState = source.mSupplicantState;\n            mBSSID = source.mBSSID;\n            mWifiSsid = source.mWifiSsid;\n            mNetworkId = source.mNetworkId;\n            mRssi = source.mRssi;\n            mLinkSpeed = source.mLinkSpeed;\n            mFrequency = source.mFrequency;\n            mIpAddress = source.mIpAddress;\n            mMacAddress = source.mMacAddress;\n            mMeteredHint = source.mMeteredHint;\n            mEphemeral = source.mEphemeral;\n            txBad = source.txBad;\n            txRetries = source.txRetries;\n            txSuccess = source.txSuccess;\n            rxSuccess = source.rxSuccess;\n            txBadRate = source.txBadRate;\n            txRetriesRate = source.txRetriesRate;\n            txSuccessRate = source.txSuccessRate;\n            rxSuccessRate = source.rxSuccessRate;\n            score = source.score;\n            badRssiCount = source.badRssiCount;\n            lowRssiCount = source.lowRssiCount;\n            linkStuckCount = source.linkStuckCount;\n        }\n    }"}
{"Number":"522","API Relative Path":"src.android.net.wifi.WifiManager.java-connect(int-ActionListener)","Corresponding Source":"/**\n     * Connect to a network with the given networkId.\n     *\n     * This function is used instead of a enableNetwork(), saveConfiguration() and\n     * reconnect()\n     *\n     * @param networkId the network id identifiying the network in the\n     *                supplicant configuration list\n     * @param listener for callbacks on success or failure. Can be null.\n     * @throws IllegalStateException if the WifiManager instance needs to be\n     * initialized again\n     * @hide\n     */\n    public void connect(int networkId, ActionListener listener) {\n        if (networkId < 0) throw new IllegalArgumentException(\"Network id cannot be negative\");\n        getChannel().sendMessage(CONNECT_NETWORK, networkId, putListener(listener));\n    }"}
{"Number":"523","API Relative Path":"src.android.net.wifi.WifiManager.java-connect(WifiConfiguration-ActionListener)","Corresponding Source":"/**\n     * Connect to a network with the given configuration. The network also\n     * gets added to the supplicant configuration.\n     *\n     * For a new network, this function is used instead of a\n     * sequence of addNetwork(), enableNetwork(), saveConfiguration() and\n     * reconnect()\n     *\n     * @param config the set of variables that describe the configuration,\n     *            contained in a {@link WifiConfiguration} object.\n     * @param listener for callbacks on success or failure. Can be null.\n     * @throws IllegalStateException if the WifiManager instance needs to be\n     * initialized again\n     *\n     * @hide\n     */\n    public void connect(WifiConfiguration config, ActionListener listener) {\n        if (config == null) throw new IllegalArgumentException(\"config cannot be null\");\n        // Use INVALID_NETWORK_ID for arg1 when passing a config object\n        // arg1 is used to pass network id when the network already exists\n        getChannel().sendMessage(CONNECT_NETWORK, WifiConfiguration.INVALID_NETWORK_ID,\n                putListener(listener), config);\n    }"}
{"Number":"524","API Relative Path":"src.android.net.wifi.WifiManager.java-disable(int-ActionListener)","Corresponding Source":"/**\n     * Disable network\n     *\n     * @param netId is the network Id\n     * @param listener for callbacks on success or failure. Can be null.\n     * @throws IllegalStateException if the WifiManager instance needs to be\n     * initialized again\n     * @hide\n     */\n    public void disable(int netId, ActionListener listener) {\n        if (netId < 0) throw new IllegalArgumentException(\"Network id cannot be negative\");\n        getChannel().sendMessage(DISABLE_NETWORK, netId, putListener(listener));\n    }"}
{"Number":"525","API Relative Path":"src.android.net.wifi.WifiManager.java-disableEphemeralNetwork(String)","Corresponding Source":"/**\n     * Disable ephemeral Network\n     *\n     * @param SSID, in the format of WifiConfiguration's SSID.\n     * @hide\n     */\n    public void disableEphemeralNetwork(String SSID) {\n        if (SSID == null) throw new IllegalArgumentException(\"SSID cannot be null\");\n        try {\n            mService.disableEphemeralNetwork(SSID);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }"}
{"Number":"526","API Relative Path":"src.android.net.wifi.WifiManager.java-forget(int-ActionListener)","Corresponding Source":"/**\n     * Delete the network in the supplicant config.\n     *\n     * This function is used instead of a sequence of removeNetwork()\n     * and saveConfiguration().\n     *\n     * @param config the set of variables that describe the configuration,\n     *            contained in a {@link WifiConfiguration} object.\n     * @param listener for callbacks on success or failure. Can be null.\n     * @throws IllegalStateException if the WifiManager instance needs to be\n     * initialized again\n     * @hide\n     */\n    public void forget(int netId, ActionListener listener) {\n        if (netId < 0) throw new IllegalArgumentException(\"Network id cannot be negative\");\n        getChannel().sendMessage(FORGET_NETWORK, netId, putListener(listener));\n    }"}
{"Number":"527","API Relative Path":"src.android.net.wifi.WifiManager.java-save(WifiConfiguration-ActionListener)","Corresponding Source":"/**\n     * Save the given network in the supplicant config. If the network already\n     * exists, the configuration is updated. A new network is enabled\n     * by default.\n     *\n     * For a new network, this function is used instead of a\n     * sequence of addNetwork(), enableNetwork() and saveConfiguration().\n     *\n     * For an existing network, it accomplishes the task of updateNetwork()\n     * and saveConfiguration()\n     *\n     * @param config the set of variables that describe the configuration,\n     *            contained in a {@link WifiConfiguration} object.\n     * @param listener for callbacks on success or failure. Can be null.\n     * @throws IllegalStateException if the WifiManager instance needs to be\n     * initialized again\n     * @hide\n     */\n    public void save(WifiConfiguration config, ActionListener listener) {\n        if (config == null) throw new IllegalArgumentException(\"config cannot be null\");\n        getChannel().sendMessage(SAVE_NETWORK, 0, putListener(listener), config);\n    }"}
{"Number":"528","API Relative Path":"src.android.net.wifi.WifiManager.java-startWps(WpsInfo-WpsCallback)","Corresponding Source":"/**\n     * Start Wi-fi Protected Setup\n     *\n     * @param config WPS configuration (does not support {@link WpsInfo#LABEL})\n     * @param listener for callbacks on success or failure. Can be null.\n     * @throws IllegalStateException if the WifiManager instance needs to be\n     * initialized again\n     */\n    public void startWps(WpsInfo config, WpsCallback listener) {\n        if (config == null) throw new IllegalArgumentException(\"config cannot be null\");\n        getChannel().sendMessage(START_WPS, 0, putListener(listener), config);\n    }"}
{"Number":"529","API Relative Path":"src.android.net.wifi.WpsResult.java-WpsResult(WpsResult)","Corresponding Source":"/** copy constructor {@hide} */\n    public WpsResult(WpsResult source) {\n        if (source != null) {\n            status = source.status;\n            pin = source.pin;\n        }\n    }"}
{"Number":"530","API Relative Path":"src.android.service.carrier.MessagePdu.java-MessagePdu(List)","Corresponding Source":"/**\n     * Constructs a MessagePdu with the list of message PDUs.\n     *\n     * @param pduList the list of message PDUs\n     */\n    public MessagePdu(@NonNull List<byte[]> pduList) {\n        if (pduList == null || pduList.contains(null)) {\n            throw new IllegalArgumentException(\"pduList must not be null or contain nulls\");\n        }\n        mPduList = pduList;\n    }"}
{"Number":"531","API Relative Path":"src.android.service.chooser.ChooserTarget.java-ChooserTarget(CharSequence-Icon-float-ComponentName-Bundle)","Corresponding Source":"/**\n     * Construct a deep link target for presentation by a chooser UI.\n     *\n     * <p>A target is composed of a title and an icon for presentation to the user.\n     * The UI presenting this target may truncate the title if it is too long to be presented\n     * in the available space, as well as crop, resize or overlay the supplied icon.<\/p>\n     *\n     * <p>The creator of a target may supply a ranking score. This score is assumed to be relative\n     * to the other targets supplied by the same\n     * {@link ChooserTargetService#onGetChooserTargets(ComponentName, IntentFilter) query}.\n     * Scores should be in the range from 0.0f (unlikely match) to 1.0f (very relevant match).\n     * Scores for a set of targets do not need to sum to 1.<\/p>\n     *\n     * <p>The ComponentName must be the name of an Activity component in the creator's own\n     * package, or an exported component from any other package. You may provide an optional\n     * Bundle of extras that will be merged into the final intent before it is sent to the\n     * target Activity; use this to add any additional data about the deep link that the target\n     * activity will read. e.g. conversation IDs, email addresses, etc.<\/p>\n     *\n     * <p>Take care not to place custom {@link android.os.Parcelable} types into\n     * the extras bundle, as the system will not be able to unparcel them to merge them.<\/p>\n     *\n     * @param title title of this target that will be shown to a user\n     * @param icon icon to represent this target\n     * @param score ranking score for this target between 0.0f and 1.0f, inclusive\n     * @param componentName Name of the component to be launched if this target is chosen\n     * @param intentExtras Bundle of extras to merge with the extras of the launched intent\n     */\n    public ChooserTarget(CharSequence title, Icon icon, float score,\n            ComponentName componentName, @Nullable Bundle intentExtras) {\n        mTitle = title;\n        mIcon = icon;\n        if (score > 1.f || score < 0.f) {\n            throw new IllegalArgumentException(\"Score \" + score + \" out of range; \"\n                    + \"must be between 0.0f and 1.0f\");\n        }\n        mScore = score;\n        mComponentName = componentName;\n        mIntentExtras = intentExtras;\n    }"}
{"Number":"532","API Relative Path":"src.android.service.media.MediaBrowserService.java-notifyChildrenChanged(String-Bundle)","Corresponding Source":"/**\n     * Notifies all connected media browsers that the children of\n     * the specified parent id have changed in some way.\n     * This will cause browsers to fetch subscribed content again.\n     *\n     * @param parentId The id of the parent media item whose\n     *            children changed.\n     * @param options A bundle of service-specific arguments to send\n     *            to the media browse. The contents of this bundle may\n     *            contain the information about the change.\n     */\n    public void notifyChildrenChanged(@NonNull String parentId, @NonNull Bundle options) {\n        if (options == null) {\n            throw new IllegalArgumentException(\"options cannot be null in notifyChildrenChanged\");\n        }\n        notifyChildrenChangedInternal(parentId, options);\n    }"}
{"Number":"533","API Relative Path":"src.android.service.notification.ConditionProviderService.java-notifyCondition(Condition)","Corresponding Source":"/**\n     * Informs the notification manager that the state of a Condition has changed. Use this method\n     * to put the system into Do Not Disturb mode or request that it exits Do Not Disturb mode. This\n     * call will be ignored unless there is an enabled {@link android.app.AutomaticZenRule} owned by\n     * service that has an {@link android.app.AutomaticZenRule#getConditionId()} equal to this\n     * {@link Condition#id}.\n     * @param condition the condition that has changed.\n     */\n    public final void notifyCondition(Condition condition) {\n        if (condition == null) return;\n        notifyConditions(new Condition[]{ condition });\n    }"}
{"Number":"534","API Relative Path":"src.android.service.notification.ConditionProviderService.java-notifyConditions(Condition)","Corresponding Source":"/**\n     * Informs the notification manager that the state of one or more Conditions has changed. See\n     * {@link #notifyCondition(Condition)} for restrictions.\n     * @param conditions the changed conditions.\n     */\n    public final void notifyConditions(Condition... conditions) {\n        if (!isBound() || conditions == null) return;\n        try {\n            getNotificationInterface().notifyConditions(getPackageName(), mProvider, conditions);\n        } catch (android.os.RemoteException ex) {\n            Log.v(TAG, \"Unable to contact notification manager\", ex);\n        }\n    }"}
{"Number":"535","API Relative Path":"src.android.service.notification.StatusBarNotification.java-StatusBarNotification(String-String-int-String-int-int-Notification-UserHandle-String-long)","Corresponding Source":"/** @hide */\n    public StatusBarNotification(String pkg, String opPkg, int id, String tag, int uid,\n            int initialPid, Notification notification, UserHandle user, String overrideGroupKey,\n            long postTime) {\n        if (pkg == null) throw new NullPointerException();\n        if (notification == null) throw new NullPointerException();\n\n        this.pkg = pkg;\n        this.opPkg = opPkg;\n        this.id = id;\n        this.tag = tag;\n        this.uid = uid;\n        this.initialPid = initialPid;\n        this.notification = notification;\n        this.user = user;\n        this.postTime = postTime;\n        this.overrideGroupKey = overrideGroupKey;\n        this.key = key();\n        this.groupKey = groupKey();\n    }"}
{"Number":"536","API Relative Path":"src.android.service.notification.StatusBarNotification.java-StatusBarNotification(String-String-int-String-int-int-Notification-UserHandle-String-long)","Corresponding Source":"/** @hide */\n    public StatusBarNotification(String pkg, String opPkg, int id, String tag, int uid,\n            int initialPid, Notification notification, UserHandle user, String overrideGroupKey,\n            long postTime) {\n        if (pkg == null) throw new NullPointerException();\n        if (notification == null) throw new NullPointerException();\n\n        this.pkg = pkg;\n        this.opPkg = opPkg;\n        this.id = id;\n        this.tag = tag;\n        this.uid = uid;\n        this.initialPid = initialPid;\n        this.notification = notification;\n        this.user = user;\n        this.postTime = postTime;\n        this.overrideGroupKey = overrideGroupKey;\n        this.key = key();\n        this.groupKey = groupKey();\n    }"}
{"Number":"537","API Relative Path":"src.android.view.AbsSavedState.java-AbsSavedState(Parcelable)","Corresponding Source":"/**\n     * Constructor called by derived classes when creating their SavedState objects\n     *\n     * @param superState The state of the superclass of this view\n     */\n    protected AbsSavedState(Parcelable superState) {\n        if (superState == null) {\n            throw new IllegalArgumentException(\"superState must not be null\");\n        }\n        mSuperState = superState != EMPTY_STATE ? superState : null;\n    }"}
{"Number":"538","API Relative Path":"src.android.view.accessibility.AccessibilityInteractionClient.java-findAccessibilityNodeInfoByAccessibilityId(int-int-long-boolean-int)","Corresponding Source":"/**\n     * Finds an {@link AccessibilityNodeInfo} by accessibility id.\n     *\n     * @param connectionId The id of a connection for interacting with the system.\n     * @param accessibilityWindowId A unique window id. Use\n     *     {@link android.view.accessibility.AccessibilityNodeInfo#ACTIVE_WINDOW_ID}\n     *     to query the currently active window.\n     * @param accessibilityNodeId A unique view id or virtual descendant id from\n     *     where to start the search. Use\n     *     {@link android.view.accessibility.AccessibilityNodeInfo#ROOT_NODE_ID}\n     *     to start from the root.\n     * @param bypassCache Whether to bypass the cache while looking for the node.\n     * @param prefetchFlags flags to guide prefetching.\n     * @return An {@link AccessibilityNodeInfo} if found, null otherwise.\n     */\n    public AccessibilityNodeInfo findAccessibilityNodeInfoByAccessibilityId(int connectionId,\n            int accessibilityWindowId, long accessibilityNodeId, boolean bypassCache,\n            int prefetchFlags) {\n        if ((prefetchFlags & AccessibilityNodeInfo.FLAG_PREFETCH_SIBLINGS) != 0\n                && (prefetchFlags & AccessibilityNodeInfo.FLAG_PREFETCH_PREDECESSORS) == 0) {\n            throw new IllegalArgumentException(\"FLAG_PREFETCH_SIBLINGS\"\n                + \" requires FLAG_PREFETCH_PREDECESSORS\");\n        }\n        try {\n            IAccessibilityServiceConnection connection = getConnection(connectionId);\n            if (connection != null) {\n                if (!bypassCache) {\n                    AccessibilityNodeInfo cachedInfo = sAccessibilityCache.getNode(\n                            accessibilityWindowId, accessibilityNodeId);\n                    if (cachedInfo != null) {\n                        if (DEBUG) {\n                            Log.i(LOG_TAG, \"Node cache hit\");\n                        }\n                        return cachedInfo;\n                    }\n                    if (DEBUG) {\n                        Log.i(LOG_TAG, \"Node cache miss\");\n                    }\n                }\n                final int interactionId = mInteractionIdCounter.getAndIncrement();\n                final long identityToken = Binder.clearCallingIdentity();\n                final boolean success = connection.findAccessibilityNodeInfoByAccessibilityId(\n                        accessibilityWindowId, accessibilityNodeId, interactionId, this,\n                        prefetchFlags, Thread.currentThread().getId());\n                Binder.restoreCallingIdentity(identityToken);\n                // If the scale is zero the call has failed.\n                if (success) {\n                    List<AccessibilityNodeInfo> infos = getFindAccessibilityNodeInfosResultAndClear(\n                            interactionId);\n                    finalizeAndCacheAccessibilityNodeInfos(infos, connectionId);\n                    if (infos != null && !infos.isEmpty()) {\n                        return infos.get(0);\n                    }\n                }\n            } else {\n                if (DEBUG) {\n                    Log.w(LOG_TAG, \"No connection for connection id: \" + connectionId);\n                }\n            }\n        } catch (RemoteException re) {\n            Log.e(LOG_TAG, \"Error while calling remote\"\n                    + \" findAccessibilityNodeInfoByAccessibilityId\", re);\n        }\n        return null;\n    }"}
{"Number":"539","API Relative Path":"src.android.view.accessibility.AccessibilityNodeInfo.java-addAction(int)","Corresponding Source":"/**\n     * Adds an action that can be performed on the node.\n     * <p>\n     *   <strong>Note:<\/strong> Cannot be called from an\n     *   {@link android.accessibilityservice.AccessibilityService}.\n     *   This class is made immutable before being delivered to an AccessibilityService.\n     * <\/p>\n     *\n     * @param action The action.\n     *\n     * @throws IllegalStateException If called from an AccessibilityService.\n     * @throws IllegalArgumentException If the argument is not one of the standard actions.\n     *\n     * @deprecated This has been deprecated for {@link #addAction(AccessibilityAction)}\n     */\n    @Deprecated\n    public void addAction(int action) {\n        enforceNotSealed();\n\n        if ((action & ACTION_TYPE_MASK) != 0) {\n            throw new IllegalArgumentException(\"Action is not a combination of the standard \" +\n                    \"actions: \" + action);\n        }\n\n        addLegacyStandardActions(action);\n    }"}
{"Number":"540","API Relative Path":"src.android.view.accessibility.AccessibilityWindowInfo.java-changed(AccessibilityWindowInfo)","Corresponding Source":"/**\n     * Checks whether this window changed. The argument should be\n     * another state of the same window, which is have the same id\n     * and type as they never change.\n     *\n     * @param other The new state.\n     * @return Whether something changed.\n     *\n     * @hide\n     */\n    public boolean changed(AccessibilityWindowInfo other) {\n        if (other.mId != mId) {\n            throw new IllegalArgumentException(\"Not same window.\");\n        }\n        if (other.mType != mType) {\n            throw new IllegalArgumentException(\"Not same type.\");\n        }\n        if (!mBoundsInScreen.equals(other.mBoundsInScreen)) {\n            return true;\n        }\n        if (mLayer != other.mLayer) {\n            return true;\n        }\n        if (mBooleanProperties != other.mBooleanProperties) {\n            return true;\n        }\n        if (mParentId != other.mParentId) {\n            return true;\n        }\n        if (mChildIds == null) {\n            if (other.mChildIds != null) {\n                return true;\n            }\n        } else if (!mChildIds.equals(other.mChildIds)) {\n            return true;\n        }\n        return false;\n    }"}
{"Number":"541","API Relative Path":"src.android.view.accessibility.AccessibilityWindowInfo.java-changed(AccessibilityWindowInfo)","Corresponding Source":"/**\n     * Checks whether this window changed. The argument should be\n     * another state of the same window, which is have the same id\n     * and type as they never change.\n     *\n     * @param other The new state.\n     * @return Whether something changed.\n     *\n     * @hide\n     */\n    public boolean changed(AccessibilityWindowInfo other) {\n        if (other.mId != mId) {\n            throw new IllegalArgumentException(\"Not same window.\");\n        }\n        if (other.mType != mType) {\n            throw new IllegalArgumentException(\"Not same type.\");\n        }\n        if (!mBoundsInScreen.equals(other.mBoundsInScreen)) {\n            return true;\n        }\n        if (mLayer != other.mLayer) {\n            return true;\n        }\n        if (mBooleanProperties != other.mBooleanProperties) {\n            return true;\n        }\n        if (mParentId != other.mParentId) {\n            return true;\n        }\n        if (mChildIds == null) {\n            if (other.mChildIds != null) {\n                return true;\n            }\n        } else if (!mChildIds.equals(other.mChildIds)) {\n            return true;\n        }\n        return false;\n    }"}
{"Number":"542","API Relative Path":"src.android.view.animation.Animation.java-setDuration(long)","Corresponding Source":"/**\n     * How long this animation should last. The duration cannot be negative.\n     * \n     * @param durationMillis Duration in milliseconds\n     *\n     * @throws java.lang.IllegalArgumentException if the duration is < 0\n     *\n     * @attr ref android.R.styleable#Animation_duration\n     */\n    public void setDuration(long durationMillis) {\n        if (durationMillis < 0) {\n            throw new IllegalArgumentException(\"Animation duration cannot be negative\");\n        }\n        mDuration = durationMillis;\n    }"}
{"Number":"543","API Relative Path":"src.android.view.animation.ClipRectAnimation.java-ClipRectAnimation(Rect-Rect)","Corresponding Source":"/**\n     * Constructor to use when building a ClipRectAnimation from code\n     *\n     * @param fromClip the clip rect to animate from\n     * @param toClip the clip rect to animate to\n     */\n    public ClipRectAnimation(Rect fromClip, Rect toClip) {\n        if (fromClip == null || toClip == null) {\n            throw new RuntimeException(\"Expected non-null animation clip rects\");\n        }\n        mFromRect.set(fromClip);\n        mToRect.set(toClip);\n    }"}
{"Number":"544","API Relative Path":"src.android.view.Choreographer.java-postCallbackDelayed(int-Runnable-Object-long)","Corresponding Source":"/**\n     * Posts a callback to run on the next frame after the specified delay.\n     * <p>\n     * The callback runs once then is automatically removed.\n     * <\/p>\n     *\n     * @param callbackType The callback type.\n     * @param action The callback action to run during the next frame after the specified delay.\n     * @param token The callback token, or null if none.\n     * @param delayMillis The delay time in milliseconds.\n     *\n     * @see #removeCallback\n     * @hide\n     */\n    public void postCallbackDelayed(int callbackType,\n            Runnable action, Object token, long delayMillis) {\n        if (action == null) {\n            throw new IllegalArgumentException(\"action must not be null\");\n        }\n        if (callbackType < 0 || callbackType > CALLBACK_LAST) {\n            throw new IllegalArgumentException(\"callbackType is invalid\");\n        }\n\n        postCallbackDelayedInternal(callbackType, action, token, delayMillis);\n    }"}
{"Number":"545","API Relative Path":"src.android.view.Choreographer.java-postCallbackDelayed(int-Runnable-Object-long)","Corresponding Source":"/**\n     * Posts a callback to run on the next frame after the specified delay.\n     * <p>\n     * The callback runs once then is automatically removed.\n     * <\/p>\n     *\n     * @param callbackType The callback type.\n     * @param action The callback action to run during the next frame after the specified delay.\n     * @param token The callback token, or null if none.\n     * @param delayMillis The delay time in milliseconds.\n     *\n     * @see #removeCallback\n     * @hide\n     */\n    public void postCallbackDelayed(int callbackType,\n            Runnable action, Object token, long delayMillis) {\n        if (action == null) {\n            throw new IllegalArgumentException(\"action must not be null\");\n        }\n        if (callbackType < 0 || callbackType > CALLBACK_LAST) {\n            throw new IllegalArgumentException(\"callbackType is invalid\");\n        }\n\n        postCallbackDelayedInternal(callbackType, action, token, delayMillis);\n    }"}
{"Number":"546","API Relative Path":"src.android.view.Choreographer.java-postFrameCallbackDelayed(FrameCallback-long)","Corresponding Source":"/**\n     * Posts a frame callback to run on the next frame after the specified delay.\n     * <p>\n     * The callback runs once then is automatically removed.\n     * <\/p>\n     *\n     * @param callback The frame callback to run during the next frame.\n     * @param delayMillis The delay time in milliseconds.\n     *\n     * @see #postFrameCallback\n     * @see #removeFrameCallback\n     */\n    public void postFrameCallbackDelayed(FrameCallback callback, long delayMillis) {\n        if (callback == null) {\n            throw new IllegalArgumentException(\"callback must not be null\");\n        }\n\n        postCallbackDelayedInternal(CALLBACK_ANIMATION,\n                callback, FRAME_CALLBACK_TOKEN, delayMillis);\n    }"}
{"Number":"547","API Relative Path":"src.android.view.Choreographer.java-removeCallbacks(int-Runnable-Object)","Corresponding Source":"/**\n     * Removes callbacks that have the specified action and token.\n     *\n     * @param callbackType The callback type.\n     * @param action The action property of the callbacks to remove, or null to remove\n     * callbacks with any action.\n     * @param token The token property of the callbacks to remove, or null to remove\n     * callbacks with any token.\n     *\n     * @see #postCallback\n     * @see #postCallbackDelayed\n     * @hide\n     */\n    public void removeCallbacks(int callbackType, Runnable action, Object token) {\n        if (callbackType < 0 || callbackType > CALLBACK_LAST) {\n            throw new IllegalArgumentException(\"callbackType is invalid\");\n        }\n\n        removeCallbacksInternal(callbackType, action, token);\n    }"}
{"Number":"548","API Relative Path":"src.android.view.Choreographer.java-removeFrameCallback(FrameCallback)","Corresponding Source":"/**\n     * Removes a previously posted frame callback.\n     *\n     * @param callback The frame callback to remove.\n     *\n     * @see #postFrameCallback\n     * @see #postFrameCallbackDelayed\n     */\n    public void removeFrameCallback(FrameCallback callback) {\n        if (callback == null) {\n            throw new IllegalArgumentException(\"callback must not be null\");\n        }\n\n        removeCallbacksInternal(CALLBACK_ANIMATION, callback, FRAME_CALLBACK_TOKEN);\n    }"}
{"Number":"549","API Relative Path":"src.android.view.DisplayEventReceiver.java-DisplayEventReceiver(Looper)","Corresponding Source":"/**\n     * Creates a display event receiver.\n     *\n     * @param looper The looper to use when invoking callbacks.\n     */\n    public DisplayEventReceiver(Looper looper) {\n        if (looper == null) {\n            throw new IllegalArgumentException(\"looper must not be null\");\n        }\n\n        mMessageQueue = looper.getQueue();\n        mReceiverPtr = nativeInit(new WeakReference<DisplayEventReceiver>(this), mMessageQueue);\n\n        mCloseGuard.open(\"dispose\");\n    }"}
{"Number":"550","API Relative Path":"src.android.view.InputChannel.java-openInputChannelPair(String)","Corresponding Source":"/**\n     * Creates a new input channel pair.  One channel should be provided to the input\n     * dispatcher and the other to the application's input queue.\n     * @param name The descriptive (non-unique) name of the channel pair.\n     * @return A pair of input channels.  The first channel is designated as the\n     * server channel and should be used to publish input events.  The second channel\n     * is designated as the client channel and should be used to consume input events.\n     */\n    public static InputChannel[] openInputChannelPair(String name) {\n        if (name == null) {\n            throw new IllegalArgumentException(\"name must not be null\");\n        }\n\n        if (DEBUG) {\n            Slog.d(TAG, \"Opening input channel pair '\" + name + \"'\");\n        }\n        return nativeOpenInputChannelPair(name);\n    }"}
{"Number":"551","API Relative Path":"src.android.view.InputChannel.java-transferTo(InputChannel)","Corresponding Source":"/**\n     * Transfers ownership of the internal state of the input channel to another\n     * instance and invalidates this instance.  This is used to pass an input channel\n     * as an out parameter in a binder call.\n     * @param other The other input channel instance.\n     */\n    public void transferTo(InputChannel outParameter) {\n        if (outParameter == null) {\n            throw new IllegalArgumentException(\"outParameter must not be null\");\n        }\n        \n        nativeTransferTo(outParameter);\n    }"}
{"Number":"552","API Relative Path":"src.android.view.InputEventReceiver.java-finishInputEvent(InputEvent-boolean)","Corresponding Source":"/**\n     * Finishes an input event and indicates whether it was handled.\n     * Must be called on the same Looper thread to which the receiver is attached.\n     *\n     * @param event The input event that was finished.\n     * @param handled True if the event was handled.\n     */\n    public final void finishInputEvent(InputEvent event, boolean handled) {\n        if (event == null) {\n            throw new IllegalArgumentException(\"event must not be null\");\n        }\n        if (mReceiverPtr == 0) {\n            Log.w(TAG, \"Attempted to finish an input event but the input event \"\n                    + \"receiver has already been disposed.\");\n        } else {\n            int index = mSeqMap.indexOfKey(event.getSequenceNumber());\n            if (index < 0) {\n                Log.w(TAG, \"Attempted to finish an input event that is not in progress.\");\n            } else {\n                int seq = mSeqMap.valueAt(index);\n                mSeqMap.removeAt(index);\n                nativeFinishInputEvent(mReceiverPtr, seq, handled);\n            }\n        }\n        event.recycleIfNeededAfterDispatch();\n    }"}
{"Number":"553","API Relative Path":"src.android.view.InputEventReceiver.java-InputEventReceiver(InputChannel-Looper)","Corresponding Source":"/**\n     * Creates an input event receiver bound to the specified input channel.\n     *\n     * @param inputChannel The input channel.\n     * @param looper The looper to use when invoking callbacks.\n     */\n    public InputEventReceiver(InputChannel inputChannel, Looper looper) {\n        if (inputChannel == null) {\n            throw new IllegalArgumentException(\"inputChannel must not be null\");\n        }\n        if (looper == null) {\n            throw new IllegalArgumentException(\"looper must not be null\");\n        }\n\n        mInputChannel = inputChannel;\n        mMessageQueue = looper.getQueue();\n        mReceiverPtr = nativeInit(new WeakReference<InputEventReceiver>(this),\n                inputChannel, mMessageQueue);\n\n        mCloseGuard.open(\"dispose\");\n    }"}
{"Number":"554","API Relative Path":"src.android.view.InputEventReceiver.java-InputEventReceiver(InputChannel-Looper)","Corresponding Source":"/**\n     * Creates an input event receiver bound to the specified input channel.\n     *\n     * @param inputChannel The input channel.\n     * @param looper The looper to use when invoking callbacks.\n     */\n    public InputEventReceiver(InputChannel inputChannel, Looper looper) {\n        if (inputChannel == null) {\n            throw new IllegalArgumentException(\"inputChannel must not be null\");\n        }\n        if (looper == null) {\n            throw new IllegalArgumentException(\"looper must not be null\");\n        }\n\n        mInputChannel = inputChannel;\n        mMessageQueue = looper.getQueue();\n        mReceiverPtr = nativeInit(new WeakReference<InputEventReceiver>(this),\n                inputChannel, mMessageQueue);\n\n        mCloseGuard.open(\"dispose\");\n    }"}
{"Number":"555","API Relative Path":"src.android.view.InputEventSender.java-InputEventSender(InputChannel-Looper)","Corresponding Source":"/**\n     * Creates an input event sender bound to the specified input channel.\n     *\n     * @param inputChannel The input channel.\n     * @param looper The looper to use when invoking callbacks.\n     */\n    public InputEventSender(InputChannel inputChannel, Looper looper) {\n        if (inputChannel == null) {\n            throw new IllegalArgumentException(\"inputChannel must not be null\");\n        }\n        if (looper == null) {\n            throw new IllegalArgumentException(\"looper must not be null\");\n        }\n\n        mInputChannel = inputChannel;\n        mMessageQueue = looper.getQueue();\n        mSenderPtr = nativeInit(new WeakReference<InputEventSender>(this),\n                inputChannel, mMessageQueue);\n\n        mCloseGuard.open(\"dispose\");\n    }"}
{"Number":"556","API Relative Path":"src.android.view.InputEventSender.java-InputEventSender(InputChannel-Looper)","Corresponding Source":"/**\n     * Creates an input event sender bound to the specified input channel.\n     *\n     * @param inputChannel The input channel.\n     * @param looper The looper to use when invoking callbacks.\n     */\n    public InputEventSender(InputChannel inputChannel, Looper looper) {\n        if (inputChannel == null) {\n            throw new IllegalArgumentException(\"inputChannel must not be null\");\n        }\n        if (looper == null) {\n            throw new IllegalArgumentException(\"looper must not be null\");\n        }\n\n        mInputChannel = inputChannel;\n        mMessageQueue = looper.getQueue();\n        mSenderPtr = nativeInit(new WeakReference<InputEventSender>(this),\n                inputChannel, mMessageQueue);\n\n        mCloseGuard.open(\"dispose\");\n    }"}
{"Number":"557","API Relative Path":"src.android.view.InputEventSender.java-sendInputEvent(int-InputEvent)","Corresponding Source":"/**\n     * Sends an input event.\n     * Must be called on the same Looper thread to which the sender is attached.\n     *\n     * @param seq The input event sequence number.\n     * @param event The input event to send.\n     * @return True if the entire event was sent successfully.  May return false\n     * if the input channel buffer filled before all samples were dispatched.\n     */\n    public final boolean sendInputEvent(int seq, InputEvent event) {\n        if (event == null) {\n            throw new IllegalArgumentException(\"event must not be null\");\n        }\n        if (mSenderPtr == 0) {\n            Log.w(TAG, \"Attempted to send an input event but the input event \"\n                    + \"sender has already been disposed.\");\n            return false;\n        }\n\n        if (event instanceof KeyEvent) {\n            return nativeSendKeyEvent(mSenderPtr, seq, (KeyEvent)event);\n        } else {\n            return nativeSendMotionEvent(mSenderPtr, seq, (MotionEvent)event);\n        }\n    }"}
{"Number":"558","API Relative Path":"src.android.view.InputFilter.java-sendInputEvent(InputEvent-int)","Corresponding Source":"/**\n     * Sends an input event to the dispatcher.\n     *\n     * @param event The input event to publish.\n     * @param policyFlags The input event policy flags.\n     */\n    public void sendInputEvent(InputEvent event, int policyFlags) {\n        if (event == null) {\n            throw new IllegalArgumentException(\"event must not be null\");\n        }\n        if (mHost == null) {\n            throw new IllegalStateException(\"Cannot send input event because the input filter \" +\n                    \"is not installed.\");\n        }\n        if (mOutboundInputEventConsistencyVerifier != null) {\n            mOutboundInputEventConsistencyVerifier.onInputEvent(event, 0);\n        }\n        try {\n            mHost.sendInputEvent(event, policyFlags);\n        } catch (RemoteException re) {\n            /* ignore */\n        }\n    }"}
{"Number":"559","API Relative Path":"src.android.view.inputmethod.InputMethodManager.java-toggleSoftInputFromWindow(IBinder-int-int)","Corresponding Source":"/**\n     * This method toggles the input method window display.\n     * If the input window is already displayed, it gets hidden. \n     * If not the input window will be displayed.\n     * @param windowToken The token of the window that is making the request,\n     * as returned by {@link View#getWindowToken() View.getWindowToken()}.\n     * @param showFlags Provides additional operating flags.  May be\n     * 0 or have the {@link #SHOW_IMPLICIT},\n     * {@link #SHOW_FORCED} bit set.\n     * @param hideFlags Provides additional operating flags.  May be\n     * 0 or have the {@link #HIDE_IMPLICIT_ONLY},\n     * {@link #HIDE_NOT_ALWAYS} bit set.\n     **/\n    public void toggleSoftInputFromWindow(IBinder windowToken, int showFlags, int hideFlags) {\n        synchronized (mH) {\n            if (mServedView == null || mServedView.getWindowToken() != windowToken) {\n                return;\n            }\n            if (mCurMethod != null) {\n                try {\n                    mCurMethod.toggleSoftInput(showFlags, hideFlags);\n                } catch (RemoteException e) {\n                }\n            }\n        }\n    }"}
{"Number":"560","API Relative Path":"src.android.view.inputmethod.InputMethodManager.java-updateCursorAnchorInfo(View-CursorAnchorInfo)","Corresponding Source":"/**\n     * Report positional change of the text insertion point and/or characters in the composition\n     * string.\n     */\n    public void updateCursorAnchorInfo(View view, final CursorAnchorInfo cursorAnchorInfo) {\n        if (view == null || cursorAnchorInfo == null) {\n            return;\n        }\n        checkFocus();\n        synchronized (mH) {\n            if ((mServedView != view &&\n                    (mServedView == null || !mServedView.checkInputConnectionProxy(view)))\n                    || mCurrentTextBoxAttribute == null || mCurMethod == null) {\n                return;\n            }\n            // If immediate bit is set, we will call updateCursorAnchorInfo() even when the data has\n            // not been changed from the previous call.\n            final boolean isImmediate = (mRequestUpdateCursorAnchorInfoMonitorMode &\n                    InputConnection.CURSOR_UPDATE_IMMEDIATE) != 0;\n            if (!isImmediate && Objects.equals(mCursorAnchorInfo, cursorAnchorInfo)) {\n                // TODO: Consider always emitting this message once we have addressed redundant\n                // calls of this method from android.widget.Editor.\n                if (DEBUG) {\n                    Log.w(TAG, \"Ignoring redundant updateCursorAnchorInfo: info=\"\n                            + cursorAnchorInfo);\n                }\n                return;\n            }\n            if (DEBUG) Log.v(TAG, \"updateCursorAnchorInfo: \" + cursorAnchorInfo);\n            try {\n                mCurMethod.updateCursorAnchorInfo(cursorAnchorInfo);\n                mCursorAnchorInfo = cursorAnchorInfo;\n                // Clear immediate bit (if any).\n                mRequestUpdateCursorAnchorInfoMonitorMode &=\n                        ~InputConnection.CURSOR_UPDATE_IMMEDIATE;\n            } catch (RemoteException e) {\n                Log.w(TAG, \"IME died: \" + mCurId, e);\n            }\n        }\n    }"}
{"Number":"561","API Relative Path":"src.android.view.inputmethod.InputMethodSubtypeArray.java-get(int)","Corresponding Source":"/**\n     * Return {@link InputMethodSubtype} specified with the given index.\n     *\n     * <p>This methods may take a bit additional time to decompress data lazily when called\n     * first time.<\/p>\n     *\n     * @param index The index of {@link InputMethodSubtype}.\n     */\n    public InputMethodSubtype get(final int index) {\n        if (index < 0 || mCount <= index) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n        InputMethodSubtype[] instance = mInstance;\n        if (instance == null) {\n            synchronized (mLockObject) {\n                instance = mInstance;\n                if (instance == null) {\n                    final byte[] decompressedData =\n                          decompress(mCompressedData, mDecompressedSize);\n                    // Clear the compressed data until {@link #getMarshalled()} is called.\n                    mCompressedData = null;\n                    mDecompressedSize = 0;\n                    if (decompressedData != null) {\n                        instance = unmarshall(decompressedData);\n                    } else {\n                        Slog.e(TAG, \"Failed to decompress data. Returns null as fallback.\");\n                        instance = new InputMethodSubtype[mCount];\n                    }\n                    mInstance = instance;\n                }\n            }\n        }\n        return instance[index];\n    }"}
{"Number":"562","API Relative Path":"src.android.view.inputmethod.InputMethodSubtypeArray.java-InputMethodSubtypeArray(List)","Corresponding Source":"/**\n     * Create a new instance of {@link InputMethodSubtypeArray} from an existing list of\n     * {@link InputMethodSubtype}.\n     *\n     * @param subtypes A list of {@link InputMethodSubtype} from which\n     * {@link InputMethodSubtypeArray} will be created.\n     */\n    public InputMethodSubtypeArray(final List<InputMethodSubtype> subtypes) {\n        if (subtypes == null) {\n            mCount = 0;\n            return;\n        }\n        mCount = subtypes.size();\n        mInstance = subtypes.toArray(new InputMethodSubtype[mCount]);\n    }"}
{"Number":"563","API Relative Path":"src.android.view.KeyCharacterMap.java-getEvents(char[])","Corresponding Source":"/**\n     * Get an array of KeyEvent objects that if put into the input stream\n     * could plausibly generate the provided sequence of characters.  It is\n     * not guaranteed that the sequence is the only way to generate these\n     * events or that it is optimal.\n     * <p>\n     * This function is primarily offered for instrumentation and testing purposes.\n     * It may fail to map characters to key codes.  In particular, the key character\n     * map for the {@link #BUILT_IN_KEYBOARD built-in keyboard} device id may be empty.\n     * Consider using the key character map associated with the\n     * {@link #VIRTUAL_KEYBOARD virtual keyboard} device id instead.\n     * <\/p><p>\n     * For robust text entry, do not use this function.  Instead construct a\n     * {@link KeyEvent} with action code {@link KeyEvent#ACTION_MULTIPLE} that contains\n     * the desired string using {@link KeyEvent#KeyEvent(long, String, int, int)}.\n     * <\/p>\n     *\n     * @param chars The sequence of characters to generate.\n     * @return An array of {@link KeyEvent} objects, or null if the given char array\n     *         can not be generated using the current key character map.\n     */\n    public KeyEvent[] getEvents(char[] chars) {\n        if (chars == null) {\n            throw new IllegalArgumentException(\"chars must not be null.\");\n        }\n        return nativeGetEvents(mPtr, chars);\n    }"}
{"Number":"564","API Relative Path":"src.android.view.KeyCharacterMap.java-getKeyData(int-KeyData)","Corresponding Source":"/**\n     * Get the character conversion data for a given key code.\n     *\n     * @param keyCode The keyCode to query.\n     * @param results A {@link KeyData} instance that will be filled with the results.\n     * @return True if the key was mapped.  If the key was not mapped, results is not modified.\n     *\n     * @deprecated instead use {@link KeyCharacterMap#getDisplayLabel(int)},\n     * {@link KeyCharacterMap#getNumber(int)} or {@link KeyCharacterMap#get(int, int)}.\n     */\n    @Deprecated\n    public boolean getKeyData(int keyCode, KeyData results) {\n        if (results.meta.length < KeyData.META_LENGTH) {\n            throw new IndexOutOfBoundsException(\n                    \"results.meta.length must be >= \" + KeyData.META_LENGTH);\n        }\n\n        char displayLabel = nativeGetDisplayLabel(mPtr, keyCode);\n        if (displayLabel == 0) {\n            return false;\n        }\n\n        results.displayLabel = displayLabel;\n        results.number = nativeGetNumber(mPtr, keyCode);\n        results.meta[0] = nativeGetCharacter(mPtr, keyCode, 0);\n        results.meta[1] = nativeGetCharacter(mPtr, keyCode, KeyEvent.META_SHIFT_ON);\n        results.meta[2] = nativeGetCharacter(mPtr, keyCode, KeyEvent.META_ALT_ON);\n        results.meta[3] = nativeGetCharacter(mPtr, keyCode,\n                KeyEvent.META_ALT_ON | KeyEvent.META_SHIFT_ON);\n        return true;\n    }"}
{"Number":"565","API Relative Path":"src.android.view.KeyCharacterMap.java-getMatch(int-char[]-int)","Corresponding Source":"/**\n     * Gets the first character in the character array that can be generated\n     * by the specified key code.  If there are multiple choices, prefers\n     * the one that would be generated with the specified meta key modifier state.\n     *\n     * @param keyCode The key code.\n     * @param chars The array of matching characters to consider.\n     * @param metaState The preferred meta key modifier state.\n     * @return The matching associated character, or 0 if none.\n     */\n    public char getMatch(int keyCode, char[] chars, int metaState) {\n        if (chars == null) {\n            throw new IllegalArgumentException(\"chars must not be null.\");\n        }\n\n        metaState = KeyEvent.normalizeMetaState(metaState);\n        return nativeGetMatch(mPtr, keyCode, chars, metaState);\n    }"}
{"Number":"566","API Relative Path":"src.android.view.KeyEvent.java-metaStateHasModifiers(int-int)","Corresponding Source":"/**\n     * Returns true if only the specified modifier keys are pressed according to\n     * the specified meta state.  Returns false if a different combination of modifier\n     * keys are pressed.\n     * <p>\n     * For the purposes of this function, {@link #KEYCODE_CAPS_LOCK},\n     * {@link #KEYCODE_SCROLL_LOCK}, and {@link #KEYCODE_NUM_LOCK} are\n     * not considered modifier keys.  Consequently, this function ignores\n     * {@link #META_CAPS_LOCK_ON}, {@link #META_SCROLL_LOCK_ON} and {@link #META_NUM_LOCK_ON}.\n     * <\/p><p>\n     * If the specified modifier mask includes directional modifiers, such as\n     * {@link #META_SHIFT_LEFT_ON}, then this method ensures that the\n     * modifier is pressed on that side.\n     * If the specified modifier mask includes non-directional modifiers, such as\n     * {@link #META_SHIFT_ON}, then this method ensures that the modifier\n     * is pressed on either side.\n     * If the specified modifier mask includes both directional and non-directional modifiers\n     * for the same type of key, such as {@link #META_SHIFT_ON} and {@link #META_SHIFT_LEFT_ON},\n     * then this method throws an illegal argument exception.\n     * <\/p>\n     *\n     * @param metaState The meta state to consider.\n     * @param modifiers The meta state of the modifier keys to check.  May be a combination\n     * of modifier meta states as defined by {@link #getModifierMetaStateMask()}.  May be 0 to\n     * ensure that no modifier keys are pressed.\n     * @return True if only the specified modifier keys are pressed.\n     * @throws IllegalArgumentException if the modifiers parameter contains invalid modifiers\n     * @see #hasModifiers\n     */\n    public static boolean metaStateHasModifiers(int metaState, int modifiers) {\n        // Note: For forward compatibility, we allow the parameter to contain meta states\n        //       that we do not recognize but we explicitly disallow meta states that\n        //       are not valid modifiers.\n        if ((modifiers & META_INVALID_MODIFIER_MASK) != 0) {\n            throw new IllegalArgumentException(\"modifiers must not contain \"\n                    + \"META_CAPS_LOCK_ON, META_NUM_LOCK_ON, META_SCROLL_LOCK_ON, \"\n                    + \"META_CAP_LOCKED, META_ALT_LOCKED, META_SYM_LOCKED, \"\n                    + \"or META_SELECTING\");\n        }\n\n        metaState = normalizeMetaState(metaState) & META_MODIFIER_MASK;\n        metaState = metaStateFilterDirectionalModifiers(metaState, modifiers,\n                META_SHIFT_ON, META_SHIFT_LEFT_ON, META_SHIFT_RIGHT_ON);\n        metaState = metaStateFilterDirectionalModifiers(metaState, modifiers,\n                META_ALT_ON, META_ALT_LEFT_ON, META_ALT_RIGHT_ON);\n        metaState = metaStateFilterDirectionalModifiers(metaState, modifiers,\n                META_CTRL_ON, META_CTRL_LEFT_ON, META_CTRL_RIGHT_ON);\n        metaState = metaStateFilterDirectionalModifiers(metaState, modifiers,\n                META_META_ON, META_META_LEFT_ON, META_META_RIGHT_ON);\n        return metaState == modifiers;\n    }"}
{"Number":"567","API Relative Path":"src.android.view.LayoutInflater.java-setFactory(Factory)","Corresponding Source":"/**\n     * Attach a custom Factory interface for creating views while using\n     * this LayoutInflater.  This must not be null, and can only be set once;\n     * after setting, you can not change the factory.  This is\n     * called on each element name as the xml is parsed. If the factory returns\n     * a View, that is added to the hierarchy. If it returns null, the next\n     * factory default {@link #onCreateView} method is called.\n     * \n     * <p>If you have an existing\n     * LayoutInflater and want to add your own factory to it, use\n     * {@link #cloneInContext} to clone the existing instance and then you\n     * can use this function (once) on the returned new instance.  This will\n     * merge your own factory with whatever factory the original instance is\n     * using.\n     */\n    public void setFactory(Factory factory) {\n        if (mFactorySet) {\n            throw new IllegalStateException(\"A factory has already been set on this LayoutInflater\");\n        }\n        if (factory == null) {\n            throw new NullPointerException(\"Given factory can not be null\");\n        }\n        mFactorySet = true;\n        if (mFactory == null) {\n            mFactory = factory;\n        } else {\n            mFactory = new FactoryMerger(factory, null, mFactory, mFactory2);\n        }\n    }"}
{"Number":"568","API Relative Path":"src.android.view.LayoutInflater.java-setFactory2(Factory2)","Corresponding Source":"/**\n     * Like {@link #setFactory}, but allows you to set a {@link Factory2}\n     * interface.\n     */\n    public void setFactory2(Factory2 factory) {\n        if (mFactorySet) {\n            throw new IllegalStateException(\"A factory has already been set on this LayoutInflater\");\n        }\n        if (factory == null) {\n            throw new NullPointerException(\"Given factory can not be null\");\n        }\n        mFactorySet = true;\n        if (mFactory == null) {\n            mFactory = mFactory2 = factory;\n        } else {\n            mFactory = mFactory2 = new FactoryMerger(factory, factory, mFactory, mFactory2);\n        }\n    }"}
{"Number":"569","API Relative Path":"src.android.view.LayoutInflater.java-setFilter(Filter)","Corresponding Source":"/**\n     * Sets the {@link Filter} to by this LayoutInflater. If a view is attempted to be inflated\n     * which is not allowed by the {@link Filter}, the {@link #inflate(int, ViewGroup)} call will\n     * throw an {@link InflateException}. This filter will replace any previous filter set on this\n     * LayoutInflater.\n     * \n     * @param filter The Filter which restricts the set of Views that are allowed to be inflated.\n     *        This filter will replace any previous filter set on this LayoutInflater.\n     */\n    public void setFilter(Filter filter) {\n        mFilter = filter;\n        if (filter != null) {\n            mFilterMap = new HashMap<String, Boolean>();\n        }\n    }"}
{"Number":"570","API Relative Path":"src.android.view.MotionEvent.java-obtain(MotionEvent)","Corresponding Source":"/**\n     * Create a new MotionEvent, copying from an existing one.\n     */\n    static public MotionEvent obtain(MotionEvent other) {\n        if (other == null) {\n            throw new IllegalArgumentException(\"other motion event must not be null\");\n        }\n\n        MotionEvent ev = obtain();\n        ev.mNativePtr = nativeCopy(ev.mNativePtr, other.mNativePtr, true /*keepHistory*/);\n        return ev;\n    }"}
{"Number":"571","API Relative Path":"src.android.view.MotionEvent.java-obtainNoHistory(MotionEvent)","Corresponding Source":"/**\n     * Create a new MotionEvent, copying from an existing one, but not including\n     * any historical point information.\n     */\n    static public MotionEvent obtainNoHistory(MotionEvent other) {\n        if (other == null) {\n            throw new IllegalArgumentException(\"other motion event must not be null\");\n        }\n\n        MotionEvent ev = obtain();\n        ev.mNativePtr = nativeCopy(ev.mNativePtr, other.mNativePtr, false /*keepHistory*/);\n        return ev;\n    }"}
{"Number":"572","API Relative Path":"src.android.view.MotionEvent.java-transform(Matrix)","Corresponding Source":"/**\n     * Applies a transformation matrix to all of the points in the event.\n     *\n     * @param matrix The transformation matrix to apply.\n     */\n    public final void transform(Matrix matrix) {\n        if (matrix == null) {\n            throw new IllegalArgumentException(\"matrix must not be null\");\n        }\n\n        nativeTransform(mNativePtr, matrix);\n    }"}
{"Number":"573","API Relative Path":"src.android.view.Surface.java-copyFrom(SurfaceControl)","Corresponding Source":"/**\n     * Copy another surface to this one.  This surface now holds a reference\n     * to the same data as the original surface, and is -not- the owner.\n     * This is for use by the window manager when returning a window surface\n     * back from a client, converting it from the representation being managed\n     * by the window manager to the representation the client uses to draw\n     * in to it.\n     * @hide\n     */\n    public void copyFrom(SurfaceControl other) {\n        if (other == null) {\n            throw new IllegalArgumentException(\"other must not be null\");\n        }\n\n        long surfaceControlPtr = other.mNativeObject;\n        if (surfaceControlPtr == 0) {\n            throw new NullPointerException(\n                    \"SurfaceControl native object is null. Are you using a released SurfaceControl?\");\n        }\n        long newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr);\n\n        synchronized (mLock) {\n            if (mNativeObject != 0) {\n                nativeRelease(mNativeObject);\n            }\n            setNativeObjectLocked(newNativeObject);\n        }\n    }"}
{"Number":"574","API Relative Path":"src.android.view.Surface.java-setCompatibilityTranslator(Translator)","Corresponding Source":"/**\n     * Sets the translator used to scale canvas's width/height in compatibility\n     * mode.\n     */\n    void setCompatibilityTranslator(Translator translator) {\n        if (translator != null) {\n            float appScale = translator.applicationScale;\n            mCompatibleMatrix = new Matrix();\n            mCompatibleMatrix.setScale(appScale, appScale);\n        }\n    }"}
{"Number":"575","API Relative Path":"src.android.view.Surface.java-Surface(SurfaceTexture)","Corresponding Source":"/**\n     * Create Surface from a {@link SurfaceTexture}.\n     *\n     * Images drawn to the Surface will be made available to the {@link\n     * SurfaceTexture}, which can attach them to an OpenGL ES texture via {@link\n     * SurfaceTexture#updateTexImage}.\n     *\n     * @param surfaceTexture The {@link SurfaceTexture} that is updated by this\n     * Surface.\n     * @throws OutOfResourcesException if the surface could not be created.\n     */\n    public Surface(SurfaceTexture surfaceTexture) {\n        if (surfaceTexture == null) {\n            throw new IllegalArgumentException(\"surfaceTexture must not be null\");\n        }\n\n        synchronized (mLock) {\n            mName = surfaceTexture.toString();\n            setNativeObjectLocked(nativeCreateFromSurfaceTexture(surfaceTexture));\n        }\n    }"}
{"Number":"576","API Relative Path":"src.android.view.Surface.java-transferFrom(Surface)","Corresponding Source":"/**\n     * This is intended to be used by {@link SurfaceView#updateWindow} only.\n     * @param other access is not thread safe\n     * @hide\n     * @deprecated\n     */\n    @Deprecated\n    public void transferFrom(Surface other) {\n        if (other == null) {\n            throw new IllegalArgumentException(\"other must not be null\");\n        }\n        if (other != this) {\n            final long newPtr;\n            synchronized (other.mLock) {\n                newPtr = other.mNativeObject;\n                other.setNativeObjectLocked(0);\n            }\n\n            synchronized (mLock) {\n                if (mNativeObject != 0) {\n                    nativeRelease(mNativeObject);\n                }\n                setNativeObjectLocked(newPtr);\n            }\n        }\n    }"}
{"Number":"577","API Relative Path":"src.android.view.textservice.SentenceSuggestionsInfo.java-SentenceSuggestionsInfo(SuggestionsInfo[]-int[]-int[])","Corresponding Source":"/**\n     * Constructor.\n     * @param suggestionsInfos from the text service\n     * @param offsets the array of offsets of suggestions\n     * @param lengths the array of lengths of suggestions\n     */\n    public SentenceSuggestionsInfo(\n            SuggestionsInfo[] suggestionsInfos, int[] offsets, int[] lengths) {\n        if (suggestionsInfos == null || offsets == null || lengths == null) {\n            throw new NullPointerException();\n        }\n        if (suggestionsInfos.length != offsets.length || offsets.length != lengths.length) {\n            throw new IllegalArgumentException();\n        }\n        final int infoSize = suggestionsInfos.length;\n        mSuggestionsInfos = Arrays.copyOf(suggestionsInfos, infoSize);\n        mOffsets = Arrays.copyOf(offsets, infoSize);\n        mLengths = Arrays.copyOf(lengths, infoSize);\n    }"}
{"Number":"578","API Relative Path":"src.android.view.textservice.SentenceSuggestionsInfo.java-SentenceSuggestionsInfo(SuggestionsInfo[]-int[]-int[])","Corresponding Source":"/**\n     * Constructor.\n     * @param suggestionsInfos from the text service\n     * @param offsets the array of offsets of suggestions\n     * @param lengths the array of lengths of suggestions\n     */\n    public SentenceSuggestionsInfo(\n            SuggestionsInfo[] suggestionsInfos, int[] offsets, int[] lengths) {\n        if (suggestionsInfos == null || offsets == null || lengths == null) {\n            throw new NullPointerException();\n        }\n        if (suggestionsInfos.length != offsets.length || offsets.length != lengths.length) {\n            throw new IllegalArgumentException();\n        }\n        final int infoSize = suggestionsInfos.length;\n        mSuggestionsInfos = Arrays.copyOf(suggestionsInfos, infoSize);\n        mOffsets = Arrays.copyOf(offsets, infoSize);\n        mLengths = Arrays.copyOf(lengths, infoSize);\n    }"}
{"Number":"579","API Relative Path":"src.android.view.textservice.SpellCheckerSession.java-SpellCheckerSession(SpellCheckerInfo-ITextServicesManager-SpellCheckerSessionListener-SpellCheckerSubtype)","Corresponding Source":"/**\n     * Constructor\n     * @hide\n     */\n    public SpellCheckerSession(\n            SpellCheckerInfo info, ITextServicesManager tsm, SpellCheckerSessionListener listener,\n            SpellCheckerSubtype subtype) {\n        if (info == null || listener == null || tsm == null) {\n            throw new NullPointerException();\n        }\n        mSpellCheckerInfo = info;\n        mSpellCheckerSessionListenerImpl = new SpellCheckerSessionListenerImpl(mHandler);\n        mInternalListener = new InternalListener(mSpellCheckerSessionListenerImpl);\n        mTextServicesManager = tsm;\n        mIsUsed = true;\n        mSpellCheckerSessionListener = listener;\n        mSubtype = subtype;\n    }"}
{"Number":"580","API Relative Path":"src.android.view.textservice.TextServicesManager.java-newSpellCheckerSession(Bundle-Locale-SpellCheckerSessionListener-boolean)","Corresponding Source":"/**\n     * Get a spell checker session for the specified spell checker\n     * @param locale the locale for the spell checker. If {@code locale} is null and\n     * referToSpellCheckerLanguageSettings is true, the locale specified in Settings will be\n     * returned. If {@code locale} is not null and referToSpellCheckerLanguageSettings is true,\n     * the locale specified in Settings will be returned only when it is same as {@code locale}.\n     * Exceptionally, when referToSpellCheckerLanguageSettings is true and {@code locale} is\n     * only language (e.g. \"en\"), the specified locale in Settings (e.g. \"en_US\") will be\n     * selected.\n     * @param listener a spell checker session lister for getting results from a spell checker.\n     * @param referToSpellCheckerLanguageSettings if true, the session for one of enabled\n     * languages in settings will be returned.\n     * @return the spell checker session of the spell checker\n     */\n    public SpellCheckerSession newSpellCheckerSession(Bundle bundle, Locale locale,\n            SpellCheckerSessionListener listener, boolean referToSpellCheckerLanguageSettings) {\n        if (listener == null) {\n            throw new NullPointerException();\n        }\n        if (!referToSpellCheckerLanguageSettings && locale == null) {\n            throw new IllegalArgumentException(\"Locale should not be null if you don't refer\"\n                    + \" settings.\");\n        }\n\n        if (referToSpellCheckerLanguageSettings && !isSpellCheckerEnabled()) {\n            return null;\n        }\n\n        final SpellCheckerInfo sci;\n        try {\n            sci = sService.getCurrentSpellChecker(null);\n        } catch (RemoteException e) {\n            return null;\n        }\n        if (sci == null) {\n            return null;\n        }\n        SpellCheckerSubtype subtypeInUse = null;\n        if (referToSpellCheckerLanguageSettings) {\n            subtypeInUse = getCurrentSpellCheckerSubtype(true);\n            if (subtypeInUse == null) {\n                return null;\n            }\n            if (locale != null) {\n                final String subtypeLocale = subtypeInUse.getLocale();\n                final String subtypeLanguage = parseLanguageFromLocaleString(subtypeLocale);\n                if (subtypeLanguage.length() < 2 || !locale.getLanguage().equals(subtypeLanguage)) {\n                    return null;\n                }\n            }\n        } else {\n            final String localeStr = locale.toString();\n            for (int i = 0; i < sci.getSubtypeCount(); ++i) {\n                final SpellCheckerSubtype subtype = sci.getSubtypeAt(i);\n                final String tempSubtypeLocale = subtype.getLocale();\n                final String tempSubtypeLanguage = parseLanguageFromLocaleString(tempSubtypeLocale);\n                if (tempSubtypeLocale.equals(localeStr)) {\n                    subtypeInUse = subtype;\n                    break;\n                } else if (tempSubtypeLanguage.length() >= 2 &&\n                        locale.getLanguage().equals(tempSubtypeLanguage)) {\n                    subtypeInUse = subtype;\n                }\n            }\n        }\n        if (subtypeInUse == null) {\n            return null;\n        }\n        final SpellCheckerSession session = new SpellCheckerSession(\n                sci, sService, listener, subtypeInUse);\n        try {\n            sService.getSpellCheckerService(sci.getId(), subtypeInUse.getLocale(),\n                    session.getTextServicesSessionListener(),\n                    session.getSpellCheckerSessionListener(), bundle);\n        } catch (RemoteException e) {\n            return null;\n        }\n        return session;\n    }"}
{"Number":"581","API Relative Path":"src.android.view.textservice.TextServicesManager.java-newSpellCheckerSession(Bundle-Locale-SpellCheckerSessionListener-boolean)","Corresponding Source":"/**\n     * Get a spell checker session for the specified spell checker\n     * @param locale the locale for the spell checker. If {@code locale} is null and\n     * referToSpellCheckerLanguageSettings is true, the locale specified in Settings will be\n     * returned. If {@code locale} is not null and referToSpellCheckerLanguageSettings is true,\n     * the locale specified in Settings will be returned only when it is same as {@code locale}.\n     * Exceptionally, when referToSpellCheckerLanguageSettings is true and {@code locale} is\n     * only language (e.g. \"en\"), the specified locale in Settings (e.g. \"en_US\") will be\n     * selected.\n     * @param listener a spell checker session lister for getting results from a spell checker.\n     * @param referToSpellCheckerLanguageSettings if true, the session for one of enabled\n     * languages in settings will be returned.\n     * @return the spell checker session of the spell checker\n     */\n    public SpellCheckerSession newSpellCheckerSession(Bundle bundle, Locale locale,\n            SpellCheckerSessionListener listener, boolean referToSpellCheckerLanguageSettings) {\n        if (listener == null) {\n            throw new NullPointerException();\n        }\n        if (!referToSpellCheckerLanguageSettings && locale == null) {\n            throw new IllegalArgumentException(\"Locale should not be null if you don't refer\"\n                    + \" settings.\");\n        }\n\n        if (referToSpellCheckerLanguageSettings && !isSpellCheckerEnabled()) {\n            return null;\n        }\n\n        final SpellCheckerInfo sci;\n        try {\n            sci = sService.getCurrentSpellChecker(null);\n        } catch (RemoteException e) {\n            return null;\n        }\n        if (sci == null) {\n            return null;\n        }\n        SpellCheckerSubtype subtypeInUse = null;\n        if (referToSpellCheckerLanguageSettings) {\n            subtypeInUse = getCurrentSpellCheckerSubtype(true);\n            if (subtypeInUse == null) {\n                return null;\n            }\n            if (locale != null) {\n                final String subtypeLocale = subtypeInUse.getLocale();\n                final String subtypeLanguage = parseLanguageFromLocaleString(subtypeLocale);\n                if (subtypeLanguage.length() < 2 || !locale.getLanguage().equals(subtypeLanguage)) {\n                    return null;\n                }\n            }\n        } else {\n            final String localeStr = locale.toString();\n            for (int i = 0; i < sci.getSubtypeCount(); ++i) {\n                final SpellCheckerSubtype subtype = sci.getSubtypeAt(i);\n                final String tempSubtypeLocale = subtype.getLocale();\n                final String tempSubtypeLanguage = parseLanguageFromLocaleString(tempSubtypeLocale);\n                if (tempSubtypeLocale.equals(localeStr)) {\n                    subtypeInUse = subtype;\n                    break;\n                } else if (tempSubtypeLanguage.length() >= 2 &&\n                        locale.getLanguage().equals(tempSubtypeLanguage)) {\n                    subtypeInUse = subtype;\n                }\n            }\n        }\n        if (subtypeInUse == null) {\n            return null;\n        }\n        final SpellCheckerSession session = new SpellCheckerSession(\n                sci, sService, listener, subtypeInUse);\n        try {\n            sService.getSpellCheckerService(sci.getId(), subtypeInUse.getLocale(),\n                    session.getTextServicesSessionListener(),\n                    session.getSpellCheckerSessionListener(), bundle);\n        } catch (RemoteException e) {\n            return null;\n        }\n        return session;\n    }"}
{"Number":"582","API Relative Path":"src.android.view.TextureView.java-setSurfaceTexture(SurfaceTexture)","Corresponding Source":"/**\n     * Set the {@link SurfaceTexture} for this view to use. If a {@link\n     * SurfaceTexture} is already being used by this view, it is immediately\n     * released and not be usable any more.  The {@link\n     * SurfaceTextureListener#onSurfaceTextureDestroyed} callback is <b>not<\/b>\n     * called for the previous {@link SurfaceTexture}.  Similarly, the {@link\n     * SurfaceTextureListener#onSurfaceTextureAvailable} callback is <b>not<\/b>\n     * called for the {@link SurfaceTexture} passed to setSurfaceTexture.\n     *\n     * The {@link SurfaceTexture} object must be detached from all OpenGL ES\n     * contexts prior to calling this method.\n     *\n     * @param surfaceTexture The {@link SurfaceTexture} that the view should use.\n     * @see SurfaceTexture#detachFromGLContext()\n     */\n    public void setSurfaceTexture(SurfaceTexture surfaceTexture) {\n        if (surfaceTexture == null) {\n            throw new NullPointerException(\"surfaceTexture must not be null\");\n        }\n        if (surfaceTexture == mSurface) {\n            throw new IllegalArgumentException(\"Trying to setSurfaceTexture to \" +\n                    \"the same SurfaceTexture that's already set.\");\n        }\n        if (surfaceTexture.isReleased()) {\n            throw new IllegalArgumentException(\"Cannot setSurfaceTexture to a \" +\n                    \"released SurfaceTexture\");\n        }\n        if (mSurface != null) {\n            mSurface.release();\n        }\n        mSurface = surfaceTexture;\n\n        /*\n         * If the view is visible and we already made a layer, update the\n         * listener in the new surface to use the existing listener in the view.\n         * Otherwise this will be called when the view becomes visible or the\n         * layer is created\n         */\n        if (((mViewFlags & VISIBILITY_MASK) == VISIBLE) && mLayer != null) {\n            mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler);\n        }\n        mUpdateSurface = true;\n        invalidateParentIfNeeded();\n    }"}
{"Number":"583","API Relative Path":"src.android.view.TextureView.java-setSurfaceTexture(SurfaceTexture)","Corresponding Source":"/**\n     * Set the {@link SurfaceTexture} for this view to use. If a {@link\n     * SurfaceTexture} is already being used by this view, it is immediately\n     * released and not be usable any more.  The {@link\n     * SurfaceTextureListener#onSurfaceTextureDestroyed} callback is <b>not<\/b>\n     * called for the previous {@link SurfaceTexture}.  Similarly, the {@link\n     * SurfaceTextureListener#onSurfaceTextureAvailable} callback is <b>not<\/b>\n     * called for the {@link SurfaceTexture} passed to setSurfaceTexture.\n     *\n     * The {@link SurfaceTexture} object must be detached from all OpenGL ES\n     * contexts prior to calling this method.\n     *\n     * @param surfaceTexture The {@link SurfaceTexture} that the view should use.\n     * @see SurfaceTexture#detachFromGLContext()\n     */\n    public void setSurfaceTexture(SurfaceTexture surfaceTexture) {\n        if (surfaceTexture == null) {\n            throw new NullPointerException(\"surfaceTexture must not be null\");\n        }\n        if (surfaceTexture == mSurface) {\n            throw new IllegalArgumentException(\"Trying to setSurfaceTexture to \" +\n                    \"the same SurfaceTexture that's already set.\");\n        }\n        if (surfaceTexture.isReleased()) {\n            throw new IllegalArgumentException(\"Cannot setSurfaceTexture to a \" +\n                    \"released SurfaceTexture\");\n        }\n        if (mSurface != null) {\n            mSurface.release();\n        }\n        mSurface = surfaceTexture;\n\n        /*\n         * If the view is visible and we already made a layer, update the\n         * listener in the new surface to use the existing listener in the view.\n         * Otherwise this will be called when the view becomes visible or the\n         * layer is created\n         */\n        if (((mViewFlags & VISIBILITY_MASK) == VISIBLE) && mLayer != null) {\n            mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler);\n        }\n        mUpdateSurface = true;\n        invalidateParentIfNeeded();\n    }"}
{"Number":"584","API Relative Path":"src.android.view.VelocityTracker.java-addMovement(MotionEvent)","Corresponding Source":"/**\n     * Add a user's movement to the tracker.  You should call this for the\n     * initial {@link MotionEvent#ACTION_DOWN}, the following\n     * {@link MotionEvent#ACTION_MOVE} events that you receive, and the\n     * final {@link MotionEvent#ACTION_UP}.  You can, however, call this\n     * for whichever events you desire.\n     * \n     * @param event The MotionEvent you received and would like to track.\n     */\n    public void addMovement(MotionEvent event) {\n        if (event == null) {\n            throw new IllegalArgumentException(\"event must not be null\");\n        }\n        nativeAddMovement(mPtr, event);\n    }"}
{"Number":"585","API Relative Path":"src.android.view.VelocityTracker.java-getEstimator(int-Estimator)","Corresponding Source":"/**\n     * Get an estimator for the movements of a pointer using past movements of the\n     * pointer to predict future movements.\n     *\n     * It is not necessary to call {@link #computeCurrentVelocity(int)} before calling\n     * this method.\n     *\n     * @param id Which pointer's velocity to return.\n     * @param outEstimator The estimator to populate.\n     * @return True if an estimator was obtained, false if there is no information\n     * available about the pointer.\n     *\n     * @hide For internal use only.  Not a final API.\n     */\n    public boolean getEstimator(int id, Estimator outEstimator) {\n        if (outEstimator == null) {\n            throw new IllegalArgumentException(\"outEstimator must not be null\");\n        }\n        return nativeGetEstimator(mPtr, id, outEstimator);\n    }"}
{"Number":"586","API Relative Path":"src.android.view.View.java-buildDrawingCache(boolean)","Corresponding Source":"/**\n     * <p>Forces the drawing cache to be built if the drawing cache is invalid.<\/p>\n     *\n     * <p>If you call {@link #buildDrawingCache()} manually without calling\n     * {@link #setDrawingCacheEnabled(boolean) setDrawingCacheEnabled(true)}, you\n     * should cleanup the cache by calling {@link #destroyDrawingCache()} afterwards.<\/p>\n     *\n     * <p>Note about auto scaling in compatibility mode: When auto scaling is not enabled,\n     * this method will create a bitmap of the same size as this view. Because this bitmap\n     * will be drawn scaled by the parent ViewGroup, the result on screen might show\n     * scaling artifacts. To avoid such artifacts, you should call this method by setting\n     * the auto scaling to true. Doing so, however, will generate a bitmap of a different\n     * size than the view. This implies that your application must be able to handle this\n     * size.<\/p>\n     *\n     * <p>You should avoid calling this method when hardware acceleration is enabled. If\n     * you do not need the drawing cache bitmap, calling this method will increase memory\n     * usage and cause the view to be rendered in software once, thus negatively impacting\n     * performance.<\/p>\n     *\n     * @see #getDrawingCache()\n     * @see #destroyDrawingCache()\n     */\n    public void buildDrawingCache(boolean autoScale) {\n        if ((mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == 0 || (autoScale ?\n                mDrawingCache == null : mUnscaledDrawingCache == null)) {\n            if (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) {\n                Trace.traceBegin(Trace.TRACE_TAG_VIEW,\n                        \"buildDrawingCache/SW Layer for \" + getClass().getSimpleName());\n            }\n            try {\n                buildDrawingCacheImpl(autoScale);\n            } finally {\n                Trace.traceEnd(Trace.TRACE_TAG_VIEW);\n            }\n        }\n    }"}
{"Number":"587","API Relative Path":"src.android.view.View.java-findViewWithTag(Object)","Corresponding Source":"/**\n     * Look for a child view with the given tag.  If this view has the given\n     * tag, return this view.\n     *\n     * @param tag The tag to search for, using \"tag.equals(getTag())\".\n     * @return The View that has the given tag in the hierarchy or null\n     */\n    public final View findViewWithTag(Object tag) {\n        if (tag == null) {\n            return null;\n        }\n        return findViewWithTagTraversal(tag);\n    }"}
{"Number":"588","API Relative Path":"src.android.view.View.java-getLocationInWindow(int[])","Corresponding Source":"/**\n     * <p>Computes the coordinates of this view in its window. The argument\n     * must be an array of two integers. After the method returns, the array\n     * contains the x and y location in that order.<\/p>\n     *\n     * @param outLocation an array of two integers in which to hold the coordinates\n     */\n    public void getLocationInWindow(@Size(2) int[] outLocation) {\n        if (outLocation == null || outLocation.length < 2) {\n            throw new IllegalArgumentException(\"outLocation must be an array of two integers\");\n        }\n\n        outLocation[0] = 0;\n        outLocation[1] = 0;\n\n        transformFromViewToWindowSpace(outLocation);\n    }"}
{"Number":"589","API Relative Path":"src.android.view.View.java-onRestoreInstanceState(Parcelable)","Corresponding Source":"/**\n     * Hook allowing a view to re-apply a representation of its internal state that had previously\n     * been generated by {@link #onSaveInstanceState}. This function will never be called with a\n     * null state.\n     *\n     * @param state The frozen state that had previously been returned by\n     *        {@link #onSaveInstanceState}.\n     *\n     * @see #onSaveInstanceState()\n     * @see #restoreHierarchyState(android.util.SparseArray)\n     * @see #dispatchRestoreInstanceState(android.util.SparseArray)\n     */\n    @CallSuper\n    protected void onRestoreInstanceState(Parcelable state) {\n        mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;\n        if (state != null && !(state instanceof AbsSavedState)) {\n            throw new IllegalArgumentException(\"Wrong state class, expecting View State but \"\n                    + \"received \" + state.getClass().toString() + \" instead. This usually happens \"\n                    + \"when two views of different type have the same id in the same hierarchy. \"\n                    + \"This view's id is \" + ViewDebug.resolveId(mContext, getId()) + \". Make sure \"\n                    + \"other views do not use the same id.\");\n        }\n        if (state != null && state instanceof BaseSavedState) {\n            mStartActivityRequestWho = ((BaseSavedState) state).mStartActivityRequestWhoSaved;\n        }\n    }"}
{"Number":"590","API Relative Path":"src.android.view.View.java-requestUnbufferedDispatch(MotionEvent)","Corresponding Source":"/**\n     * Request unbuffered dispatch of the given stream of MotionEvents to this View.\n     *\n     * Until this View receives a corresponding {@link MotionEvent#ACTION_UP}, ask that the input\n     * system not batch {@link MotionEvent}s but instead deliver them as soon as they're\n     * available. This method should only be called for touch events.\n     *\n     * <p class=\"note\">This api is not intended for most applications. Buffered dispatch\n     * provides many of benefits, and just requesting unbuffered dispatch on most MotionEvent\n     * streams will not improve your input latency. Side effects include: increased latency,\n     * jittery scrolls and inability to take advantage of system resampling. Talk to your input\n     * professional to see if {@link #requestUnbufferedDispatch(MotionEvent)} is right for\n     * you.<\/p>\n     */\n    public final void requestUnbufferedDispatch(MotionEvent event) {\n        final int action = event.getAction();\n        if (mAttachInfo == null\n                || action != MotionEvent.ACTION_DOWN && action != MotionEvent.ACTION_MOVE\n                || !event.isTouchEvent()) {\n            return;\n        }\n        mAttachInfo.mUnbufferedDispatchRequested = true;\n    }"}
{"Number":"591","API Relative Path":"src.android.view.View.java-scheduleDrawable(Drawable-Runnable-long)","Corresponding Source":"/**\n     * Schedules an action on a drawable to occur at a specified time.\n     *\n     * @param who the recipient of the action\n     * @param what the action to run on the drawable\n     * @param when the time at which the action must occur. Uses the\n     *        {@link SystemClock#uptimeMillis} timebase.\n     */\n    @Override\n    public void scheduleDrawable(@NonNull Drawable who, @NonNull Runnable what, long when) {\n        if (verifyDrawable(who) && what != null) {\n            final long delay = when - SystemClock.uptimeMillis();\n            if (mAttachInfo != null) {\n                mAttachInfo.mViewRootImpl.mChoreographer.postCallbackDelayed(\n                        Choreographer.CALLBACK_ANIMATION, what, who,\n                        Choreographer.subtractFrameDelay(delay));\n            } else {\n                // Postpone the runnable until we know\n                // on which thread it needs to run.\n                getRunQueue().postDelayed(what, delay);\n            }\n        }\n    }"}
{"Number":"592","API Relative Path":"src.android.view.View.java-setAnimation(Animation)","Corresponding Source":"/**\n     * Sets the next animation to play for this view.\n     * If you want the animation to play immediately, use\n     * {@link #startAnimation(android.view.animation.Animation)} instead.\n     * This method provides allows fine-grained\n     * control over the start time and invalidation, but you\n     * must make sure that 1) the animation has a start time set, and\n     * 2) the view's parent (which controls animations on its children)\n     * will be invalidated when the animation is supposed to\n     * start.\n     *\n     * @param animation The next animation, or null.\n     */\n    public void setAnimation(Animation animation) {\n        mCurrentAnimation = animation;\n\n        if (animation != null) {\n            // If the screen is off assume the animation start time is now instead of\n            // the next frame we draw. Keeping the START_ON_FIRST_FRAME start time\n            // would cause the animation to start when the screen turns back on\n            if (mAttachInfo != null && mAttachInfo.mDisplayState == Display.STATE_OFF\n                    && animation.getStartTime() == Animation.START_ON_FIRST_FRAME) {\n                animation.setStartTime(AnimationUtils.currentAnimationTimeMillis());\n            }\n            animation.reset();\n        }\n    }"}
{"Number":"593","API Relative Path":"src.android.view.View.java-setClipBounds(Rect)","Corresponding Source":"/**\n     * Sets a rectangular area on this view to which the view will be clipped\n     * when it is drawn. Setting the value to null will remove the clip bounds\n     * and the view will draw normally, using its full bounds.\n     *\n     * @param clipBounds The rectangular area, in the local coordinates of\n     * this view, to which future drawing operations will be clipped.\n     */\n    public void setClipBounds(Rect clipBounds) {\n        if (clipBounds == mClipBounds\n                || (clipBounds != null && clipBounds.equals(mClipBounds))) {\n            return;\n        }\n        if (clipBounds != null) {\n            if (mClipBounds == null) {\n                mClipBounds = new Rect(clipBounds);\n            } else {\n                mClipBounds.set(clipBounds);\n            }\n        } else {\n            mClipBounds = null;\n        }\n        mRenderNode.setClipBounds(mClipBounds);\n        invalidateViewProperty(false, false);\n    }"}
{"Number":"594","API Relative Path":"src.android.view.View.java-setContentDescription(CharSequence)","Corresponding Source":"/**\n     * Sets the {@link View}'s content description.\n     * <p>\n     * A content description briefly describes the view and is primarily used\n     * for accessibility support to determine how a view should be presented to\n     * the user. In the case of a view with no textual representation, such as\n     * {@link android.widget.ImageButton}, a useful content description\n     * explains what the view does. For example, an image button with a phone\n     * icon that is used to place a call may use \"Call\" as its content\n     * description. An image of a floppy disk that is used to save a file may\n     * use \"Save\".\n     *\n     * @param contentDescription The content description.\n     * @see #getContentDescription()\n     * @attr ref android.R.styleable#View_contentDescription\n     */\n    @RemotableViewMethod\n    public void setContentDescription(CharSequence contentDescription) {\n        if (mContentDescription == null) {\n            if (contentDescription == null) {\n                return;\n            }\n        } else if (mContentDescription.equals(contentDescription)) {\n            return;\n        }\n        mContentDescription = contentDescription;\n        final boolean nonEmptyDesc = contentDescription != null && contentDescription.length() > 0;\n        if (nonEmptyDesc && getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {\n            setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);\n            notifySubtreeAccessibilityStateChangedIfNeeded();\n        } else {\n            notifyViewAccessibilityStateChangedIfNeeded(\n                    AccessibilityEvent.CONTENT_CHANGE_TYPE_CONTENT_DESCRIPTION);\n        }\n    }"}
{"Number":"595","API Relative Path":"src.android.view.View.java-setDisplayListProperties(RenderNode)","Corresponding Source":"/**\n     * This method is called by getDisplayList() when a display list is recorded for a View.\n     * It pushes any properties to the RenderNode that aren't managed by the RenderNode.\n     */\n    void setDisplayListProperties(RenderNode renderNode) {\n        if (renderNode != null) {\n            renderNode.setHasOverlappingRendering(getHasOverlappingRendering());\n            renderNode.setClipToBounds(mParent instanceof ViewGroup\n                    && ((ViewGroup) mParent).getClipChildren());\n\n            float alpha = 1;\n            if (mParent instanceof ViewGroup && (((ViewGroup) mParent).mGroupFlags &\n                    ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {\n                ViewGroup parentVG = (ViewGroup) mParent;\n                final Transformation t = parentVG.getChildTransformation();\n                if (parentVG.getChildStaticTransformation(this, t)) {\n                    final int transformType = t.getTransformationType();\n                    if (transformType != Transformation.TYPE_IDENTITY) {\n                        if ((transformType & Transformation.TYPE_ALPHA) != 0) {\n                            alpha = t.getAlpha();\n                        }\n                        if ((transformType & Transformation.TYPE_MATRIX) != 0) {\n                            renderNode.setStaticMatrix(t.getMatrix());\n                        }\n                    }\n                }\n            }\n            if (mTransformationInfo != null) {\n                alpha *= getFinalAlpha();\n                if (alpha < 1) {\n                    final int multipliedAlpha = (int) (255 * alpha);\n                    if (onSetAlpha(multipliedAlpha)) {\n                        alpha = 1;\n                    }\n                }\n                renderNode.setAlpha(alpha);\n            } else if (alpha < 1) {\n                renderNode.setAlpha(alpha);\n            }\n        }\n    }"}
{"Number":"596","API Relative Path":"src.android.view.View.java-setForeground(Drawable)","Corresponding Source":"/**\n     * Supply a Drawable that is to be rendered on top of all of the content in the view.\n     *\n     * @param foreground the Drawable to be drawn on top of the children\n     *\n     * @attr ref android.R.styleable#View_foreground\n     */\n    public void setForeground(Drawable foreground) {\n        if (mForegroundInfo == null) {\n            if (foreground == null) {\n                // Nothing to do.\n                return;\n            }\n            mForegroundInfo = new ForegroundInfo();\n        }\n\n        if (foreground == mForegroundInfo.mDrawable) {\n            // Nothing to do\n            return;\n        }\n\n        if (mForegroundInfo.mDrawable != null) {\n            if (isAttachedToWindow()) {\n                mForegroundInfo.mDrawable.setVisible(false, false);\n            }\n            mForegroundInfo.mDrawable.setCallback(null);\n            unscheduleDrawable(mForegroundInfo.mDrawable);\n        }\n\n        mForegroundInfo.mDrawable = foreground;\n        mForegroundInfo.mBoundsChanged = true;\n        if (foreground != null) {\n            if ((mPrivateFlags & PFLAG_SKIP_DRAW) != 0) {\n                mPrivateFlags &= ~PFLAG_SKIP_DRAW;\n            }\n            foreground.setLayoutDirection(getLayoutDirection());\n            if (foreground.isStateful()) {\n                foreground.setState(getDrawableState());\n            }\n            applyForegroundTint();\n            if (isAttachedToWindow()) {\n                foreground.setVisible(getWindowVisibility() == VISIBLE && isShown(), false);\n            }\n            // Set callback last, since the view may still be initializing.\n            foreground.setCallback(this);\n        } else if ((mViewFlags & WILL_NOT_DRAW) != 0 && mBackground == null) {\n            mPrivateFlags |= PFLAG_SKIP_DRAW;\n        }\n        requestLayout();\n        invalidate();\n    }"}
{"Number":"597","API Relative Path":"src.android.view.View.java-setLayerType(int-Paint)","Corresponding Source":"/**\n     * <p>Specifies the type of layer backing this view. The layer can be\n     * {@link #LAYER_TYPE_NONE}, {@link #LAYER_TYPE_SOFTWARE} or\n     * {@link #LAYER_TYPE_HARDWARE}.<\/p>\n     *\n     * <p>A layer is associated with an optional {@link android.graphics.Paint}\n     * instance that controls how the layer is composed on screen. The following\n     * properties of the paint are taken into account when composing the layer:<\/p>\n     * <ul>\n     * <li>{@link android.graphics.Paint#getAlpha() Translucency (alpha)}<\/li>\n     * <li>{@link android.graphics.Paint#getXfermode() Blending mode}<\/li>\n     * <li>{@link android.graphics.Paint#getColorFilter() Color filter}<\/li>\n     * <\/ul>\n     *\n     * <p>If this view has an alpha value set to < 1.0 by calling\n     * {@link #setAlpha(float)}, the alpha value of the layer's paint is superseded\n     * by this view's alpha value.<\/p>\n     *\n     * <p>Refer to the documentation of {@link #LAYER_TYPE_NONE},\n     * {@link #LAYER_TYPE_SOFTWARE} and {@link #LAYER_TYPE_HARDWARE}\n     * for more information on when and how to use layers.<\/p>\n     *\n     * @param layerType The type of layer to use with this view, must be one of\n     *        {@link #LAYER_TYPE_NONE}, {@link #LAYER_TYPE_SOFTWARE} or\n     *        {@link #LAYER_TYPE_HARDWARE}\n     * @param paint The paint used to compose the layer. This argument is optional\n     *        and can be null. It is ignored when the layer type is\n     *        {@link #LAYER_TYPE_NONE}\n     *\n     * @see #getLayerType()\n     * @see #LAYER_TYPE_NONE\n     * @see #LAYER_TYPE_SOFTWARE\n     * @see #LAYER_TYPE_HARDWARE\n     * @see #setAlpha(float)\n     *\n     * @attr ref android.R.styleable#View_layerType\n     */\n    public void setLayerType(int layerType, @Nullable Paint paint) {\n        if (layerType < LAYER_TYPE_NONE || layerType > LAYER_TYPE_HARDWARE) {\n            throw new IllegalArgumentException(\"Layer type can only be one of: LAYER_TYPE_NONE, \"\n                    + \"LAYER_TYPE_SOFTWARE or LAYER_TYPE_HARDWARE\");\n        }\n\n        boolean typeChanged = mRenderNode.setLayerType(layerType);\n\n        if (!typeChanged) {\n            setLayerPaint(paint);\n            return;\n        }\n\n        if (layerType != LAYER_TYPE_SOFTWARE) {\n            // Destroy any previous software drawing cache if present\n            // NOTE: even if previous layer type is HW, we do this to ensure we've cleaned up\n            // drawing cache created in View#draw when drawing to a SW canvas.\n            destroyDrawingCache();\n        }\n\n        mLayerType = layerType;\n        mLayerPaint = mLayerType == LAYER_TYPE_NONE ? null : paint;\n        mRenderNode.setLayerPaint(mLayerPaint);\n\n        // draw() behaves differently if we are on a layer, so we need to\n        // invalidate() here\n        invalidateParentCaches();\n        invalidate(true);\n    }"}
{"Number":"598","API Relative Path":"src.android.view.View.java-setOverScrollMode(int)","Corresponding Source":"/**\n     * Set the over-scroll mode for this view. Valid over-scroll modes are\n     * {@link #OVER_SCROLL_ALWAYS} (default), {@link #OVER_SCROLL_IF_CONTENT_SCROLLS}\n     * (allow over-scrolling only if the view content is larger than the container),\n     * or {@link #OVER_SCROLL_NEVER}.\n     *\n     * Setting the over-scroll mode of a view will have an effect only if the\n     * view is capable of scrolling.\n     *\n     * @param overScrollMode The new over-scroll mode for this view.\n     */\n    public void setOverScrollMode(int overScrollMode) {\n        if (overScrollMode != OVER_SCROLL_ALWAYS &&\n                overScrollMode != OVER_SCROLL_IF_CONTENT_SCROLLS &&\n                overScrollMode != OVER_SCROLL_NEVER) {\n            throw new IllegalArgumentException(\"Invalid overscroll mode \" + overScrollMode);\n        }\n        mOverScrollMode = overScrollMode;\n    }"}
{"Number":"599","API Relative Path":"src.android.view.View.java-setTag(int-Object)","Corresponding Source":"/**\n     * Sets a tag associated with this view and a key. A tag can be used\n     * to mark a view in its hierarchy and does not have to be unique within\n     * the hierarchy. Tags can also be used to store data within a view\n     * without resorting to another data structure.\n     *\n     * The specified key should be an id declared in the resources of the\n     * application to ensure it is unique (see the <a\n     * href=\"{@docRoot}guide/topics/resources/more-resources.html#Id\">ID resource type<\/a>).\n     * Keys identified as belonging to\n     * the Android framework or not associated with any package will cause\n     * an {@link IllegalArgumentException} to be thrown.\n     *\n     * @param key The key identifying the tag\n     * @param tag An Object to tag the view with\n     *\n     * @throws IllegalArgumentException If they specified key is not valid\n     *\n     * @see #setTag(Object)\n     * @see #getTag(int)\n     */\n    public void setTag(int key, final Object tag) {\n        // If the package id is 0x00 or 0x01, it's either an undefined package\n        // or a framework id\n        if ((key >>> 24) < 2) {\n            throw new IllegalArgumentException(\"The key must be an application-specific \"\n                    + \"resource id.\");\n        }\n\n        setKeyedTag(key, tag);\n    }"}
{"Number":"600","API Relative Path":"src.android.view.View.java-setTagInternal(int-Object)","Corresponding Source":"/**\n     * Variation of {@link #setTag(int, Object)} that enforces the key to be a\n     * framework id.\n     *\n     * @hide\n     */\n    public void setTagInternal(int key, Object tag) {\n        if ((key >>> 24) != 0x1) {\n            throw new IllegalArgumentException(\"The key must be a framework-specific \"\n                    + \"resource id.\");\n        }\n\n        setKeyedTag(key, tag);\n    }"}
{"Number":"601","API Relative Path":"src.android.view.View.java-transformFromViewToWindowSpace(int[])","Corresponding Source":"/** @hide */\n    public void transformFromViewToWindowSpace(@Size(2) int[] inOutLocation) {\n        if (inOutLocation == null || inOutLocation.length < 2) {\n            throw new IllegalArgumentException(\"inOutLocation must be an array of two integers\");\n        }\n\n        if (mAttachInfo == null) {\n            // When the view is not attached to a window, this method does not make sense\n            inOutLocation[0] = inOutLocation[1] = 0;\n            return;\n        }\n\n        float position[] = mAttachInfo.mTmpTransformLocation;\n        position[0] = inOutLocation[0];\n        position[1] = inOutLocation[1];\n\n        if (!hasIdentityMatrix()) {\n            getMatrix().mapPoints(position);\n        }\n\n        position[0] += mLeft;\n        position[1] += mTop;\n\n        ViewParent viewParent = mParent;\n        while (viewParent instanceof View) {\n            final View view = (View) viewParent;\n\n            position[0] -= view.mScrollX;\n            position[1] -= view.mScrollY;\n\n            if (!view.hasIdentityMatrix()) {\n                view.getMatrix().mapPoints(position);\n            }\n\n            position[0] += view.mLeft;\n            position[1] += view.mTop;\n\n            viewParent = view.mParent;\n         }\n\n        if (viewParent instanceof ViewRootImpl) {\n            // *cough*\n            final ViewRootImpl vr = (ViewRootImpl) viewParent;\n            position[1] -= vr.mCurScrollY;\n        }\n\n        inOutLocation[0] = Math.round(position[0]);\n        inOutLocation[1] = Math.round(position[1]);\n    }"}
{"Number":"602","API Relative Path":"src.android.view.View.java-unscheduleDrawable(Drawable-Runnable)","Corresponding Source":"/**\n     * Cancels a scheduled action on a drawable.\n     *\n     * @param who the recipient of the action\n     * @param what the action to cancel\n     */\n    @Override\n    public void unscheduleDrawable(@NonNull Drawable who, @NonNull Runnable what) {\n        if (verifyDrawable(who) && what != null) {\n            if (mAttachInfo != null) {\n                mAttachInfo.mViewRootImpl.mChoreographer.removeCallbacks(\n                        Choreographer.CALLBACK_ANIMATION, what, who);\n            }\n            getRunQueue().removeCallbacks(what);\n        }\n    }"}
{"Number":"603","API Relative Path":"src.android.view.ViewGroup.java-addView(View-int)","Corresponding Source":"/**\n     * Adds a child view. If no layout parameters are already set on the child, the\n     * default parameters for this ViewGroup are set on the child.\n     *\n     * <p><strong>Note:<\/strong> do not invoke this method from\n     * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},\n     * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.<\/p>\n     *\n     * @param child the child view to add\n     * @param index the position at which to add the child\n     *\n     * @see #generateDefaultLayoutParams()\n     */\n    public void addView(View child, int index) {\n        if (child == null) {\n            throw new IllegalArgumentException(\"Cannot add a null child view to a ViewGroup\");\n        }\n        LayoutParams params = child.getLayoutParams();\n        if (params == null) {\n            params = generateDefaultLayoutParams();\n            if (params == null) {\n                throw new IllegalArgumentException(\"generateDefaultLayoutParams() cannot return null\");\n            }\n        }\n        addView(child, index, params);\n    }"}
{"Number":"604","API Relative Path":"src.android.view.ViewGroup.java-addView(View-int-LayoutParams)","Corresponding Source":"/**\n     * Adds a child view with the specified layout parameters.\n     *\n     * <p><strong>Note:<\/strong> do not invoke this method from\n     * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},\n     * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.<\/p>\n     *\n     * @param child the child view to add\n     * @param index the position at which to add the child or -1 to add last\n     * @param params the layout parameters to set on the child\n     */\n    public void addView(View child, int index, LayoutParams params) {\n        if (DBG) {\n            System.out.println(this + \" addView\");\n        }\n\n        if (child == null) {\n            throw new IllegalArgumentException(\"Cannot add a null child view to a ViewGroup\");\n        }\n\n        // addViewInner() will call child.requestLayout() when setting the new LayoutParams\n        // therefore, we call requestLayout() on ourselves before, so that the child's request\n        // will be blocked at our level\n        requestLayout();\n        invalidate(true);\n        addViewInner(child, index, params, false);\n    }"}
{"Number":"605","API Relative Path":"src.android.view.ViewGroup.java-addViewInLayout(View-int-LayoutParams-boolean)","Corresponding Source":"/**\n     * Adds a view during layout. This is useful if in your onLayout() method,\n     * you need to add more views (as does the list view for example).\n     *\n     * If index is negative, it means put it at the end of the list.\n     *\n     * @param child the view to add to the group\n     * @param index the index at which the child must be added or -1 to add last\n     * @param params the layout parameters to associate with the child\n     * @param preventRequestLayout if true, calling this method will not trigger a\n     *        layout request on child\n     * @return true if the child was added, false otherwise\n     */\n    protected boolean addViewInLayout(View child, int index, LayoutParams params,\n            boolean preventRequestLayout) {\n        if (child == null) {\n            throw new IllegalArgumentException(\"Cannot add a null child view to a ViewGroup\");\n        }\n        child.mParent = null;\n        addViewInner(child, index, params, preventRequestLayout);\n        child.mPrivateFlags = (child.mPrivateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;\n        return true;\n    }"}
{"Number":"606","API Relative Path":"src.android.view.ViewGroup.java-endViewTransition(View)","Corresponding Source":"/**\n     * This method should always be called following an earlier call to\n     * {@link #startViewTransition(View)}. The given View is finally removed from its parent\n     * and will no longer be displayed. Note that this method does not perform the functionality\n     * of removing a view from its parent; it just discontinues the display of a View that\n     * has previously been removed.\n     *\n     * @return view The View object that has been removed but is being kept around in the visible\n     * hierarchy by an earlier call to {@link #startViewTransition(View)}.\n     */\n    public void endViewTransition(View view) {\n        if (mTransitioningViews != null) {\n            mTransitioningViews.remove(view);\n            final ArrayList<View> disappearingChildren = mDisappearingChildren;\n            if (disappearingChildren != null && disappearingChildren.contains(view)) {\n                disappearingChildren.remove(view);\n                if (mVisibilityChangingChildren != null &&\n                        mVisibilityChangingChildren.contains(view)) {\n                    mVisibilityChangingChildren.remove(view);\n                } else {\n                    if (view.mAttachInfo != null) {\n                        view.dispatchDetachedFromWindow();\n                    }\n                    if (view.mParent != null) {\n                        view.mParent = null;\n                    }\n                }\n                invalidate();\n            }\n        }\n    }"}
{"Number":"607","API Relative Path":"src.android.view.ViewRootImpl.java-requestTransitionStart(LayoutTransition)","Corresponding Source":"/**\n     * Add LayoutTransition to the list of transitions to be started in the next traversal.\n     * This list will be cleared after the transitions on the list are start()'ed. These\n     * transitionsa re added by LayoutTransition itself when it sets up animations. The setup\n     * happens during the layout phase of traversal, which we want to complete before any of the\n     * animations are started (because those animations may side-effect properties that layout\n     * depends upon, like the bounding rectangles of the affected views). So we add the transition\n     * to the list and it is started just prior to starting the drawing phase of traversal.\n     *\n     * @param transition The LayoutTransition to be started on the next traversal.\n     *\n     * @hide\n     */\n    public void requestTransitionStart(LayoutTransition transition) {\n        if (mPendingTransitions == null || !mPendingTransitions.contains(transition)) {\n            if (mPendingTransitions == null) {\n                 mPendingTransitions = new ArrayList<LayoutTransition>();\n            }\n            mPendingTransitions.add(transition);\n        }\n    }"}
{"Number":"608","API Relative Path":"src.android.view.Window.java-addOnFrameMetricsAvailableListener(OnFrameMetricsAvailableListener-Handler)","Corresponding Source":"/**\n     * Set an observer to collect frame stats for each frame rendererd in this window.\n     *\n     * Must be in hardware rendering mode.\n     */\n    public final void addOnFrameMetricsAvailableListener(\n            @NonNull OnFrameMetricsAvailableListener listener,\n            Handler handler) {\n        final View decorView = getDecorView();\n        if (decorView == null) {\n            throw new IllegalStateException(\"can't observe a Window without an attached view\");\n        }\n\n        if (listener == null) {\n            throw new NullPointerException(\"listener cannot be null\");\n        }\n\n        decorView.addFrameMetricsListener(this, listener, handler);\n    }"}
{"Number":"609","API Relative Path":"src.android.view.Window.java-setContainer(Window)","Corresponding Source":"/**\n     * Set the container for this window.  If not set, the DecorWindow\n     * operates as a top-level window; otherwise, it negotiates with the\n     * container to display itself appropriately.\n     *\n     * @param container The desired containing Window.\n     */\n    public void setContainer(Window container) {\n        mContainer = container;\n        if (container != null) {\n            // Embedded screens never have a title.\n            mFeatures |= 1<<FEATURE_NO_TITLE;\n            mLocalFeatures |= 1<<FEATURE_NO_TITLE;\n            container.mHasChildren = true;\n        }\n    }"}
{"Number":"610","API Relative Path":"src.android.view.WindowManagerGlobal.java-changeCanvasOpacity(IBinder-boolean)","Corresponding Source":"/** @hide */\n    public void changeCanvasOpacity(IBinder token, boolean opaque) {\n        if (token == null) {\n            return;\n        }\n        synchronized (mLock) {\n            for (int i = mParams.size() - 1; i >= 0; --i) {\n                if (mParams.get(i).token == token) {\n                    mRoots.get(i).changeCanvasOpacity(opaque);\n                    return;\n                }\n            }\n        }\n    }"}
{"Number":"611","API Relative Path":"src.android.webkit.CookieSyncManager.java-createInstance(Context)","Corresponding Source":"/**\n     * Create a singleton CookieSyncManager within a context\n     * @param context\n     * @return CookieSyncManager\n     */\n    public static synchronized CookieSyncManager createInstance(Context context) {\n        if (context == null) {\n            throw new IllegalArgumentException(\"Invalid context argument\");\n        }\n        setGetInstanceIsAllowed();\n        return getInstance();\n    }"}
{"Number":"612","API Relative Path":"src.android.webkit.WebResourceResponse.java-setData(InputStream)","Corresponding Source":"/**\n     * Sets the input stream that provides the resource response's data. Callers\n     * must implement {@link InputStream#read(byte[]) InputStream.read(byte[])}.\n     *\n     * @param data the input stream that provides the resource response's data. Must not be a\n     *             StringBufferInputStream.\n     */\n    public void setData(InputStream data) {\n        checkImmutable();\n        // If data is (or is a subclass of) StringBufferInputStream\n        if (data != null && StringBufferInputStream.class.isAssignableFrom(data.getClass())) {\n            throw new IllegalArgumentException(\"StringBufferInputStream is deprecated and must \" +\n                \"not be passed to a WebResourceResponse\");\n        }\n        mInputStream = data;\n    }"}
{"Number":"613","API Relative Path":"src.android.webkit.WebResourceResponse.java-setStatusCodeAndReasonPhrase(int-String)","Corresponding Source":"/**\n     * Sets the resource response's status code and reason phrase.\n     *\n     * @param statusCode the status code needs to be in the ranges [100, 299], [400, 599].\n     *                   Causing a redirect by specifying a 3xx code is not supported.\n     * @param reasonPhrase the phrase describing the status code, for example \"OK\". Must be non-null\n     *                     and not empty.\n     */\n    public void setStatusCodeAndReasonPhrase(int statusCode, String reasonPhrase) {\n        checkImmutable();\n        if (statusCode < 100)\n            throw new IllegalArgumentException(\"statusCode can't be less than 100.\");\n        if (statusCode > 599)\n            throw new IllegalArgumentException(\"statusCode can't be greater than 599.\");\n        if (statusCode > 299 && statusCode < 400)\n            throw new IllegalArgumentException(\"statusCode can't be in the [300, 399] range.\");\n        if (reasonPhrase == null)\n            throw new IllegalArgumentException(\"reasonPhrase can't be null.\");\n        if (reasonPhrase.trim().isEmpty())\n            throw new IllegalArgumentException(\"reasonPhrase can't be empty.\");\n        for (int i = 0; i < reasonPhrase.length(); i++) {\n            int c = reasonPhrase.charAt(i);\n            if (c > 0x7F) {\n                throw new IllegalArgumentException(\n                        \"reasonPhrase can't contain non-ASCII characters.\");\n            }\n        }\n        mStatusCode = statusCode;\n        mReasonPhrase = reasonPhrase;\n    }"}
{"Number":"614","API Relative Path":"src.android.webkit.WebResourceResponse.java-setStatusCodeAndReasonPhrase(int-String)","Corresponding Source":"/**\n     * Sets the resource response's status code and reason phrase.\n     *\n     * @param statusCode the status code needs to be in the ranges [100, 299], [400, 599].\n     *                   Causing a redirect by specifying a 3xx code is not supported.\n     * @param reasonPhrase the phrase describing the status code, for example \"OK\". Must be non-null\n     *                     and not empty.\n     */\n    public void setStatusCodeAndReasonPhrase(int statusCode, String reasonPhrase) {\n        checkImmutable();\n        if (statusCode < 100)\n            throw new IllegalArgumentException(\"statusCode can't be less than 100.\");\n        if (statusCode > 599)\n            throw new IllegalArgumentException(\"statusCode can't be greater than 599.\");\n        if (statusCode > 299 && statusCode < 400)\n            throw new IllegalArgumentException(\"statusCode can't be in the [300, 399] range.\");\n        if (reasonPhrase == null)\n            throw new IllegalArgumentException(\"reasonPhrase can't be null.\");\n        if (reasonPhrase.trim().isEmpty())\n            throw new IllegalArgumentException(\"reasonPhrase can't be empty.\");\n        for (int i = 0; i < reasonPhrase.length(); i++) {\n            int c = reasonPhrase.charAt(i);\n            if (c > 0x7F) {\n                throw new IllegalArgumentException(\n                        \"reasonPhrase can't contain non-ASCII characters.\");\n            }\n        }\n        mStatusCode = statusCode;\n        mReasonPhrase = reasonPhrase;\n    }"}
{"Number":"615","API Relative Path":"src.android.webkit.WebResourceResponse.java-setStatusCodeAndReasonPhrase(int-String)","Corresponding Source":"/**\n     * Sets the resource response's status code and reason phrase.\n     *\n     * @param statusCode the status code needs to be in the ranges [100, 299], [400, 599].\n     *                   Causing a redirect by specifying a 3xx code is not supported.\n     * @param reasonPhrase the phrase describing the status code, for example \"OK\". Must be non-null\n     *                     and not empty.\n     */\n    public void setStatusCodeAndReasonPhrase(int statusCode, String reasonPhrase) {\n        checkImmutable();\n        if (statusCode < 100)\n            throw new IllegalArgumentException(\"statusCode can't be less than 100.\");\n        if (statusCode > 599)\n            throw new IllegalArgumentException(\"statusCode can't be greater than 599.\");\n        if (statusCode > 299 && statusCode < 400)\n            throw new IllegalArgumentException(\"statusCode can't be in the [300, 399] range.\");\n        if (reasonPhrase == null)\n            throw new IllegalArgumentException(\"reasonPhrase can't be null.\");\n        if (reasonPhrase.trim().isEmpty())\n            throw new IllegalArgumentException(\"reasonPhrase can't be empty.\");\n        for (int i = 0; i < reasonPhrase.length(); i++) {\n            int c = reasonPhrase.charAt(i);\n            if (c > 0x7F) {\n                throw new IllegalArgumentException(\n                        \"reasonPhrase can't contain non-ASCII characters.\");\n            }\n        }\n        mStatusCode = statusCode;\n        mReasonPhrase = reasonPhrase;\n    }"}
{"Number":"616","API Relative Path":"src.android.webkit.WebResourceResponse.java-setStatusCodeAndReasonPhrase(int-String)","Corresponding Source":"/**\n     * Sets the resource response's status code and reason phrase.\n     *\n     * @param statusCode the status code needs to be in the ranges [100, 299], [400, 599].\n     *                   Causing a redirect by specifying a 3xx code is not supported.\n     * @param reasonPhrase the phrase describing the status code, for example \"OK\". Must be non-null\n     *                     and not empty.\n     */\n    public void setStatusCodeAndReasonPhrase(int statusCode, String reasonPhrase) {\n        checkImmutable();\n        if (statusCode < 100)\n            throw new IllegalArgumentException(\"statusCode can't be less than 100.\");\n        if (statusCode > 599)\n            throw new IllegalArgumentException(\"statusCode can't be greater than 599.\");\n        if (statusCode > 299 && statusCode < 400)\n            throw new IllegalArgumentException(\"statusCode can't be in the [300, 399] range.\");\n        if (reasonPhrase == null)\n            throw new IllegalArgumentException(\"reasonPhrase can't be null.\");\n        if (reasonPhrase.trim().isEmpty())\n            throw new IllegalArgumentException(\"reasonPhrase can't be empty.\");\n        for (int i = 0; i < reasonPhrase.length(); i++) {\n            int c = reasonPhrase.charAt(i);\n            if (c > 0x7F) {\n                throw new IllegalArgumentException(\n                        \"reasonPhrase can't contain non-ASCII characters.\");\n            }\n        }\n        mStatusCode = statusCode;\n        mReasonPhrase = reasonPhrase;\n    }"}
{"Number":"617","API Relative Path":"src.android.webkit.WebView.java-WebView(Context-AttributeSet-int-int-Map-boolean)","Corresponding Source":"/**\n     * @hide\n     */\n    @SuppressWarnings(\"deprecation\")  // for super() call into deprecated base class constructor.\n    protected WebView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes,\n            Map<String, Object> javaScriptInterfaces, boolean privateBrowsing) {\n        super(context, attrs, defStyleAttr, defStyleRes);\n        if (context == null) {\n            throw new IllegalArgumentException(\"Invalid context argument\");\n        }\n        sEnforceThreadChecking = context.getApplicationInfo().targetSdkVersion >=\n                Build.VERSION_CODES.JELLY_BEAN_MR2;\n        checkThread();\n\n        ensureProviderCreated();\n        mProvider.init(javaScriptInterfaces, privateBrowsing);\n        // Post condition of creating a webview is the CookieSyncManager.getInstance() is allowed.\n        CookieSyncManager.setGetInstanceIsAllowed();\n    }"}
{"Number":"618","API Relative Path":"src.android.webkit.WebView.java-zoomBy(float)","Corresponding Source":"/**\n     * Performs a zoom operation in this WebView.\n     *\n     * @param zoomFactor the zoom factor to apply. The zoom factor will be clamped to the Webview's\n     * zoom limits. This value must be in the range 0.01 to 100.0 inclusive.\n     */\n    public void zoomBy(float zoomFactor) {\n        checkThread();\n        if (zoomFactor < 0.01)\n            throw new IllegalArgumentException(\"zoomFactor must be greater than 0.01.\");\n        if (zoomFactor > 100.0)\n            throw new IllegalArgumentException(\"zoomFactor must be less than 100.\");\n        mProvider.zoomBy(zoomFactor);\n    }"}
{"Number":"619","API Relative Path":"src.android.webkit.WebView.java-zoomBy(float)","Corresponding Source":"/**\n     * Performs a zoom operation in this WebView.\n     *\n     * @param zoomFactor the zoom factor to apply. The zoom factor will be clamped to the Webview's\n     * zoom limits. This value must be in the range 0.01 to 100.0 inclusive.\n     */\n    public void zoomBy(float zoomFactor) {\n        checkThread();\n        if (zoomFactor < 0.01)\n            throw new IllegalArgumentException(\"zoomFactor must be greater than 0.01.\");\n        if (zoomFactor > 100.0)\n            throw new IllegalArgumentException(\"zoomFactor must be less than 100.\");\n        mProvider.zoomBy(zoomFactor);\n    }"}
{"Number":"620","API Relative Path":"src.android.webkit.WebViewDelegate.java-callDrawGlFunction(Canvas-long)","Corresponding Source":"/**\n     * Calls the function specified with the nativeDrawGLFunctor functor pointer. This\n     * functionality is used by the WebView for calling into their renderer from the\n     * framework display lists.\n     *\n     * @param canvas a hardware accelerated canvas (see {@link Canvas#isHardwareAccelerated()})\n     * @param nativeDrawGLFunctor the pointer to the native functor that implements\n     *        system/core/include/utils/Functor.h\n     * @throws IllegalArgumentException if the canvas is not hardware accelerated\n     */\n    public void callDrawGlFunction(Canvas canvas, long nativeDrawGLFunctor) {\n        if (!(canvas instanceof DisplayListCanvas)) {\n            // Canvas#isHardwareAccelerated() is only true for subclasses of HardwareCanvas.\n            throw new IllegalArgumentException(canvas.getClass().getName()\n                    + \" is not a DisplayList canvas\");\n        }\n        ((DisplayListCanvas) canvas).drawGLFunctor2(nativeDrawGLFunctor, null);\n    }"}
{"Number":"621","API Relative Path":"src.android.webkit.WebViewDelegate.java-callDrawGlFunction(Canvas-long-Runnable)","Corresponding Source":"/**\n     * Calls the function specified with the nativeDrawGLFunctor functor pointer. This\n     * functionality is used by the WebView for calling into their renderer from the\n     * framework display lists.\n     *\n     * @param canvas a hardware accelerated canvas (see {@link Canvas#isHardwareAccelerated()})\n     * @param nativeDrawGLFunctor the pointer to the native functor that implements\n     *        system/core/include/utils/Functor.h\n     * @param releasedRunnable Called when this nativeDrawGLFunctor is no longer referenced by this\n     *        canvas, so is safe to be destroyed.\n     * @throws IllegalArgumentException if the canvas is not hardware accelerated\n     */\n    public void callDrawGlFunction(@NonNull Canvas canvas, long nativeDrawGLFunctor,\n            @Nullable Runnable releasedRunnable) {\n        if (!(canvas instanceof DisplayListCanvas)) {\n            // Canvas#isHardwareAccelerated() is only true for subclasses of HardwareCanvas.\n            throw new IllegalArgumentException(canvas.getClass().getName()\n                    + \" is not a DisplayList canvas\");\n        }\n        ((DisplayListCanvas) canvas).drawGLFunctor2(nativeDrawGLFunctor, releasedRunnable);\n    }"}
